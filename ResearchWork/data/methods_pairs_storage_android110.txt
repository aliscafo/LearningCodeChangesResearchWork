309
#method_before
private synchronized long trimToFit() throws IOException {
    // Expunge aged items (including tombstones marking deleted data).
    int ageSeconds = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_AGE_SECONDS, DEFAULT_AGE_SECONDS);
    int maxFiles = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_MAX_FILES, DEFAULT_MAX_FILES);
    long cutoffMillis = System.currentTimeMillis() - ageSeconds * 1000;
    while (!mAllFiles.contents.isEmpty()) {
        EntryFile entry = mAllFiles.contents.first();
        if (entry.timestampMillis > cutoffMillis && mAllFiles.contents.size() < maxFiles)
            break;
        FileList tag = mFilesByTag.get(entry.tag);
        if (tag != null && tag.contents.remove(entry))
            tag.blocks -= entry.blocks;
        if (mAllFiles.contents.remove(entry))
            mAllFiles.blocks -= entry.blocks;
        if (entry.file != null)
            entry.file.delete();
    }
    // Compute overall quota (a fraction of available free space) in blocks.
    // The quota changes dynamically based on the amount of free space;
    // that way when lots of data is available we can use it, but we'll get
    // out of the way if storage starts getting tight.
    long uptimeMillis = SystemClock.uptimeMillis();
    if (uptimeMillis > mCachedQuotaUptimeMillis + QUOTA_RESCAN_MILLIS) {
        int quotaPercent = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_QUOTA_PERCENT, DEFAULT_QUOTA_PERCENT);
        int reservePercent = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_RESERVE_PERCENT, DEFAULT_RESERVE_PERCENT);
        int quotaKb = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_QUOTA_KB, DEFAULT_QUOTA_KB);
        try {
            mStatFs.restat(mDropBoxDir.getPath());
            int available = mStatFs.getAvailableBlocks();
            int nonreserved = available - mStatFs.getBlockCount() * reservePercent / 100;
            int maximum = quotaKb * 1024 / mBlockSize;
            mCachedQuotaBlocks = Math.min(maximum, Math.max(0, nonreserved * quotaPercent / 100));
            mCachedQuotaUptimeMillis = uptimeMillis;
        } catch (IllegalArgumentException e) {
            // restat throws this on error
            throw new IOException("Can't restat: " + mDropBoxDir);
        }
    }
    if (mAllFiles.blocks > mCachedQuotaBlocks) {
        // Find a fair share amount of space to limit each tag
        int unsqueezed = mAllFiles.blocks, squeezed = 0;
        TreeSet<FileList> tags = new TreeSet<FileList>(mFilesByTag.values());
        for (FileList tag : tags) {
            if (squeezed > 0 && tag.blocks <= (mCachedQuotaBlocks - unsqueezed) / squeezed) {
                break;
            }
            unsqueezed -= tag.blocks;
            squeezed++;
        }
        int tagQuota = (mCachedQuotaBlocks - unsqueezed) / squeezed;
        // Remove old items from each tag until it meets the per-tag quota.
        for (FileList tag : tags) {
            if (mAllFiles.blocks < mCachedQuotaBlocks)
                break;
            while (tag.blocks > tagQuota && !tag.contents.isEmpty()) {
                EntryFile entry = tag.contents.first();
                if (tag.contents.remove(entry))
                    tag.blocks -= entry.blocks;
                if (mAllFiles.contents.remove(entry))
                    mAllFiles.blocks -= entry.blocks;
                try {
                    if (entry.file != null)
                        entry.file.delete();
                    enrollEntry(new EntryFile(mDropBoxDir, entry.tag, entry.timestampMillis));
                } catch (IOException e) {
                    Slog.e(TAG, "Can't write tombstone file", e);
                }
            }
        }
    }
    return mCachedQuotaBlocks * mBlockSize;
}
#method_after
private synchronized long trimToFit() throws IOException {
    // Expunge aged items (including tombstones marking deleted data).
    int ageSeconds = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_AGE_SECONDS, DEFAULT_AGE_SECONDS);
    int maxFiles = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_MAX_FILES, DEFAULT_MAX_FILES);
    long cutoffMillis = System.currentTimeMillis() - ageSeconds * 1000;
    while (!mAllFiles.contents.isEmpty()) {
        EntryFile entry = mAllFiles.contents.first();
        if (entry.timestampMillis > cutoffMillis && mAllFiles.contents.size() < maxFiles)
            break;
        FileList tag = mFilesByTag.get(entry.tag);
        if (tag != null && tag.contents.remove(entry))
            tag.blocks -= entry.blocks;
        if (mAllFiles.contents.remove(entry))
            mAllFiles.blocks -= entry.blocks;
        if (entry.file != null)
            entry.file.delete();
    }
    // Compute overall quota (a fraction of available free space) in blocks.
    // The quota changes dynamically based on the amount of free space;
    // that way when lots of data is available we can use it, but we'll get
    // out of the way if storage starts getting tight.
    long uptimeMillis = SystemClock.uptimeMillis();
    if (uptimeMillis > mCachedQuotaUptimeMillis + QUOTA_RESCAN_MILLIS) {
        int quotaPercent = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_QUOTA_PERCENT, DEFAULT_QUOTA_PERCENT);
        int reservePercent = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_RESERVE_PERCENT, DEFAULT_RESERVE_PERCENT);
        int quotaKb = Settings.Global.getInt(mContentResolver, Settings.Global.DROPBOX_QUOTA_KB, DEFAULT_QUOTA_KB);
        String dirPath = mDropBoxDir.getPath();
        try {
            mStatFs.restat(dirPath);
        } catch (IllegalArgumentException e) {
            // restat throws this on error
            throw new IOException("Can't restat: " + mDropBoxDir);
        }
        int available = mStatFs.getAvailableBlocks();
        int nonreserved = available - mStatFs.getBlockCount() * reservePercent / 100;
        int maximum = quotaKb * 1024 / mBlockSize;
        mCachedQuotaBlocks = Math.min(maximum, Math.max(0, nonreserved * quotaPercent / 100));
        mCachedQuotaUptimeMillis = uptimeMillis;
    }
    if (mAllFiles.blocks > mCachedQuotaBlocks) {
        // Find a fair share amount of space to limit each tag
        int unsqueezed = mAllFiles.blocks, squeezed = 0;
        TreeSet<FileList> tags = new TreeSet<FileList>(mFilesByTag.values());
        for (FileList tag : tags) {
            if (squeezed > 0 && tag.blocks <= (mCachedQuotaBlocks - unsqueezed) / squeezed) {
                break;
            }
            unsqueezed -= tag.blocks;
            squeezed++;
        }
        int tagQuota = (mCachedQuotaBlocks - unsqueezed) / squeezed;
        // Remove old items from each tag until it meets the per-tag quota.
        for (FileList tag : tags) {
            if (mAllFiles.blocks < mCachedQuotaBlocks)
                break;
            while (tag.blocks > tagQuota && !tag.contents.isEmpty()) {
                EntryFile entry = tag.contents.first();
                if (tag.contents.remove(entry))
                    tag.blocks -= entry.blocks;
                if (mAllFiles.contents.remove(entry))
                    mAllFiles.blocks -= entry.blocks;
                try {
                    if (entry.file != null)
                        entry.file.delete();
                    enrollEntry(new EntryFile(mDropBoxDir, entry.tag, entry.timestampMillis));
                } catch (IOException e) {
                    Slog.e(TAG, "Can't write tombstone file", e);
                }
            }
        }
    }
    return mCachedQuotaBlocks * mBlockSize;
}
#end_block

#method_before
public static boolean hasMimeType(String mimeType) {
    if (mimeType == null || mimeType.isEmpty()) {
        return false;
    }
    return mimeTypeToExtensionMap.containsKey(mimeType);
}
#method_after
public static boolean hasMimeType(String mimeType) {
    return (guessExtensionFromMimeType(mimeType) != null);
}
#end_block

#method_before
public static String guessMimeTypeFromExtension(String extension) {
    if (extension == null || extension.isEmpty()) {
        return null;
    }
    extension = extension.toLowerCase();
    return extensionToMimeTypeMap.get(extension);
}
#method_after
public static String guessMimeTypeFromExtension(String extension) {
    if (extension == null || extension.isEmpty()) {
        return null;
    }
    extension = extension.toLowerCase(Locale.US);
    return extensionToMimeTypeMap.get(extension);
}
#end_block

#method_before
public static boolean hasExtension(String extension) {
    if (extension == null || extension.isEmpty()) {
        return false;
    }
    extension = extension.toLowerCase();
    return extensionToMimeTypeMap.containsKey(extension);
}
#method_after
public static boolean hasExtension(String extension) {
    return (guessMimeTypeFromExtension(extension) != null);
}
#end_block

#method_before
public static String guessExtensionFromMimeType(String mimeType) {
    if (mimeType == null || mimeType.isEmpty()) {
        return null;
    }
    return mimeTypeToExtensionMap.get(mimeType);
}
#method_after
public static String guessExtensionFromMimeType(String mimeType) {
    if (mimeType == null || mimeType.isEmpty()) {
        return null;
    }
    mimeType = mimeType.toLowerCase(Locale.US);
    return mimeTypeToExtensionMap.get(mimeType);
}
#end_block

#method_before
public void test_30207891() {
    assertEquals("image/png", MimeUtils.guessMimeTypeFromExtension("PNG"));
    assertTrue(MimeUtils.hasExtension("PNG"));
}
#method_after
public void test_30207891() {
    assertTrue(MimeUtils.hasMimeType("IMAGE/PNG"));
    assertTrue(MimeUtils.hasMimeType("IMAGE/png"));
    assertFalse(MimeUtils.hasMimeType(""));
    assertEquals("png", MimeUtils.guessExtensionFromMimeType("IMAGE/PNG"));
    assertEquals("png", MimeUtils.guessExtensionFromMimeType("IMAGE/png"));
    assertNull(MimeUtils.guessMimeTypeFromExtension(""));
    assertNull(MimeUtils.guessMimeTypeFromExtension("doesnotexist"));
    assertTrue(MimeUtils.hasExtension("PNG"));
    assertTrue(MimeUtils.hasExtension("PnG"));
    assertFalse(MimeUtils.hasExtension(""));
    assertFalse(MimeUtils.hasExtension(".png"));
    assertEquals("image/png", MimeUtils.guessMimeTypeFromExtension("PNG"));
    assertEquals("image/png", MimeUtils.guessMimeTypeFromExtension("PnG"));
    assertNull(MimeUtils.guessMimeTypeFromExtension(".png"));
    assertNull(MimeUtils.guessMimeTypeFromExtension(""));
    assertNull(MimeUtils.guessExtensionFromMimeType("doesnotexist"));
}
#end_block

#method_before
private void checkAll(UriMatcher matcher) {
    check("content://asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people", PEOPLE, matcher);
    check("content://people/1", PEOPLE_ID, matcher);
    check("content://people/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people/2/phones", PEOPLE_PHONES, matcher);
    check("content://people/2/phones/3", PEOPLE_PHONES_ID, matcher);
    check("content://people/2/phones/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people/2/addresses", PEOPLE_ADDRESSES, matcher);
    check("content://people/2/addresses/3", PEOPLE_ADDRESSES_ID, matcher);
    check("content://people/2/addresses/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people/2/contact-methods", PEOPLE_CONTACTMETH, matcher);
    check("content://people/2/contact-methods/3", PEOPLE_CONTACTMETH_ID, matcher);
    check("content://people/2/contact-methods/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://calls", CALLS, matcher);
    check("content://calls/1", CALLS_ID, matcher);
    check("content://calls/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://caller-id", CALLERID, matcher);
    check("content://caller-id/asdf", CALLERID_TEXT, matcher);
    check("content://caller-id/1", CALLERID_TEXT, matcher);
    check("content://filter-recent", FILTERRECENT, matcher);
    check("content://auth/another/path/segment", ANOTHER_PATH_SEGMENT, matcher);
}
#method_after
private void checkAll(UriMatcher matcher) {
    check("content://asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people", PEOPLE, matcher);
    check("content://people/", PEOPLE, matcher);
    check("content://people/1", PEOPLE_ID, matcher);
    check("content://people/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people/2/phones", PEOPLE_PHONES, matcher);
    check("content://people/2/phones/3", PEOPLE_PHONES_ID, matcher);
    check("content://people/2/phones/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people/2/addresses", PEOPLE_ADDRESSES, matcher);
    check("content://people/2/addresses/3", PEOPLE_ADDRESSES_ID, matcher);
    check("content://people/2/addresses/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://people/2/contact-methods", PEOPLE_CONTACTMETH, matcher);
    check("content://people/2/contact-methods/3", PEOPLE_CONTACTMETH_ID, matcher);
    check("content://people/2/contact-methods/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://calls", CALLS, matcher);
    check("content://calls/", CALLS, matcher);
    check("content://calls/1", CALLS_ID, matcher);
    check("content://calls/asdf", UriMatcher.NO_MATCH, matcher);
    check("content://caller-id", CALLERID, matcher);
    check("content://caller-id/", CALLERID, matcher);
    check("content://caller-id/asdf", CALLERID_TEXT, matcher);
    check("content://caller-id/1", CALLERID_TEXT, matcher);
    check("content://filter-recent", FILTERRECENT, matcher);
    check("content://auth/another/path/segment", ANOTHER_PATH_SEGMENT, matcher);
}
#end_block

#method_before
public void addURI(String authority, String path, int code) {
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = PATH_SPLIT_PATTERN.split(newPath);
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
#method_after
public void addURI(String authority, String path, int code) {
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split("/");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
#end_block

#method_before
private void loadPrivateKeyAndCerts(PasswordRetriever passwordRetriever) throws Exception {
    if (keyFile != null) {
        if (keystoreFile != null) {
            throw new ParameterException("--key and --ks may not be specified at the same time");
        }
        loadPrivateKeyAndCertsFromFiles(passwordRetriever);
    } else {
        loadPrivateKeyAndCertsFromKeyStore(passwordRetriever);
    }
}
#method_after
private void loadPrivateKeyAndCerts(PasswordRetriever passwordRetriever) throws Exception {
    if (keystoreFile != null) {
        if (keyFile != null) {
            throw new ParameterException("--ks and --key may not be specified at the same time");
        } else if (certFile != null) {
            throw new ParameterException("--ks and --cert may not be specified at the same time");
        }
        loadPrivateKeyAndCertsFromKeyStore(passwordRetriever);
    } else if (keyFile != null) {
        loadPrivateKeyAndCertsFromFiles(passwordRetriever);
    } else {
        throw new ParameterException("KeyStore (--ks) or private key file (--key) must be specified");
    }
}
#end_block

#method_before
private void loadPrivateKeyAndCertsFromKeyStore(PasswordRetriever passwordRetriever) throws Exception {
    if (keystoreFile == null) {
        throw new ParameterException("KeyStore file must be specified (see --ks)");
    }
    // 1. Obtain a KeyStore implementation
    String ksType = (keystoreType != null) ? keystoreType : KeyStore.getDefaultType();
    KeyStore ks;
    if (keystoreProviderName != null) {
        // Use a named Provider (assumes the provider is already installed)
        ks = KeyStore.getInstance(ksType, keystoreProviderName);
    } else if (keystoreProviderClass != null) {
        // Use a new Provider instance (does not require the provider to be installed)
        Class<?> ksProviderClass = Class.forName(keystoreProviderClass);
        if (!Provider.class.isAssignableFrom(ksProviderClass)) {
            throw new ParameterException("Keystore Provider class " + keystoreProviderClass + " not subclass of " + Provider.class.getName());
        }
        Provider ksProvider;
        if (keystoreProviderArg != null) {
            // Single-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.getConstructor(String.class).newInstance(keystoreProviderArg);
        } else {
            // No-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.newInstance();
        }
        ks = KeyStore.getInstance(ksType, ksProvider);
    } else {
        // Use the highest-priority Provider which offers the requested KeyStore type
        ks = KeyStore.getInstance(ksType);
    }
    // 2. Load the KeyStore
    char[] keystorePwd = null;
    if ("NONE".equals(keystoreFile)) {
        ks.load(null);
    } else {
        boolean loaded = false;
        if (keystorePasswordSpec == null) {
            // No password specified. Check whether the KeyStore loads without a password.
            try {
                try (FileInputStream in = new FileInputStream(keystoreFile)) {
                    ks.load(in, null);
                    loaded = true;
                }
            } catch (IOException e) {
                if (e.getCause() instanceof UnrecoverableKeyException) {
                    // Looks like the KeyStore is password-protected
                    loaded = false;
                } else {
                    throw e;
                }
            }
        }
        if (!loaded) {
            String keystorePasswordSpec = (this.keystorePasswordSpec != null) ? this.keystorePasswordSpec : PasswordRetriever.SPEC_STDIN;
            String keystorePwdString = passwordRetriever.getPassword(keystorePasswordSpec, "Keystore password for " + name);
            keystorePwd = keystorePwdString.toCharArray();
            try (FileInputStream in = new FileInputStream(keystoreFile)) {
                ks.load(in, keystorePwd);
            }
        }
    }
    // 3. Load the PrivateKey and cert chain from KeyStore
    char[] keyPwd;
    if (keyPasswordSpec == null) {
        keyPwd = keystorePwd;
    } else {
        keyPwd = passwordRetriever.getPassword(keyPasswordSpec, "Key password for " + name).toCharArray();
    }
    String keyAlias = null;
    PrivateKey key = null;
    try {
        if (keystoreKeyAlias == null) {
            // Private key entry alias not specified. Find the key entry contained in this
            // KeyStore. If the KeyStore contains multiple key entries, return an error.
            Enumeration<String> aliases = ks.aliases();
            if (aliases != null) {
                while (aliases.hasMoreElements()) {
                    String entryAlias = aliases.nextElement();
                    if (ks.isKeyEntry(entryAlias)) {
                        keyAlias = entryAlias;
                        if (keystoreKeyAlias != null) {
                            throw new ParameterException(keystoreFile + " contains multiple key entries" + ". --ks-key-alias option must be used to specify" + " which entry to use.");
                        }
                        keystoreKeyAlias = keyAlias;
                    }
                }
            }
            if (keystoreKeyAlias == null) {
                throw new ParameterException(keystoreFile + " does not contain key entries");
            }
        }
        // Private key entry alias known. Load that entry's private key.
        keyAlias = keystoreKeyAlias;
        if (!ks.isKeyEntry(keyAlias)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        }
        Key entryKey;
        if (keyPwd != null) {
            // Key password specified -- load this key as a password-protected key
            entryKey = ks.getKey(keyAlias, keyPwd);
        } else {
            // Key password not specified -- try to load this key without using a password
            try {
                entryKey = ks.getKey(keyAlias, null);
            } catch (UnrecoverableKeyException expected) {
                // Looks like this might be a password-protected key. Prompt for password
                // and try loading the key using the password.
                keyPwd = passwordRetriever.getPassword(PasswordRetriever.SPEC_STDIN, "Password for key with alias \"" + keyAlias + "\"").toCharArray();
                entryKey = ks.getKey(keyAlias, keyPwd);
            }
        }
        if (entryKey == null) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        } else if (!(entryKey instanceof PrivateKey)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a private" + " key. It contains a key of algorithm: " + entryKey.getAlgorithm());
        }
        key = (PrivateKey) entryKey;
    } catch (UnrecoverableKeyException e) {
        throw new IOException("Failed to obtain key with alias \"" + keyAlias + "\" from " + keystoreFile + ". Wrong password?", e);
    }
    this.privateKey = key;
    Certificate[] certChain = ks.getCertificateChain(keyAlias);
    if ((certChain == null) || (certChain.length == 0)) {
        throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain certificates");
    }
    this.certs = new ArrayList<>(certChain.length);
    for (Certificate cert : certChain) {
        this.certs.add((X509Certificate) cert);
    }
}
#method_after
private void loadPrivateKeyAndCertsFromKeyStore(PasswordRetriever passwordRetriever) throws Exception {
    if (keystoreFile == null) {
        throw new ParameterException("KeyStore (--ks) must be specified");
    }
    // 1. Obtain a KeyStore implementation
    String ksType = (keystoreType != null) ? keystoreType : KeyStore.getDefaultType();
    KeyStore ks;
    if (keystoreProviderName != null) {
        // Use a named Provider (assumes the provider is already installed)
        ks = KeyStore.getInstance(ksType, keystoreProviderName);
    } else if (keystoreProviderClass != null) {
        // Use a new Provider instance (does not require the provider to be installed)
        Class<?> ksProviderClass = Class.forName(keystoreProviderClass);
        if (!Provider.class.isAssignableFrom(ksProviderClass)) {
            throw new ParameterException("Keystore Provider class " + keystoreProviderClass + " not subclass of " + Provider.class.getName());
        }
        Provider ksProvider;
        if (keystoreProviderArg != null) {
            // Single-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.getConstructor(String.class).newInstance(keystoreProviderArg);
        } else {
            // No-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.newInstance();
        }
        ks = KeyStore.getInstance(ksType, ksProvider);
    } else {
        // Use the highest-priority Provider which offers the requested KeyStore type
        ks = KeyStore.getInstance(ksType);
    }
    // 2. Load the KeyStore
    char[] keystorePwd = null;
    if ("NONE".equals(keystoreFile)) {
        ks.load(null);
    } else {
        boolean loaded = false;
        if (keystorePasswordSpec == null) {
            // No password specified. Check whether the KeyStore loads without a password.
            try {
                try (FileInputStream in = new FileInputStream(keystoreFile)) {
                    ks.load(in, null);
                    loaded = true;
                }
            } catch (IOException e) {
                if (e.getCause() instanceof UnrecoverableKeyException) {
                    // Looks like the KeyStore is password-protected
                    loaded = false;
                } else {
                    throw e;
                }
            }
        }
        if (!loaded) {
            String keystorePasswordSpec = (this.keystorePasswordSpec != null) ? this.keystorePasswordSpec : PasswordRetriever.SPEC_STDIN;
            String keystorePwdString = passwordRetriever.getPassword(keystorePasswordSpec, "Keystore password for " + name);
            keystorePwd = keystorePwdString.toCharArray();
            try (FileInputStream in = new FileInputStream(keystoreFile)) {
                ks.load(in, keystorePwd);
            }
        }
    }
    // 3. Load the PrivateKey and cert chain from KeyStore
    char[] keyPwd;
    if (keyPasswordSpec == null) {
        keyPwd = keystorePwd;
    } else {
        keyPwd = passwordRetriever.getPassword(keyPasswordSpec, "Key password for " + name).toCharArray();
    }
    String keyAlias = null;
    PrivateKey key = null;
    try {
        if (keystoreKeyAlias == null) {
            // Private key entry alias not specified. Find the key entry contained in this
            // KeyStore. If the KeyStore contains multiple key entries, return an error.
            Enumeration<String> aliases = ks.aliases();
            if (aliases != null) {
                while (aliases.hasMoreElements()) {
                    String entryAlias = aliases.nextElement();
                    if (ks.isKeyEntry(entryAlias)) {
                        keyAlias = entryAlias;
                        if (keystoreKeyAlias != null) {
                            throw new ParameterException(keystoreFile + " contains multiple key entries" + ". --ks-key-alias option must be used to specify" + " which entry to use.");
                        }
                        keystoreKeyAlias = keyAlias;
                    }
                }
            }
            if (keystoreKeyAlias == null) {
                throw new ParameterException(keystoreFile + " does not contain key entries");
            }
        }
        // Private key entry alias known. Load that entry's private key.
        keyAlias = keystoreKeyAlias;
        if (!ks.isKeyEntry(keyAlias)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        }
        Key entryKey;
        if (keyPwd != null) {
            // Key password specified -- load this key as a password-protected key
            entryKey = ks.getKey(keyAlias, keyPwd);
        } else {
            // Key password not specified -- try to load this key without using a password
            try {
                entryKey = ks.getKey(keyAlias, null);
            } catch (UnrecoverableKeyException expected) {
                // Looks like this might be a password-protected key. Prompt for password
                // and try loading the key using the password.
                keyPwd = passwordRetriever.getPassword(PasswordRetriever.SPEC_STDIN, "Password for key with alias \"" + keyAlias + "\"").toCharArray();
                entryKey = ks.getKey(keyAlias, keyPwd);
            }
        }
        if (entryKey == null) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        } else if (!(entryKey instanceof PrivateKey)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a private" + " key. It contains a key of algorithm: " + entryKey.getAlgorithm());
        }
        key = (PrivateKey) entryKey;
    } catch (UnrecoverableKeyException e) {
        throw new IOException("Failed to obtain key with alias \"" + keyAlias + "\" from " + keystoreFile + ". Wrong password?", e);
    }
    this.privateKey = key;
    Certificate[] certChain = ks.getCertificateChain(keyAlias);
    if ((certChain == null) || (certChain.length == 0)) {
        throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain certificates");
    }
    this.certs = new ArrayList<>(certChain.length);
    for (Certificate cert : certChain) {
        this.certs.add((X509Certificate) cert);
    }
}
#end_block

#method_before
private void loadPrivateKeyAndCertsFromFiles(PasswordRetriever passwordRetriver) throws Exception {
    if (certFile == null) {
        throw new ParameterException("Certificate file (see --cert) must be specified for " + name);
    }
    byte[] privateKeyBlob = readFully(new File(keyFile));
    PKCS8EncodedKeySpec keySpec;
    // Potentially encrypted key blob
    try {
        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(privateKeyBlob);
        // The blob is indeed an encrypted private key blob
        String passwordSpec = (keyPasswordSpec != null) ? keyPasswordSpec : PasswordRetriever.SPEC_STDIN;
        String keyPassword = passwordRetriver.getPassword(passwordSpec, "Private key password for " + name);
        PBEKeySpec decryptionKeySpec = new PBEKeySpec(keyPassword.toCharArray());
        SecretKey decryptionKey = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName()).generateSecret(decryptionKeySpec);
        keySpec = encryptedPrivateKeyInfo.getKeySpec(decryptionKey);
    } catch (IOException e) {
        // The blob is not an encrypted private key blob
        if (keyPasswordSpec == null) {
            // Given that no password was specified, assume the blob is an unencrypted
            // private key blob
            keySpec = new PKCS8EncodedKeySpec(privateKeyBlob);
        } else {
            throw new InvalidKeySpecException("Failed to parse encrypted private key blob " + keyFile, e);
        }
    }
    // Load the private key from its PKCS #8 encoded form.
    try {
        privateKey = loadPkcs8EncodedPrivateKey(keySpec);
    } catch (InvalidKeySpecException e) {
        throw new InvalidKeySpecException("Failed to load PKCS #8 encoded private key from " + keyFile, e);
    }
    // Load certificates
    Collection<? extends Certificate> certs;
    try (FileInputStream in = new FileInputStream(certFile)) {
        certs = CertificateFactory.getInstance("X.509").generateCertificates(in);
    }
    List<X509Certificate> certList = new ArrayList<>(certs.size());
    for (Certificate cert : certs) {
        certList.add((X509Certificate) cert);
    }
    this.certs = certList;
}
#method_after
private void loadPrivateKeyAndCertsFromFiles(PasswordRetriever passwordRetriver) throws Exception {
    if (keyFile == null) {
        throw new ParameterException("Private key file (--key) must be specified");
    }
    if (certFile == null) {
        throw new ParameterException("Certificate file (--cert) must be specified");
    }
    byte[] privateKeyBlob = readFully(new File(keyFile));
    PKCS8EncodedKeySpec keySpec;
    // Potentially encrypted key blob
    try {
        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(privateKeyBlob);
        // The blob is indeed an encrypted private key blob
        String passwordSpec = (keyPasswordSpec != null) ? keyPasswordSpec : PasswordRetriever.SPEC_STDIN;
        String keyPassword = passwordRetriver.getPassword(passwordSpec, "Private key password for " + name);
        PBEKeySpec decryptionKeySpec = new PBEKeySpec(keyPassword.toCharArray());
        SecretKey decryptionKey = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName()).generateSecret(decryptionKeySpec);
        keySpec = encryptedPrivateKeyInfo.getKeySpec(decryptionKey);
    } catch (IOException e) {
        // The blob is not an encrypted private key blob
        if (keyPasswordSpec == null) {
            // Given that no password was specified, assume the blob is an unencrypted
            // private key blob
            keySpec = new PKCS8EncodedKeySpec(privateKeyBlob);
        } else {
            throw new InvalidKeySpecException("Failed to parse encrypted private key blob " + keyFile, e);
        }
    }
    // Load the private key from its PKCS #8 encoded form.
    try {
        privateKey = loadPkcs8EncodedPrivateKey(keySpec);
    } catch (InvalidKeySpecException e) {
        throw new InvalidKeySpecException("Failed to load PKCS #8 encoded private key from " + keyFile, e);
    }
    // Load certificates
    Collection<? extends Certificate> certs;
    try (FileInputStream in = new FileInputStream(certFile)) {
        certs = CertificateFactory.getInstance("X.509").generateCertificates(in);
    }
    List<X509Certificate> certList = new ArrayList<>(certs.size());
    for (Certificate cert : certs) {
        certList.add((X509Certificate) cert);
    }
    this.certs = certList;
}
#end_block

#method_before
private void notifyHandshakeCompletedListeners() {
    if (listeners != null && !listeners.isEmpty()) {
        // notify the listeners
        HandshakeCompletedEvent event = new HandshakeCompletedEvent(this, sslSession);
        for (HandshakeCompletedListener listener : listeners) {
            try {
                listener.handshakeCompleted(event);
            } catch (RuntimeException e) {
                // The RI runs the handlers in a separate thread,
                // which we do not. But we try to preserve their
                // behavior of logging a problem and not killing
                // the handshaking thread just because a listener
                // has a problem.
                Thread thread = Thread.currentThread();
                thread.getUncaughtExceptionHandler().uncaughtException(thread, e);
            }
        }
    }
}
#method_after
void notifyHandshakeCompletedListeners() {
    if (listeners != null && !listeners.isEmpty()) {
        // notify the listeners
        HandshakeCompletedEvent event = new HandshakeCompletedEvent(this, sslSession);
        for (HandshakeCompletedListener listener : listeners) {
            try {
                listener.handshakeCompleted(event);
            } catch (RuntimeException e) {
                // The RI runs the handlers in a separate thread,
                // which we do not. But we try to preserve their
                // behavior of logging a problem and not killing
                // the handshaking thread just because a listener
                // has a problem.
                Thread thread = Thread.currentThread();
                thread.getUncaughtExceptionHandler().uncaughtException(thread, e);
            }
        }
    }
}
#end_block

#method_before
public static void main(String[] params) throws Exception {
    GeneralOptions generalOptions = new GeneralOptions();
    OptionsParser optionsParser = new OptionsParser(params);
    String optionName;
    while ((optionName = optionsParser.nextOption()) != null) {
        if (("h".equals(optionName)) || ("help".equals(optionName))) {
            printUsage(USAGE_PAGE_GENERAL);
            return;
        } else if ("version".equals(optionName)) {
            System.out.println(VERSION);
            return;
        } else if (("v".equals(optionName)) || ("verbose".equals(optionName))) {
            generalOptions.verbose = optionsParser.getOptionalBooleanValue(true);
        } else if ("Wall".equals(optionName)) {
            generalOptions.warningsTreatedAsErrors = optionsParser.getOptionalBooleanValue(true);
        } else {
            throw new ParameterException("Unsupported option: " + optionsParser.getOptionOriginalForm() + ". See --help for supported options.");
        }
    }
    params = optionsParser.getRemainingParams();
    if (params.length == 0) {
        printUsage(USAGE_PAGE_GENERAL);
        return;
    }
    String cmd = params[0];
    try {
        if ("sign".equals(cmd)) {
            sign(generalOptions, Arrays.copyOfRange(params, 1, params.length));
            return;
        } else if ("verify".equals(cmd)) {
            verify(generalOptions, Arrays.copyOfRange(params, 1, params.length));
            return;
        } else if ("help".equals(cmd)) {
            printUsage(USAGE_PAGE_GENERAL);
            return;
        } else if ("version".equals(cmd)) {
            System.out.println(VERSION);
            return;
        } else {
            throw new ParameterException("Unsupported command: " + cmd + ". See --help for supported commands");
        }
    } catch (ParameterException | OptionsParser.OptionsException e) {
        System.err.println(e.getMessage());
        System.exit(1);
        return;
    }
}
#method_after
public static void main(String[] params) throws Exception {
    if ((params.length == 0) || ("--help".equals(params[0])) || ("-h".equals(params[0]))) {
        printUsage(HELP_PAGE_GENERAL);
        return;
    } else if ("--version".equals(params[0])) {
        System.out.println(VERSION);
        return;
    }
    String cmd = params[0];
    try {
        if ("sign".equals(cmd)) {
            sign(Arrays.copyOfRange(params, 1, params.length));
            return;
        } else if ("verify".equals(cmd)) {
            verify(Arrays.copyOfRange(params, 1, params.length));
            return;
        } else if ("help".equals(cmd)) {
            printUsage(HELP_PAGE_GENERAL);
            return;
        } else if ("version".equals(cmd)) {
            System.out.println(VERSION);
            return;
        } else {
            throw new ParameterException("Unsupported command: " + cmd + ". See --help for supported commands");
        }
    } catch (ParameterException | OptionsParser.OptionsException e) {
        System.err.println(e.getMessage());
        System.exit(1);
        return;
    }
}
#end_block

#method_before
private static void sign(GeneralOptions generalOptions, String[] params) throws Exception {
    throw new ParameterException("sign command not yet implemented");
}
#method_after
private static void sign(String[] params) throws Exception {
    throw new ParameterException("sign command not yet implemented");
}
#end_block

#method_before
private static void verify(GeneralOptions generalOptions, String[] params) throws Exception {
    throw new ParameterException("verify command not yet implemented");
}
#method_after
private static void verify(String[] params) throws Exception {
    throw new ParameterException("verify command not yet implemented");
}
#end_block

#method_before
static TestBase newTest(TestName testName) {
    switch(testName) {
        case LEVELS_VEC3_RELAXED:
            return new LevelsV4(false, false);
        case LEVELS_VEC4_RELAXED:
            return new LevelsV4(false, true);
        case LEVELS_VEC3_FULL:
            return new LevelsV4(true, false);
        case LEVELS_VEC4_FULL:
            return new LevelsV4(true, true);
        case BLUR_RADIUS_25:
            return new Blur25(false, false);
        case BLUR_RADIUS_25_HALF:
            return new Blur25(false, true);
        case INTRINSIC_BLUR_RADIUS_25:
            return new Blur25(true, false);
        case GREYSCALE:
            return new Greyscale();
        case GRAIN:
            return new Grain();
        case FISHEYE_FULL:
            return new Fisheye(false, false);
        case FISHEYE_RELAXED:
            return new Fisheye(false, true);
        case FISHEYE_APPROXIMATE_FULL:
            return new Fisheye(true, false);
        case FISHEYE_APPROXIMATE_RELAXED:
            return new Fisheye(true, true);
        case VIGNETTE_FULL:
            return new Vignette(false, false);
        case VIGNETTE_RELAXED:
            return new Vignette(false, true);
        case VIGNETTE_APPROXIMATE_FULL:
            return new Vignette(true, false);
        case VIGNETTE_APPROXIMATE_RELAXED:
            return new Vignette(true, true);
        case GROUP_TEST_EMULATED:
            return new GroupTest(false);
        case GROUP_TEST_NATIVE:
            return new GroupTest(true);
        case CONVOLVE_3X3:
            return new Convolve3x3(false);
        case INTRINSICS_CONVOLVE_3X3:
            return new Convolve3x3(true);
        case COLOR_MATRIX:
            return new ColorMatrix(false, false);
        case INTRINSICS_COLOR_MATRIX:
            return new ColorMatrix(true, false);
        case INTRINSICS_COLOR_MATRIX_GREY:
            return new ColorMatrix(true, true);
        case COPY:
            return new Copy();
        case CROSS_PROCESS_USING_LUT:
            return new CrossProcess();
        case CONVOLVE_5X5:
            return new Convolve5x5(false);
        case INTRINSICS_CONVOLVE_5X5:
            return new Convolve5x5(true);
        case MANDELBROT_FLOAT:
            return new Mandelbrot(false);
        case MANDELBROT_DOUBLE:
            return new Mandelbrot(true);
        case INTRINSICS_BLEND:
            return new Blend();
        case INTRINSICS_BLUR_25G:
            return new Blur25G();
        case VIBRANCE:
            return new Vibrance();
        case BW_FILTER:
            return new BWFilter();
        /*
        case SHADOWS:
            return new Shadows();
            */
        case CONTRAST:
            return new Contrast();
        case EXPOSURE:
            return new Exposure();
        case WHITE_BALANCE:
            return new WhiteBalance();
        case COLOR_CUBE:
            return new ColorCube(false);
        case COLOR_CUBE_3D_INTRINSIC:
            return new ColorCube(true);
        case ARTISTIC1:
            return new Artistic1();
        case RESIZE_BI_SCRIPT:
            return new Resize(false);
        case RESIZE_BI_INTRINSIC:
            return new Resize(true);
        case POSTERIZE_INVOKE:
            return new Posterize(true);
        case POSTERIZE_SET:
            return new Posterize(false);
    }
    return null;
}
#method_after
static TestBase newTest(TestName testName) {
    switch(testName) {
        case LEVELS_VEC3_RELAXED:
            return new LevelsV4(false, false);
        case LEVELS_VEC4_RELAXED:
            return new LevelsV4(false, true);
        case LEVELS_VEC3_FULL:
            return new LevelsV4(true, false);
        case LEVELS_VEC4_FULL:
            return new LevelsV4(true, true);
        case BLUR_RADIUS_25:
            return new Blur25(false, false);
        case BLUR_RADIUS_25_HALF:
            return new Blur25(false, true);
        case INTRINSIC_BLUR_RADIUS_25:
            return new Blur25(true, false);
        case GREYSCALE:
            return new Greyscale();
        case GRAIN:
            return new Grain();
        case FISHEYE_FULL:
            return new Fisheye(false, false);
        case FISHEYE_RELAXED:
            return new Fisheye(false, true);
        case FISHEYE_APPROXIMATE_FULL:
            return new Fisheye(true, false);
        case FISHEYE_APPROXIMATE_RELAXED:
            return new Fisheye(true, true);
        case VIGNETTE_FULL:
            return new Vignette(false, false);
        case VIGNETTE_RELAXED:
            return new Vignette(false, true);
        case VIGNETTE_APPROXIMATE_FULL:
            return new Vignette(true, false);
        case VIGNETTE_APPROXIMATE_RELAXED:
            return new Vignette(true, true);
        case GROUP_TEST_EMULATED:
            return new GroupTest(false);
        case GROUP_TEST_NATIVE:
            return new GroupTest(true);
        case CONVOLVE_3X3:
            return new Convolve3x3(false);
        case INTRINSICS_CONVOLVE_3X3:
            return new Convolve3x3(true);
        case COLOR_MATRIX:
            return new ColorMatrix(false, false);
        case INTRINSICS_COLOR_MATRIX:
            return new ColorMatrix(true, false);
        case INTRINSICS_COLOR_MATRIX_GREY:
            return new ColorMatrix(true, true);
        case COPY:
            return new Copy();
        case CROSS_PROCESS_USING_LUT:
            return new CrossProcess();
        case CONVOLVE_5X5:
            return new Convolve5x5(false);
        case INTRINSICS_CONVOLVE_5X5:
            return new Convolve5x5(true);
        case MANDELBROT_FLOAT:
            return new Mandelbrot(false);
        case MANDELBROT_DOUBLE:
            return new Mandelbrot(true);
        case INTRINSICS_BLEND:
            return new Blend();
        case INTRINSICS_BLUR_25G:
            return new Blur25G();
        case VIBRANCE:
            return new Vibrance();
        case BW_FILTER:
            return new BWFilter();
        case SHADOWS:
            return new Shadows();
        case CONTRAST:
            return new Contrast();
        case EXPOSURE:
            return new Exposure();
        case WHITE_BALANCE:
            return new WhiteBalance();
        case COLOR_CUBE:
            return new ColorCube(false);
        case COLOR_CUBE_3D_INTRINSIC:
            return new ColorCube(true);
        case ARTISTIC1:
            return new Artistic1();
        case RESIZE_BI_SCRIPT:
            return new Resize(false);
        case RESIZE_BI_INTRINSIC:
            return new Resize(true);
        case POSTERIZE_INVOKE:
            return new Posterize(true);
        case POSTERIZE_SET:
            return new Posterize(false);
        case HISTOGRAM_SCRIPT:
            return new Histogram(false);
        case HISTOGRAM_INTRINSIC:
            return new Histogram(true);
    }
    return null;
}
#end_block

#method_before
public void onBar1Changed(int progress) {
    mRadius = ((float) progress) / 100.0f * MAX_RADIUS;
    if (mRadius <= 0.10f) {
        mRadius = 0.10f;
    }
    if (mUseIntrinsic) {
        mIntrinsic.setRadius(mRadius);
    } else if (mUseHalfPrecision) {
        mScript.invoke_setRadius_half((int) mRadius);
    } else {
        mScript.invoke_setRadius((int) mRadius);
    }
}
#method_after
public void onBar1Changed(int progress) {
    mRadius = ((float) progress) / 100.0f * MAX_RADIUS;
    if (mRadius <= 0.10f) {
        mRadius = 0.10f;
    }
    if (mUseIntrinsic) {
        mIntrinsic.setRadius(mRadius);
    } else if (mUseHalfPrecision) {
        mScript_half.invoke_setRadius((int) mRadius);
    } else {
        mScript.invoke_setRadius((int) mRadius);
    }
}
#end_block

#method_before
public void createTest(android.content.res.Resources res) {
    int width = mInPixelsAllocation.getType().getX();
    int height = mInPixelsAllocation.getType().getY();
    if (mUseIntrinsic) {
        mIntrinsic = ScriptIntrinsicBlur.create(mRS, Element.U8_4(mRS));
        mIntrinsic.setRadius(MAX_RADIUS);
        mIntrinsic.setInput(mInPixelsAllocation);
    } else {
        Type.Builder tb;
        if (mUseHalfPrecision)
            tb = new Type.Builder(mRS, Element.F16_4(mRS));
        else
            tb = new Type.Builder(mRS, Element.F32_4(mRS));
        tb.setX(width);
        tb.setY(height);
        mScratchPixelsAllocation1 = Allocation.createTyped(mRS, tb.create());
        mScratchPixelsAllocation2 = Allocation.createTyped(mRS, tb.create());
        mScript = new ScriptC_threshold(mRS);
        mScript.set_width(width);
        mScript.set_height(height);
        if (mUseHalfPrecision)
            mScript.invoke_setRadius_half(MAX_RADIUS);
        else
            mScript.invoke_setRadius(MAX_RADIUS);
        mScript.set_InPixel(mInPixelsAllocation);
        mScript.set_ScratchPixel1(mScratchPixelsAllocation1);
        mScript.set_ScratchPixel2(mScratchPixelsAllocation2);
    }
}
#method_after
public void createTest(android.content.res.Resources res) {
    int width = mInPixelsAllocation.getType().getX();
    int height = mInPixelsAllocation.getType().getY();
    if (mUseIntrinsic) {
        mIntrinsic = ScriptIntrinsicBlur.create(mRS, Element.U8_4(mRS));
        mIntrinsic.setRadius(MAX_RADIUS);
        mIntrinsic.setInput(mInPixelsAllocation);
    } else {
        Type.Builder tb;
        if (mUseHalfPrecision)
            tb = new Type.Builder(mRS, Element.F16_4(mRS));
        else
            tb = new Type.Builder(mRS, Element.F32_4(mRS));
        tb.setX(width);
        tb.setY(height);
        mScratchPixelsAllocation1 = Allocation.createTyped(mRS, tb.create());
        mScratchPixelsAllocation2 = Allocation.createTyped(mRS, tb.create());
        if (mUseHalfPrecision) {
            mScript_half = new ScriptC_threshold_half(mRS);
            mScript_half.set_width(width);
            mScript_half.set_height(height);
            mScript_half.invoke_setRadius(MAX_RADIUS);
            mScript_half.set_InPixel(mInPixelsAllocation);
            mScript_half.set_ScratchPixel1(mScratchPixelsAllocation1);
            mScript_half.set_ScratchPixel2(mScratchPixelsAllocation2);
        } else {
            mScript = new ScriptC_threshold(mRS);
            mScript.set_width(width);
            mScript.set_height(height);
            mScript.invoke_setRadius(MAX_RADIUS);
            mScript.set_InPixel(mInPixelsAllocation);
            mScript.set_ScratchPixel1(mScratchPixelsAllocation1);
            mScript.set_ScratchPixel2(mScratchPixelsAllocation2);
        }
    }
}
#end_block

#method_before
public void runTest() {
    if (mUseIntrinsic) {
        mIntrinsic.forEach(mOutPixelsAllocation);
    } else if (mUseHalfPrecision) {
        mScript.forEach_copyIn_half(mInPixelsAllocation, mScratchPixelsAllocation1);
        mScript.forEach_horz_half(mScratchPixelsAllocation2);
        mScript.forEach_vert_half(mOutPixelsAllocation);
    } else {
        mScript.forEach_copyIn(mInPixelsAllocation, mScratchPixelsAllocation1);
        mScript.forEach_horz(mScratchPixelsAllocation2);
        mScript.forEach_vert(mOutPixelsAllocation);
    }
}
#method_after
public void runTest() {
    if (mUseIntrinsic) {
        mIntrinsic.forEach(mOutPixelsAllocation);
    } else if (mUseHalfPrecision) {
        mScript_half.forEach_copyIn(mInPixelsAllocation, mScratchPixelsAllocation1);
        mScript_half.forEach_horz(mScratchPixelsAllocation2);
        mScript_half.forEach_vert(mOutPixelsAllocation);
    } else {
        mScript.forEach_copyIn(mInPixelsAllocation, mScratchPixelsAllocation1);
        mScript.forEach_horz(mScratchPixelsAllocation2);
        mScript.forEach_vert(mOutPixelsAllocation);
    }
}
#end_block

#method_before
public void testTimeZoneFormattingRespectsSetZoneStrings() throws ParseException {
    DateFormatSymbols symbols = DateFormatSymbols.getInstance(Locale.ENGLISH);
    String[][] zoneStrings = symbols.getZoneStrings();
    TimeZone tz = TimeZone.getTimeZone(zoneStrings[0][0]);
    zoneStrings[0][1] = "CustomTimeZone";
    symbols.setZoneStrings(zoneStrings);
    SimpleDateFormat sdf = new SimpleDateFormat("zzzz", symbols);
    sdf.setTimeZone(tz);
    assertEquals("CustomTimeZone", sdf.format(new Date(1376927400000L)));
}
#method_after
public void testTimeZoneFormattingRespectsSetZoneStrings() throws ParseException {
    DateFormatSymbols symbols = DateFormatSymbols.getInstance(Locale.ENGLISH);
    String[][] zoneStrings = symbols.getZoneStrings();
    TimeZone tz = TimeZone.getTimeZone(zoneStrings[0][0]);
    String originalTzName = zoneStrings[0][1];
    symbols.setZoneStrings(zoneStrings);
    SimpleDateFormat sdf = new SimpleDateFormat("zzzz", symbols);
    sdf.setTimeZone(tz);
    // just re-setting the default values
    assertEquals(originalTzName, sdf.format(new Date(1376927400000L)));
    // providing a custom name
    zoneStrings[0][1] = "CustomTimeZone";
    symbols.setZoneStrings(zoneStrings);
    sdf = new SimpleDateFormat("zzzz", symbols);
    sdf.setTimeZone(tz);
    assertEquals("CustomTimeZone", sdf.format(new Date(1376927400000L)));
    // setting the name to null should format as GMT[+-]...
    zoneStrings[0][1] = null;
    symbols.setZoneStrings(zoneStrings);
    sdf = new SimpleDateFormat("zzzz", symbols);
    sdf.setTimeZone(tz);
    assertTrue(sdf.format(new Date(1376927400000L)).startsWith("GMT"));
}
#end_block

#method_before
@Override
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    // There may be multiple widgets active, so update all of them
    final int N = appWidgetIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidget(context, appWidgetManager, appWidgetIds[i]);
    }
}
#method_after
@Override
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    // There may be multiple widgets active, so update all of them
    for (int i = 0; i < appWidgetIds.length; i++) {
        updateAppWidget(context, appWidgetManager, appWidgetIds[i]);
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_appwidgetwerviceimpitest);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.appwidgettest_title, R.string.appwidgettest_info, -1);
    Button readContacts = (Button) findViewById(R.id.readContacts);
    readContacts.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            try {
                runWidgetConfig();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_appwidgetserviceimpitest);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.appwidgettest_title, R.string.appwidgettest_info, -1);
    Button readContacts = (Button) findViewById(R.id.readContacts);
    readContacts.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            try {
                runWidgetConfig();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.ca_certificate_wifi);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.sec_wifi_ca_cert_test, R.string.sec_wifi_ca_cert_test_info, -1);
    mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
    getPassButton().setEnabled(false);
    Button transferCertificateButton = (Button) findViewById(R.id.transfer_ca_certificate);
    final Button goToSettingsButton = (Button) findViewById(R.id.gotosettings);
    goToSettingsButton.setEnabled(false);
    final Button goToWifiSettingsButton = (Button) findViewById(R.id.gotowifisettings);
    goToWifiSettingsButton.setEnabled(false);
    final Button goToWebBrowserButton = (Button) findViewById(R.id.gotowebbrowser);
    goToWebBrowserButton.setEnabled(false);
    goToSettingsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            /**
             * Launch settings of the device
             */
            startActivityForResult(new Intent(android.provider.Settings.ACTION_SECURITY_SETTINGS), 0);
        }
    });
    goToWifiSettingsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            /**
             * Launch WiFi settings of the device
             */
            startActivity(new Intent(android.provider.Settings.ACTION_WIFI_SETTINGS));
        }
    });
    transferCertificateButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mKeyguardManager.isKeyguardSecure() && checkDeviceInternetConnection() && checkDeviceDate()) {
                if (transferCertificateToDevice()) {
                    goToSettingsButton.setEnabled(true);
                    goToWifiSettingsButton.setEnabled(true);
                    goToWebBrowserButton.setEnabled(true);
                } else {
                    openDialog(getResources().getString(R.string.sec_file_transfer_failed));
                }
            } else {
                String message = getResources().getString(R.string.sec_wifi_ca_cert_test_info);
                openDialog(message);
            }
        }
    });
    goToWebBrowserButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            /**
             * Launch the web browser of the device and check for the vulnerability
             */
            Uri uriUrl = Uri.parse(getResources().getString(R.string.sec_wifi_ca_cert_test_url));
            Intent launchBrowser = new Intent(Intent.ACTION_VIEW, uriUrl);
            startActivity(launchBrowser);
            getPassButton().setEnabled(true);
        }
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.ca_certificate_wifi);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.sec_wifi_ca_cert_test, R.string.sec_wifi_ca_cert_test_info, -1);
    mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
    getPassButton().setEnabled(false);
    Button transferCertificateButton = (Button) findViewById(R.id.transfer_ca_certificate);
    final Button goToSettingsButton = (Button) findViewById(R.id.gotosettings);
    goToSettingsButton.setEnabled(false);
    final Button goToWifiSettingsButton = (Button) findViewById(R.id.gotowifisettings);
    goToWifiSettingsButton.setEnabled(false);
    final Button certificateTrustCheckButton = (Button) findViewById(R.id.check_cert_trust);
    certificateTrustCheckButton.setEnabled(false);
    final TextView finalStepTextView = (TextView) findViewById(R.id.clear_creds_textView);
    goToSettingsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            // Launch settings of the device
            startActivityForResult(new Intent(android.provider.Settings.ACTION_SECURITY_SETTINGS), 0);
            if (testResult) {
                getPassButton().setEnabled(true);
                finalStepTextView.setText(getResources().getString(R.string.sec_pass_test_instruction));
            } else {
                finalStepTextView.setText(getResources().getString(R.string.sec_fail_test_instruction));
            }
        }
    });
    goToWifiSettingsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            // Launch WiFi settings of the device
            startActivity(new Intent(android.provider.Settings.ACTION_WIFI_SETTINGS));
        }
    });
    transferCertificateButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            if (transferCertificateToDevice()) {
                openDialog(getResources().getString(R.string.sec_file_transferred_text));
                goToSettingsButton.setEnabled(true);
                goToWifiSettingsButton.setEnabled(true);
                certificateTrustCheckButton.setEnabled(true);
            } else {
                openDialog(getResources().getString(R.string.sec_file_transfer_failed));
            }
        }
    });
    certificateTrustCheckButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            Certificate caCert = readCertificate(convertFileToByteArray(certStagingFile));
            if (caCert != null) {
                if (isCaCertificateTrusted(caCert)) {
                    testResult = false;
                    openDialog(getResources().getString(R.string.sec_cert_trusted_text));
                } else {
                    testResult = true;
                    openDialog(getResources().getString(R.string.sec_cert_nottrusted_text));
                }
            } else {
                openDialog(getResources().getString(R.string.sec_read_cert_exception));
            }
        }
    });
}
#end_block

#method_before
private boolean transferCertificateToDevice() {
    InputStream is = null;
    FileOutputStream os = null;
    String result = "";
    try {
        try {
            is = getAssets().open(CERT_ASSET_NAME);
            os = new FileOutputStream(certStagingFile);
            byte[] buffer = new byte[1024];
            int length;
            while ((length = is.read(buffer)) > 0) {
                os.write(buffer, 0, length);
            }
        } finally {
            if (is != null)
                is.close();
            if (os != null)
                os.close();
            certStagingFile.setReadable(true, false);
        }
    } catch (IOException ioe) {
        result = getResources().getString(R.string.sec_file_transfer_failed);
        openDialog(result);
        return false;
    }
    result = getResources().getString(R.string.sec_file_transferred_text);
    openDialog(result);
    return true;
}
#method_after
private boolean transferCertificateToDevice() {
    InputStream is = null;
    FileOutputStream os = null;
    try {
        try {
            is = getAssets().open(CERT_ASSET_NAME);
            os = new FileOutputStream(certStagingFile);
            byte[] buffer = new byte[1024];
            int length;
            while ((length = is.read(buffer)) > 0) {
                os.write(buffer, 0, length);
            }
        } finally {
            if (is != null)
                is.close();
            if (os != null)
                os.close();
            certStagingFile.setReadable(true, false);
        }
    } catch (IOException ioe) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void openDialog(String message) {
    AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(this);
    alertDialogBuilder.setMessage(message);
    alertDialogBuilder.setPositiveButton("OK", new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface arg0, int arg1) {
        }
    });
    AlertDialog alertDialog = alertDialogBuilder.create();
    alertDialog.show();
}
#method_after
private void openDialog(String message) {
    AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(this);
    alertDialogBuilder.setMessage(message);
    alertDialogBuilder.setPositiveButton(getResources().getString(R.string.hifi_ultrasound_test_ok), new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int arg1) {
            dialog.dismiss();
        }
    });
    AlertDialog alertDialog = alertDialogBuilder.create();
    alertDialog.show();
}
#end_block

#method_before
public void test_JDK7171415() {
    URI lower = URI.create("http://www.example.com/%2b");
    URI mixed = URI.create("http://wWw.ExAmPlE.com/%2B");
    assertTrue(lower.equals(mixed));
    assertEquals(lower.hashCode(), mixed.hashCode());
}
#method_after
public void test_JDK7171415() {
    URI lower, mixed;
    lower = URI.create("http://www.example.com/%2b");
    mixed = URI.create("http://wWw.ExAmPlE.com/%2B");
    assertTrue(lower.equals(mixed));
    assertEquals(lower.hashCode(), mixed.hashCode());
    lower = URI.create("http://www.example.com/%2bbb");
    mixed = URI.create("http://wWw.ExAmPlE.com/%2BbB");
    assertFalse(lower.equals(mixed));
    assertFalse(lower.hashCode() == mixed.hashCode());
}
#end_block

#method_before
int read(byte[] b, int off, int length, int timeout) throws IOException {
    int n;
    // EOF already encountered
    if (eof) {
        return -1;
    }
    // connection reset
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    // bounds check
    if (length <= 0 || off < 0 || off + length > b.length) {
        if (length == 0) {
            return 0;
        }
        throw new ArrayIndexOutOfBoundsException();
    }
    boolean gotReset = false;
    // acquire file descriptor and do the read
    FileDescriptor fd = impl.acquireFD();
    try {
        BlockGuard.getThreadPolicy().onNetwork();
        n = socketRead0(fd, b, off, length, timeout);
        if (n > 0) {
            return n;
        }
    } catch (ConnectionResetException rstExc) {
        gotReset = true;
    }
    /*
         * We receive a "connection reset" but there may be bytes still
         * buffered on the socket
         */
    if (gotReset) {
        impl.setConnectionResetPending();
        try {
            n = socketRead(fd, b, off, length, timeout);
            if (n > 0) {
                return n;
            }
        } catch (ConnectionResetException rstExc) {
        }
    }
    /*
         * If we get here we are at EOF, the socket has been closed,
         * or the connection has been reset.
         */
    if (impl.isClosedOrPending()) {
        throw new SocketException("Socket closed");
    }
    if (impl.isConnectionResetPending()) {
        impl.setConnectionReset();
    }
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    eof = true;
    return -1;
}
#method_after
int read(byte[] b, int off, int length, int timeout) throws IOException {
    int n;
    // EOF already encountered
    if (eof) {
        return -1;
    }
    // connection reset
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    // bounds check
    if (length <= 0 || off < 0 || off + length > b.length) {
        if (length == 0) {
            return 0;
        }
        throw new ArrayIndexOutOfBoundsException();
    }
    boolean gotReset = false;
    // acquire file descriptor and do the read
    FileDescriptor fd = impl.acquireFD();
    try {
        BlockGuard.getThreadPolicy().onNetwork();
        n = socketRead(fd, b, off, length, timeout);
        if (n > 0) {
            return n;
        }
    } catch (ConnectionResetException rstExc) {
        gotReset = true;
    }
    /*
         * We receive a "connection reset" but there may be bytes still
         * buffered on the socket
         */
    if (gotReset) {
        impl.setConnectionResetPending();
        try {
            n = socketRead(fd, b, off, length, timeout);
            if (n > 0) {
                return n;
            }
        } catch (ConnectionResetException rstExc) {
        }
    }
    /*
         * If we get here we are at EOF, the socket has been closed,
         * or the connection has been reset.
         */
    if (impl.isClosedOrPending()) {
        throw new SocketException("Socket closed");
    }
    if (impl.isConnectionResetPending()) {
        impl.setConnectionReset();
    }
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    eof = true;
    return -1;
}
#end_block

#method_before
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, mAppOps, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        // Execute registerReceiver() calls on BackgroundThread.
        // Thus registerReceiver() will be called without holding mLock,
        // avoiding a deadlock b/w mLock and ActivityManagerService lock,
        // as another thread can acquire these locks in the reverse order.
        BackgroundThread.getHandler().post(new Runnable() {

            @Override
            public void run() {
                // Register for broadcasts from other components of the system.
                IntentFilter filter = new IntentFilter();
                filter.addAction(Intent.ACTION_BATTERY_CHANGED);
                filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
                mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
                filter = new IntentFilter();
                filter.addAction(Intent.ACTION_DREAMING_STARTED);
                filter.addAction(Intent.ACTION_DREAMING_STOPPED);
                mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
                filter = new IntentFilter();
                filter.addAction(Intent.ACTION_USER_SWITCHED);
                mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
                filter = new IntentFilter();
                filter.addAction(Intent.ACTION_DOCK_EVENT);
                mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
            }
        });
        // Register for settings changes.
        final ContentResolver resolver = mContext.getContentResolver();
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
        // Go.
        readConfigurationLocked();
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
}
#method_after
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, mAppOps, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        // Register for settings changes.
        final ContentResolver resolver = mContext.getContentResolver();
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
        // Go.
        readConfigurationLocked();
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
    // Register for broadcasts from other components of the system.
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
}
#end_block

#method_before
private void dispatchAdjustVolumeLocked(int suggestedStream, int direction, int flags, MediaSessionRecord session) {
    if (DEBUG) {
        String description = session == null ? null : session.toString();
        Log.d(TAG, "Adjusting session " + description + " by " + direction + ". flags=" + flags + ", suggestedStream=" + suggestedStream);
    }
    boolean preferSuggestedStream = false;
    if (isValidLocalStreamType(suggestedStream) && AudioSystem.isStreamActive(suggestedStream, 0)) {
        preferSuggestedStream = true;
    }
    if (session == null || preferSuggestedStream) {
        if ((flags & AudioManager.FLAG_ACTIVE_MEDIA_ONLY) != 0 && !AudioSystem.isStreamActive(AudioManager.STREAM_MUSIC, 0)) {
            if (DEBUG) {
                Log.d(TAG, "No active session to adjust, skipping media only volume event");
            }
            return;
        }
        String packageName = getContext().getOpPackageName();
        postAdjustSuggestedStreamVolume(direction, suggestedStream, flags, packageName, TAG);
    } else {
        session.adjustVolume(direction, flags, getContext().getPackageName(), UserHandle.myUserId(), true);
    }
}
#method_after
private void dispatchAdjustVolumeLocked(int suggestedStream, int direction, int flags, MediaSessionRecord session) {
    if (DEBUG) {
        String description = session == null ? null : session.toString();
        Log.d(TAG, "Adjusting session " + description + " by " + direction + ". flags=" + flags + ", suggestedStream=" + suggestedStream);
    }
    boolean preferSuggestedStream = false;
    if (isValidLocalStreamType(suggestedStream) && AudioSystem.isStreamActive(suggestedStream, 0)) {
        preferSuggestedStream = true;
    }
    if (session == null || preferSuggestedStream) {
        if ((flags & AudioManager.FLAG_ACTIVE_MEDIA_ONLY) != 0 && !AudioSystem.isStreamActive(AudioManager.STREAM_MUSIC, 0)) {
            if (DEBUG) {
                Log.d(TAG, "No active session to adjust, skipping media only volume event");
            }
            return;
        }
        // Execute mAudioService.adjustSuggestedStreamVolume() on
        // handler thread of MediaSessionService.
        // This will release the MediaSessionService.mLock sooner and avoid
        // a potential deadlock between MediaSessionService.mLock and
        // ActivityManagerService lock.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                try {
                    String packageName = getContext().getOpPackageName();
                    mAudioService.adjustSuggestedStreamVolume(direction, suggestedStream, flags, packageName, TAG);
                } catch (RemoteException e) {
                    Log.e(TAG, "Error adjusting default volume.", e);
                }
            }
        });
    } else {
        session.adjustVolume(direction, flags, getContext().getPackageName(), UserHandle.myUserId(), true);
    }
}
#end_block

#method_before
private void dispatchMediaKeyEventLocked(KeyEvent keyEvent, boolean needWakeLock, MediaSessionRecord session) {
    if (session != null) {
        if (DEBUG) {
            Log.d(TAG, "Sending media key to " + session.toString());
        }
        if (needWakeLock) {
            mKeyEventReceiver.aquireWakeLockLocked();
        }
        // If we don't need a wakelock use -1 as the id so we
        // won't release it later
        session.sendMediaButton(keyEvent, needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mKeyEventReceiver);
    } else {
        // Launch the last PendingIntent we had with priority
        UserRecord user = mUserRecords.get(mCurrentUserId);
        if (user.mLastMediaButtonReceiver != null || user.mRestoredMediaButtonReceiver != null) {
            if (DEBUG) {
                Log.d(TAG, "Sending media key to last known PendingIntent " + user.mLastMediaButtonReceiver + " or restored Intent " + user.mRestoredMediaButtonReceiver);
            }
            if (needWakeLock) {
                mKeyEventReceiver.aquireWakeLockLocked();
            }
            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                if (user.mLastMediaButtonReceiver != null) {
                    user.mLastMediaButtonReceiver.send(getContext(), needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mediaButtonIntent, mKeyEventReceiver, mHandler);
                } else {
                    mediaButtonIntent.setComponent(user.mRestoredMediaButtonReceiver);
                    getContext().sendBroadcastAsUser(mediaButtonIntent, new UserHandle(userId));
                }
            } catch (CanceledException e) {
                Log.i(TAG, "Error sending key event to media button receiver " + user.mLastMediaButtonReceiver, e);
            }
        } else {
            if (DEBUG) {
                Log.d(TAG, "Sending media key ordered broadcast");
            }
            if (needWakeLock) {
                mMediaEventWakeLock.acquire();
            }
            // Fallback to legacy behavior
            Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
            keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            getContext().sendOrderedBroadcastAsUser(keyIntent, UserHandle.CURRENT, null, mKeyEventDone, mHandler, Activity.RESULT_OK, null, null);
        }
    }
}
#method_after
private void dispatchMediaKeyEventLocked(KeyEvent keyEvent, boolean needWakeLock, MediaSessionRecord session) {
    if (session != null) {
        if (DEBUG) {
            Log.d(TAG, "Sending media key to " + session.toString());
        }
        if (needWakeLock) {
            mKeyEventReceiver.aquireWakeLockLocked();
        }
        // If we don't need a wakelock use -1 as the id so we
        // won't release it later
        session.sendMediaButton(keyEvent, needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mKeyEventReceiver);
    } else {
        // Launch the last PendingIntent we had with priority
        UserRecord user = mUserRecords.get(mCurrentUserId);
        if (user.mLastMediaButtonReceiver != null || user.mRestoredMediaButtonReceiver != null) {
            if (DEBUG) {
                Log.d(TAG, "Sending media key to last known PendingIntent " + user.mLastMediaButtonReceiver + " or restored Intent " + user.mRestoredMediaButtonReceiver);
            }
            if (needWakeLock) {
                mKeyEventReceiver.aquireWakeLockLocked();
            }
            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                if (user.mLastMediaButtonReceiver != null) {
                    user.mLastMediaButtonReceiver.send(getContext(), needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mediaButtonIntent, mKeyEventReceiver, mHandler);
                } else {
                    mediaButtonIntent.setComponent(user.mRestoredMediaButtonReceiver);
                    getContext().sendBroadcastAsUser(mediaButtonIntent, new UserHandle(mCurrentUserId));
                }
            } catch (CanceledException e) {
                Log.i(TAG, "Error sending key event to media button receiver " + user.mLastMediaButtonReceiver, e);
            }
        } else {
            if (DEBUG) {
                Log.d(TAG, "Sending media key ordered broadcast");
            }
            if (needWakeLock) {
                mMediaEventWakeLock.acquire();
            }
            // Fallback to legacy behavior
            Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
            keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            getContext().sendOrderedBroadcastAsUser(keyIntent, UserHandle.CURRENT, null, mKeyEventDone, mHandler, Activity.RESULT_OK, null, null);
        }
    }
}
#end_block

#method_before
private void updateUser() {
    // Move getCurrentUser() out of synchronized block.
    // Doing so will avoid a potential deadlock between
    // MediaSessionService.mLock and ActivityManagerService
    // lock.
    int userId = ActivityManager.getCurrentUser();
    synchronized (mLock) {
        if (mCurrentUserId != userId) {
            final int oldUserId = mCurrentUserId;
            // do this first
            mCurrentUserId = userId;
            UserRecord oldUser = mUserRecords.get(oldUserId);
            if (oldUser != null) {
                oldUser.stopLocked();
            }
            UserRecord newUser = getOrCreateUser(userId);
            newUser.startLocked();
        }
    }
}
#method_after
private void updateUser() {
    int userId = ActivityManager.getCurrentUser();
    synchronized (mLock) {
        if (mCurrentUserId != userId) {
            final int oldUserId = mCurrentUserId;
            // do this first
            mCurrentUserId = userId;
            UserRecord oldUser = mUserRecords.get(oldUserId);
            if (oldUser != null) {
                oldUser.stopLocked();
            }
            UserRecord newUser = getOrCreateUser(userId);
            newUser.startLocked();
        }
    }
}
#end_block

#method_before
@Override
public void dispatchMediaKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
    if (keyEvent == null || !KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        Log.w(TAG, "Attempted to dispatch null or non-media key event.");
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        if (DEBUG) {
            Log.d(TAG, "dispatchMediaKeyEvent, pid=" + pid + ", uid=" + uid + ", event=" + keyEvent);
        }
        if (!isUserSetupComplete()) {
            // Global media key handling can have the side-effect of starting new
            // activities which is undesirable while setup is in progress.
            Slog.i(TAG, "Not dispatching media key event because user " + "setup is in progress.");
            return;
        }
        synchronized (mLock) {
            // If we don't have a media button receiver to fall back on
            // include non-playing sessions for dispatching
            UserRecord ur = mUserRecords.get(ActivityManager.getCurrentUser());
            boolean useNotPlayingSessions = (ur == null) || (ur.mLastMediaButtonReceiver == null && ur.mRestoredMediaButtonReceiver == null);
            MediaSessionRecord session = mPriorityStack.getDefaultMediaButtonSession(mCurrentUserId, useNotPlayingSessions);
            if (isVoiceKey(keyEvent.getKeyCode())) {
                handleVoiceKeyEventLocked(keyEvent, needWakeLock, session);
            } else {
                dispatchMediaKeyEventLocked(keyEvent, needWakeLock, session);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void dispatchMediaKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
    if (keyEvent == null || !KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        Log.w(TAG, "Attempted to dispatch null or non-media key event.");
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        if (DEBUG) {
            Log.d(TAG, "dispatchMediaKeyEvent, pid=" + pid + ", uid=" + uid + ", event=" + keyEvent);
        }
        if (!isUserSetupComplete()) {
            // Global media key handling can have the side-effect of starting new
            // activities which is undesirable while setup is in progress.
            Slog.i(TAG, "Not dispatching media key event because user " + "setup is in progress.");
            return;
        }
        synchronized (mLock) {
            // If we don't have a media button receiver to fall back on
            // include non-playing sessions for dispatching
            UserRecord ur = mUserRecords.get(mCurrentUserId);
            boolean useNotPlayingSessions = (ur == null) || (ur.mLastMediaButtonReceiver == null && ur.mRestoredMediaButtonReceiver == null);
            MediaSessionRecord session = mPriorityStack.getDefaultMediaButtonSession(mCurrentUserId, useNotPlayingSessions);
            if (isVoiceKey(keyEvent.getKeyCode())) {
                handleVoiceKeyEventLocked(keyEvent, needWakeLock, session);
            } else {
                dispatchMediaKeyEventLocked(keyEvent, needWakeLock, session);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private void dispatchMediaKeyEventLocked(KeyEvent keyEvent, boolean needWakeLock, MediaSessionRecord session) {
    if (session != null) {
        if (DEBUG) {
            Log.d(TAG, "Sending media key to " + session.toString());
        }
        if (needWakeLock) {
            mKeyEventReceiver.aquireWakeLockLocked();
        }
        // If we don't need a wakelock use -1 as the id so we
        // won't release it later
        session.sendMediaButton(keyEvent, needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mKeyEventReceiver);
    } else {
        // Launch the last PendingIntent we had with priority
        int userId = ActivityManager.getCurrentUser();
        UserRecord user = mUserRecords.get(userId);
        if (user.mLastMediaButtonReceiver != null || user.mRestoredMediaButtonReceiver != null) {
            if (DEBUG) {
                Log.d(TAG, "Sending media key to last known PendingIntent " + user.mLastMediaButtonReceiver + " or restored Intent " + user.mRestoredMediaButtonReceiver);
            }
            if (needWakeLock) {
                mKeyEventReceiver.aquireWakeLockLocked();
            }
            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                if (user.mLastMediaButtonReceiver != null) {
                    user.mLastMediaButtonReceiver.send(getContext(), needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mediaButtonIntent, mKeyEventReceiver, null);
                } else {
                    mediaButtonIntent.setComponent(user.mRestoredMediaButtonReceiver);
                    getContext().sendBroadcastAsUser(mediaButtonIntent, new UserHandle(userId));
                }
            } catch (CanceledException e) {
                Log.i(TAG, "Error sending key event to media button receiver " + user.mLastMediaButtonReceiver, e);
            }
        } else {
            if (DEBUG) {
                Log.d(TAG, "Sending media key ordered broadcast");
            }
            if (needWakeLock) {
                mMediaEventWakeLock.acquire();
            }
            // Fallback to legacy behavior
            Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
            keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            getContext().sendOrderedBroadcastAsUser(keyIntent, UserHandle.CURRENT, null, mKeyEventDone, mHandler, Activity.RESULT_OK, null, null);
        }
    }
}
#method_after
private void dispatchMediaKeyEventLocked(KeyEvent keyEvent, boolean needWakeLock, MediaSessionRecord session) {
    if (session != null) {
        if (DEBUG) {
            Log.d(TAG, "Sending media key to " + session.toString());
        }
        if (needWakeLock) {
            mKeyEventReceiver.aquireWakeLockLocked();
        }
        // If we don't need a wakelock use -1 as the id so we
        // won't release it later
        session.sendMediaButton(keyEvent, needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mKeyEventReceiver);
    } else {
        // Launch the last PendingIntent we had with priority
        UserRecord user = mUserRecords.get(mCurrentUserId);
        if (user.mLastMediaButtonReceiver != null || user.mRestoredMediaButtonReceiver != null) {
            if (DEBUG) {
                Log.d(TAG, "Sending media key to last known PendingIntent " + user.mLastMediaButtonReceiver + " or restored Intent " + user.mRestoredMediaButtonReceiver);
            }
            if (needWakeLock) {
                mKeyEventReceiver.aquireWakeLockLocked();
            }
            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                if (user.mLastMediaButtonReceiver != null) {
                    user.mLastMediaButtonReceiver.send(getContext(), needWakeLock ? mKeyEventReceiver.mLastTimeoutId : -1, mediaButtonIntent, mKeyEventReceiver, null);
                } else {
                    mediaButtonIntent.setComponent(user.mRestoredMediaButtonReceiver);
                    getContext().sendBroadcastAsUser(mediaButtonIntent, new UserHandle(mCurrentUserId));
                }
            } catch (CanceledException e) {
                Log.i(TAG, "Error sending key event to media button receiver " + user.mLastMediaButtonReceiver, e);
            }
        } else {
            if (DEBUG) {
                Log.d(TAG, "Sending media key ordered broadcast");
            }
            if (needWakeLock) {
                mMediaEventWakeLock.acquire();
            }
            // Fallback to legacy behavior
            Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
            keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            getContext().sendOrderedBroadcastAsUser(keyIntent, UserHandle.CURRENT, null, mKeyEventDone, mHandler, Activity.RESULT_OK, null, null);
        }
    }
}
#end_block

#method_before
/*
   * Test simplification of double Boolean negation. Note that sometimes
   * both negations can be removed but we only expect the simplifier to
   * remove the second.
   */
// / CHECK-START: boolean Main.NotNotBool(boolean) instruction_simplifier_after_bce (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const0:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 1
// / CHECK-DAG:     <<NotArg:i\d+>>    Select [<<Const1>>,<<Const0>>,<<Arg>>]
// / CHECK-DAG:     <<NotNotArg:i\d+>> Select [<<Const1>>,<<Const0>>,<<NotArg>>]
// / CHECK-DAG:                        Return [<<NotNotArg>>]
// / CHECK-START: boolean Main.NotNotBool(boolean) instruction_simplifier_after_bce (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:                        Return [<<Arg>>]
public static boolean NegateValue(boolean arg) {
    return !arg;
}
#method_after
/*
   * Test simplification of double Boolean negation. Note that sometimes
   * both negations can be removed but we only expect the simplifier to
   * remove the second.
   */
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier_after_bce (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const0:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 1
// / CHECK-DAG:     <<NotArg:i\d+>>    Select [<<Const1>>,<<Const0>>,<<Arg>>]
// / CHECK-DAG:     <<NotNotArg:i\d+>> Select [<<Const1>>,<<Const0>>,<<NotArg>>]
// / CHECK-DAG:                        Return [<<NotNotArg>>]
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier_after_bce (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:                        Return [<<Arg>>]
public static boolean NegateValue(boolean arg) {
    return !arg;
}
#end_block

#method_before
public static void main(String[] args) {
    int arg = 123456;
    assertLongEquals(Add0(arg), arg);
    assertIntEquals(5, AddAddSubAddConst(1));
    assertIntEquals(AndAllOnes(arg), arg);
    assertLongEquals(Div1(arg), arg);
    assertIntEquals(DivN1(arg), -arg);
    assertLongEquals(Mul1(arg), arg);
    assertIntEquals(MulN1(arg), -arg);
    assertLongEquals(MulPowerOfTwo128(arg), (128 * arg));
    assertLongEquals(2640, MulMulMulConst(2));
    assertIntEquals(Or0(arg), arg);
    assertLongEquals(OrSame(arg), arg);
    assertIntEquals(Shl0(arg), arg);
    assertLongEquals(Shr0(arg), arg);
    assertLongEquals(Shr64(arg), arg);
    assertLongEquals(Sub0(arg), arg);
    assertIntEquals(SubAliasNeg(arg), -arg);
    assertIntEquals(9, SubAddConst1(2));
    assertIntEquals(-2, SubAddConst2(3));
    assertLongEquals(3, SubSubConst(4));
    assertLongEquals(UShr0(arg), arg);
    assertIntEquals(Xor0(arg), arg);
    assertIntEquals(XorAllOnes(arg), ~arg);
    assertIntEquals(AddNegs1(arg, arg + 1), -(arg + arg + 1));
    assertIntEquals(AddNegs2(arg, arg + 1), -(arg + arg + 1));
    assertLongEquals(AddNegs3(arg, arg + 1), -(2 * arg + 1));
    assertLongEquals(AddNeg1(arg, arg + 1), 1);
    assertLongEquals(AddNeg2(arg, arg + 1), -1);
    assertLongEquals(NegNeg1(arg), arg);
    assertIntEquals(NegNeg2(arg), 0);
    assertLongEquals(NegNeg3(arg), arg);
    assertIntEquals(NegSub1(arg, arg + 1), 1);
    assertIntEquals(NegSub2(arg, arg + 1), 1);
    assertLongEquals(NotNot1(arg), arg);
    assertIntEquals(NotNot2(arg), -1);
    assertIntEquals(SubNeg1(arg, arg + 1), -(arg + arg + 1));
    assertIntEquals(SubNeg2(arg, arg + 1), -(arg + arg + 1));
    assertLongEquals(SubNeg3(arg, arg + 1), -(2 * arg + 1));
    assertBooleanEquals(EqualBoolVsIntConst(true), true);
    assertBooleanEquals(EqualBoolVsIntConst(true), true);
    assertBooleanEquals(NotEqualBoolVsIntConst(false), false);
    assertBooleanEquals(NotEqualBoolVsIntConst(false), false);
    assertBooleanEquals(NotNotBool(true), true);
    assertBooleanEquals(NotNotBool(false), false);
    assertFloatEquals(Div2(100.0f), 50.0f);
    assertDoubleEquals(Div2(150.0), 75.0);
    assertFloatEquals(DivMP25(100.0f), -400.0f);
    assertDoubleEquals(DivMP25(150.0), -600.0);
    assertIntEquals(UShr28And15(0xc1234567), 0xc);
    assertLongEquals(UShr60And15(0xc123456787654321L), 0xcL);
    assertIntEquals(UShr28And7(0xc1234567), 0x4);
    assertLongEquals(UShr60And7(0xc123456787654321L), 0x4L);
    assertIntEquals(Shr24And255(0xc1234567), 0xc1);
    assertLongEquals(Shr56And255(0xc123456787654321L), 0xc1L);
    assertIntEquals(Shr24And127(0xc1234567), 0x41);
    assertLongEquals(Shr56And127(0xc123456787654321L), 0x41L);
    assertIntEquals(0, mulPow2Plus1(0));
    assertIntEquals(9, mulPow2Plus1(1));
    assertIntEquals(18, mulPow2Plus1(2));
    assertIntEquals(900, mulPow2Plus1(100));
    assertIntEquals(111105, mulPow2Plus1(12345));
    assertLongEquals(0, mulPow2Minus1(0));
    assertLongEquals(31, mulPow2Minus1(1));
    assertLongEquals(62, mulPow2Minus1(2));
    assertLongEquals(3100, mulPow2Minus1(100));
    assertLongEquals(382695, mulPow2Minus1(12345));
    booleanField = false;
    assertIntEquals(booleanFieldNotEqualOne(), 54);
    assertIntEquals(booleanFieldEqualZero(), 54);
    booleanField = true;
    assertIntEquals(booleanFieldNotEqualOne(), 13);
    assertIntEquals(booleanFieldEqualZero(), 13);
    assertIntEquals(intConditionNotEqualOne(6), 54);
    assertIntEquals(intConditionNotEqualOne(43), 13);
    assertIntEquals(intConditionEqualZero(6), 54);
    assertIntEquals(intConditionEqualZero(43), 13);
    assertIntEquals(floatConditionNotEqualOne(6.0f), 54);
    assertIntEquals(floatConditionNotEqualOne(43.0f), 13);
    assertIntEquals(doubleConditionEqualZero(6.0), 54);
    assertIntEquals(doubleConditionEqualZero(43.0), 13);
    assertIntEquals(1234567, intToDoubleToInt(1234567));
    assertIntEquals(Integer.MIN_VALUE, intToDoubleToInt(Integer.MIN_VALUE));
    assertIntEquals(Integer.MAX_VALUE, intToDoubleToInt(Integer.MAX_VALUE));
    assertStringEquals("d=7654321.0, i=7654321", intToDoubleToIntPrint(7654321));
    assertIntEquals(12, byteToDoubleToInt((byte) 12));
    assertIntEquals(Byte.MIN_VALUE, byteToDoubleToInt(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, byteToDoubleToInt(Byte.MAX_VALUE));
    assertIntEquals(11, floatToDoubleToInt(11.3f));
    assertStringEquals("d=12.25, i=12", floatToDoubleToIntPrint(12.25f));
    assertIntEquals(123, byteToDoubleToShort((byte) 123));
    assertIntEquals(Byte.MIN_VALUE, byteToDoubleToShort(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, byteToDoubleToShort(Byte.MAX_VALUE));
    assertIntEquals(1234, charToDoubleToShort((char) 1234));
    assertIntEquals(Character.MIN_VALUE, charToDoubleToShort(Character.MIN_VALUE));
    assertIntEquals(/* sign-extended */
    -1, charToDoubleToShort(Character.MAX_VALUE));
    assertIntEquals(12345, floatToIntToShort(12345.75f));
    assertIntEquals(Short.MAX_VALUE, floatToIntToShort((float) (Short.MIN_VALUE - 1)));
    assertIntEquals(Short.MIN_VALUE, floatToIntToShort((float) (Short.MAX_VALUE + 1)));
    assertIntEquals(-54321, intToFloatToInt(-54321));
    assertDoubleEquals((double) 0x12345678, longToIntToDouble(0x1234567812345678L));
    assertDoubleEquals(0.0, longToIntToDouble(Long.MIN_VALUE));
    assertDoubleEquals(-1.0, longToIntToDouble(Long.MAX_VALUE));
    assertLongEquals(0x0000000012345678L, longToIntToLong(0x1234567812345678L));
    assertLongEquals(0xffffffff87654321L, longToIntToLong(0x1234567887654321L));
    assertLongEquals(0L, longToIntToLong(Long.MIN_VALUE));
    assertLongEquals(-1L, longToIntToLong(Long.MAX_VALUE));
    assertIntEquals((short) -5678, shortToCharToShort((short) -5678));
    assertIntEquals(Short.MIN_VALUE, shortToCharToShort(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, shortToCharToShort(Short.MAX_VALUE));
    assertIntEquals(5678, shortToLongToInt((short) 5678));
    assertIntEquals(Short.MIN_VALUE, shortToLongToInt(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, shortToLongToInt(Short.MAX_VALUE));
    assertIntEquals(0x34, shortToCharToByte((short) 0x1234));
    assertIntEquals(-0x10, shortToCharToByte((short) 0x12f0));
    assertIntEquals(0, shortToCharToByte(Short.MIN_VALUE));
    assertIntEquals(-1, shortToCharToByte(Short.MAX_VALUE));
    assertStringEquals("c=1025, b=1", shortToCharToBytePrint((short) 1025));
    assertStringEquals("c=1023, b=-1", shortToCharToBytePrint((short) 1023));
    assertStringEquals("c=65535, b=-1", shortToCharToBytePrint((short) -1));
    assertIntEquals(0x21, longAnd0xffToByte(0x1234432112344321L));
    assertIntEquals(0, longAnd0xffToByte(Long.MIN_VALUE));
    assertIntEquals(-1, longAnd0xffToByte(Long.MAX_VALUE));
    assertIntEquals(0x1234, intAnd0x1ffffToChar(0x43211234));
    assertIntEquals(0, intAnd0x1ffffToChar(Integer.MIN_VALUE));
    assertIntEquals(Character.MAX_VALUE, intAnd0x1ffffToChar(Integer.MAX_VALUE));
    assertIntEquals(0x4321, intAnd0x17fffToShort(0x87654321));
    assertIntEquals(0x0888, intAnd0x17fffToShort(0x88888888));
    assertIntEquals(0, intAnd0x17fffToShort(Integer.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, intAnd0x17fffToShort(Integer.MAX_VALUE));
    assertDoubleEquals(0.0, shortAnd0xffffToShortToDouble((short) 0));
    assertDoubleEquals(1.0, shortAnd0xffffToShortToDouble((short) 1));
    assertDoubleEquals(-2.0, shortAnd0xffffToShortToDouble((short) -2));
    assertDoubleEquals(12345.0, shortAnd0xffffToShortToDouble((short) 12345));
    assertDoubleEquals((double) Short.MAX_VALUE, shortAnd0xffffToShortToDouble(Short.MAX_VALUE));
    assertDoubleEquals((double) Short.MIN_VALUE, shortAnd0xffffToShortToDouble(Short.MIN_VALUE));
    assertIntEquals(intReverseCondition(41), 13);
    assertIntEquals(intReverseConditionNaN(-5), 13);
    for (String condition : new String[] { "Equal", "NotEqual" }) {
        for (String constant : new String[] { "True", "False" }) {
            for (String side : new String[] { "Rhs", "Lhs" }) {
                String name = condition + constant + side;
                assertIntEquals(runSmaliTest(name, true), 5);
                assertIntEquals(runSmaliTest(name, false), 3);
            }
        }
    }
    assertIntEquals(0, runSmaliTestConst("AddSubConst", 1));
    assertIntEquals(3, runSmaliTestConst("SubAddConst", 2));
    assertIntEquals(-16, runSmaliTestConst("SubSubConst1", 3));
    assertIntEquals(-5, runSmaliTestConst("SubSubConst2", 4));
    assertIntEquals(26, runSmaliTestConst("SubSubConst3", 5));
}
#method_after
public static void main(String[] args) {
    int arg = 123456;
    assertLongEquals(arg, $noinline$Add0(arg));
    assertIntEquals(5, $noinline$AddAddSubAddConst(1));
    assertIntEquals(arg, $noinline$AndAllOnes(arg));
    assertLongEquals(arg, $noinline$Div1(arg));
    assertIntEquals(-arg, $noinline$DivN1(arg));
    assertLongEquals(arg, $noinline$Mul1(arg));
    assertIntEquals(-arg, $noinline$MulN1(arg));
    assertLongEquals((128 * arg), $noinline$MulPowerOfTwo128(arg));
    assertLongEquals(2640, $noinline$MulMulMulConst(2));
    assertIntEquals(arg, $noinline$Or0(arg));
    assertLongEquals(arg, $noinline$OrSame(arg));
    assertIntEquals(arg, $noinline$Shl0(arg));
    assertLongEquals(arg, $noinline$Shr0(arg));
    assertLongEquals(arg, $noinline$Shr64(arg));
    assertLongEquals(arg, $noinline$Sub0(arg));
    assertIntEquals(-arg, $noinline$SubAliasNeg(arg));
    assertIntEquals(9, $noinline$SubAddConst1(2));
    assertIntEquals(-2, $noinline$SubAddConst2(3));
    assertLongEquals(3, $noinline$SubSubConst(4));
    assertLongEquals(arg, $noinline$UShr0(arg));
    assertIntEquals(arg, $noinline$Xor0(arg));
    assertIntEquals(~arg, $noinline$XorAllOnes(arg));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$AddNegs3(arg, arg + 1));
    assertLongEquals(1, $noinline$AddNeg1(arg, arg + 1));
    assertLongEquals(-1, $noinline$AddNeg2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NegNeg1(arg));
    assertIntEquals(0, $noinline$NegNeg2(arg));
    assertLongEquals(arg, $noinline$NegNeg3(arg));
    assertIntEquals(1, $noinline$NegSub1(arg, arg + 1));
    assertIntEquals(1, $noinline$NegSub2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NotNot1(arg));
    assertIntEquals(-1, $noinline$NotNot2(arg));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$SubNeg3(arg, arg + 1));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(true, $noinline$NotNotBool(true));
    assertBooleanEquals(false, $noinline$NotNotBool(false));
    assertFloatEquals(50.0f, $noinline$Div2(100.0f));
    assertDoubleEquals(75.0, $noinline$Div2(150.0));
    assertFloatEquals(-400.0f, $noinline$DivMP25(100.0f));
    assertDoubleEquals(-600.0, $noinline$DivMP25(150.0));
    assertIntEquals(0xc, $noinline$UShr28And15(0xc1234567));
    assertLongEquals(0xcL, $noinline$UShr60And15(0xc123456787654321L));
    assertIntEquals(0x4, $noinline$UShr28And7(0xc1234567));
    assertLongEquals(0x4L, $noinline$UShr60And7(0xc123456787654321L));
    assertIntEquals(0xc1, $noinline$Shr24And255(0xc1234567));
    assertLongEquals(0xc1L, $noinline$Shr56And255(0xc123456787654321L));
    assertIntEquals(0x41, $noinline$Shr24And127(0xc1234567));
    assertLongEquals(0x41L, $noinline$Shr56And127(0xc123456787654321L));
    assertIntEquals(0, $noinline$mulPow2Plus1(0));
    assertIntEquals(9, $noinline$mulPow2Plus1(1));
    assertIntEquals(18, $noinline$mulPow2Plus1(2));
    assertIntEquals(900, $noinline$mulPow2Plus1(100));
    assertIntEquals(111105, $noinline$mulPow2Plus1(12345));
    assertLongEquals(0, $noinline$mulPow2Minus1(0));
    assertLongEquals(31, $noinline$mulPow2Minus1(1));
    assertLongEquals(62, $noinline$mulPow2Minus1(2));
    assertLongEquals(3100, $noinline$mulPow2Minus1(100));
    assertLongEquals(382695, $noinline$mulPow2Minus1(12345));
    booleanField = false;
    assertIntEquals($noinline$booleanFieldNotEqualOne(), 54);
    assertIntEquals($noinline$booleanFieldEqualZero(), 54);
    booleanField = true;
    assertIntEquals(13, $noinline$booleanFieldNotEqualOne());
    assertIntEquals(13, $noinline$booleanFieldEqualZero());
    assertIntEquals(54, $noinline$intConditionNotEqualOne(6));
    assertIntEquals(13, $noinline$intConditionNotEqualOne(43));
    assertIntEquals(54, $noinline$intConditionEqualZero(6));
    assertIntEquals(13, $noinline$intConditionEqualZero(43));
    assertIntEquals(54, $noinline$floatConditionNotEqualOne(6.0f));
    assertIntEquals(13, $noinline$floatConditionNotEqualOne(43.0f));
    assertIntEquals(54, $noinline$doubleConditionEqualZero(6.0));
    assertIntEquals(13, $noinline$doubleConditionEqualZero(43.0));
    assertIntEquals(1234567, $noinline$intToDoubleToInt(1234567));
    assertIntEquals(Integer.MIN_VALUE, $noinline$intToDoubleToInt(Integer.MIN_VALUE));
    assertIntEquals(Integer.MAX_VALUE, $noinline$intToDoubleToInt(Integer.MAX_VALUE));
    assertStringEquals("d=7654321.0, i=7654321", $noinline$intToDoubleToIntPrint(7654321));
    assertIntEquals(12, $noinline$byteToDoubleToInt((byte) 12));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToInt(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToInt(Byte.MAX_VALUE));
    assertIntEquals(11, $noinline$floatToDoubleToInt(11.3f));
    assertStringEquals("d=12.25, i=12", $noinline$floatToDoubleToIntPrint(12.25f));
    assertIntEquals(123, $noinline$byteToDoubleToShort((byte) 123));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToShort(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToShort(Byte.MAX_VALUE));
    assertIntEquals(1234, $noinline$charToDoubleToShort((char) 1234));
    assertIntEquals(Character.MIN_VALUE, $noinline$charToDoubleToShort(Character.MIN_VALUE));
    assertIntEquals(/* sign-extended */
    -1, $noinline$charToDoubleToShort(Character.MAX_VALUE));
    assertIntEquals(12345, $noinline$floatToIntToShort(12345.75f));
    assertIntEquals(Short.MAX_VALUE, $noinline$floatToIntToShort((float) (Short.MIN_VALUE - 1)));
    assertIntEquals(Short.MIN_VALUE, $noinline$floatToIntToShort((float) (Short.MAX_VALUE + 1)));
    assertIntEquals(-54321, $noinline$intToFloatToInt(-54321));
    assertDoubleEquals((double) 0x12345678, $noinline$longToIntToDouble(0x1234567812345678L));
    assertDoubleEquals(0.0, $noinline$longToIntToDouble(Long.MIN_VALUE));
    assertDoubleEquals(-1.0, $noinline$longToIntToDouble(Long.MAX_VALUE));
    assertLongEquals(0x0000000012345678L, $noinline$longToIntToLong(0x1234567812345678L));
    assertLongEquals(0xffffffff87654321L, $noinline$longToIntToLong(0x1234567887654321L));
    assertLongEquals(0L, $noinline$longToIntToLong(Long.MIN_VALUE));
    assertLongEquals(-1L, $noinline$longToIntToLong(Long.MAX_VALUE));
    assertIntEquals((short) -5678, $noinline$shortToCharToShort((short) -5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToCharToShort(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToCharToShort(Short.MAX_VALUE));
    assertIntEquals(5678, $noinline$shortToLongToInt((short) 5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToLongToInt(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToLongToInt(Short.MAX_VALUE));
    assertIntEquals(0x34, $noinline$shortToCharToByte((short) 0x1234));
    assertIntEquals(-0x10, $noinline$shortToCharToByte((short) 0x12f0));
    assertIntEquals(0, $noinline$shortToCharToByte(Short.MIN_VALUE));
    assertIntEquals(-1, $noinline$shortToCharToByte(Short.MAX_VALUE));
    assertStringEquals("c=1025, b=1", $noinline$shortToCharToBytePrint((short) 1025));
    assertStringEquals("c=1023, b=-1", $noinline$shortToCharToBytePrint((short) 1023));
    assertStringEquals("c=65535, b=-1", $noinline$shortToCharToBytePrint((short) -1));
    assertIntEquals(0x21, $noinline$longAnd0xffToByte(0x1234432112344321L));
    assertIntEquals(0, $noinline$longAnd0xffToByte(Long.MIN_VALUE));
    assertIntEquals(-1, $noinline$longAnd0xffToByte(Long.MAX_VALUE));
    assertIntEquals(0x1234, $noinline$intAnd0x1ffffToChar(0x43211234));
    assertIntEquals(0, $noinline$intAnd0x1ffffToChar(Integer.MIN_VALUE));
    assertIntEquals(Character.MAX_VALUE, $noinline$intAnd0x1ffffToChar(Integer.MAX_VALUE));
    assertIntEquals(0x4321, $noinline$intAnd0x17fffToShort(0x87654321));
    assertIntEquals(0x0888, $noinline$intAnd0x17fffToShort(0x88888888));
    assertIntEquals(0, $noinline$intAnd0x17fffToShort(Integer.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$intAnd0x17fffToShort(Integer.MAX_VALUE));
    assertDoubleEquals(0.0, $noinline$shortAnd0xffffToShortToDouble((short) 0));
    assertDoubleEquals(1.0, $noinline$shortAnd0xffffToShortToDouble((short) 1));
    assertDoubleEquals(-2.0, $noinline$shortAnd0xffffToShortToDouble((short) -2));
    assertDoubleEquals(12345.0, $noinline$shortAnd0xffffToShortToDouble((short) 12345));
    assertDoubleEquals((double) Short.MAX_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MAX_VALUE));
    assertDoubleEquals((double) Short.MIN_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MIN_VALUE));
    assertIntEquals(13, $noinline$intReverseCondition(41));
    assertIntEquals(13, $noinline$intReverseConditionNaN(-5));
    for (String condition : new String[] { "Equal", "NotEqual" }) {
        for (String constant : new String[] { "True", "False" }) {
            for (String side : new String[] { "Rhs", "Lhs" }) {
                String name = condition + constant + side;
                assertIntEquals(5, $noinline$runSmaliTest(name, true));
                assertIntEquals(3, $noinline$runSmaliTest(name, false));
            }
        }
    }
    assertIntEquals(0, $noinline$runSmaliTestConst("AddSubConst", 1));
    assertIntEquals(3, $noinline$runSmaliTestConst("SubAddConst", 2));
    assertIntEquals(-16, $noinline$runSmaliTestConst("SubSubConst1", 3));
    assertIntEquals(-5, $noinline$runSmaliTestConst("SubSubConst2", 4));
    assertIntEquals(26, $noinline$runSmaliTestConst("SubSubConst3", 5));
    assertIntEquals(0x5e6f7808, $noinline$intUnnecessaryShiftMasking(0xabcdef01, 3));
    assertIntEquals(0x5e6f7808, $noinline$intUnnecessaryShiftMasking(0xabcdef01, 3 + 32));
    assertLongEquals(0xffffffffffffeaf3L, $noinline$longUnnecessaryShiftMasking(0xabcdef0123456789L, 50));
    assertLongEquals(0xffffffffffffeaf3L, $noinline$longUnnecessaryShiftMasking(0xabcdef0123456789L, 50 + 64));
    assertIntEquals(0x2af37b, $noinline$intUnnecessaryWiderShiftMasking(0xabcdef01, 10));
    assertIntEquals(0x2af37b, $noinline$intUnnecessaryWiderShiftMasking(0xabcdef01, 10 + 128));
    assertLongEquals(0xaf37bc048d159e24L, $noinline$longSmallerShiftMasking(0xabcdef0123456789L, 2));
    assertLongEquals(0xaf37bc048d159e24L, $noinline$longSmallerShiftMasking(0xabcdef0123456789L, 2 + 256));
    assertIntEquals(0xfffd5e7c, $noinline$otherUseOfUnnecessaryShiftMasking(0xabcdef01, 13));
    assertIntEquals(0xfffd5e7c, $noinline$otherUseOfUnnecessaryShiftMasking(0xabcdef01, 13 + 512));
}
#end_block

#method_before
// / CHECK-START: void Main.testExplicitArgumentMoreSpecific(SubclassA) inliner (before)
// / CHECK-DAG:     <<Arg:l\d+>>   ParameterValue klass:SubclassA
// / CHECK-DAG:                    InvokeStaticOrDirect [<<Arg>>{{(,[ij]\d+)?}}] method_name:Main.$inline$hashCode
// / CHECK-START: void Main.testExplicitArgumentMoreSpecific(SubclassA) inliner (after)
// / CHECK-DAG:     <<Arg:l\d+>>   ParameterValue klass:SubclassA
// / CHECK-DAG:     <<NCArg:l\d+>> NullCheck [<<Arg>>] klass:SubclassA
// / CHECK-DAG:                    InvokeVirtual [<<NCArg>>] method_name:Super.hashCode
public void testExplicitArgumentMoreSpecific(SubclassA obj) {
    // Inlining a method will build it with reference types from its signature,
    // here the callee graph is built with Super as the type of its only argument.
    // Running RTP after its ParameterValue instructions are replaced with actual
    // arguments will type the inner graph more precisely.
    $inline$hashCode(obj);
}
#method_after
// / CHECK-START: void Main.testExplicitArgumentMoreSpecific(SubclassA) inliner (before)
// / CHECK-DAG:     <<Arg:l\d+>>   ParameterValue klass:SubclassA
// Note: The ArtMethod* (typed as int or long) is optional after sharpening.
// / CHECK-DAG:                    InvokeStaticOrDirect [<<Arg>>{{(,[ij]\d+)?}}] method_name:Main.$inline$hashCode
// / CHECK-START: void Main.testExplicitArgumentMoreSpecific(SubclassA) inliner (after)
// / CHECK-DAG:     <<Arg:l\d+>>   ParameterValue klass:SubclassA
// / CHECK-DAG:     <<NCArg:l\d+>> NullCheck [<<Arg>>] klass:SubclassA
// / CHECK-DAG:                    InvokeVirtual [<<NCArg>>] method_name:Super.hashCode
public void testExplicitArgumentMoreSpecific(SubclassA obj) {
    // Inlining a method will build it with reference types from its signature,
    // here the callee graph is built with Super as the type of its only argument.
    // Running RTP after its ParameterValue instructions are replaced with actual
    // arguments will type the inner graph more precisely.
    $inline$hashCode(obj);
}
#end_block

#method_before
/*
   * Test simplification of double Boolean negation. Note that sometimes
   * both negations can be removed but we only expect the simplifier to
   * remove the second.
   */
// / CHECK-START: boolean Main.NotNotBool(boolean) instruction_simplifier_after_bce (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const0:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 1
// / CHECK-DAG:     <<NotArg:i\d+>>    Select [<<Const1>>,<<Const0>>,<<Arg>>]
// / CHECK-DAG:     <<NotNotArg:i\d+>> Select [<<Const1>>,<<Const0>>,<<NotArg>>]
// / CHECK-DAG:                        Return [<<NotNotArg>>]
// / CHECK-START: boolean Main.NotNotBool(boolean) instruction_simplifier_after_bce (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:                        Return [<<Arg>>]
public static boolean NegateValue(boolean arg) {
    return !arg;
}
#method_after
/*
   * Test simplification of double Boolean negation. Note that sometimes
   * both negations can be removed but we only expect the simplifier to
   * remove the second.
   */
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier_after_bce (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const0:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 1
// / CHECK-DAG:     <<NotArg:i\d+>>    Select [<<Const1>>,<<Const0>>,<<Arg>>]
// / CHECK-DAG:     <<NotNotArg:i\d+>> Select [<<Const1>>,<<Const0>>,<<NotArg>>]
// / CHECK-DAG:                        Return [<<NotNotArg>>]
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier_after_bce (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:                        Return [<<Arg>>]
public static boolean NegateValue(boolean arg) {
    return !arg;
}
#end_block

#method_before
public static void main(String[] args) {
    int arg = 123456;
    assertLongEquals(arg, Add0(arg));
    assertIntEquals(arg, AndAllOnes(arg));
    assertLongEquals(arg, Div1(arg));
    assertIntEquals(-arg, DivN1(arg));
    assertLongEquals(arg, Mul1(arg));
    assertIntEquals(-arg, MulN1(arg));
    assertLongEquals((128 * arg), MulPowerOfTwo128(arg));
    assertIntEquals(arg, Or0(arg));
    assertLongEquals(arg, OrSame(arg));
    assertIntEquals(arg, Shl0(arg));
    assertLongEquals(arg, Shr0(arg));
    assertLongEquals(arg, Shr64(arg));
    assertLongEquals(arg, Sub0(arg));
    assertIntEquals(-arg, SubAliasNeg(arg));
    assertLongEquals(arg, UShr0(arg));
    assertIntEquals(arg, Xor0(arg));
    assertIntEquals(~arg, XorAllOnes(arg));
    assertIntEquals(-(arg + arg + 1), AddNegs1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), AddNegs2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), AddNegs3(arg, arg + 1));
    assertLongEquals(1, AddNeg1(arg, arg + 1));
    assertLongEquals(-1, AddNeg2(arg, arg + 1));
    assertLongEquals(arg, NegNeg1(arg));
    assertIntEquals(0, NegNeg2(arg));
    assertLongEquals(arg, NegNeg3(arg));
    assertIntEquals(1, NegSub1(arg, arg + 1));
    assertIntEquals(1, NegSub2(arg, arg + 1));
    assertLongEquals(arg, NotNot1(arg));
    assertIntEquals(-1, NotNot2(arg));
    assertIntEquals(-(arg + arg + 1), SubNeg1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), SubNeg2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), SubNeg3(arg, arg + 1));
    assertBooleanEquals(true, EqualBoolVsIntConst(true));
    assertBooleanEquals(true, EqualBoolVsIntConst(true));
    assertBooleanEquals(false, NotEqualBoolVsIntConst(false));
    assertBooleanEquals(false, NotEqualBoolVsIntConst(false));
    assertBooleanEquals(true, NotNotBool(true));
    assertBooleanEquals(false, NotNotBool(false));
    assertFloatEquals(50.0f, Div2(100.0f));
    assertDoubleEquals(75.0, Div2(150.0));
    assertFloatEquals(-400.0f, DivMP25(100.0f));
    assertDoubleEquals(-600.0, DivMP25(150.0));
    assertIntEquals(0xc, UShr28And15(0xc1234567));
    assertLongEquals(0xcL, UShr60And15(0xc123456787654321L));
    assertIntEquals(0x4, UShr28And7(0xc1234567));
    assertLongEquals(0x4L, UShr60And7(0xc123456787654321L));
    assertIntEquals(0xc1, Shr24And255(0xc1234567));
    assertLongEquals(0xc1L, Shr56And255(0xc123456787654321L));
    assertIntEquals(0x41, Shr24And127(0xc1234567));
    assertLongEquals(0x41L, Shr56And127(0xc123456787654321L));
    assertIntEquals(0, mulPow2Plus1(0));
    assertIntEquals(9, mulPow2Plus1(1));
    assertIntEquals(18, mulPow2Plus1(2));
    assertIntEquals(900, mulPow2Plus1(100));
    assertIntEquals(111105, mulPow2Plus1(12345));
    assertLongEquals(0, mulPow2Minus1(0));
    assertLongEquals(31, mulPow2Minus1(1));
    assertLongEquals(62, mulPow2Minus1(2));
    assertLongEquals(3100, mulPow2Minus1(100));
    assertLongEquals(382695, mulPow2Minus1(12345));
    booleanField = false;
    assertIntEquals(booleanFieldNotEqualOne(), 54);
    assertIntEquals(booleanFieldEqualZero(), 54);
    booleanField = true;
    assertIntEquals(13, booleanFieldNotEqualOne());
    assertIntEquals(13, booleanFieldEqualZero());
    assertIntEquals(54, intConditionNotEqualOne(6));
    assertIntEquals(13, intConditionNotEqualOne(43));
    assertIntEquals(54, intConditionEqualZero(6));
    assertIntEquals(13, intConditionEqualZero(43));
    assertIntEquals(54, floatConditionNotEqualOne(6.0f));
    assertIntEquals(13, floatConditionNotEqualOne(43.0f));
    assertIntEquals(54, doubleConditionEqualZero(6.0));
    assertIntEquals(13, doubleConditionEqualZero(43.0));
    assertIntEquals(1234567, intToDoubleToInt(1234567));
    assertIntEquals(Integer.MIN_VALUE, intToDoubleToInt(Integer.MIN_VALUE));
    assertIntEquals(Integer.MAX_VALUE, intToDoubleToInt(Integer.MAX_VALUE));
    assertStringEquals("d=7654321.0, i=7654321", intToDoubleToIntPrint(7654321));
    assertIntEquals(12, byteToDoubleToInt((byte) 12));
    assertIntEquals(Byte.MIN_VALUE, byteToDoubleToInt(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, byteToDoubleToInt(Byte.MAX_VALUE));
    assertIntEquals(11, floatToDoubleToInt(11.3f));
    assertStringEquals("d=12.25, i=12", floatToDoubleToIntPrint(12.25f));
    assertIntEquals(123, byteToDoubleToShort((byte) 123));
    assertIntEquals(Byte.MIN_VALUE, byteToDoubleToShort(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, byteToDoubleToShort(Byte.MAX_VALUE));
    assertIntEquals(1234, charToDoubleToShort((char) 1234));
    assertIntEquals(Character.MIN_VALUE, charToDoubleToShort(Character.MIN_VALUE));
    assertIntEquals(/* sign-extended */
    -1, charToDoubleToShort(Character.MAX_VALUE));
    assertIntEquals(12345, floatToIntToShort(12345.75f));
    assertIntEquals(Short.MAX_VALUE, floatToIntToShort((float) (Short.MIN_VALUE - 1)));
    assertIntEquals(Short.MIN_VALUE, floatToIntToShort((float) (Short.MAX_VALUE + 1)));
    assertIntEquals(-54321, intToFloatToInt(-54321));
    assertDoubleEquals((double) 0x12345678, longToIntToDouble(0x1234567812345678L));
    assertDoubleEquals(0.0, longToIntToDouble(Long.MIN_VALUE));
    assertDoubleEquals(-1.0, longToIntToDouble(Long.MAX_VALUE));
    assertLongEquals(0x0000000012345678L, longToIntToLong(0x1234567812345678L));
    assertLongEquals(0xffffffff87654321L, longToIntToLong(0x1234567887654321L));
    assertLongEquals(0L, longToIntToLong(Long.MIN_VALUE));
    assertLongEquals(-1L, longToIntToLong(Long.MAX_VALUE));
    assertIntEquals((short) -5678, shortToCharToShort((short) -5678));
    assertIntEquals(Short.MIN_VALUE, shortToCharToShort(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, shortToCharToShort(Short.MAX_VALUE));
    assertIntEquals(5678, shortToLongToInt((short) 5678));
    assertIntEquals(Short.MIN_VALUE, shortToLongToInt(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, shortToLongToInt(Short.MAX_VALUE));
    assertIntEquals(0x34, shortToCharToByte((short) 0x1234));
    assertIntEquals(-0x10, shortToCharToByte((short) 0x12f0));
    assertIntEquals(0, shortToCharToByte(Short.MIN_VALUE));
    assertIntEquals(-1, shortToCharToByte(Short.MAX_VALUE));
    assertStringEquals("c=1025, b=1", shortToCharToBytePrint((short) 1025));
    assertStringEquals("c=1023, b=-1", shortToCharToBytePrint((short) 1023));
    assertStringEquals("c=65535, b=-1", shortToCharToBytePrint((short) -1));
    assertIntEquals(0x21, longAnd0xffToByte(0x1234432112344321L));
    assertIntEquals(0, longAnd0xffToByte(Long.MIN_VALUE));
    assertIntEquals(-1, longAnd0xffToByte(Long.MAX_VALUE));
    assertIntEquals(0x1234, intAnd0x1ffffToChar(0x43211234));
    assertIntEquals(0, intAnd0x1ffffToChar(Integer.MIN_VALUE));
    assertIntEquals(Character.MAX_VALUE, intAnd0x1ffffToChar(Integer.MAX_VALUE));
    assertIntEquals(0x4321, intAnd0x17fffToShort(0x87654321));
    assertIntEquals(0x0888, intAnd0x17fffToShort(0x88888888));
    assertIntEquals(0, intAnd0x17fffToShort(Integer.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, intAnd0x17fffToShort(Integer.MAX_VALUE));
    assertDoubleEquals(0.0, shortAnd0xffffToShortToDouble((short) 0));
    assertDoubleEquals(1.0, shortAnd0xffffToShortToDouble((short) 1));
    assertDoubleEquals(-2.0, shortAnd0xffffToShortToDouble((short) -2));
    assertDoubleEquals(12345.0, shortAnd0xffffToShortToDouble((short) 12345));
    assertDoubleEquals((double) Short.MAX_VALUE, shortAnd0xffffToShortToDouble(Short.MAX_VALUE));
    assertDoubleEquals((double) Short.MIN_VALUE, shortAnd0xffffToShortToDouble(Short.MIN_VALUE));
    assertIntEquals(13, intReverseCondition(41));
    assertIntEquals(13, intReverseConditionNaN(-5));
    for (String condition : new String[] { "Equal", "NotEqual" }) {
        for (String constant : new String[] { "True", "False" }) {
            for (String side : new String[] { "Rhs", "Lhs" }) {
                String name = condition + constant + side;
                assertIntEquals(5, runSmaliTest(name, true));
                assertIntEquals(3, runSmaliTest(name, false));
            }
        }
    }
}
#method_after
public static void main(String[] args) {
    int arg = 123456;
    assertLongEquals(arg, $noinline$Add0(arg));
    assertIntEquals(arg, $noinline$AndAllOnes(arg));
    assertLongEquals(arg, $noinline$Div1(arg));
    assertIntEquals(-arg, $noinline$DivN1(arg));
    assertLongEquals(arg, $noinline$Mul1(arg));
    assertIntEquals(-arg, $noinline$MulN1(arg));
    assertLongEquals((128 * arg), $noinline$MulPowerOfTwo128(arg));
    assertIntEquals(arg, $noinline$Or0(arg));
    assertLongEquals(arg, $noinline$OrSame(arg));
    assertIntEquals(arg, $noinline$Shl0(arg));
    assertLongEquals(arg, $noinline$Shr0(arg));
    assertLongEquals(arg, $noinline$Shr64(arg));
    assertLongEquals(arg, $noinline$Sub0(arg));
    assertIntEquals(-arg, $noinline$SubAliasNeg(arg));
    assertLongEquals(arg, $noinline$UShr0(arg));
    assertIntEquals(arg, $noinline$Xor0(arg));
    assertIntEquals(~arg, $noinline$XorAllOnes(arg));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$AddNegs3(arg, arg + 1));
    assertLongEquals(1, $noinline$AddNeg1(arg, arg + 1));
    assertLongEquals(-1, $noinline$AddNeg2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NegNeg1(arg));
    assertIntEquals(0, $noinline$NegNeg2(arg));
    assertLongEquals(arg, $noinline$NegNeg3(arg));
    assertIntEquals(1, $noinline$NegSub1(arg, arg + 1));
    assertIntEquals(1, $noinline$NegSub2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NotNot1(arg));
    assertIntEquals(-1, $noinline$NotNot2(arg));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$SubNeg3(arg, arg + 1));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(true, $noinline$NotNotBool(true));
    assertBooleanEquals(false, $noinline$NotNotBool(false));
    assertFloatEquals(50.0f, $noinline$Div2(100.0f));
    assertDoubleEquals(75.0, $noinline$Div2(150.0));
    assertFloatEquals(-400.0f, $noinline$DivMP25(100.0f));
    assertDoubleEquals(-600.0, $noinline$DivMP25(150.0));
    assertIntEquals(0xc, $noinline$UShr28And15(0xc1234567));
    assertLongEquals(0xcL, $noinline$UShr60And15(0xc123456787654321L));
    assertIntEquals(0x4, $noinline$UShr28And7(0xc1234567));
    assertLongEquals(0x4L, $noinline$UShr60And7(0xc123456787654321L));
    assertIntEquals(0xc1, $noinline$Shr24And255(0xc1234567));
    assertLongEquals(0xc1L, $noinline$Shr56And255(0xc123456787654321L));
    assertIntEquals(0x41, $noinline$Shr24And127(0xc1234567));
    assertLongEquals(0x41L, $noinline$Shr56And127(0xc123456787654321L));
    assertIntEquals(0, $noinline$mulPow2Plus1(0));
    assertIntEquals(9, $noinline$mulPow2Plus1(1));
    assertIntEquals(18, $noinline$mulPow2Plus1(2));
    assertIntEquals(900, $noinline$mulPow2Plus1(100));
    assertIntEquals(111105, $noinline$mulPow2Plus1(12345));
    assertLongEquals(0, $noinline$mulPow2Minus1(0));
    assertLongEquals(31, $noinline$mulPow2Minus1(1));
    assertLongEquals(62, $noinline$mulPow2Minus1(2));
    assertLongEquals(3100, $noinline$mulPow2Minus1(100));
    assertLongEquals(382695, $noinline$mulPow2Minus1(12345));
    booleanField = false;
    assertIntEquals($noinline$booleanFieldNotEqualOne(), 54);
    assertIntEquals($noinline$booleanFieldEqualZero(), 54);
    booleanField = true;
    assertIntEquals(13, $noinline$booleanFieldNotEqualOne());
    assertIntEquals(13, $noinline$booleanFieldEqualZero());
    assertIntEquals(54, $noinline$intConditionNotEqualOne(6));
    assertIntEquals(13, $noinline$intConditionNotEqualOne(43));
    assertIntEquals(54, $noinline$intConditionEqualZero(6));
    assertIntEquals(13, $noinline$intConditionEqualZero(43));
    assertIntEquals(54, $noinline$floatConditionNotEqualOne(6.0f));
    assertIntEquals(13, $noinline$floatConditionNotEqualOne(43.0f));
    assertIntEquals(54, $noinline$doubleConditionEqualZero(6.0));
    assertIntEquals(13, $noinline$doubleConditionEqualZero(43.0));
    assertIntEquals(1234567, $noinline$intToDoubleToInt(1234567));
    assertIntEquals(Integer.MIN_VALUE, $noinline$intToDoubleToInt(Integer.MIN_VALUE));
    assertIntEquals(Integer.MAX_VALUE, $noinline$intToDoubleToInt(Integer.MAX_VALUE));
    assertStringEquals("d=7654321.0, i=7654321", $noinline$intToDoubleToIntPrint(7654321));
    assertIntEquals(12, $noinline$byteToDoubleToInt((byte) 12));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToInt(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToInt(Byte.MAX_VALUE));
    assertIntEquals(11, $noinline$floatToDoubleToInt(11.3f));
    assertStringEquals("d=12.25, i=12", $noinline$floatToDoubleToIntPrint(12.25f));
    assertIntEquals(123, $noinline$byteToDoubleToShort((byte) 123));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToShort(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToShort(Byte.MAX_VALUE));
    assertIntEquals(1234, $noinline$charToDoubleToShort((char) 1234));
    assertIntEquals(Character.MIN_VALUE, $noinline$charToDoubleToShort(Character.MIN_VALUE));
    assertIntEquals(/* sign-extended */
    -1, $noinline$charToDoubleToShort(Character.MAX_VALUE));
    assertIntEquals(12345, $noinline$floatToIntToShort(12345.75f));
    assertIntEquals(Short.MAX_VALUE, $noinline$floatToIntToShort((float) (Short.MIN_VALUE - 1)));
    assertIntEquals(Short.MIN_VALUE, $noinline$floatToIntToShort((float) (Short.MAX_VALUE + 1)));
    assertIntEquals(-54321, $noinline$intToFloatToInt(-54321));
    assertDoubleEquals((double) 0x12345678, $noinline$longToIntToDouble(0x1234567812345678L));
    assertDoubleEquals(0.0, $noinline$longToIntToDouble(Long.MIN_VALUE));
    assertDoubleEquals(-1.0, $noinline$longToIntToDouble(Long.MAX_VALUE));
    assertLongEquals(0x0000000012345678L, $noinline$longToIntToLong(0x1234567812345678L));
    assertLongEquals(0xffffffff87654321L, $noinline$longToIntToLong(0x1234567887654321L));
    assertLongEquals(0L, $noinline$longToIntToLong(Long.MIN_VALUE));
    assertLongEquals(-1L, $noinline$longToIntToLong(Long.MAX_VALUE));
    assertIntEquals((short) -5678, $noinline$shortToCharToShort((short) -5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToCharToShort(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToCharToShort(Short.MAX_VALUE));
    assertIntEquals(5678, $noinline$shortToLongToInt((short) 5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToLongToInt(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToLongToInt(Short.MAX_VALUE));
    assertIntEquals(0x34, $noinline$shortToCharToByte((short) 0x1234));
    assertIntEquals(-0x10, $noinline$shortToCharToByte((short) 0x12f0));
    assertIntEquals(0, $noinline$shortToCharToByte(Short.MIN_VALUE));
    assertIntEquals(-1, $noinline$shortToCharToByte(Short.MAX_VALUE));
    assertStringEquals("c=1025, b=1", $noinline$shortToCharToBytePrint((short) 1025));
    assertStringEquals("c=1023, b=-1", $noinline$shortToCharToBytePrint((short) 1023));
    assertStringEquals("c=65535, b=-1", $noinline$shortToCharToBytePrint((short) -1));
    assertIntEquals(0x21, $noinline$longAnd0xffToByte(0x1234432112344321L));
    assertIntEquals(0, $noinline$longAnd0xffToByte(Long.MIN_VALUE));
    assertIntEquals(-1, $noinline$longAnd0xffToByte(Long.MAX_VALUE));
    assertIntEquals(0x1234, $noinline$intAnd0x1ffffToChar(0x43211234));
    assertIntEquals(0, $noinline$intAnd0x1ffffToChar(Integer.MIN_VALUE));
    assertIntEquals(Character.MAX_VALUE, $noinline$intAnd0x1ffffToChar(Integer.MAX_VALUE));
    assertIntEquals(0x4321, $noinline$intAnd0x17fffToShort(0x87654321));
    assertIntEquals(0x0888, $noinline$intAnd0x17fffToShort(0x88888888));
    assertIntEquals(0, $noinline$intAnd0x17fffToShort(Integer.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$intAnd0x17fffToShort(Integer.MAX_VALUE));
    assertDoubleEquals(0.0, $noinline$shortAnd0xffffToShortToDouble((short) 0));
    assertDoubleEquals(1.0, $noinline$shortAnd0xffffToShortToDouble((short) 1));
    assertDoubleEquals(-2.0, $noinline$shortAnd0xffffToShortToDouble((short) -2));
    assertDoubleEquals(12345.0, $noinline$shortAnd0xffffToShortToDouble((short) 12345));
    assertDoubleEquals((double) Short.MAX_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MAX_VALUE));
    assertDoubleEquals((double) Short.MIN_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MIN_VALUE));
    assertIntEquals(13, $noinline$intReverseCondition(41));
    assertIntEquals(13, $noinline$intReverseConditionNaN(-5));
    for (String condition : new String[] { "Equal", "NotEqual" }) {
        for (String constant : new String[] { "True", "False" }) {
            for (String side : new String[] { "Rhs", "Lhs" }) {
                String name = condition + constant + side;
                assertIntEquals(5, $noinline$runSmaliTest(name, true));
                assertIntEquals(3, $noinline$runSmaliTest(name, false));
            }
        }
    }
}
#end_block

#method_before
static URLStreamHandler getURLStreamHandler(String protocol) {
    URLStreamHandler handler = (URLStreamHandler) handlers.get(protocol);
    if (handler == null) {
        boolean checkedWithFactory = false;
        // Use the factory (if any)
        if (factory != null) {
            handler = factory.createURLStreamHandler(protocol);
            checkedWithFactory = true;
        }
        // Try java protocol handler
        if (handler == null) {
            final String packagePrefixList = System.getProperty(protocolPathProp, "");
            StringTokenizer packagePrefixIter = new StringTokenizer(packagePrefixList, "|");
            while (handler == null && packagePrefixIter.hasMoreTokens()) {
                String packagePrefix = packagePrefixIter.nextToken().trim();
                try {
                    String clsName = packagePrefix + "." + protocol + ".Handler";
                    Class cls = null;
                    try {
                        ClassLoader cl = ClassLoader.getSystemClassLoader();
                        cls = Class.forName(clsName, true, cl);
                    } catch (ClassNotFoundException e) {
                        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
                        if (contextLoader != null) {
                            cls = Class.forName(clsName, true, contextLoader);
                        }
                    }
                    if (cls != null) {
                        handler = (URLStreamHandler) cls.newInstance();
                    }
                } catch (ReflectiveOperationException ignored) {
                }
            }
        }
        // Makes okhttp the default http/https handler
        if (handler == null) {
            try {
                if (protocol.equals("file")) {
                    handler = new sun.net.www.protocol.file.Handler();
                } else if (protocol.equals("ftp")) {
                    handler = new sun.net.www.protocol.ftp.Handler();
                } else if (protocol.equals("jar")) {
                    handler = new sun.net.www.protocol.jar.Handler();
                } else if (protocol.equals("http")) {
                    handler = (URLStreamHandler) Class.forName("com.android.okhttp.HttpHandler").newInstance();
                } else if (protocol.equals("https")) {
                    handler = (URLStreamHandler) Class.forName("com.android.okhttp.HttpsHandler").newInstance();
                }
            } catch (Exception e) {
                throw new AssertionError(e);
            }
        }
        synchronized (streamHandlerLock) {
            URLStreamHandler handler2 = null;
            // Check again with hashtable just in case another
            // thread created a handler since we last checked
            handler2 = (URLStreamHandler) handlers.get(protocol);
            if (handler2 != null) {
                return handler2;
            }
            // factory since our last check
            if (!checkedWithFactory && factory != null) {
                handler2 = factory.createURLStreamHandler(protocol);
            }
            if (handler2 != null) {
                // The handler from the factory must be given more
                // importance. Discard the default handler that
                // this thread created.
                handler = handler2;
            }
            // Insert this handler into the hashtable
            if (handler != null) {
                handlers.put(protocol, handler);
            }
        }
    }
    return handler;
}
#method_after
static URLStreamHandler getURLStreamHandler(String protocol) {
    URLStreamHandler handler = (URLStreamHandler) handlers.get(protocol);
    if (handler == null) {
        boolean checkedWithFactory = false;
        // Use the factory (if any)
        if (factory != null) {
            handler = factory.createURLStreamHandler(protocol);
            checkedWithFactory = true;
        }
        // Try java protocol handler
        if (handler == null) {
            final String packagePrefixList = System.getProperty(protocolPathProp, "");
            StringTokenizer packagePrefixIter = new StringTokenizer(packagePrefixList, "|");
            while (handler == null && packagePrefixIter.hasMoreTokens()) {
                String packagePrefix = packagePrefixIter.nextToken().trim();
                try {
                    String clsName = packagePrefix + "." + protocol + ".Handler";
                    Class cls = null;
                    try {
                        ClassLoader cl = ClassLoader.getSystemClassLoader();
                        cls = Class.forName(clsName, true, cl);
                    } catch (ClassNotFoundException e) {
                        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
                        if (contextLoader != null) {
                            cls = Class.forName(clsName, true, contextLoader);
                        }
                    }
                    if (cls != null) {
                        handler = (URLStreamHandler) cls.newInstance();
                    }
                } catch (ReflectiveOperationException ignored) {
                }
            }
        }
        // Makes okhttp the default http/https handler
        if (handler == null) {
            try {
                // Removed unnecessary use of reflection for sun classes
                if (protocol.equals("file")) {
                    handler = new sun.net.www.protocol.file.Handler();
                } else if (protocol.equals("ftp")) {
                    handler = new sun.net.www.protocol.ftp.Handler();
                } else if (protocol.equals("jar")) {
                    handler = new sun.net.www.protocol.jar.Handler();
                } else if (protocol.equals("http")) {
                    handler = (URLStreamHandler) Class.forName("com.android.okhttp.HttpHandler").newInstance();
                } else if (protocol.equals("https")) {
                    handler = (URLStreamHandler) Class.forName("com.android.okhttp.HttpsHandler").newInstance();
                }
            // END android-changed
            } catch (Exception e) {
                throw new AssertionError(e);
            }
        }
        synchronized (streamHandlerLock) {
            URLStreamHandler handler2 = null;
            // Check again with hashtable just in case another
            // thread created a handler since we last checked
            handler2 = (URLStreamHandler) handlers.get(protocol);
            if (handler2 != null) {
                return handler2;
            }
            // factory since our last check
            if (!checkedWithFactory && factory != null) {
                handler2 = factory.createURLStreamHandler(protocol);
            }
            if (handler2 != null) {
                // The handler from the factory must be given more
                // importance. Discard the default handler that
                // this thread created.
                handler = handler2;
            }
            // Insert this handler into the hashtable
            if (handler != null) {
                handlers.put(protocol, handler);
            }
        }
    }
    return handler;
}
#end_block

#method_before
public void testConnectViaHttps() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/foo").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertContent("this response comes via HTTPS", connection);
    RecordedRequest request = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
    assertEquals("TLSv1.2", request.getSslProtocol());
}
#method_after
public void testConnectViaHttps() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/foo").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertContent("this response comes via HTTPS", connection);
    RecordedRequest request = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
    assertEquals("TLSv1.2", request.getSslProtocol());
}
#end_block

#method_before
public void testConnectViaHttpsReusingConnections() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createTestSSLContext();
    SSLSocketFactory clientSocketFactory = testSSLContext.clientContext.getSocketFactory();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(clientSocketFactory);
    assertContent("this response comes via HTTPS", connection);
    connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(clientSocketFactory);
    assertContent("another response via HTTPS", connection);
    assertEquals(0, server.takeRequest().getSequenceNumber());
    assertEquals(1, server.takeRequest().getSequenceNumber());
}
#method_after
public void testConnectViaHttpsReusingConnections() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    SSLSocketFactory clientSocketFactory = testSSLContext.clientContext.getSocketFactory();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(clientSocketFactory);
    assertContent("this response comes via HTTPS", connection);
    connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(clientSocketFactory);
    assertContent("another response via HTTPS", connection);
    assertEquals(0, server.takeRequest().getSequenceNumber());
    assertEquals(1, server.takeRequest().getSequenceNumber());
}
#end_block

#method_before
public void testConnectViaHttpsReusingConnectionsDifferentFactories() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
    server.play();
    // install a custom SSL socket factory so the server can be authorized
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertContent("this response comes via HTTPS", connection);
    connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    try {
        readAscii(connection.getInputStream(), Integer.MAX_VALUE);
        fail("without an SSL socket factory, the connection should fail");
    } catch (SSLException expected) {
    }
}
#method_after
public void testConnectViaHttpsReusingConnectionsDifferentFactories() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
    server.play();
    // install a custom SSL socket factory so the server can be authorized
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertContent("this response comes via HTTPS", connection);
    connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    try {
        readAscii(connection.getInputStream(), Integer.MAX_VALUE);
        fail("without an SSL socket factory, the connection should fail");
    } catch (SSLException expected) {
    }
}
#end_block

#method_before
private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.play();
    URL url = server.getUrl("/foo");
    HttpsURLConnection connection = (HttpsURLConnection) proxyConfig.connect(server, url);
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertContent("this response comes via HTTPS", connection);
    RecordedRequest request = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
}
#method_after
private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
    server.play();
    URL url = server.getUrl("/foo");
    HttpsURLConnection connection = (HttpsURLConnection) proxyConfig.connect(server, url);
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertContent("this response comes via HTTPS", connection);
    RecordedRequest request = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
}
#end_block

#method_before
private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) proxyConfig.connect(server, url);
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(hostnameVerifier);
    assertContent("this response comes via a secure proxy", connection);
    RecordedRequest connect = server.takeRequest();
    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
    assertContains(connect.getHeaders(), "Host: android.com");
    RecordedRequest get = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
    assertContains(get.getHeaders(), "Host: android.com");
    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
}
#method_after
private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) proxyConfig.connect(server, url);
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(hostnameVerifier);
    assertContent("this response comes via a secure proxy", connection);
    RecordedRequest connect = server.takeRequest();
    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
    assertContains(connect.getHeaders(), "Host: android.com");
    RecordedRequest get = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
    assertContains(get.getHeaders(), "Host: android.com");
    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
}
#end_block

#method_before
public void testConnectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    initResponseCache();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    // The inclusion of a body in the response to the CONNECT is key to reproducing b/6754912.
    MockResponse badProxyResponse = new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders().setBody("bogus proxy connect response content");
    server.enqueue(badProxyResponse);
    server.enqueue(new MockResponse().setBody("response"));
    server.play();
    URL url = new URL("https://android.com/foo");
    ProxyConfig proxyConfig = ProxyConfig.PROXY_SYSTEM_PROPERTY;
    HttpsURLConnection connection = (HttpsURLConnection) proxyConfig.connect(server, url);
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(new RecordingHostnameVerifier());
    assertContent("response", connection);
    RecordedRequest connect = server.takeRequest();
    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
    assertContains(connect.getHeaders(), "Host: android.com");
}
#method_after
public void testConnectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    initResponseCache();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    // The inclusion of a body in the response to the CONNECT is key to reproducing b/6754912.
    MockResponse badProxyResponse = new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders().setBody("bogus proxy connect response content");
    server.enqueue(badProxyResponse);
    server.enqueue(new MockResponse().setBody("response"));
    server.play();
    URL url = new URL("https://android.com/foo");
    ProxyConfig proxyConfig = ProxyConfig.PROXY_SYSTEM_PROPERTY;
    HttpsURLConnection connection = (HttpsURLConnection) proxyConfig.connect(server, url);
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(new RecordingHostnameVerifier());
    assertContent("response", connection);
    RecordedRequest connect = server.takeRequest();
    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
    assertContains(connect.getHeaders(), "Host: android.com");
}
#end_block

#method_before
public void testProxyConnectIncludesProxyHeadersOnly() throws IOException, InterruptedException {
    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(server.toProxyAddress());
    connection.addRequestProperty("Private", "Secret");
    connection.addRequestProperty("Proxy-Authorization", "bar");
    connection.addRequestProperty("User-Agent", "baz");
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(hostnameVerifier);
    assertContent("encrypted response from the origin server", connection);
    RecordedRequest connect = server.takeRequest();
    assertContainsNoneMatching(connect.getHeaders(), "Private.*");
    assertContains(connect.getHeaders(), "Proxy-Authorization: bar");
    assertContains(connect.getHeaders(), "User-Agent: baz");
    assertContains(connect.getHeaders(), "Host: android.com");
    assertContains(connect.getHeaders(), "Proxy-Connection: Keep-Alive");
    RecordedRequest get = server.takeRequest();
    assertContains(get.getHeaders(), "Private: Secret");
    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
}
#method_after
public void testProxyConnectIncludesProxyHeadersOnly() throws IOException, InterruptedException {
    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(server.toProxyAddress());
    connection.addRequestProperty("Private", "Secret");
    connection.addRequestProperty("Proxy-Authorization", "bar");
    connection.addRequestProperty("User-Agent", "baz");
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(hostnameVerifier);
    assertContent("encrypted response from the origin server", connection);
    RecordedRequest connect = server.takeRequest();
    assertContainsNoneMatching(connect.getHeaders(), "Private.*");
    assertContains(connect.getHeaders(), "Proxy-Authorization: bar");
    assertContains(connect.getHeaders(), "User-Agent: baz");
    assertContains(connect.getHeaders(), "Host: android.com");
    assertContains(connect.getHeaders(), "Proxy-Connection: Keep-Alive");
    RecordedRequest get = server.takeRequest();
    assertContains(get.getHeaders(), "Private: Secret");
    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
}
#end_block

#method_before
public void testProxyAuthenticateOnConnect() throws Exception {
    Authenticator.setDefault(new SimpleAuthenticator());
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setResponseCode(407).addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("A"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(server.toProxyAddress());
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(new RecordingHostnameVerifier());
    assertContent("A", connection);
    RecordedRequest connect1 = server.takeRequest();
    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
    assertContainsNoneMatching(connect1.getHeaders(), "Proxy\\-Authorization.*");
    RecordedRequest connect2 = server.takeRequest();
    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
    assertContains(connect2.getHeaders(), "Proxy-Authorization: Basic " + SimpleAuthenticator.BASE_64_CREDENTIALS);
    RecordedRequest get = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
    assertContainsNoneMatching(get.getHeaders(), "Proxy\\-Authorization.*");
}
#method_after
public void testProxyAuthenticateOnConnect() throws Exception {
    Authenticator.setDefault(new SimpleAuthenticator());
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setResponseCode(407).addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("A"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(server.toProxyAddress());
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(new RecordingHostnameVerifier());
    assertContent("A", connection);
    RecordedRequest connect1 = server.takeRequest();
    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
    assertContainsNoneMatching(connect1.getHeaders(), "Proxy\\-Authorization.*");
    RecordedRequest connect2 = server.takeRequest();
    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
    assertContains(connect2.getHeaders(), "Proxy-Authorization: Basic " + SimpleAuthenticator.BASE_64_CREDENTIALS);
    RecordedRequest get = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
    assertContainsNoneMatching(get.getHeaders(), "Proxy\\-Authorization.*");
}
#end_block

#method_before
// Don't disconnect after building a tunnel with CONNECT
public void testProxyWithConnectionClose() throws IOException {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(server.toProxyAddress());
    connection.setRequestProperty("Connection", "close");
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(new RecordingHostnameVerifier());
    assertContent("this response comes via a proxy", connection);
}
#method_after
// Don't disconnect after building a tunnel with CONNECT
public void testProxyWithConnectionClose() throws IOException {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), true);
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
    server.play();
    URL url = new URL("https://android.com/foo");
    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(server.toProxyAddress());
    connection.setRequestProperty("Connection", "close");
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setHostnameVerifier(new RecordingHostnameVerifier());
    assertContent("this response comes via a proxy", connection);
}
#end_block

#method_before
private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("Success!"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setDoOutput(true);
    byte[] requestBody = { 'A', 'B', 'C', 'D' };
    if (streamingMode == StreamingMode.FIXED_LENGTH) {
        connection.setFixedLengthStreamingMode(requestBody.length);
    } else if (streamingMode == StreamingMode.CHUNKED) {
        connection.setChunkedStreamingMode(0);
    }
    OutputStream outputStream = connection.getOutputStream();
    outputStream.write(requestBody);
    outputStream.close();
    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    RecordedRequest request = server.takeRequest();
    assertEquals("POST / HTTP/1.1", request.getRequestLine());
    if (streamingMode == StreamingMode.FIXED_LENGTH) {
        assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
    } else if (streamingMode == StreamingMode.CHUNKED) {
        assertEquals(Arrays.asList(4), request.getChunkSizes());
    }
    assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
}
#method_after
private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setBody("Success!"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.setDoOutput(true);
    byte[] requestBody = { 'A', 'B', 'C', 'D' };
    if (streamingMode == StreamingMode.FIXED_LENGTH) {
        connection.setFixedLengthStreamingMode(requestBody.length);
    } else if (streamingMode == StreamingMode.CHUNKED) {
        connection.setChunkedStreamingMode(0);
    }
    OutputStream outputStream = connection.getOutputStream();
    outputStream.write(requestBody);
    outputStream.close();
    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    RecordedRequest request = server.takeRequest();
    assertEquals("POST / HTTP/1.1", request.getRequestLine());
    if (streamingMode == StreamingMode.FIXED_LENGTH) {
        assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
    } else if (streamingMode == StreamingMode.CHUNKED) {
        assertEquals(Arrays.asList(4), request.getChunkSizes());
    }
    assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
}
#end_block

#method_before
public void testRedirectedOnHttps() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").setBody("This page has moved!"));
    server.enqueue(new MockResponse().setBody("This is the new location!"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertEquals("This is the new location!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    RecordedRequest first = server.takeRequest();
    assertEquals("GET / HTTP/1.1", first.getRequestLine());
    RecordedRequest retry = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
}
#method_after
public void testRedirectedOnHttps() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").setBody("This page has moved!"));
    server.enqueue(new MockResponse().setBody("This is the new location!"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertEquals("This is the new location!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    RecordedRequest first = server.takeRequest();
    assertEquals("GET / HTTP/1.1", first.getRequestLine());
    RecordedRequest retry = server.takeRequest();
    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
}
#end_block

#method_before
public void testNotRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: http://anyhost/foo").setBody("This page has moved!"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
}
#method_after
public void testNotRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: http://anyhost/foo").setBody("This page has moved!"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
}
#end_block

#method_before
public void testHttpsWithCustomTrustManager() throws Exception {
    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
    RecordingTrustManager trustManager = new RecordingTrustManager();
    SSLContext sc = SSLContext.getInstance("TLS");
    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
    HostnameVerifier defaultHostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
    HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
    SSLSocketFactory defaultSSLSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    try {
        TestSSLContext testSSLContext = createTestSSLContext();
        server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
        server.enqueue(new MockResponse().setBody("ABC"));
        server.enqueue(new MockResponse().setBody("DEF"));
        server.enqueue(new MockResponse().setBody("GHI"));
        server.play();
        URL url = server.getUrl("/");
        assertEquals("ABC", readAscii(url.openStream(), Integer.MAX_VALUE));
        assertEquals("DEF", readAscii(url.openStream(), Integer.MAX_VALUE));
        assertEquals("GHI", readAscii(url.openStream(), Integer.MAX_VALUE));
        assertEquals(Arrays.asList("verify " + hostName), hostnameVerifier.calls);
        assertEquals(Arrays.asList("checkServerTrusted [" + "CN=" + hostName + " 3, " + "CN=Test Intermediate Certificate Authority 2, " + "CN=Test Root Certificate Authority 1" + "] ECDHE_RSA"), trustManager.calls);
    } finally {
        HttpsURLConnection.setDefaultHostnameVerifier(defaultHostnameVerifier);
        HttpsURLConnection.setDefaultSSLSocketFactory(defaultSSLSocketFactory);
    }
}
#method_after
public void testHttpsWithCustomTrustManager() throws Exception {
    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
    RecordingTrustManager trustManager = new RecordingTrustManager();
    SSLContext sc = SSLContext.getInstance("TLS");
    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
    HostnameVerifier defaultHostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
    HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
    SSLSocketFactory defaultSSLSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    try {
        TestSSLContext testSSLContext = createDefaultTestSSLContext();
        server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
        server.enqueue(new MockResponse().setBody("ABC"));
        server.enqueue(new MockResponse().setBody("DEF"));
        server.enqueue(new MockResponse().setBody("GHI"));
        server.play();
        URL url = server.getUrl("/");
        assertEquals("ABC", readAscii(url.openStream(), Integer.MAX_VALUE));
        assertEquals("DEF", readAscii(url.openStream(), Integer.MAX_VALUE));
        assertEquals("GHI", readAscii(url.openStream(), Integer.MAX_VALUE));
        assertEquals(Arrays.asList("verify " + hostName), hostnameVerifier.calls);
        assertEquals(Arrays.asList("checkServerTrusted [" + "CN=" + hostName + " 3, " + "CN=Test Intermediate Certificate Authority 2, " + "CN=Test Root Certificate Authority 1" + "] ECDHE_RSA"), trustManager.calls);
    } finally {
        HttpsURLConnection.setDefaultHostnameVerifier(defaultHostnameVerifier);
        HttpsURLConnection.setDefaultSSLSocketFactory(defaultSSLSocketFactory);
    }
}
#end_block

#method_before
public void testSslFallback_allSupportedProtocols() throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    String[] allSupportedProtocols = { "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3" };
    SSLSocketFactory serverSocketFactory = new LimitedProtocolsSocketFactory(testSSLContext.serverContext.getSocketFactory(), allSupportedProtocols);
    server.useHttps(serverSocketFactory, false);
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setBody("This required fallbacks"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    // Keeps track of the client sockets created so that we can interrogate them.
    final boolean disableFallbackScsv = true;
    FallbackTestClientSocketFactory clientSocketFactory = new FallbackTestClientSocketFactory(new LimitedProtocolsSocketFactory(testSSLContext.clientContext.getSocketFactory(), allSupportedProtocols), disableFallbackScsv);
    connection.setSSLSocketFactory(clientSocketFactory);
    assertEquals("This required fallbacks", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    // Confirm the server accepted a single connection.
    RecordedRequest retry = server.takeRequest();
    assertEquals(0, retry.getSequenceNumber());
    assertEquals("SSLv3", retry.getSslProtocol());
    // Confirm the client fallback looks ok.
    List<SSLSocket> createdSockets = clientSocketFactory.getCreatedSockets();
    assertEquals(4, createdSockets.size());
    TlsFallbackDisabledScsvSSLSocket clientSocket1 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(0);
    assertSslSocket(clientSocket1, false, /* expectedWasFallbackScsvSet */
    "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3");
    TlsFallbackDisabledScsvSSLSocket clientSocket2 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(1);
    assertSslSocket(clientSocket2, true, /* expectedWasFallbackScsvSet */
    "TLSv1.1", "TLSv1", "SSLv3");
    TlsFallbackDisabledScsvSSLSocket clientSocket3 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(2);
    assertSslSocket(clientSocket3, true, /* expectedWasFallbackScsvSet */
    "TLSv1", "SSLv3");
    TlsFallbackDisabledScsvSSLSocket clientSocket4 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(3);
    assertSslSocket(clientSocket4, true, /* expectedWasFallbackScsvSet */
    "SSLv3");
}
#method_after
public void testSslFallback_allSupportedProtocols() throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    String[] allSupportedProtocols = { "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3" };
    SSLSocketFactory serverSocketFactory = new LimitedProtocolsSocketFactory(testSSLContext.serverContext.getSocketFactory(), allSupportedProtocols);
    server.useHttps(serverSocketFactory, false);
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setBody("This required fallbacks"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    // Keeps track of the client sockets created so that we can interrogate them.
    final boolean disableFallbackScsv = true;
    FallbackTestClientSocketFactory clientSocketFactory = new FallbackTestClientSocketFactory(new LimitedProtocolsSocketFactory(testSSLContext.clientContext.getSocketFactory(), allSupportedProtocols), disableFallbackScsv);
    connection.setSSLSocketFactory(clientSocketFactory);
    assertEquals("This required fallbacks", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    // Confirm the server accepted a single connection.
    RecordedRequest retry = server.takeRequest();
    assertEquals(0, retry.getSequenceNumber());
    assertEquals("SSLv3", retry.getSslProtocol());
    // Confirm the client fallback looks ok.
    List<SSLSocket> createdSockets = clientSocketFactory.getCreatedSockets();
    assertEquals(4, createdSockets.size());
    TlsFallbackDisabledScsvSSLSocket clientSocket1 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(0);
    assertSslSocket(clientSocket1, false, /* expectedWasFallbackScsvSet */
    "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3");
    TlsFallbackDisabledScsvSSLSocket clientSocket2 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(1);
    assertSslSocket(clientSocket2, true, /* expectedWasFallbackScsvSet */
    "TLSv1.1", "TLSv1", "SSLv3");
    TlsFallbackDisabledScsvSSLSocket clientSocket3 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(2);
    assertSslSocket(clientSocket3, true, /* expectedWasFallbackScsvSet */
    "TLSv1", "SSLv3");
    TlsFallbackDisabledScsvSSLSocket clientSocket4 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(3);
    assertSslSocket(clientSocket4, true, /* expectedWasFallbackScsvSet */
    "SSLv3");
}
#end_block

#method_before
public void testSslFallback_defaultProtocols() throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setBody("This required fallbacks"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    // Keeps track of the client sockets created so that we can interrogate them.
    final boolean disableFallbackScsv = true;
    FallbackTestClientSocketFactory clientSocketFactory = new FallbackTestClientSocketFactory(testSSLContext.clientContext.getSocketFactory(), disableFallbackScsv);
    connection.setSSLSocketFactory(clientSocketFactory);
    assertEquals("This required fallbacks", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    // Confirm the server accepted a single connection.
    RecordedRequest retry = server.takeRequest();
    assertEquals(0, retry.getSequenceNumber());
    assertEquals("TLSv1", retry.getSslProtocol());
    // Confirm the client fallback looks ok.
    List<SSLSocket> createdSockets = clientSocketFactory.getCreatedSockets();
    assertEquals(3, createdSockets.size());
    TlsFallbackDisabledScsvSSLSocket clientSocket1 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(0);
    assertSslSocket(clientSocket1, false, /* expectedWasFallbackScsvSet */
    "TLSv1.2", "TLSv1.1", "TLSv1");
    TlsFallbackDisabledScsvSSLSocket clientSocket2 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(1);
    assertSslSocket(clientSocket2, true, /* expectedWasFallbackScsvSet */
    "TLSv1.1", "TLSv1");
    TlsFallbackDisabledScsvSSLSocket clientSocket3 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(2);
    assertSslSocket(clientSocket3, true, /* expectedWasFallbackScsvSet */
    "TLSv1");
}
#method_after
public void testSslFallback_defaultProtocols() throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
    server.enqueue(new MockResponse().setBody("This required fallbacks"));
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    // Keeps track of the client sockets created so that we can interrogate them.
    final boolean disableFallbackScsv = true;
    FallbackTestClientSocketFactory clientSocketFactory = new FallbackTestClientSocketFactory(testSSLContext.clientContext.getSocketFactory(), disableFallbackScsv);
    connection.setSSLSocketFactory(clientSocketFactory);
    assertEquals("This required fallbacks", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
    // Confirm the server accepted a single connection.
    RecordedRequest retry = server.takeRequest();
    assertEquals(0, retry.getSequenceNumber());
    assertEquals("TLSv1", retry.getSslProtocol());
    // Confirm the client fallback looks ok.
    List<SSLSocket> createdSockets = clientSocketFactory.getCreatedSockets();
    assertEquals(3, createdSockets.size());
    TlsFallbackDisabledScsvSSLSocket clientSocket1 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(0);
    assertSslSocket(clientSocket1, false, /* expectedWasFallbackScsvSet */
    "TLSv1.2", "TLSv1.1", "TLSv1");
    TlsFallbackDisabledScsvSSLSocket clientSocket2 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(1);
    assertSslSocket(clientSocket2, true, /* expectedWasFallbackScsvSet */
    "TLSv1.1", "TLSv1");
    TlsFallbackDisabledScsvSSLSocket clientSocket3 = (TlsFallbackDisabledScsvSSLSocket) createdSockets.get(2);
    assertSslSocket(clientSocket3, true, /* expectedWasFallbackScsvSet */
    "TLSv1");
}
#end_block

#method_before
public void testInspectSslBeforeConnect() throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse());
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertNotNull(connection.getHostnameVerifier());
    try {
        connection.getLocalCertificates();
        fail();
    } catch (IllegalStateException expected) {
    }
    try {
        connection.getServerCertificates();
        fail();
    } catch (IllegalStateException expected) {
    }
    try {
        connection.getCipherSuite();
        fail();
    } catch (IllegalStateException expected) {
    }
    try {
        connection.getPeerPrincipal();
        fail();
    } catch (IllegalStateException expected) {
    }
}
#method_after
public void testInspectSslBeforeConnect() throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse());
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    assertNotNull(connection.getHostnameVerifier());
    try {
        connection.getLocalCertificates();
        fail();
    } catch (IllegalStateException expected) {
    }
    try {
        connection.getServerCertificates();
        fail();
    } catch (IllegalStateException expected) {
    }
    try {
        connection.getCipherSuite();
        fail();
    } catch (IllegalStateException expected) {
    }
    try {
        connection.getPeerPrincipal();
        fail();
    } catch (IllegalStateException expected) {
    }
}
#end_block

#method_before
public void testInspectSslAfterConnect() throws Exception {
    TestSSLContext testSSLContext = createTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse());
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.connect();
    try {
        assertNotNull(connection.getHostnameVerifier());
        assertNull(connection.getLocalCertificates());
        assertNotNull(connection.getServerCertificates());
        assertNotNull(connection.getCipherSuite());
        assertNotNull(connection.getPeerPrincipal());
    } finally {
        connection.disconnect();
    }
}
#method_after
public void testInspectSslAfterConnect() throws Exception {
    TestSSLContext testSSLContext = createDefaultTestSSLContext();
    server.useHttps(testSSLContext.serverContext.getSocketFactory(), false);
    server.enqueue(new MockResponse());
    server.play();
    HttpsURLConnection connection = (HttpsURLConnection) server.getUrl("/").openConnection();
    connection.setSSLSocketFactory(testSSLContext.clientContext.getSocketFactory());
    connection.connect();
    try {
        assertNotNull(connection.getHostnameVerifier());
        assertNull(connection.getLocalCertificates());
        assertNotNull(connection.getServerCertificates());
        assertNotNull(connection.getCipherSuite());
        assertNotNull(connection.getPeerPrincipal());
    } finally {
        connection.disconnect();
    }
}
#end_block

#method_before
public void testReadingFromBackendCache() throws Exception {
    // Create a preferences filesystem backend storage file.
    // It emulates a situation where we saved some data in past,
    // restarted the application and we're trying to read it.
    // We use java.io package here because it's not used anywhere
    // else in this test.
    File backendFile = new File(backendDir, "/user/java/io/prefs.xml");
    InputStream inputData = PreferencesTest.class.getResourceAsStream("/resources/prefs/java/util/prefs/backendread.xml");
    assertTrue(new File(backendDir, "/user/java/io").mkdirs());
    assertTrue(backendFile.createNewFile());
    // Copy the example content (one test=test1 entry) to storage file
    FileOutputStream fos = new FileOutputStream(backendFile);
    try {
        byte[] buffer = new byte[1024];
        int length;
        while ((length = inputData.read(buffer)) > 0) {
            fos.write(buffer, 0, length);
        }
    } finally {
        fos.close();
        inputData.close();
    }
    Preferences prefs = Preferences.userNodeForPackage(OutputStream.class);
    // Due to interesting coding, any exception from reading the file
    // will be swallowed and ignored, only result we will see is lack of
    // requested key-value pair.
    assertEquals("test1", prefs.get("test", ""));
}
#method_after
public void testReadingFromBackendCache() throws Exception {
    // Create a preferences filesystem backend storage file.
    // It emulates a situation where we saved some data in the past,
    // restarted the application and we're trying to read it.
    // 
    // We need a package without the existing backing file (so a package that
    // wasn't used in this test case), java.io is a good candidate.
    File backendFile = new File(backendDir, "/user/java/io/prefs.xml");
    InputStream inputData = PreferencesTest.class.getResourceAsStream("/resources/prefs/java/util/prefs/backendread.xml");
    assertTrue(new File(backendDir, "/user/java/io").mkdirs());
    assertTrue(backendFile.createNewFile());
    // Copy the example content (one test=test1 entry) to a storage file
    FileOutputStream fos = new FileOutputStream(backendFile);
    try {
        byte[] buffer = new byte[1024];
        int length;
        while ((length = inputData.read(buffer)) > 0) {
            fos.write(buffer, 0, length);
        }
    } finally {
        fos.close();
        inputData.close();
    }
    Preferences prefs = Preferences.userNodeForPackage(OutputStream.class);
    // Any exception from reading the file will be swallowed and ignored,
    // only result we will see is a lack of requested key-value pair.
    assertEquals("test1", prefs.get("test", ""));
}
#end_block

#method_before
static void importMap(InputStream is, Map m) throws IOException, InvalidPreferencesFormatException {
    try {
        Document doc = loadPrefsDoc(is);
        Element xmlMap = doc.getDocumentElement();
        // check version
        String mapVersion = xmlMap.getAttribute("MAP_XML_VERSION");
        if (mapVersion.compareTo(MAP_XML_VERSION) > 0)
            throw new InvalidPreferencesFormatException("Preferences map file format version " + mapVersion + " is not supported. This java installation can read" + " versions " + MAP_XML_VERSION + " or older. You may need" + " to install a newer version of JDK.");
        NodeList entries = xmlMap.getChildNodes();
        for (int i = 0, numEntries = entries.getLength(); i < numEntries; i++) {
            // (may be a TextData).
            if (!(entries.item(i) instanceof Element)) {
                continue;
            }
            Element entry = (Element) entries.item(i);
            m.put(entry.getAttribute("key"), entry.getAttribute("value"));
        }
    } catch (SAXException e) {
        throw new InvalidPreferencesFormatException(e);
    }
}
#method_after
static void importMap(InputStream is, Map m) throws IOException, InvalidPreferencesFormatException {
    try {
        Document doc = loadPrefsDoc(is);
        Element xmlMap = doc.getDocumentElement();
        // check version
        String mapVersion = xmlMap.getAttribute("MAP_XML_VERSION");
        if (mapVersion.compareTo(MAP_XML_VERSION) > 0)
            throw new InvalidPreferencesFormatException("Preferences map file format version " + mapVersion + " is not supported. This java installation can read" + " versions " + MAP_XML_VERSION + " or older. You may need" + " to install a newer version of JDK.");
        NodeList entries = xmlMap.getChildNodes();
        for (int i = 0, numEntries = entries.getLength(); i < numEntries; i++) {
            // expecting anything else than Element node.
            if (!(entries.item(i) instanceof Element)) {
                continue;
            }
            Element entry = (Element) entries.item(i);
            m.put(entry.getAttribute("key"), entry.getAttribute("value"));
        }
    } catch (SAXException e) {
        throw new InvalidPreferencesFormatException(e);
    }
}
#end_block

#method_before
@Override
protected int getIssueCapacity(@NonNull EnumSet<Scope> scope) {
    if (scope.equals(Scope.ALL)) {
        return getIssues().size();
    } else {
        int initialSize = 12;
        if (scope.contains(Scope.RESOURCE_FILE)) {
            initialSize += 75;
        } else if (scope.contains(Scope.ALL_RESOURCE_FILES)) {
            initialSize += 10;
        }
        if (scope.contains(Scope.JAVA_FILE)) {
            initialSize += 60;
        } else if (scope.contains(Scope.CLASS_FILE)) {
            initialSize += 15;
        } else if (scope.contains(Scope.MANIFEST)) {
            initialSize += 37;
        } else if (scope.contains(Scope.GRADLE_FILE)) {
            initialSize += 5;
        }
        return initialSize;
    }
}
#method_after
@Override
protected int getIssueCapacity(@NonNull EnumSet<Scope> scope) {
    if (scope.equals(Scope.ALL)) {
        return getIssues().size();
    } else {
        int initialSize = 12;
        if (scope.contains(Scope.RESOURCE_FILE)) {
            initialSize += 75;
        } else if (scope.contains(Scope.ALL_RESOURCE_FILES)) {
            initialSize += 10;
        }
        if (scope.contains(Scope.JAVA_FILE)) {
            initialSize += 74;
        } else if (scope.contains(Scope.CLASS_FILE)) {
            initialSize += 15;
        } else if (scope.contains(Scope.MANIFEST)) {
            initialSize += 37;
        } else if (scope.contains(Scope.GRADLE_FILE)) {
            initialSize += 5;
        }
        return initialSize;
    }
}
#end_block

#method_before
@Override
protected void connect(SocketAddress endpoint, int timeout) throws IOException {
    final long deadlineMillis;
    if (timeout == 0) {
        deadlineMillis = 0L;
    } else {
        long finish = System.currentTimeMillis() + timeout;
        deadlineMillis = finish < 0 ? Long.MAX_VALUE : finish;
    }
    SecurityManager security = System.getSecurityManager();
    if (endpoint == null || !(endpoint instanceof InetSocketAddress))
        throw new IllegalArgumentException("Unsupported address type");
    InetSocketAddress epoint = (InetSocketAddress) endpoint;
    if (security != null) {
        if (epoint.isUnresolved())
            security.checkConnect(epoint.getHostName(), epoint.getPort());
        else
            security.checkConnect(epoint.getAddress().getHostAddress(), epoint.getPort());
    }
    if (server == null) {
        /*
             * Android-changed: There was a huge chunk of code here that
             * tries to establish proxy connection if ProxySelector#getDefault() is not null.
             * This was never the case in previous android releases, was causing 
             * issues and therefore was removed.
             */
        super.connect(epoint, remainingMillis(deadlineMillis));
        return;
    } else {
        // Connects to the SOCKS server
        try {
            privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
        } catch (IOException e) {
            throw new SocketException(e.getMessage());
        }
    }
    // cmdIn & cmdOut were intialized during the privilegedConnect() call
    BufferedOutputStream out = new BufferedOutputStream(cmdOut, 512);
    InputStream in = cmdIn;
    if (useV4) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    // This is SOCKS V5
    out.write(PROTO_VERS);
    out.write(2);
    out.write(NO_AUTH);
    out.write(USER_PASSW);
    out.flush();
    byte[] data = new byte[2];
    int i = readSocksReply(in, data, deadlineMillis);
    if (i != 2 || ((int) data[0]) != PROTO_VERS) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    if (((int) data[1]) == NO_METHODS)
        throw new SocketException("SOCKS : No acceptable methods");
    if (!authenticate(data[1], in, out, deadlineMillis)) {
        throw new SocketException("SOCKS : authentication failed");
    }
    out.write(PROTO_VERS);
    out.write(CONNECT);
    out.write(0);
    /* Test for IPV4/IPV6/Unresolved */
    if (epoint.isUnresolved()) {
        out.write(DOMAIN_NAME);
        out.write(epoint.getHostName().length());
        try {
            out.write(epoint.getHostName().getBytes("ISO-8859-1"));
        } catch (java.io.UnsupportedEncodingException uee) {
            assert false;
        }
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else if (epoint.getAddress() instanceof Inet6Address) {
        out.write(IPV6);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else {
        out.write(IPV4);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    }
    out.flush();
    data = new byte[4];
    i = readSocksReply(in, data, deadlineMillis);
    if (i != 4)
        throw new SocketException("Reply from SOCKS server has bad length");
    SocketException ex = null;
    int len;
    byte[] addr;
    switch(data[1]) {
        case REQUEST_OK:
            // success!
            switch(data[3]) {
                case IPV4:
                    addr = new byte[4];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != 4)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case DOMAIN_NAME:
                    len = data[1];
                    byte[] host = new byte[len];
                    i = readSocksReply(in, host, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case IPV6:
                    len = data[1];
                    addr = new byte[len];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                default:
                    ex = new SocketException("Reply from SOCKS server contains wrong code");
                    break;
            }
            break;
        case GENERAL_FAILURE:
            ex = new SocketException("SOCKS server general failure");
            break;
        case NOT_ALLOWED:
            ex = new SocketException("SOCKS: Connection not allowed by ruleset");
            break;
        case NET_UNREACHABLE:
            ex = new SocketException("SOCKS: Network unreachable");
            break;
        case HOST_UNREACHABLE:
            ex = new SocketException("SOCKS: Host unreachable");
            break;
        case CONN_REFUSED:
            ex = new SocketException("SOCKS: Connection refused");
            break;
        case TTL_EXPIRED:
            ex = new SocketException("SOCKS: TTL expired");
            break;
        case CMD_NOT_SUPPORTED:
            ex = new SocketException("SOCKS: Command not supported");
            break;
        case ADDR_TYPE_NOT_SUP:
            ex = new SocketException("SOCKS: address type not supported");
            break;
    }
    if (ex != null) {
        in.close();
        out.close();
        throw ex;
    }
    external_address = epoint;
}
#method_after
@Override
protected void connect(SocketAddress endpoint, int timeout) throws IOException {
    final long deadlineMillis;
    if (timeout == 0) {
        deadlineMillis = 0L;
    } else {
        long finish = System.currentTimeMillis() + timeout;
        deadlineMillis = finish < 0 ? Long.MAX_VALUE : finish;
    }
    SecurityManager security = System.getSecurityManager();
    if (endpoint == null || !(endpoint instanceof InetSocketAddress))
        throw new IllegalArgumentException("Unsupported address type");
    InetSocketAddress epoint = (InetSocketAddress) endpoint;
    if (security != null) {
        if (epoint.isUnresolved())
            security.checkConnect(epoint.getHostName(), epoint.getPort());
        else
            security.checkConnect(epoint.getAddress().getHostAddress(), epoint.getPort());
    }
    if (server == null) {
        /*
             * Android-changed: Removed code that tried to establish proxy connection if
             * ProxySelector#getDefault() is not null.
             * This was never the case in previous android releases, was causing
             * issues and therefore was removed.
             */
        super.connect(epoint, remainingMillis(deadlineMillis));
        return;
    } else {
        // Connects to the SOCKS server
        try {
            privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
        } catch (IOException e) {
            throw new SocketException(e.getMessage());
        }
    }
    // cmdIn & cmdOut were intialized during the privilegedConnect() call
    BufferedOutputStream out = new BufferedOutputStream(cmdOut, 512);
    InputStream in = cmdIn;
    if (useV4) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    // This is SOCKS V5
    out.write(PROTO_VERS);
    out.write(2);
    out.write(NO_AUTH);
    out.write(USER_PASSW);
    out.flush();
    byte[] data = new byte[2];
    int i = readSocksReply(in, data, deadlineMillis);
    if (i != 2 || ((int) data[0]) != PROTO_VERS) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    if (((int) data[1]) == NO_METHODS)
        throw new SocketException("SOCKS : No acceptable methods");
    if (!authenticate(data[1], in, out, deadlineMillis)) {
        throw new SocketException("SOCKS : authentication failed");
    }
    out.write(PROTO_VERS);
    out.write(CONNECT);
    out.write(0);
    /* Test for IPV4/IPV6/Unresolved */
    if (epoint.isUnresolved()) {
        out.write(DOMAIN_NAME);
        out.write(epoint.getHostName().length());
        try {
            out.write(epoint.getHostName().getBytes("ISO-8859-1"));
        } catch (java.io.UnsupportedEncodingException uee) {
            assert false;
        }
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else if (epoint.getAddress() instanceof Inet6Address) {
        out.write(IPV6);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else {
        out.write(IPV4);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    }
    out.flush();
    data = new byte[4];
    i = readSocksReply(in, data, deadlineMillis);
    if (i != 4)
        throw new SocketException("Reply from SOCKS server has bad length");
    SocketException ex = null;
    int len;
    byte[] addr;
    switch(data[1]) {
        case REQUEST_OK:
            // success!
            switch(data[3]) {
                case IPV4:
                    addr = new byte[4];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != 4)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case DOMAIN_NAME:
                    len = data[1];
                    byte[] host = new byte[len];
                    i = readSocksReply(in, host, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case IPV6:
                    len = data[1];
                    addr = new byte[len];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                default:
                    ex = new SocketException("Reply from SOCKS server contains wrong code");
                    break;
            }
            break;
        case GENERAL_FAILURE:
            ex = new SocketException("SOCKS server general failure");
            break;
        case NOT_ALLOWED:
            ex = new SocketException("SOCKS: Connection not allowed by ruleset");
            break;
        case NET_UNREACHABLE:
            ex = new SocketException("SOCKS: Network unreachable");
            break;
        case HOST_UNREACHABLE:
            ex = new SocketException("SOCKS: Host unreachable");
            break;
        case CONN_REFUSED:
            ex = new SocketException("SOCKS: Connection refused");
            break;
        case TTL_EXPIRED:
            ex = new SocketException("SOCKS: TTL expired");
            break;
        case CMD_NOT_SUPPORTED:
            ex = new SocketException("SOCKS: Command not supported");
            break;
        case ADDR_TYPE_NOT_SUP:
            ex = new SocketException("SOCKS: address type not supported");
            break;
    }
    if (ex != null) {
        in.close();
        out.close();
        throw ex;
    }
    external_address = epoint;
}
#end_block

#method_before
public void test_connect() throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    assertNotNull(asc.provider());
    assertTrue(asc.isOpen());
    assertNull(asc.getRemoteAddress());
    assertNull(asc.getLocalAddress());
    // Connect
    Future<Void> connectFuture = asc.connect(ss.getLocalSocketAddress());
    connectFuture.get(1000, TimeUnit.MILLISECONDS);
    assertNotNull(asc.getRemoteAddress());
    assertNotNull(asc.getLocalAddress());
    assertTrue(asc.isOpen());
    asc.close();
    ss.close();
}
#method_after
public void test_connect() throws Exception {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    assertEquals(asc.provider(), AsynchronousChannelProvider.provider());
    assertTrue(asc.isOpen());
    assertNull(asc.getRemoteAddress());
    assertNull(asc.getLocalAddress());
    // Connect
    InetSocketAddress remoteAddress = new InetSocketAddress("localhost", ss.getLocalPort());
    Future<Void> connectFuture = asc.connect(remoteAddress);
    connectFuture.get(1000, TimeUnit.MILLISECONDS);
    Socket s = ss.accept();
    assertNotNull(asc.getLocalAddress());
    assertEquals(asc.getLocalAddress(), s.getRemoteSocketAddress());
    assertNotNull(asc.getRemoteAddress());
    assertEquals(asc.getRemoteAddress(), s.getLocalSocketAddress());
    assertTrue(asc.isOpen());
    asc.close();
    ss.close();
    s.close();
}
#end_block

#method_before
public void test_bind_unresolvedAddress() throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    try {
        asc.bind(new InetSocketAddress("unresolvedname", 31415));
        fail();
    } catch (UnresolvedAddressException expected) {
    }
    assertNull(asc.getLocalAddress());
    assertNull(asc.getRemoteAddress());
    assertTrue(asc.isOpen());
    try {
        asc.bind(ss.getLocalSocketAddress());
        fail();
    } catch (BindException expected) {
    }
    ss.close();
    asc.close();
}
#method_after
public void test_bind_unresolvedAddress() throws Exception {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    try {
        asc.bind(new InetSocketAddress("unresolvedname", 31415));
        fail();
    } catch (UnresolvedAddressException expected) {
    }
    assertNull(asc.getLocalAddress());
    assertNull(asc.getRemoteAddress());
    assertTrue(asc.isOpen());
    asc.close();
}
#end_block

#method_before
public void test_connect_unresolvedAddress() throws Throwable {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    try {
        asc.connect(new InetSocketAddress("unresolvedname", 31415));
        fail();
    } catch (UnresolvedAddressException expected) {
    }
    assertNull(asc.getRemoteAddress());
    assertTrue(asc.isOpen());
    asc.close();
}
#method_after
public void test_connect_unresolvedAddress() throws Exception {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    try {
        asc.connect(new InetSocketAddress("unresolvedname", 31415));
        fail();
    } catch (UnresolvedAddressException expected) {
    }
    assertNull(asc.getRemoteAddress());
    assertTrue(asc.isOpen());
    asc.close();
}
#end_block

#method_before
public void test_close() throws Throwable {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    assertTrue(asc.isOpen());
    asc.close();
    try {
        asc.getRemoteAddress();
        fail();
    } catch (ClosedChannelException expected) {
    }
    try {
        asc.getLocalAddress();
        fail();
    } catch (ClosedChannelException expected) {
    }
    assertFalse(asc.isOpen());
}
#method_after
public void test_close() throws Throwable {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    assertTrue(asc.isOpen());
    asc.close();
    assertFalse(asc.isOpen());
    try {
        asc.getRemoteAddress();
        fail();
    } catch (ClosedChannelException expected) {
    }
    try {
        asc.getLocalAddress();
        fail();
    } catch (ClosedChannelException expected) {
    }
    ByteBuffer tmp = createTestByteBuffer(16, false);
    FutureLikeCompletionHandler<Integer> intCompletionHandler = null;
    FutureLikeCompletionHandler<Long> longCompletionHandler = null;
    Future<Integer> readFuture = asc.read(tmp);
    try {
        readFuture.get(1000, TimeUnit.MILLISECONDS);
        fail();
    } catch (ExecutionException expected) {
        assertTrue(expected.getCause() instanceof ClosedChannelException);
    }
    longCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.read(new ByteBuffer[] { tmp }, 0, 1, 100L, TimeUnit.MILLISECONDS, null, longCompletionHandler);
    try {
        longCompletionHandler.get(1000);
        fail();
    } catch (ClosedChannelException expected) {
    }
    intCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.read(tmp, null, intCompletionHandler);
    try {
        intCompletionHandler.get(1000);
        fail();
    } catch (ClosedChannelException expected) {
    }
    intCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.read(tmp, 100, TimeUnit.MILLISECONDS, null, intCompletionHandler);
    try {
        intCompletionHandler.get(100);
        fail();
    } catch (ClosedChannelException expected) {
    }
    Future<Integer> writeFuture = asc.write(tmp);
    try {
        writeFuture.get(1000, TimeUnit.MILLISECONDS);
        fail();
    } catch (ExecutionException expected) {
        assertTrue(expected.getCause() instanceof ClosedChannelException);
    }
    longCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.write(new ByteBuffer[] { tmp }, 0, 1, 100, TimeUnit.MILLISECONDS, null, longCompletionHandler);
    try {
        longCompletionHandler.get(1000);
        fail();
    } catch (ClosedChannelException expected) {
    }
    intCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.write(tmp, null, intCompletionHandler);
    try {
        intCompletionHandler.get(1000);
        fail();
    } catch (ClosedChannelException expected) {
    }
    intCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.write(tmp, 100, TimeUnit.MILLISECONDS, null, intCompletionHandler);
    try {
        intCompletionHandler.get(1000);
        fail();
    } catch (ClosedChannelException expected) {
    }
    try {
        asc.setOption(StandardSocketOptions.SO_REUSEADDR, true);
        fail();
    } catch (ClosedChannelException expected) {
    }
    // Try second close
    asc.close();
}
#end_block

#method_before
public void test_futureReadWrite_DirectByteBuffer() throws Throwable {
    test_futureReadWrite(true);
}
#method_after
public void test_futureReadWrite_DirectByteBuffer() throws Exception {
    test_futureReadWrite(true);
}
#end_block

#method_before
private void test_futureReadWrite(boolean useDirectByteBuffer) throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    // Connect
    Future<Void> connectFuture = asc.connect(ss.getLocalSocketAddress());
    connectFuture.get(1000, TimeUnit.MILLISECONDS);
    assertNotNull(asc.getRemoteAddress());
    // Accept & write data
    ByteBuffer sendData = allocateByteBuffer(32, useDirectByteBuffer);
    Socket sss = ss.accept();
    sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), 32);
    // Read data from async channel and call #get on result future
    ByteBuffer receivedData = allocateByteBuffer(32, useDirectByteBuffer);
    assertEquals(32, (int) asc.read(receivedData).get(1000, TimeUnit.MILLISECONDS));
    // Compare results
    receivedData.flip();
    assertEquals(sendData, receivedData);
    // Write data to async channel and call #get on result future
    assertEquals(32, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
    // Read data and compare with original
    byte[] readArray = new byte[32];
    assertEquals(32, sss.getInputStream().read(readArray));
    // Compare results
    sendData.flip();
    assertEquals(sendData, ByteBuffer.wrap(readArray));
    asc.close();
    sss.close();
    ss.close();
}
#method_after
private void test_futureReadWrite(boolean useDirectByteBuffer) throws Exception {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    // Connect
    Future<Void> connectFuture = asc.connect(ss.getLocalSocketAddress());
    connectFuture.get(1000, TimeUnit.MILLISECONDS);
    assertNotNull(asc.getRemoteAddress());
    assertTrue(connectFuture.isDone());
    // Accept & write data
    final int messageSize = NON_BLOCKING_MESSAGE_SIZE;
    final ByteBuffer sendData = createTestByteBuffer(messageSize, useDirectByteBuffer);
    Socket sss = ss.accept();
    // Small message, won't block on write
    sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), messageSize);
    // Read data from async channel and call #get on result future
    ByteBuffer receivedData = createTestByteBuffer(messageSize, useDirectByteBuffer);
    assertEquals(messageSize, (int) asc.read(receivedData).get(1000, TimeUnit.MILLISECONDS));
    // Compare results
    receivedData.flip();
    assertEquals(sendData, receivedData);
    // Write data to async channel and call #get on result future
    assertEquals(messageSize, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
    // Read data and compare with original
    byte[] readArray = new byte[messageSize];
    assertEquals(messageSize, sss.getInputStream().read(readArray));
    // Compare results
    sendData.flip();
    assertEquals(sendData, ByteBuffer.wrap(readArray));
    asc.close();
    sss.close();
    ss.close();
}
#end_block

#method_before
private void test_completionHandlerReadWrite(boolean useDirectByteBuffer) throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    // Connect
    FutureLikeCompletionHandler<Void> connectCompletionHandler = new FutureLikeCompletionHandler<Void>();
    asc.connect(ss.getLocalSocketAddress(), null, connectCompletionHandler);
    connectCompletionHandler.get(1000);
    assertNotNull(asc.getRemoteAddress());
    // Accept & write data
    ByteBuffer sendData = allocateByteBuffer(32, useDirectByteBuffer);
    Socket sss = ss.accept();
    sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), 32);
    // Read data from async channel
    ByteBuffer receivedData = allocateByteBuffer(32, useDirectByteBuffer);
    FutureLikeCompletionHandler<Integer> readCompletionHandler = new FutureLikeCompletionHandler<Integer>();
    asc.read(receivedData, null, readCompletionHandler);
    assertEquals(32, (int) readCompletionHandler.get(1000));
    // Compare results
    receivedData.flip();
    assertEquals(sendData, receivedData);
    // Write data to async channel
    FutureLikeCompletionHandler<Integer> writeCompletionHandler = new FutureLikeCompletionHandler<Integer>();
    asc.write(sendData, null, writeCompletionHandler);
    assertEquals(32, (int) writeCompletionHandler.get(1000));
    // Read data and compare with original
    byte[] readArray = new byte[32];
    assertEquals(32, sss.getInputStream().read(readArray));
    sendData.flip();
    assertEquals(sendData, ByteBuffer.wrap(readArray));
    asc.close();
    sss.close();
    ss.close();
}
#method_after
private void test_completionHandlerReadWrite(boolean useDirectByteBuffer) throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    // Connect
    FutureLikeCompletionHandler<Void> connectCompletionHandler = new FutureLikeCompletionHandler<>();
    Object attachment = new Integer(1);
    asc.connect(ss.getLocalSocketAddress(), attachment, connectCompletionHandler);
    connectCompletionHandler.get(1000);
    assertNotNull(asc.getRemoteAddress());
    assertEquals(attachment, connectCompletionHandler.getAttachment());
    // Accept & write data
    final int messageSize = NON_BLOCKING_MESSAGE_SIZE;
    ByteBuffer sendData = createTestByteBuffer(messageSize, useDirectByteBuffer);
    Socket sss = ss.accept();
    // Small message, won't block on write
    sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), messageSize);
    // Read data from async channel
    ByteBuffer receivedData = createTestByteBuffer(messageSize, useDirectByteBuffer);
    FutureLikeCompletionHandler<Integer> readCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.read(receivedData, attachment, readCompletionHandler);
    assertEquals(messageSize, (int) readCompletionHandler.get(1000));
    assertEquals(attachment, readCompletionHandler.getAttachment());
    // Compare results
    receivedData.flip();
    assertEquals(sendData, receivedData);
    // Write data to async channel
    FutureLikeCompletionHandler<Integer> writeCompletionHandler = new FutureLikeCompletionHandler<>();
    asc.write(sendData, attachment, writeCompletionHandler);
    assertEquals(messageSize, (int) writeCompletionHandler.get(1000));
    assertEquals(attachment, writeCompletionHandler.getAttachment());
    // Read data and compare with original
    byte[] readArray = new byte[messageSize];
    assertEquals(messageSize, sss.getInputStream().read(readArray));
    sendData.flip();
    assertEquals(sendData, ByteBuffer.wrap(readArray));
    asc.close();
    sss.close();
    ss.close();
}
#end_block

#method_before
public void test_completionHandler_connect_npe() throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    FutureLikeCompletionHandler<Void> connectCompletionHandler = new FutureLikeCompletionHandler<Void>();
    // 1st argument NPE
    try {
        asc.connect(null, null, connectCompletionHandler);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // 3rd argument NPE
    try {
        asc.connect(ss.getLocalSocketAddress(), null, null);
        fail();
    } catch (NullPointerException expected) {
    }
    asc.close();
    ss.close();
}
#method_after
public void test_completionHandler_connect_npe() throws Exception {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    FutureLikeCompletionHandler<Void> connectCompletionHandler = new FutureLikeCompletionHandler<>();
    // 1st argument NPE
    try {
        asc.connect(null, null, connectCompletionHandler);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // 3rd argument NPE
    try {
        asc.connect(ss.getLocalSocketAddress(), null, null);
        fail();
    } catch (NullPointerException expected) {
    }
    asc.close();
    ss.close();
}
#end_block

#method_before
public void test_shutdown() throws Throwable {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    // Connect
    Future<Void> connectFuture = asc.connect(ss.getLocalSocketAddress());
    connectFuture.get(1000, TimeUnit.MILLISECONDS);
    assertNotNull(asc.getRemoteAddress());
    // Accept & write data
    ByteBuffer sendData = allocateByteBuffer(32, false);
    Socket sss = ss.accept();
    sss.getOutputStream().write(sendData.array());
    // Shutdown input, expect -1 from read
    asc.shutdownInput();
    ByteBuffer receivedData = allocateByteBuffer(32, false);
    // We did write something into the socket,  #shutdownInput javadocs
    // say that "...effect on an outstanding read operation is system dependent and
    // therefore not specified...". It looks like on android/linux the data in
    // received buffer is discarded.
    assertEquals(-1, (int) asc.read(receivedData).get(1000, TimeUnit.MILLISECONDS));
    assertEquals(-1, (int) asc.read(receivedData).get(1000, TimeUnit.MILLISECONDS));
    // But we can still write!
    assertEquals(32, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
    byte[] readArray = new byte[32];
    assertEquals(32, sss.getInputStream().read(readArray));
    assertTrue(Arrays.equals(sendData.array(), readArray));
    // Shutdown output, expect ClosedChannelException
    asc.shutdownOutput();
    try {
        assertEquals(-1, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
        fail();
    } catch (ExecutionException expected) {
        assertTrue(expected.getCause() instanceof ClosedChannelException);
    }
    try {
        assertEquals(-1, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
        fail();
    } catch (ExecutionException expected) {
        assertTrue(expected.getCause() instanceof ClosedChannelException);
    }
    // shutdownInput() & shudownOutput() != closed, shocking!
    assertNotNull(asc.getRemoteAddress());
    assertTrue(asc.isOpen());
    asc.close();
    sss.close();
    ss.close();
}
#method_after
public void test_shutdown() throws Exception {
    ServerSocket ss = new ServerSocket(0);
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    // Connect
    Future<Void> connectFuture = asc.connect(ss.getLocalSocketAddress());
    connectFuture.get(1000, TimeUnit.MILLISECONDS);
    assertNotNull(asc.getRemoteAddress());
    // Accept & write data
    final int messageSize = NON_BLOCKING_MESSAGE_SIZE;
    ByteBuffer sendData = createTestByteBuffer(messageSize, false);
    Socket sss = ss.accept();
    // Small message, won't block on write
    sss.getOutputStream().write(sendData.array());
    // Shutdown input, expect -1 from read
    asc.shutdownInput();
    ByteBuffer receivedData = createTestByteBuffer(messageSize, false);
    // We did write something into the socket,  #shutdownInput javadocs
    // say that "...effect on an outstanding read operation is system dependent and
    // therefore not specified...". It looks like on android/linux the data in
    // received buffer is discarded.
    assertEquals(-1, (int) asc.read(receivedData).get(1000, TimeUnit.MILLISECONDS));
    assertEquals(-1, (int) asc.read(receivedData).get(1000, TimeUnit.MILLISECONDS));
    // But we can still write!
    assertEquals(32, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
    byte[] readArray = new byte[32];
    assertEquals(32, sss.getInputStream().read(readArray));
    assertTrue(Arrays.equals(sendData.array(), readArray));
    // Shutdown output, expect ClosedChannelException from write
    asc.shutdownOutput();
    try {
        assertEquals(-1, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
        fail();
    } catch (ExecutionException expected) {
        assertTrue(expected.getCause() instanceof ClosedChannelException);
    }
    try {
        assertEquals(-1, (int) asc.write(sendData).get(1000, TimeUnit.MILLISECONDS));
        fail();
    } catch (ExecutionException expected) {
        assertTrue(expected.getCause() instanceof ClosedChannelException);
    }
    // shutdownInput() & shudownOutput() != closed, shocking!
    assertNotNull(asc.getRemoteAddress());
    assertTrue(asc.isOpen());
    asc.close();
    sss.close();
    ss.close();
}
#end_block

#method_before
public void test_options() throws Throwable {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    asc.setOption(StandardSocketOptions.SO_SNDBUF, 5000);
    assertEquals(5000, (long) asc.getOption(StandardSocketOptions.SO_SNDBUF));
    asc.setOption(StandardSocketOptions.SO_RCVBUF, 5000);
    assertEquals(5000, (long) asc.getOption(StandardSocketOptions.SO_RCVBUF));
    asc.setOption(StandardSocketOptions.SO_KEEPALIVE, true);
    assertTrue(asc.getOption(StandardSocketOptions.SO_KEEPALIVE));
    asc.setOption(StandardSocketOptions.SO_REUSEADDR, true);
    assertTrue(asc.getOption(StandardSocketOptions.SO_REUSEADDR));
    asc.setOption(StandardSocketOptions.TCP_NODELAY, true);
    assertTrue(asc.getOption(StandardSocketOptions.TCP_NODELAY));
}
#method_after
public void test_options() throws Exception {
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
    asc.setOption(StandardSocketOptions.SO_SNDBUF, 5000);
    assertEquals(5000, (long) asc.getOption(StandardSocketOptions.SO_SNDBUF));
    asc.setOption(StandardSocketOptions.SO_RCVBUF, 5000);
    assertEquals(5000, (long) asc.getOption(StandardSocketOptions.SO_RCVBUF));
    asc.setOption(StandardSocketOptions.SO_KEEPALIVE, true);
    assertTrue(asc.getOption(StandardSocketOptions.SO_KEEPALIVE));
    asc.setOption(StandardSocketOptions.SO_REUSEADDR, true);
    assertTrue(asc.getOption(StandardSocketOptions.SO_REUSEADDR));
    asc.setOption(StandardSocketOptions.TCP_NODELAY, true);
    assertTrue(asc.getOption(StandardSocketOptions.TCP_NODELAY));
}
#end_block

#method_before
public void test_group() throws Throwable {
    AsynchronousChannelProvider provider = AsynchronousChannelProvider.provider();
    AsynchronousChannelGroup group = provider.openAsynchronousChannelGroup(2, Executors.defaultThreadFactory());
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open(group);
    assertEquals(provider, asc.provider());
    asc.close();
}
#method_after
public void test_group() throws Exception {
    AsynchronousChannelProvider provider = AsynchronousChannelProvider.provider();
    AsynchronousChannelGroup group = provider.openAsynchronousChannelGroup(2, Executors.defaultThreadFactory());
    AsynchronousSocketChannel asc = AsynchronousSocketChannel.open(group);
    assertEquals(provider, asc.provider());
    asc.close();
}
#end_block

#method_before
public void test_bind() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assertTrue(assc.isOpen());
    assc.bind(new InetSocketAddress(0));
    try {
        assc.bind(new InetSocketAddress(0));
        fail();
    } catch (AlreadyBoundException expected) {
    }
    assc.close();
    assertFalse(assc.isOpen());
}
#method_after
public void test_bind() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assertTrue(assc.isOpen());
    assertNull(assc.getLocalAddress());
    assc.bind(new InetSocketAddress(0));
    assertNotNull(assc.getLocalAddress());
    try {
        assc.bind(new InetSocketAddress(0));
        fail();
    } catch (AlreadyBoundException expected) {
    }
    assc.close();
    assertFalse(assc.isOpen());
}
#end_block

#method_before
public void test_bind_null() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assertTrue(assc.isOpen());
    assc.bind(null);
    try {
        assc.bind(null);
        fail();
    } catch (AlreadyBoundException expected) {
    }
    assc.close();
    assertFalse(assc.isOpen());
}
#method_after
public void test_bind_null() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assertTrue(assc.isOpen());
    assertNull(assc.getLocalAddress());
    assc.bind(null);
    assertNotNull(assc.getLocalAddress());
    try {
        assc.bind(null);
        fail();
    } catch (AlreadyBoundException expected) {
    }
    assc.close();
    assertFalse(assc.isOpen());
}
#end_block

#method_before
public void test_bind_unresolvedAddress() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    ServerSocket ss = new ServerSocket(0);
    try {
        assc.bind(new InetSocketAddress("unresolvedname", 31415));
        fail();
    } catch (UnresolvedAddressException expected) {
    }
    assertNull(assc.getLocalAddress());
    assertTrue(assc.isOpen());
    try {
        assc.bind(ss.getLocalSocketAddress());
        fail();
    } catch (BindException expected) {
    }
    ss.close();
    assc.close();
}
#method_after
public void test_bind_unresolvedAddress() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    try {
        assc.bind(new InetSocketAddress("unresolvedname", 31415));
        fail();
    } catch (UnresolvedAddressException expected) {
    }
    assertNull(assc.getLocalAddress());
    assertTrue(assc.isOpen());
    assc.close();
}
#end_block

#method_before
public void test_futureAccept() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.bind(new InetSocketAddress(0));
    Future<AsynchronousSocketChannel> acceptFuture = assc.accept();
    Socket s = new Socket();
    s.connect(assc.getLocalAddress());
    AsynchronousSocketChannel asc = acceptFuture.get(1000, TimeUnit.MILLISECONDS);
    assertTrue(s.isConnected());
    assertNotNull(asc.getLocalAddress());
    assertNotNull(asc.getRemoteAddress());
    asc.close();
    s.close();
    assc.close();
}
#method_after
public void test_futureAccept() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.bind(new InetSocketAddress(0));
    Future<AsynchronousSocketChannel> acceptFuture = assc.accept();
    Socket s = new Socket();
    s.connect(assc.getLocalAddress());
    AsynchronousSocketChannel asc = acceptFuture.get(1000, TimeUnit.MILLISECONDS);
    assertTrue(s.isConnected());
    assertNotNull(asc.getLocalAddress());
    assertEquals(asc.getLocalAddress(), s.getRemoteSocketAddress());
    assertNotNull(asc.getRemoteAddress());
    assertEquals(asc.getRemoteAddress(), s.getLocalSocketAddress());
    asc.close();
    s.close();
    assc.close();
}
#end_block

#method_before
public void test_completionHandlerAccept() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.bind(new InetSocketAddress(0));
    FutureLikeCompletionHandler<AsynchronousSocketChannel> acceptCompletionHandler = new FutureLikeCompletionHandler<AsynchronousSocketChannel>();
    assc.accept(null, acceptCompletionHandler);
    Socket s = new Socket();
    s.connect(assc.getLocalAddress());
    AsynchronousSocketChannel asc = acceptCompletionHandler.get(1000);
    assertTrue(s.isConnected());
    assertNotNull(asc.getLocalAddress());
    assertNotNull(asc.getRemoteAddress());
    asc.close();
    s.close();
    assc.close();
}
#method_after
public void test_completionHandlerAccept() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.bind(new InetSocketAddress(0));
    FutureLikeCompletionHandler<AsynchronousSocketChannel> acceptCompletionHandler = new FutureLikeCompletionHandler<AsynchronousSocketChannel>();
    assc.accept(null, /* attachment */
    acceptCompletionHandler);
    Socket s = new Socket();
    s.connect(assc.getLocalAddress());
    AsynchronousSocketChannel asc = acceptCompletionHandler.get(1000);
    assertNotNull(asc);
    assertTrue(s.isConnected());
    assertNotNull(asc.getLocalAddress());
    assertEquals(asc.getLocalAddress(), s.getRemoteSocketAddress());
    assertNotNull(asc.getRemoteAddress());
    assertEquals(asc.getRemoteAddress(), s.getLocalSocketAddress());
    assertNull(acceptCompletionHandler.getAttachment());
    asc.close();
    s.close();
    assc.close();
}
#end_block

#method_before
public void test_completionHandlerAccept_npe() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.bind(new InetSocketAddress(0));
    try {
        assc.accept(null, null);
        fail();
    } catch (NullPointerException expected) {
    }
    assc.close();
}
#method_after
public void test_completionHandlerAccept_npe() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.bind(new InetSocketAddress(0));
    try {
        assc.accept(null, /* attachment */
        null);
        fail();
    } catch (NullPointerException expected) {
    }
    assc.close();
}
#end_block

#method_before
public void test_options() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.setOption(StandardSocketOptions.SO_RCVBUF, 5000);
    assertEquals(5000, (long) assc.getOption(StandardSocketOptions.SO_RCVBUF));
    assc.setOption(StandardSocketOptions.SO_REUSEADDR, true);
    assertTrue(assc.getOption(StandardSocketOptions.SO_REUSEADDR));
}
#method_after
public void test_options() throws Throwable {
    AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
    assc.setOption(StandardSocketOptions.SO_RCVBUF, 5000);
    assertEquals(5000, (long) assc.getOption(StandardSocketOptions.SO_RCVBUF));
    assc.setOption(StandardSocketOptions.SO_REUSEADDR, true);
    assertTrue(assc.getOption(StandardSocketOptions.SO_REUSEADDR));
    assc.close();
}
#end_block

#method_before
public void completed(V result, Void attachment) {
    synchronized (this) {
        this.result = result;
        this.done = true;
        this.notifyAll();
    }
}
#method_after
public void completed(V result, Object attachment) {
    synchronized (this) {
        if (done) {
            e = new IllegalStateException("CompletionHandler used twice");
        }
        this.result = result;
        this.done = true;
        this.attachment = attachment;
        this.notifyAll();
    }
}
#end_block

#method_before
public void failed(Throwable exc, Void attachment) {
    synchronized (this) {
        this.e = exc;
        this.done = true;
        this.notifyAll();
    }
}
#method_after
public void failed(Throwable exc, Object attachment) {
    synchronized (this) {
        if (done) {
            e = new IllegalStateException("CompletionHandler used twice");
        }
        this.e = exc;
        this.done = true;
        this.attachment = attachment;
        this.notifyAll();
    }
}
#end_block

#method_before
public String startListening(String address) throws IOException {
    String hostName = TestOptions.extractHostnameFromAddress(address);
    InetAddress hostAddr = null;
    int port = 0;
    try {
        port = TestOptions.extractPortNumberFromAddress(address);
    } catch (NumberFormatException e) {
        throw new IOException("Illegal port number in socket address: " + address);
    }
    if (hostName != null) {
        hostAddr = InetAddress.getByName(hostName);
        serverSocket = new ServerSocket(port, 0, hostAddr);
    } else {
        serverSocket = new ServerSocket(port);
    }
    // use as workaround for unspecified behaviour of isAnyLocalAddress()
    InetAddress iAddress = null;
    if (hostName != null) {
        iAddress = serverSocket.getInetAddress();
    } else {
        iAddress = InetAddress.getLocalHost();
    }
    address = iAddress.getHostName() + ":" + serverSocket.getLocalPort();
    return address;
}
#method_after
public String startListening(String address) throws IOException {
    String hostName = null;
    InetAddress hostAddr = null;
    int port = 0;
    if (address != null) {
        String portName = null;
        int i = address.indexOf(':');
        if (i < 0) {
            portName = address;
        } else {
            hostName = address.substring(0, i);
            portName = address.substring(i + 1);
        }
        try {
            port = Integer.parseInt(portName);
        } catch (NumberFormatException e) {
            throw new IOException("Illegal port number in socket address: " + address);
        }
    }
    if (hostName != null) {
        hostAddr = InetAddress.getByName(hostName);
        serverSocket = new ServerSocket(port, 0, hostAddr);
    } else {
        serverSocket = new ServerSocket(port);
    }
    // use as workaround for unspecified behaviour of isAnyLocalAddress()
    InetAddress iAddress = null;
    if (hostName != null) {
        iAddress = serverSocket.getInetAddress();
    } else {
        iAddress = InetAddress.getLocalHost();
    }
    address = iAddress.getHostName() + ":" + serverSocket.getLocalPort();
    return address;
}
#end_block

#method_before
@Test
public void testVpn() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = testFramework.getDevice();
    // Check if VPN is on. If true, skip.
    if (!verifyVpnStatus(device)) {
        AppManager.installApp(instrumentation, "FredVPN.apk");
        AppLauncher.launch(instrumentation, "TestVPN");
        VpnPopupWatcher watcher = new VpnPopupWatcher(device);
        device.findObject(new UiSelector().resourceId(START_VPN_BUTTON_RES)).clickAndWaitForNewWindow();
        watcher.checkForCondition();
        Assert.assertTrue("Failed to find the VPN lock icon after starting VPN!", verifyVpnStatus(device));
    }
    AppManager.uninstallApp(instrumentation, "TestVPN", null);
}
#method_after
@Test
public void testVpn() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = testFramework.getDevice();
    // Check if VPN is on. If true, skip.
    if (!verifyVpnStatus(device)) {
        AppManager.installApp(instrumentation, "FredVPN.apk");
        AppLauncher.launch(instrumentation, "TestVPN");
        device.findObject(new UiSelector().resourceId(START_VPN_BUTTON_RES)).clickAndWaitForNewWindow();
        new VpnPopupWatcher(device).checkForCondition();
        Assert.assertTrue("Failed to find the VPN lock icon after starting VPN!", verifyVpnStatus(device));
    }
    AppManager.uninstallApp(instrumentation, "TestVPN", null);
}
#end_block

#method_before
public void testNinePatchHeapOverflow() throws Exception {
    Bitmap image;
    InputStream inStream = mContext.getResources().openRawResource(R.raw.cve_2015_1532);
    /*
         * Depending on heap layout, multiple trigger attempts may be
         * necessary to observe a crash.
         */
    for (int i = 0; i < 100; i++) {
        image = BitmapFactory.decodeStream(inStream);
    }
}
#method_after
public void testNinePatchHeapOverflow() throws Exception {
    InputStream inStream = new BufferedInputStream(mContext.getResources().openRawResource(R.raw.cve_2015_1532));
    BitmapFactory.decodeStream(inStream);
}
#end_block

#method_before
// ***** Private Methods
// TODO(jeffbrown): Delete me.
// The RIL should *not* be listening for screen state changes since they are
// becoming increasingly ambiguous on our devices.  The RIL_REQUEST_SCREEN_STATE
// message should be deleted and replaced with more precise messages to control
// behavior such as signal strength reporting or power managements based on
// more robust signals.
private void updateScreenState() {
    final int oldState = mRadioScreenState;
    mRadioScreenState = (mDefaultDisplayState == Display.STATE_ON || mIsDevicePlugged) ? RADIO_SCREEN_ON : RADIO_SCREEN_OFF;
    if (mRadioScreenState != oldState) {
        if (RILJ_LOGV) {
            riljLog("defaultDisplayState: " + mDefaultDisplayState + ", isDevicePlugged: " + mIsDevicePlugged);
        }
        sendScreenState(mRadioScreenState == RADIO_SCREEN_ON);
    }
}
#method_after
// ***** Private Methods
// TODO(jeffbrown): Delete me.
// The RIL should *not* be listening for screen state changes since they are
// becoming increasingly ambiguous on our devices.  The RIL_REQUEST_SCREEN_STATE
// message should be deleted and replaced with more precise messages to control
// behavior such as signal strength reporting or power managements based on
// more robust signals.
private void updateScreenState(boolean forceUpdate) {
    final int oldState = mRadioScreenState;
    mRadioScreenState = (mDefaultDisplayState == Display.STATE_ON || mIsDevicePlugged) ? RADIO_SCREEN_ON : RADIO_SCREEN_OFF;
    if (mRadioScreenState != oldState || forceUpdate) {
        if (RILJ_LOGV) {
            riljLog("defaultDisplayState: " + mDefaultDisplayState + ", isDevicePlugged: " + mIsDevicePlugged);
        }
        sendScreenState(mRadioScreenState == RADIO_SCREEN_ON);
    }
}
#end_block

#method_before
@Override
protected void onRadioAvailable() {
    // In case screen state was lost (due to process crash),
    // this ensures that the RIL knows the correct screen state.
    updateScreenState();
}
#method_after
@Override
protected void onRadioAvailable() {
    // In case screen state was lost (due to process crash),
    // this ensures that the RIL knows the correct screen state.
    updateScreenState(false);
}
#end_block

#method_before
private void processUnsolicited(Parcel p) {
    int response;
    Object ret;
    response = p.readInt();
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                // the correct state (to stop signal strength reporting, etc.)
                if (mDefaultDisplay.getState() == Display.STATE_OFF) {
                    sendScreenState(false);
                }
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#method_after
private void processUnsolicited(Parcel p) {
    int response;
    Object ret;
    response = p.readInt();
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            /* has bonus radio state int */
            RadioState newState = getRadioStateFromInt(p.readInt());
            if (RILJ_LOGD)
                unsljLogMore(response, newState.toString());
            switchToRadioState(newState);
            break;
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                // When modem crashes, if user turns the screen off before RIL reconnects, screen
                // state cannot be sent to modem. Resend the display state here so that modem
                // has the correct state (to stop signal strength reporting, etc).
                updateScreenState(true);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#end_block

#method_before
public void notifyDataActivityForSubscriber(int subId, int state) {
    if (!checkNotifyPermission("notifyDataActivity()")) {
        return;
    }
    synchronized (mRecords) {
        int phoneId = SubscriptionManager.getPhoneId(subId);
        if (validatePhoneId(phoneId)) {
            mDataActivity[phoneId] = state;
            for (Record r : mRecords) {
                // Such as screen on/off action.
                if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_DATA_ACTIVITY) && idMatch(r.subId, subId, phoneId)) {
                    try {
                        r.callback.onDataActivity(state);
                    } catch (RemoteException ex) {
                        mRemoveList.add(r.binder);
                    }
                }
            }
        }
        handleRemoveListLocked();
    }
}
#method_after
public void notifyDataActivityForSubscriber(int subId, int state) {
    if (!checkNotifyPermission("notifyDataActivity()")) {
        return;
    }
    synchronized (mRecords) {
        int phoneId = SubscriptionManager.getPhoneId(subId);
        if (validatePhoneId(phoneId)) {
            mDataActivity[phoneId] = state;
            for (Record r : mRecords) {
                // Notify by correct subId.
                if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_DATA_ACTIVITY) && idMatch(r.subId, subId, phoneId)) {
                    try {
                        r.callback.onDataActivity(state);
                    } catch (RemoteException ex) {
                        mRemoveList.add(r.binder);
                    }
                }
            }
        }
        handleRemoveListLocked();
    }
}
#end_block

#method_before
public void testDivideAndRemainderUnsigned() {
    long[] vals = { 1L, 23L, 456L, 0x7fff_ffffL, 0x8000_0000L, 0xffff_ffffL };
    for (long dividend : vals) {
        for (long divisor : vals) {
            int uq = Integer.divideUnsigned((int) dividend, (int) divisor);
            int ur = Integer.remainderUnsigned((int) dividend, (int) divisor);
            assertEquals((int) (dividend / divisor), uq);
            assertEquals((int) (dividend % divisor), ur);
            assertEquals((int) dividend, uq * (int) divisor + ur);
        }
    }
    for (long dividend : vals) {
        try {
            Integer.divideUnsigned((int) dividend, 0);
        } catch (ArithmeticException expected) {
        }
        try {
            Integer.remainderUnsigned((int) dividend, 0);
        } catch (ArithmeticException expected) {
        }
    }
}
#method_after
public void testDivideAndRemainderUnsigned() {
    long[] vals = { 1L, 23L, 456L, 0x7fff_ffffL, 0x8000_0000L, 0xffff_ffffL };
    for (long dividend : vals) {
        for (long divisor : vals) {
            int uq = Integer.divideUnsigned((int) dividend, (int) divisor);
            int ur = Integer.remainderUnsigned((int) dividend, (int) divisor);
            assertEquals((int) (dividend / divisor), uq);
            assertEquals((int) (dividend % divisor), ur);
            assertEquals((int) dividend, uq * (int) divisor + ur);
        }
    }
    for (long dividend : vals) {
        try {
            Integer.divideUnsigned((int) dividend, 0);
            fail();
        } catch (ArithmeticException expected) {
        }
        try {
            Integer.remainderUnsigned((int) dividend, 0);
            fail();
        } catch (ArithmeticException expected) {
        }
    }
}
#end_block

#method_before
public void testParseUnsignedInt() {
    int[] vals = { 0, 1, 23, 456, 0x7fff_ffff, 0x8000_0000, 0xffff_ffff };
    for (int val : vals) {
        // Special radices
        assertEquals(val, Integer.parseUnsignedInt(Integer.toBinaryString(val), 2));
        assertEquals(val, Integer.parseUnsignedInt(Integer.toOctalString(val), 8));
        assertEquals(val, Integer.parseUnsignedInt(Integer.toUnsignedString(val)));
        assertEquals(val, Integer.parseUnsignedInt(Integer.toHexString(val), 16));
        for (int radix = Character.MIN_RADIX; radix < Character.MAX_RADIX; ++radix) {
            assertEquals(val, Integer.parseUnsignedInt(Integer.toUnsignedString(val, radix), radix));
        }
    }
    try {
        Integer.parseUnsignedInt("-1");
    } catch (NumberFormatException expected) {
    }
    try {
        Integer.parseUnsignedInt("123", 2);
    } catch (NumberFormatException expected) {
    }
}
#method_after
public void testParseUnsignedInt() {
    int[] vals = { 0, 1, 23, 456, 0x7fff_ffff, 0x8000_0000, 0xffff_ffff };
    for (int val : vals) {
        // Special radices
        assertEquals(val, Integer.parseUnsignedInt(Integer.toBinaryString(val), 2));
        assertEquals(val, Integer.parseUnsignedInt(Integer.toOctalString(val), 8));
        assertEquals(val, Integer.parseUnsignedInt(Integer.toUnsignedString(val)));
        assertEquals(val, Integer.parseUnsignedInt(Integer.toHexString(val), 16));
        for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; ++radix) {
            assertEquals(val, Integer.parseUnsignedInt(Integer.toUnsignedString(val, radix), radix));
        }
    }
    try {
        Integer.parseUnsignedInt("-1");
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Integer.parseUnsignedInt("123", 2);
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Integer.parseUnsignedInt(null);
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Integer.parseUnsignedInt("0", Character.MAX_RADIX + 1);
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Integer.parseUnsignedInt("0", Character.MIN_RADIX - 1);
        fail();
    } catch (NumberFormatException expected) {
    }
}
#end_block

#method_before
public void testToUnsignedString() {
    int[] vals = { 0, 1, 23, 456, 0x7fff_ffff, 0x8000_0000, 0xffff_ffff };
    for (int val : vals) {
        // Special radices
        assertTrue(Integer.toUnsignedString(val, 2).equals(Integer.toBinaryString(val)));
        assertTrue(Integer.toUnsignedString(val, 8).equals(Integer.toOctalString(val)));
        assertTrue(Integer.toUnsignedString(val, 10).equals(Integer.toUnsignedString(val)));
        assertTrue(Integer.toUnsignedString(val, 16).equals(Integer.toHexString(val)));
        for (int radix = Character.MIN_RADIX; radix < Character.MAX_RADIX; ++radix) {
            assertTrue(Integer.toUnsignedString(val, radix).equals(Long.toString(Integer.toUnsignedLong(val), radix)));
        }
    }
}
#method_after
public void testToUnsignedString() {
    int[] vals = { 0, 1, 23, 456, 0x7fff_ffff, 0x8000_0000, 0xffff_ffff };
    for (int val : vals) {
        // Special radices
        assertTrue(Integer.toUnsignedString(val, 2).equals(Integer.toBinaryString(val)));
        assertTrue(Integer.toUnsignedString(val, 8).equals(Integer.toOctalString(val)));
        assertTrue(Integer.toUnsignedString(val, 10).equals(Integer.toUnsignedString(val)));
        assertTrue(Integer.toUnsignedString(val, 16).equals(Integer.toHexString(val)));
        for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; ++radix) {
            assertTrue(Integer.toUnsignedString(val, radix).equals(Long.toString(Integer.toUnsignedLong(val), radix)));
        }
    // Behavior is not defined by Java API specification if the radix falls outside of valid
    // range, thus we don't test for such cases.
    }
}
#end_block

#method_before
public void testDivideAndRemainderUnsigned() {
    BigInteger[] vals = { BigInteger.ONE, BigInteger.valueOf(23L), BigInteger.valueOf(456L), BigInteger.valueOf(0x7fff_ffff_ffff_ffffL), BigInteger.valueOf(0x7fff_ffff_ffff_ffffL).add(BigInteger.ONE), BigInteger.valueOf(2).shiftLeft(63).subtract(BigInteger.ONE) };
    for (BigInteger dividend : vals) {
        for (BigInteger divisor : vals) {
            long uq = Long.divideUnsigned(dividend.longValue(), divisor.longValue());
            long ur = Long.remainderUnsigned(dividend.longValue(), divisor.longValue());
            assertEquals(dividend.divide(divisor).longValue(), uq);
            assertEquals(dividend.remainder(divisor).longValue(), ur);
        // assertTrue(dividend.equals(uq * divisor.longValue() + ur));
        }
    }
    for (BigInteger dividend : vals) {
        try {
            Long.divideUnsigned(dividend.longValue(), 0);
        } catch (ArithmeticException expected) {
        }
        try {
            Long.remainderUnsigned(dividend.longValue(), 0);
        } catch (ArithmeticException expected) {
        }
    }
}
#method_after
public void testDivideAndRemainderUnsigned() {
    BigInteger[] vals = { BigInteger.ONE, BigInteger.valueOf(23L), BigInteger.valueOf(456L), BigInteger.valueOf(0x7fff_ffff_ffff_ffffL), BigInteger.valueOf(0x7fff_ffff_ffff_ffffL).add(BigInteger.ONE), BigInteger.valueOf(2).shiftLeft(63).subtract(BigInteger.ONE) };
    for (BigInteger dividend : vals) {
        for (BigInteger divisor : vals) {
            long uq = Long.divideUnsigned(dividend.longValue(), divisor.longValue());
            long ur = Long.remainderUnsigned(dividend.longValue(), divisor.longValue());
            assertEquals(dividend.divide(divisor).longValue(), uq);
            assertEquals(dividend.remainder(divisor).longValue(), ur);
            assertEquals(dividend.longValue(), uq * divisor.longValue() + ur);
        }
    }
    for (BigInteger dividend : vals) {
        try {
            Long.divideUnsigned(dividend.longValue(), 0);
            fail();
        } catch (ArithmeticException expected) {
        }
        try {
            Long.remainderUnsigned(dividend.longValue(), 0);
            fail();
        } catch (ArithmeticException expected) {
        }
    }
}
#end_block

#method_before
public void testParseUnsignedLong() {
    long[] vals = { 0L, 1L, 23L, 456L, 0x7fff_ffff_ffff_ffffL, 0x8000_0000_0000_0000L, 0xffff_ffff_ffff_ffffL };
    for (long val : vals) {
        // Special radices
        assertEquals(val, Long.parseUnsignedLong(Long.toBinaryString(val), 2));
        assertEquals(val, Long.parseUnsignedLong(Long.toOctalString(val), 8));
        assertEquals(val, Long.parseUnsignedLong(Long.toUnsignedString(val)));
        assertEquals(val, Long.parseUnsignedLong(Long.toHexString(val), 16));
        for (int radix = Character.MIN_RADIX; radix < Character.MAX_RADIX; ++radix) {
            assertEquals(val, Long.parseUnsignedLong(Long.toUnsignedString(val, radix), radix));
        }
    }
    try {
        Long.parseUnsignedLong("-1");
    } catch (NumberFormatException expected) {
    }
    try {
        Long.parseUnsignedLong("123", 2);
    } catch (NumberFormatException expected) {
    }
}
#method_after
public void testParseUnsignedLong() {
    long[] vals = { 0L, 1L, 23L, 456L, 0x7fff_ffff_ffff_ffffL, 0x8000_0000_0000_0000L, 0xffff_ffff_ffff_ffffL };
    for (long val : vals) {
        // Special radices
        assertEquals(val, Long.parseUnsignedLong(Long.toBinaryString(val), 2));
        assertEquals(val, Long.parseUnsignedLong(Long.toOctalString(val), 8));
        assertEquals(val, Long.parseUnsignedLong(Long.toUnsignedString(val)));
        assertEquals(val, Long.parseUnsignedLong(Long.toHexString(val), 16));
        for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; ++radix) {
            assertEquals(val, Long.parseUnsignedLong(Long.toUnsignedString(val, radix), radix));
        }
    }
    try {
        Long.parseUnsignedLong("-1");
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Long.parseUnsignedLong("123", 2);
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Long.parseUnsignedLong(null, 2);
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Long.parseUnsignedLong("0", Character.MAX_RADIX + 1);
        fail();
    } catch (NumberFormatException expected) {
    }
    try {
        Long.parseUnsignedLong("0", Character.MIN_RADIX - 1);
        fail();
    } catch (NumberFormatException expected) {
    }
}
#end_block

#method_before
public void testToUnsignedString() {
    long[] vals = { 0L, 1L, 23L, 456L, 0x7fff_ffff_ffff_ffffL, 0x8000_0000_0000_0000L, 0xffff_ffff_ffff_ffffL };
    for (long val : vals) {
        // Special radices
        assertTrue(Long.toUnsignedString(val, 2).equals(Long.toBinaryString(val)));
        assertTrue(Long.toUnsignedString(val, 8).equals(Long.toOctalString(val)));
        assertTrue(Long.toUnsignedString(val, 10).equals(Long.toUnsignedString(val)));
        assertTrue(Long.toUnsignedString(val, 16).equals(Long.toHexString(val)));
        for (int radix = Character.MIN_RADIX; radix < Character.MAX_RADIX; ++radix) {
            int upper = (int) (val >>> 32), lower = (int) val;
            BigInteger b = (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));
            assertTrue(Long.toUnsignedString(val, radix).equals(b.toString(radix)));
        }
    }
}
#method_after
public void testToUnsignedString() {
    long[] vals = { 0L, 1L, 23L, 456L, 0x7fff_ffff_ffff_ffffL, 0x8000_0000_0000_0000L, 0xffff_ffff_ffff_ffffL };
    for (long val : vals) {
        // Special radices
        assertTrue(Long.toUnsignedString(val, 2).equals(Long.toBinaryString(val)));
        assertTrue(Long.toUnsignedString(val, 8).equals(Long.toOctalString(val)));
        assertTrue(Long.toUnsignedString(val, 10).equals(Long.toUnsignedString(val)));
        assertTrue(Long.toUnsignedString(val, 16).equals(Long.toHexString(val)));
        for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; ++radix) {
            int upper = (int) (val >>> 32), lower = (int) val;
            BigInteger b = (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));
            assertTrue(Long.toUnsignedString(val, radix).equals(b.toString(radix)));
        }
    // Behavior is not defined by Java API specification if the radix falls outside of valid
    // range, thus we don't test for such cases.
    }
}
#end_block

#method_before
private static void setupEncoderParameters() {
    // Loop over each tabel entry until a proper encoder setting is found.
    for (int i = 0; i < ENCODER_PARAM_TABLE.length; i++) {
        // Check if we can support it?
        if (verifySupportForEncoderLevel(i)) {
            WIDTH = ENCODER_PARAM_TABLE[i][1];
            HEIGHT = ENCODER_PARAM_TABLE[i][2];
            BIT_RATE = ENCODER_PARAM_TABLE[i][3];
            FRAME_RATE = ENCODER_PARAM_TABLE[i][4];
            Log.d(TAG, "encoder parameters changed: width = " + WIDTH + ", height = " + HEIGHT + ", bitrate = " + BIT_RATE + ", framerate = " + FRAME_RATE);
            break;
        }
    }
}
#method_after
private static void setupEncoderParameters() {
    // Loop over each tabel entry until a proper encoder setting is found.
    for (int i = 0; i < ENCODER_PARAM_TABLE.length; i++) {
        // Check if we can support it?
        if (verifySupportForEncoderLevel(i)) {
            sWidth = ENCODER_PARAM_TABLE[i][1];
            sHeight = ENCODER_PARAM_TABLE[i][2];
            sBitRate = ENCODER_PARAM_TABLE[i][3];
            sFrameRate = ENCODER_PARAM_TABLE[i][4];
            Log.d(TAG, "encoder parameters changed: width = " + sWidth + ", height = " + sHeight + ", bitrate = " + sBitRate + ", framerate = " + sFrameRate);
            break;
        }
    }
}
#end_block

#method_before
private void encodeVirtualDisplayTest() {
    MediaCodec encoder = null;
    MediaCodec decoder = null;
    OutputSurface outputSurface = null;
    VirtualDisplay virtualDisplay = null;
    try {
        // Encoded video resolution matches virtual display.
        MediaFormat encoderFormat = MediaFormat.createVideoFormat(MIME_TYPE, WIDTH, HEIGHT);
        encoderFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);
        encoderFormat.setInteger(MediaFormat.KEY_BIT_RATE, BIT_RATE);
        encoderFormat.setInteger(MediaFormat.KEY_FRAME_RATE, FRAME_RATE);
        encoderFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);
        encoder = MediaCodec.createEncoderByType(MIME_TYPE);
        encoder.configure(encoderFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
        Surface inputSurface = encoder.createInputSurface();
        encoder.start();
        // Create a virtual display that will output to our encoder.
        virtualDisplay = mDisplayManager.createVirtualDisplay(NAME, WIDTH, HEIGHT, DENSITY, inputSurface, 0);
        // We also need a decoder to check the output of the encoder.
        decoder = MediaCodec.createDecoderByType(MIME_TYPE);
        MediaFormat decoderFormat = MediaFormat.createVideoFormat(MIME_TYPE, WIDTH, HEIGHT);
        outputSurface = new OutputSurface(WIDTH, HEIGHT);
        decoder.configure(decoderFormat, outputSurface.getSurface(), null, 0);
        decoder.start();
        // Run the color slide show on a separate thread.
        mInputDone = false;
        new ColorSlideShow(virtualDisplay.getDisplay()).start();
        // Record everything we can and check the results.
        doTestEncodeVirtual(encoder, decoder, outputSurface);
    } finally {
        if (VERBOSE)
            Log.d(TAG, "releasing codecs, surfaces, and virtual display");
        if (virtualDisplay != null) {
            virtualDisplay.release();
        }
        if (outputSurface != null) {
            outputSurface.release();
        }
        if (encoder != null) {
            encoder.stop();
            encoder.release();
        }
        if (decoder != null) {
            decoder.stop();
            decoder.release();
        }
    }
}
#method_after
private void encodeVirtualDisplayTest() {
    MediaCodec encoder = null;
    MediaCodec decoder = null;
    OutputSurface outputSurface = null;
    VirtualDisplay virtualDisplay = null;
    try {
        // Encoded video resolution matches virtual display.
        MediaFormat encoderFormat = MediaFormat.createVideoFormat(MIME_TYPE, sWidth, sHeight);
        encoderFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);
        encoderFormat.setInteger(MediaFormat.KEY_BIT_RATE, sBitRate);
        encoderFormat.setInteger(MediaFormat.KEY_FRAME_RATE, sFrameRate);
        encoderFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);
        encoder = MediaCodec.createEncoderByType(MIME_TYPE);
        encoder.configure(encoderFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
        Surface inputSurface = encoder.createInputSurface();
        encoder.start();
        // Create a virtual display that will output to our encoder.
        virtualDisplay = mDisplayManager.createVirtualDisplay(NAME, sWidth, sHeight, DENSITY, inputSurface, 0);
        // We also need a decoder to check the output of the encoder.
        decoder = MediaCodec.createDecoderByType(MIME_TYPE);
        MediaFormat decoderFormat = MediaFormat.createVideoFormat(MIME_TYPE, sWidth, sHeight);
        outputSurface = new OutputSurface(sWidth, sHeight);
        decoder.configure(decoderFormat, outputSurface.getSurface(), null, 0);
        decoder.start();
        // Run the color slide show on a separate thread.
        mInputDone = false;
        new ColorSlideShow(virtualDisplay.getDisplay()).start();
        // Record everything we can and check the results.
        doTestEncodeVirtual(encoder, decoder, outputSurface);
    } finally {
        if (VERBOSE)
            Log.d(TAG, "releasing codecs, surfaces, and virtual display");
        if (virtualDisplay != null) {
            virtualDisplay.release();
        }
        if (outputSurface != null) {
            outputSurface.release();
        }
        if (encoder != null) {
            encoder.stop();
            encoder.release();
        }
        if (decoder != null) {
            decoder.stop();
            decoder.release();
        }
    }
}
#end_block

#method_before
private void doTestEncodeVirtual(MediaCodec encoder, MediaCodec decoder, OutputSurface outputSurface) {
    final int TIMEOUT_USEC = 10000;
    ByteBuffer[] encoderOutputBuffers = encoder.getOutputBuffers();
    ByteBuffer[] decoderInputBuffers = decoder.getInputBuffers();
    MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
    boolean inputEosSignaled = false;
    int lastIndex = -1;
    int goodFrames = 0;
    int debugFrameCount = 0;
    // Save a copy to disk.  Useful for debugging the test.  Note this is a raw elementary
    // stream, not a .mp4 file, so not all players will know what to do with it.
    FileOutputStream outputStream = null;
    if (DEBUG_SAVE_FILE) {
        String fileName = DEBUG_FILE_NAME_BASE + WIDTH + "x" + HEIGHT + ".mp4";
        try {
            outputStream = new FileOutputStream(fileName);
            Log.d(TAG, "encoded output will be saved as " + fileName);
        } catch (IOException ioe) {
            Log.w(TAG, "Unable to create debug output file " + fileName);
            throw new RuntimeException(ioe);
        }
    }
    // Loop until the output side is done.
    boolean encoderDone = false;
    boolean outputDone = false;
    while (!outputDone) {
        if (VERBOSE)
            Log.d(TAG, "loop");
        if (!inputEosSignaled && mInputDone) {
            if (VERBOSE)
                Log.d(TAG, "signaling input EOS");
            encoder.signalEndOfInputStream();
            inputEosSignaled = true;
        }
        boolean decoderOutputAvailable = true;
        boolean encoderOutputAvailable = !encoderDone;
        while (decoderOutputAvailable || encoderOutputAvailable) {
            // Start by draining any pending output from the decoder.  It's important to
            // do this before we try to stuff any more data in.
            int decoderStatus = decoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
            if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                // no output available yet
                if (VERBOSE)
                    Log.d(TAG, "no output from decoder available");
                decoderOutputAvailable = false;
            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                if (VERBOSE)
                    Log.d(TAG, "decoder output buffers changed (but we don't care)");
            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                // this happens before the first frame is returned
                MediaFormat decoderOutputFormat = decoder.getOutputFormat();
                if (VERBOSE)
                    Log.d(TAG, "decoder output format changed: " + decoderOutputFormat);
            } else if (decoderStatus < 0) {
                fail("unexpected result from deocder.dequeueOutputBuffer: " + decoderStatus);
            } else {
                // decoderStatus >= 0
                if (VERBOSE)
                    Log.d(TAG, "surface decoder given buffer " + decoderStatus + " (size=" + info.size + ")");
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    if (VERBOSE)
                        Log.d(TAG, "output EOS");
                    outputDone = true;
                }
                // The ByteBuffers are null references, but we still get a nonzero size for
                // the decoded data.
                boolean doRender = (info.size != 0);
                // As soon as we call releaseOutputBuffer, the buffer will be forwarded
                // to SurfaceTexture to convert to a texture.  The API doesn't guarantee
                // that the texture will be available before the call returns, so we
                // need to wait for the onFrameAvailable callback to fire.  If we don't
                // wait, we risk dropping frames.
                outputSurface.makeCurrent();
                decoder.releaseOutputBuffer(decoderStatus, doRender);
                if (doRender) {
                    if (VERBOSE)
                        Log.d(TAG, "awaiting frame " + (lastIndex + 1));
                    outputSurface.awaitNewImage();
                    outputSurface.drawImage();
                    int foundIndex = checkSurfaceFrame();
                    if (foundIndex == lastIndex + 1) {
                        // found the next one in the series
                        lastIndex = foundIndex;
                        goodFrames++;
                    } else if (foundIndex == lastIndex) {
                        // Sometimes we see the same color two frames in a row.
                        if (VERBOSE)
                            Log.d(TAG, "Got another " + lastIndex);
                    } else if (foundIndex > 0) {
                        // can catch the rest.
                        if (foundIndex < lastIndex) {
                            Log.w(TAG, "Ignoring backward skip from " + lastIndex + " to " + foundIndex);
                        } else {
                            Log.w(TAG, "Frame skipped, advancing lastIndex from " + lastIndex + " to " + foundIndex);
                            goodFrames++;
                            lastIndex = foundIndex;
                        }
                    }
                }
            }
            if (decoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {
                // Continue attempts to drain output.
                continue;
            }
            // the encoder.
            if (!encoderDone) {
                int encoderStatus = encoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                    // no output available yet
                    if (VERBOSE)
                        Log.d(TAG, "no output from encoder available");
                    encoderOutputAvailable = false;
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    // not expected for an encoder
                    encoderOutputBuffers = encoder.getOutputBuffers();
                    if (VERBOSE)
                        Log.d(TAG, "encoder output buffers changed");
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // received before first buffer
                    MediaFormat newFormat = encoder.getOutputFormat();
                    if (VERBOSE)
                        Log.d(TAG, "encoder output format changed: " + newFormat);
                } else if (encoderStatus < 0) {
                    fail("unexpected result from encoder.dequeueOutputBuffer: " + encoderStatus);
                } else {
                    // encoderStatus >= 0
                    ByteBuffer encodedData = encoderOutputBuffers[encoderStatus];
                    if (encodedData == null) {
                        fail("encoderOutputBuffer " + encoderStatus + " was null");
                    }
                    // It's usually necessary to adjust the ByteBuffer values to match BufferInfo.
                    encodedData.position(info.offset);
                    encodedData.limit(info.offset + info.size);
                    if (outputStream != null) {
                        byte[] data = new byte[info.size];
                        encodedData.get(data);
                        encodedData.position(info.offset);
                        try {
                            outputStream.write(data);
                        } catch (IOException ioe) {
                            Log.w(TAG, "failed writing debug data to file");
                            throw new RuntimeException(ioe);
                        }
                        debugFrameCount++;
                    }
                    // Get a decoder input buffer, blocking until it's available.  We just
                    // drained the decoder output, so we expect there to be a free input
                    // buffer now or in the near future (i.e. this should never deadlock
                    // if the codec is meeting requirements).
                    // 
                    // The first buffer of data we get will have the BUFFER_FLAG_CODEC_CONFIG
                    // flag set; the decoder will see this and finish configuring itself.
                    int inputBufIndex = decoder.dequeueInputBuffer(-1);
                    ByteBuffer inputBuf = decoderInputBuffers[inputBufIndex];
                    inputBuf.clear();
                    inputBuf.put(encodedData);
                    decoder.queueInputBuffer(inputBufIndex, 0, info.size, info.presentationTimeUs, info.flags);
                    // can stop polling the encoder output.  (This just an optimization.)
                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        encoderDone = true;
                        encoderOutputAvailable = false;
                    }
                    if (VERBOSE)
                        Log.d(TAG, "passed " + info.size + " bytes to decoder" + (encoderDone ? " (EOS)" : ""));
                    encoder.releaseOutputBuffer(encoderStatus, false);
                }
            }
        }
    }
    if (outputStream != null) {
        try {
            outputStream.close();
            if (VERBOSE)
                Log.d(TAG, "Wrote " + debugFrameCount + " frames");
        } catch (IOException ioe) {
            Log.w(TAG, "failed closing debug file");
            throw new RuntimeException(ioe);
        }
    }
    if (goodFrames != TEST_COLORS.length) {
        fail("Found " + goodFrames + " of " + TEST_COLORS.length + " expected frames");
    }
}
#method_after
private void doTestEncodeVirtual(MediaCodec encoder, MediaCodec decoder, OutputSurface outputSurface) {
    final int TIMEOUT_USEC = 10000;
    ByteBuffer[] encoderOutputBuffers = encoder.getOutputBuffers();
    ByteBuffer[] decoderInputBuffers = decoder.getInputBuffers();
    MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
    boolean inputEosSignaled = false;
    int lastIndex = -1;
    int goodFrames = 0;
    int debugFrameCount = 0;
    // Save a copy to disk.  Useful for debugging the test.  Note this is a raw elementary
    // stream, not a .mp4 file, so not all players will know what to do with it.
    FileOutputStream outputStream = null;
    if (DEBUG_SAVE_FILE) {
        String fileName = DEBUG_FILE_NAME_BASE + sWidth + "x" + sHeight + ".mp4";
        try {
            outputStream = new FileOutputStream(fileName);
            Log.d(TAG, "encoded output will be saved as " + fileName);
        } catch (IOException ioe) {
            Log.w(TAG, "Unable to create debug output file " + fileName);
            throw new RuntimeException(ioe);
        }
    }
    // Loop until the output side is done.
    boolean encoderDone = false;
    boolean outputDone = false;
    while (!outputDone) {
        if (VERBOSE)
            Log.d(TAG, "loop");
        if (!inputEosSignaled && mInputDone) {
            if (VERBOSE)
                Log.d(TAG, "signaling input EOS");
            encoder.signalEndOfInputStream();
            inputEosSignaled = true;
        }
        boolean decoderOutputAvailable = true;
        boolean encoderOutputAvailable = !encoderDone;
        while (decoderOutputAvailable || encoderOutputAvailable) {
            // Start by draining any pending output from the decoder.  It's important to
            // do this before we try to stuff any more data in.
            int decoderStatus = decoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
            if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                // no output available yet
                if (VERBOSE)
                    Log.d(TAG, "no output from decoder available");
                decoderOutputAvailable = false;
            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                if (VERBOSE)
                    Log.d(TAG, "decoder output buffers changed (but we don't care)");
            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                // this happens before the first frame is returned
                MediaFormat decoderOutputFormat = decoder.getOutputFormat();
                if (VERBOSE)
                    Log.d(TAG, "decoder output format changed: " + decoderOutputFormat);
            } else if (decoderStatus < 0) {
                fail("unexpected result from deocder.dequeueOutputBuffer: " + decoderStatus);
            } else {
                // decoderStatus >= 0
                if (VERBOSE)
                    Log.d(TAG, "surface decoder given buffer " + decoderStatus + " (size=" + info.size + ")");
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    if (VERBOSE)
                        Log.d(TAG, "output EOS");
                    outputDone = true;
                }
                // The ByteBuffers are null references, but we still get a nonzero size for
                // the decoded data.
                boolean doRender = (info.size != 0);
                // As soon as we call releaseOutputBuffer, the buffer will be forwarded
                // to SurfaceTexture to convert to a texture.  The API doesn't guarantee
                // that the texture will be available before the call returns, so we
                // need to wait for the onFrameAvailable callback to fire.  If we don't
                // wait, we risk dropping frames.
                outputSurface.makeCurrent();
                decoder.releaseOutputBuffer(decoderStatus, doRender);
                if (doRender) {
                    if (VERBOSE)
                        Log.d(TAG, "awaiting frame " + (lastIndex + 1));
                    outputSurface.awaitNewImage();
                    outputSurface.drawImage();
                    int foundIndex = checkSurfaceFrame();
                    if (foundIndex == lastIndex + 1) {
                        // found the next one in the series
                        lastIndex = foundIndex;
                        goodFrames++;
                    } else if (foundIndex == lastIndex) {
                        // Sometimes we see the same color two frames in a row.
                        if (VERBOSE)
                            Log.d(TAG, "Got another " + lastIndex);
                    } else if (foundIndex > 0) {
                        // can catch the rest.
                        if (foundIndex < lastIndex) {
                            Log.w(TAG, "Ignoring backward skip from " + lastIndex + " to " + foundIndex);
                        } else {
                            Log.w(TAG, "Frame skipped, advancing lastIndex from " + lastIndex + " to " + foundIndex);
                            goodFrames++;
                            lastIndex = foundIndex;
                        }
                    }
                }
            }
            if (decoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {
                // Continue attempts to drain output.
                continue;
            }
            // the encoder.
            if (!encoderDone) {
                int encoderStatus = encoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                    // no output available yet
                    if (VERBOSE)
                        Log.d(TAG, "no output from encoder available");
                    encoderOutputAvailable = false;
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    // not expected for an encoder
                    encoderOutputBuffers = encoder.getOutputBuffers();
                    if (VERBOSE)
                        Log.d(TAG, "encoder output buffers changed");
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // received before first buffer
                    MediaFormat newFormat = encoder.getOutputFormat();
                    if (VERBOSE)
                        Log.d(TAG, "encoder output format changed: " + newFormat);
                } else if (encoderStatus < 0) {
                    fail("unexpected result from encoder.dequeueOutputBuffer: " + encoderStatus);
                } else {
                    // encoderStatus >= 0
                    ByteBuffer encodedData = encoderOutputBuffers[encoderStatus];
                    if (encodedData == null) {
                        fail("encoderOutputBuffer " + encoderStatus + " was null");
                    }
                    // It's usually necessary to adjust the ByteBuffer values to match BufferInfo.
                    encodedData.position(info.offset);
                    encodedData.limit(info.offset + info.size);
                    if (outputStream != null) {
                        byte[] data = new byte[info.size];
                        encodedData.get(data);
                        encodedData.position(info.offset);
                        try {
                            outputStream.write(data);
                        } catch (IOException ioe) {
                            Log.w(TAG, "failed writing debug data to file");
                            throw new RuntimeException(ioe);
                        }
                        debugFrameCount++;
                    }
                    // Get a decoder input buffer, blocking until it's available.  We just
                    // drained the decoder output, so we expect there to be a free input
                    // buffer now or in the near future (i.e. this should never deadlock
                    // if the codec is meeting requirements).
                    // 
                    // The first buffer of data we get will have the BUFFER_FLAG_CODEC_CONFIG
                    // flag set; the decoder will see this and finish configuring itself.
                    int inputBufIndex = decoder.dequeueInputBuffer(-1);
                    ByteBuffer inputBuf = decoderInputBuffers[inputBufIndex];
                    inputBuf.clear();
                    inputBuf.put(encodedData);
                    decoder.queueInputBuffer(inputBufIndex, 0, info.size, info.presentationTimeUs, info.flags);
                    // can stop polling the encoder output.  (This just an optimization.)
                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        encoderDone = true;
                        encoderOutputAvailable = false;
                    }
                    if (VERBOSE)
                        Log.d(TAG, "passed " + info.size + " bytes to decoder" + (encoderDone ? " (EOS)" : ""));
                    encoder.releaseOutputBuffer(encoderStatus, false);
                }
            }
        }
    }
    if (outputStream != null) {
        try {
            outputStream.close();
            if (VERBOSE)
                Log.d(TAG, "Wrote " + debugFrameCount + " frames");
        } catch (IOException ioe) {
            Log.w(TAG, "failed closing debug file");
            throw new RuntimeException(ioe);
        }
    }
    if (goodFrames != TEST_COLORS.length) {
        fail("Found " + goodFrames + " of " + TEST_COLORS.length + " expected frames");
    }
}
#end_block

#method_before
private int checkSurfaceFrame() {
    boolean frameFailed = false;
    // Read a pixel from the center of the surface.  Might want to read from multiple points
    // and average them together.
    int x = WIDTH / 2;
    int y = HEIGHT / 2;
    GLES20.glReadPixels(x, y, 1, 1, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPixelBuf);
    int r = mPixelBuf.get(0) & 0xff;
    int g = mPixelBuf.get(1) & 0xff;
    int b = mPixelBuf.get(2) & 0xff;
    if (VERBOSE)
        Log.d(TAG, "GOT: r=" + r + " g=" + g + " b=" + b);
    if (approxEquals(0, r) && approxEquals(0, g) && approxEquals(0, b)) {
        return -2;
    }
    // RGB<->YCbCr conversions, so don't expect exact matches.
    for (int i = 0; i < TEST_COLORS.length; i++) {
        int testRed = (TEST_COLORS[i] >> 16) & 0xff;
        int testGreen = (TEST_COLORS[i] >> 8) & 0xff;
        int testBlue = TEST_COLORS[i] & 0xff;
        if (approxEquals(testRed, r) && approxEquals(testGreen, g) && approxEquals(testBlue, b)) {
            if (VERBOSE)
                Log.d(TAG, "Matched color " + i + ": r=" + r + " g=" + g + " b=" + b);
            return i;
        }
    }
    throw new RuntimeException("No match for color r=" + r + " g=" + g + " b=" + b);
}
#method_after
private int checkSurfaceFrame() {
    boolean frameFailed = false;
    // Read a pixel from the center of the surface.  Might want to read from multiple points
    // and average them together.
    int x = sWidth / 2;
    int y = sHeight / 2;
    GLES20.glReadPixels(x, y, 1, 1, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPixelBuf);
    int r = mPixelBuf.get(0) & 0xff;
    int g = mPixelBuf.get(1) & 0xff;
    int b = mPixelBuf.get(2) & 0xff;
    if (VERBOSE)
        Log.d(TAG, "GOT: r=" + r + " g=" + g + " b=" + b);
    if (approxEquals(0, r) && approxEquals(0, g) && approxEquals(0, b)) {
        return -2;
    }
    // RGB<->YCbCr conversions, so don't expect exact matches.
    for (int i = 0; i < TEST_COLORS.length; i++) {
        int testRed = (TEST_COLORS[i] >> 16) & 0xff;
        int testGreen = (TEST_COLORS[i] >> 8) & 0xff;
        int testBlue = TEST_COLORS[i] & 0xff;
        if (approxEquals(testRed, r) && approxEquals(testGreen, g) && approxEquals(testBlue, b)) {
            if (VERBOSE)
                Log.d(TAG, "Matched color " + i + ": r=" + r + " g=" + g + " b=" + b);
            return i;
        }
    }
    throw new RuntimeException("No match for color r=" + r + " g=" + g + " b=" + b);
}
#end_block

#method_before
public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
    // Let be: this = [u1,s1]  and  divisor = [u2,s2]
    if (roundingMode == null) {
        throw new NullPointerException("roundingMode == null");
    }
    if (divisor.isZero()) {
        throw new ArithmeticException("Division by zero");
    }
    long diffScale = ((long) this.scale - divisor.scale) - scale;
    // Check whether the diffScale will fit into an int. See http://b/17393664.
    if (bitLength(diffScale) > 32) {
        throw new ArithmeticException("Unable to perform divisor / dividend scaling: the difference in scale is too" + " big (" + diffScale + ")");
    }
    if (this.bitLength < 64 && divisor.bitLength < 64) {
        if (diffScale == 0) {
            return dividePrimitiveLongs(this.smallValue, divisor.smallValue, scale, roundingMode);
        } else if (diffScale > 0) {
            if (diffScale < MathUtils.LONG_POWERS_OF_TEN.length && divisor.bitLength + LONG_POWERS_OF_TEN_BIT_LENGTH[(int) diffScale] < 64) {
                return dividePrimitiveLongs(this.smallValue, divisor.smallValue * MathUtils.LONG_POWERS_OF_TEN[(int) diffScale], scale, roundingMode);
            }
        } else {
            // diffScale < 0
            if (-diffScale < MathUtils.LONG_POWERS_OF_TEN.length && this.bitLength + LONG_POWERS_OF_TEN_BIT_LENGTH[(int) -diffScale] < 64) {
                return dividePrimitiveLongs(this.smallValue * MathUtils.LONG_POWERS_OF_TEN[(int) -diffScale], divisor.smallValue, scale, roundingMode);
            }
        }
    }
    BigInteger scaledDividend = this.getUnscaledValue();
    // for scaling of 'u2'
    BigInteger scaledDivisor = divisor.getUnscaledValue();
    if (diffScale > 0) {
        // Multiply 'u2'  by:  10^((s1 - s2) - scale)
        scaledDivisor = Multiplication.multiplyByTenPow(scaledDivisor, (int) diffScale);
    } else if (diffScale < 0) {
        // Multiply 'u1'  by:  10^(scale - (s1 - s2))
        scaledDividend = Multiplication.multiplyByTenPow(scaledDividend, (int) -diffScale);
    }
    return divideBigIntegers(scaledDividend, scaledDivisor, scale, roundingMode);
}
#method_after
public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
    // Let be: this = [u1,s1]  and  divisor = [u2,s2]
    if (roundingMode == null) {
        throw new NullPointerException("roundingMode == null");
    }
    if (divisor.isZero()) {
        throw new ArithmeticException("Division by zero");
    }
    long diffScale = ((long) this.scale - divisor.scale) - scale;
    // Check whether the diffScale will fit into an int. See http://b/17393664.
    if (bitLength(diffScale) > 32) {
        throw new ArithmeticException("Unable to perform divisor / dividend scaling: the difference in scale is too" + " big (" + diffScale + ")");
    }
    if (this.bitLength < 64 && divisor.bitLength < 64) {
        if (diffScale == 0) {
            // http://b/26105053 - corner case: Long.MIN_VALUE / (-1) overflows a long
            if (this.smallValue != Long.MIN_VALUE || divisor.smallValue != -1) {
                return dividePrimitiveLongs(this.smallValue, divisor.smallValue, scale, roundingMode);
            }
        } else if (diffScale > 0) {
            if (diffScale < MathUtils.LONG_POWERS_OF_TEN.length && divisor.bitLength + LONG_POWERS_OF_TEN_BIT_LENGTH[(int) diffScale] < 64) {
                return dividePrimitiveLongs(this.smallValue, divisor.smallValue * MathUtils.LONG_POWERS_OF_TEN[(int) diffScale], scale, roundingMode);
            }
        } else {
            // diffScale < 0
            if (-diffScale < MathUtils.LONG_POWERS_OF_TEN.length && this.bitLength + LONG_POWERS_OF_TEN_BIT_LENGTH[(int) -diffScale] < 64) {
                return dividePrimitiveLongs(this.smallValue * MathUtils.LONG_POWERS_OF_TEN[(int) -diffScale], divisor.smallValue, scale, roundingMode);
            }
        }
    }
    BigInteger scaledDividend = this.getUnscaledValue();
    // for scaling of 'u2'
    BigInteger scaledDivisor = divisor.getUnscaledValue();
    if (diffScale > 0) {
        // Multiply 'u2'  by:  10^((s1 - s2) - scale)
        scaledDivisor = Multiplication.multiplyByTenPow(scaledDivisor, (int) diffScale);
    } else if (diffScale < 0) {
        // Multiply 'u1'  by:  10^(scale - (s1 - s2))
        scaledDividend = Multiplication.multiplyByTenPow(scaledDividend, (int) -diffScale);
    }
    return divideBigIntegers(scaledDividend, scaledDivisor, scale, roundingMode);
}
#end_block

#method_before
private static BigDecimal divideBigIntegers(BigInteger scaledDividend, BigInteger scaledDivisor, int scale, RoundingMode roundingMode) {
    // quotient and remainder
    BigInteger[] quotAndRem = scaledDividend.divideAndRemainder(scaledDivisor);
    // If after division there is a remainder...
    BigInteger quotient = quotAndRem[0];
    BigInteger remainder = quotAndRem[1];
    if (remainder.signum() == 0) {
        return new BigDecimal(quotient, scale);
    }
    int sign = scaledDividend.signum() * scaledDivisor.signum();
    // 'compare to remainder'
    int compRem;
    if (scaledDivisor.bitLength() < 63) {
        // 63 in order to avoid out of long after *2
        long rem = remainder.longValue();
        long divisor = scaledDivisor.longValue();
        compRem = longCompareTo(Math.abs(rem) * 2, Math.abs(divisor));
        // To look if there is a carry
        compRem = roundingBehavior(quotient.testBit(0) ? 1 : 0, sign * (5 + compRem), roundingMode);
    } else {
        // Checking if:  remainder * 2 >= scaledDivisor
        compRem = remainder.abs().shiftLeftOneBit().compareTo(scaledDivisor.abs());
        compRem = roundingBehavior(quotient.testBit(0) ? 1 : 0, sign * (5 + compRem), roundingMode);
    }
    if (compRem != 0) {
        if (quotient.bitLength() < 63) {
            return valueOf(quotient.longValue() + compRem, scale);
        }
        quotient = quotient.add(BigInteger.valueOf(compRem));
        return new BigDecimal(quotient, scale);
    }
    // Constructing the result with the appropriate unscaled value
    return new BigDecimal(quotient, scale);
}
#method_after
private static BigDecimal divideBigIntegers(BigInteger scaledDividend, BigInteger scaledDivisor, int scale, RoundingMode roundingMode) {
    // quotient and remainder
    BigInteger[] quotAndRem = scaledDividend.divideAndRemainder(scaledDivisor);
    // If after division there is a remainder...
    BigInteger quotient = quotAndRem[0];
    BigInteger remainder = quotAndRem[1];
    if (remainder.signum() == 0) {
        return new BigDecimal(quotient, scale);
    }
    int sign = scaledDividend.signum() * scaledDivisor.signum();
    // 'compare to remainder'
    int compRem;
    if (scaledDivisor.bitLength() < 63) {
        // 63 in order to avoid out of long after *2
        long rem = remainder.longValue();
        long divisor = scaledDivisor.longValue();
        compRem = compareForRounding(rem, divisor);
        // To look if there is a carry
        compRem = roundingBehavior(quotient.testBit(0) ? 1 : 0, sign * (5 + compRem), roundingMode);
    } else {
        // Checking if:  remainder * 2 >= scaledDivisor
        compRem = remainder.abs().shiftLeftOneBit().compareTo(scaledDivisor.abs());
        compRem = roundingBehavior(quotient.testBit(0) ? 1 : 0, sign * (5 + compRem), roundingMode);
    }
    if (compRem != 0) {
        if (quotient.bitLength() < 63) {
            return valueOf(quotient.longValue() + compRem, scale);
        }
        quotient = quotient.add(BigInteger.valueOf(compRem));
        return new BigDecimal(quotient, scale);
    }
    // Constructing the result with the appropriate unscaled value
    return new BigDecimal(quotient, scale);
}
#end_block

#method_before
private static BigDecimal dividePrimitiveLongs(long scaledDividend, long scaledDivisor, int scale, RoundingMode roundingMode) {
    long quotient = scaledDividend / scaledDivisor;
    long remainder = scaledDividend % scaledDivisor;
    int sign = Long.signum(scaledDividend) * Long.signum(scaledDivisor);
    if (remainder != 0) {
        // Checking if:  remainder * 2 >= scaledDivisor
        // 'compare to remainder'
        int compRem;
        compRem = longCompareTo(Math.abs(remainder) * 2, Math.abs(scaledDivisor));
        // To look if there is a carry
        quotient += roundingBehavior(((int) quotient) & 1, sign * (5 + compRem), roundingMode);
    }
    // Constructing the result with the appropriate unscaled value
    return valueOf(quotient, scale);
}
#method_after
private static BigDecimal dividePrimitiveLongs(long scaledDividend, long scaledDivisor, int scale, RoundingMode roundingMode) {
    long quotient = scaledDividend / scaledDivisor;
    long remainder = scaledDividend % scaledDivisor;
    int sign = Long.signum(scaledDividend) * Long.signum(scaledDivisor);
    if (remainder != 0) {
        // Checking if:  remainder * 2 >= scaledDivisor
        // 'compare to remainder'
        int compRem = compareForRounding(remainder, scaledDivisor);
        // To look if there is a carry
        quotient += roundingBehavior(((int) quotient) & 1, sign * (5 + compRem), roundingMode);
    }
    // Constructing the result with the appropriate unscaled value
    return valueOf(quotient, scale);
}
#end_block

#method_before
private void smallRound(MathContext mc, int discardedPrecision) {
    long sizeOfFraction = MathUtils.LONG_POWERS_OF_TEN[discardedPrecision];
    long newScale = (long) scale - discardedPrecision;
    long unscaledVal = smallValue;
    // Getting the integer part and the discarded fraction
    long integer = unscaledVal / sizeOfFraction;
    long fraction = unscaledVal % sizeOfFraction;
    int compRem;
    // If the discarded fraction is non-zero perform rounding
    if (fraction != 0) {
        // To check if the discarded fraction >= 0.5
        compRem = longCompareTo(Math.abs(fraction) * 2, sizeOfFraction);
        // To look if there is a carry
        integer += roundingBehavior(((int) integer) & 1, Long.signum(fraction) * (5 + compRem), mc.getRoundingMode());
        // If after to add the increment the precision changed, we normalize the size
        if (Math.log10(Math.abs(integer)) >= mc.getPrecision()) {
            integer /= 10;
            newScale--;
        }
    }
    // To update all internal fields
    scale = safeLongToInt(newScale);
    precision = mc.getPrecision();
    smallValue = integer;
    bitLength = bitLength(integer);
    intVal = null;
}
#method_after
private void smallRound(MathContext mc, int discardedPrecision) {
    long sizeOfFraction = MathUtils.LONG_POWERS_OF_TEN[discardedPrecision];
    long newScale = (long) scale - discardedPrecision;
    long unscaledVal = smallValue;
    // Getting the integer part and the discarded fraction
    long integer = unscaledVal / sizeOfFraction;
    long fraction = unscaledVal % sizeOfFraction;
    int compRem;
    // If the discarded fraction is non-zero perform rounding
    if (fraction != 0) {
        // To check if the discarded fraction >= 0.5
        compRem = compareForRounding(fraction, sizeOfFraction);
        // To look if there is a carry
        integer += roundingBehavior(((int) integer) & 1, Long.signum(fraction) * (5 + compRem), mc.getRoundingMode());
        // If after to add the increment the precision changed, we normalize the size
        if (Math.log10(Math.abs(integer)) >= mc.getPrecision()) {
            integer /= 10;
            newScale--;
        }
    }
    // To update all internal fields
    scale = safeLongToInt(newScale);
    precision = mc.getPrecision();
    smallValue = integer;
    bitLength = bitLength(integer);
    intVal = null;
}
#end_block

#method_before
public void testOverlay1Content() throws Exception {
    File project = buildProject("overlay1", BasePlugin.GRADLE_TEST_VERSION);
    File drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "type_overlay.png", GREEN);
}
#method_after
public void testOverlay1Content() throws Exception {
    File project = buildProject(FOLDER_TEST_REGULAR, "overlay1", BasePlugin.GRADLE_TEST_VERSION);
    File drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "type_overlay.png", GREEN);
}
#end_block

#method_before
public void testOverlay2Content() throws Exception {
    File project = buildProject("overlay2", BasePlugin.GRADLE_TEST_VERSION);
    File drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/one/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "type_overlay.png", GREEN);
    checkImageColor(drawableOutput, "flavor_overlay.png", GREEN);
    checkImageColor(drawableOutput, "type_flavor_overlay.png", GREEN);
    checkImageColor(drawableOutput, "variant_type_flavor_overlay.png", GREEN);
}
#method_after
public void testOverlay2Content() throws Exception {
    File project = buildProject(FOLDER_TEST_REGULAR, "overlay2", BasePlugin.GRADLE_TEST_VERSION);
    File drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/one/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "type_overlay.png", GREEN);
    checkImageColor(drawableOutput, "flavor_overlay.png", GREEN);
    checkImageColor(drawableOutput, "type_flavor_overlay.png", GREEN);
    checkImageColor(drawableOutput, "variant_type_flavor_overlay.png", GREEN);
}
#end_block

#method_before
public void testOverlay3Content() throws Exception {
    File project = buildProject("overlay3", BasePlugin.GRADLE_TEST_VERSION);
    File drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/freebeta/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "beta_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_beta_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_beta_debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_normal_overlay.png", RED);
    drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/freenormal/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "beta_overlay.png", RED);
    checkImageColor(drawableOutput, "free_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_beta_overlay.png", RED);
    checkImageColor(drawableOutput, "free_beta_debug_overlay.png", RED);
    checkImageColor(drawableOutput, "free_normal_overlay.png", GREEN);
    drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/paidbeta/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "beta_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_overlay.png", RED);
    checkImageColor(drawableOutput, "free_beta_overlay.png", RED);
    checkImageColor(drawableOutput, "free_beta_debug_overlay.png", RED);
    checkImageColor(drawableOutput, "free_normal_overlay.png", RED);
}
#method_after
public void testOverlay3Content() throws Exception {
    File project = buildProject(FOLDER_TEST_REGULAR, "overlay3", BasePlugin.GRADLE_TEST_VERSION);
    File drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/freebeta/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "beta_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_beta_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_beta_debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_normal_overlay.png", RED);
    drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/freenormal/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "beta_overlay.png", RED);
    checkImageColor(drawableOutput, "free_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_beta_overlay.png", RED);
    checkImageColor(drawableOutput, "free_beta_debug_overlay.png", RED);
    checkImageColor(drawableOutput, "free_normal_overlay.png", GREEN);
    drawableOutput = new File(project, "build/" + FD_INTERMEDIATES + "/res/paidbeta/debug/drawable");
    checkImageColor(drawableOutput, "no_overlay.png", GREEN);
    checkImageColor(drawableOutput, "debug_overlay.png", GREEN);
    checkImageColor(drawableOutput, "beta_overlay.png", GREEN);
    checkImageColor(drawableOutput, "free_overlay.png", RED);
    checkImageColor(drawableOutput, "free_beta_overlay.png", RED);
    checkImageColor(drawableOutput, "free_beta_debug_overlay.png", RED);
    checkImageColor(drawableOutput, "free_normal_overlay.png", RED);
}
#end_block

#method_before
public void testRepo() {
    File repo = new File(testDir, "repo");
    try {
        runTasksOn(new File(repo, "util"), BasePlugin.GRADLE_TEST_VERSION, "clean", "uploadArchives");
        runTasksOn(new File(repo, "baseLibrary"), BasePlugin.GRADLE_TEST_VERSION, "clean", "uploadArchives");
        runTasksOn(new File(repo, "library"), BasePlugin.GRADLE_TEST_VERSION, "clean", "uploadArchives");
        runTasksOn(new File(repo, "app"), BasePlugin.GRADLE_TEST_VERSION, "clean", "assemble");
    } finally {
        // clean up the test repository.
        File testRepo = new File(repo, "testrepo");
        deleteFolder(testRepo);
    }
}
#method_after
public void testRepo() {
    File repo = new File(manualDir, "repo");
    try {
        runTasksOn(new File(repo, "util"), BasePlugin.GRADLE_TEST_VERSION, "clean", "uploadArchives");
        runTasksOn(new File(repo, "baseLibrary"), BasePlugin.GRADLE_TEST_VERSION, "clean", "uploadArchives");
        runTasksOn(new File(repo, "library"), BasePlugin.GRADLE_TEST_VERSION, "clean", "uploadArchives");
        runTasksOn(new File(repo, "app"), BasePlugin.GRADLE_TEST_VERSION, "clean", "assemble");
    } finally {
        // clean up the test repository.
        File testRepo = new File(repo, "testrepo");
        deleteFolder(testRepo);
    }
}
#end_block

#method_before
public void testLibsManifestMerging() throws Exception {
    File project = new File(testDir, "libsTest");
    File fileOutput = new File(project, "libapp/build/" + FD_INTERMEDIATES + "/bundles/release/AndroidManifest.xml");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "build");
    assertTrue(fileOutput.exists());
}
#method_after
public void testLibsManifestMerging() throws Exception {
    File project = new File(regularDir, "libsTest");
    File fileOutput = new File(project, "libapp/build/" + FD_INTERMEDIATES + "/bundles/release/AndroidManifest.xml");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "build");
    assertTrue(fileOutput.exists());
}
#end_block

#method_before
public void testLibProguardConsumerFile() throws Exception {
    File project = new File(testDir, "libProguardConsumerFiles");
    File debugFileOutput = new File(project, "build/" + FD_INTERMEDIATES + "/bundles/debug");
    File releaseFileOutput = new File(project, "build/" + FD_INTERMEDIATES + "/bundles/release");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "build");
    checkFile(debugFileOutput, "proguard.txt", new String[] { "A" });
    checkFile(releaseFileOutput, "proguard.txt", new String[] { "A", "B", "C" });
}
#method_after
public void testLibProguardConsumerFile() throws Exception {
    File project = new File(regularDir, "libProguardConsumerFiles");
    File debugFileOutput = new File(project, "build/" + FD_INTERMEDIATES + "/bundles/debug");
    File releaseFileOutput = new File(project, "build/" + FD_INTERMEDIATES + "/bundles/release");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "build");
    checkFile(debugFileOutput, "proguard.txt", new String[] { "A" });
    checkFile(releaseFileOutput, "proguard.txt", new String[] { "A", "B", "C" });
}
#end_block

#method_before
public void testShrinkResources() throws Exception {
    File project = new File(testDir, "shrink");
    File output = new File(project, "build/" + FD_OUTPUTS);
    File intermediates = new File(project, "build/" + FD_INTERMEDIATES);
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleRelease", "assembleDebug", "assembleProguardNoShrink");
    // The release target has shrinking enabled.
    // The proguardNoShrink target has proguard but no shrinking enabled.
    // The debug target has neither proguard nor shrinking enabled.
    File apkRelease = new File(output, "apk" + separator + "shrink-release-unsigned.apk");
    File apkDebug = new File(output, "apk" + separator + "shrink-debug.apk");
    File apkProguardOnly = new File(output, "apk" + separator + "shrink-proguardNoShrink-unsigned.apk");
    assertTrue(apkDebug + " is not a file", apkDebug.isFile());
    assertTrue(apkRelease + " is not a file", apkRelease.isFile());
    assertTrue(apkProguardOnly + " is not a file", apkProguardOnly.isFile());
    File compressed = new File(intermediates, "res" + separator + "resources-release-compressed.ap_");
    File uncompressed = new File(intermediates, "res" + separator + "resources-release.ap_");
    assertTrue(compressed + " is not a file", compressed.isFile());
    assertTrue(uncompressed + " is not a file", uncompressed.isFile());
    // Check that there is no shrinking in the other two targets:
    assertTrue(new File(intermediates, "res" + separator + "resources-debug.ap_").exists());
    assertFalse(new File(intermediates, "res" + separator + "resources-debug-compressed.ap_").exists());
    assertTrue(new File(intermediates, "res" + separator + "resources-proguardNoShrink.ap_").exists());
    assertFalse(new File(intermediates, "res" + separator + "resources-proguardNoShrink-compressed.ap_").exists());
    String expectedUnstrippedApk = "" + "AndroidManifest.xml\n" + "classes.dex\n" + "resources.arsc\n" + "res/layout/unused1.xml\n" + "res/layout/unused2.xml\n" + "res/drawable/unused9.xml\n" + "res/drawable/unused10.xml\n" + "res/drawable/unused11.xml\n" + "res/menu/unused12.xml\n" + "res/layout/unused13.xml\n" + "res/layout/used1.xml\n" + "res/layout/used2.xml\n" + "res/layout/used3.xml\n" + "res/layout/used4.xml\n" + "res/layout/used5.xml\n" + "res/layout/used6.xml\n" + "res/layout/used7.xml\n" + "res/layout/used8.xml\n" + "res/drawable/used9.xml\n" + "res/drawable/used10.xml\n" + "res/drawable/used11.xml\n" + "res/drawable/used12.xml\n" + "res/menu/used13.xml\n" + "res/layout/used14.xml";
    String expectedStrippedApkContents = "" + "AndroidManifest.xml\n" + "classes.dex\n" + "resources.arsc\n" + "res/layout/used1.xml\n" + "res/layout/used2.xml\n" + "res/layout/used3.xml\n" + "res/layout/used4.xml\n" + "res/layout/used5.xml\n" + "res/layout/used6.xml\n" + "res/layout/used7.xml\n" + "res/layout/used8.xml\n" + "res/drawable/used9.xml\n" + "res/drawable/used10.xml\n" + "res/drawable/used11.xml\n" + "res/drawable/used12.xml\n" + "res/menu/used13.xml\n" + "res/layout/used14.xml";
    // Should not have any unused resources in the compressed list
    assertFalse(expectedStrippedApkContents, expectedStrippedApkContents.contains("unused"));
    // Should have *all* the used resources, currently 1-14
    for (int i = 1; i <= 14; i++) {
        assertTrue("Missing used" + i + " in " + expectedStrippedApkContents, expectedStrippedApkContents.contains("/used" + i + "."));
    }
    // Check that the uncompressed resources (.ap_) for the release target have everything
    // we expect
    String expectedUncompressed = expectedUnstrippedApk.replace("classes.dex\n", "");
    assertEquals(expectedUncompressed, dumpZipContents(uncompressed).trim());
    // The debug target should have everything there in the APK
    assertEquals(expectedUnstrippedApk, dumpZipContents(apkDebug));
    assertEquals(expectedUnstrippedApk, dumpZipContents(apkProguardOnly));
    // Check the compressed .ap_:
    String actualCompressed = dumpZipContents(compressed);
    String expectedCompressed = expectedStrippedApkContents.replace("classes.dex\n", "");
    assertEquals(expectedCompressed, actualCompressed);
    assertFalse(expectedCompressed, expectedCompressed.contains("unused"));
    assertEquals(expectedStrippedApkContents, dumpZipContents(apkRelease));
}
#method_after
public void testShrinkResources() throws Exception {
    File project = new File(manualDir, "shrink");
    File output = new File(project, "build/" + FD_OUTPUTS);
    File intermediates = new File(project, "build/" + FD_INTERMEDIATES);
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleRelease", "assembleDebug", "assembleProguardNoShrink");
    // The release target has shrinking enabled.
    // The proguardNoShrink target has proguard but no shrinking enabled.
    // The debug target has neither proguard nor shrinking enabled.
    File apkRelease = new File(output, "apk" + separator + "shrink-release-unsigned.apk");
    File apkDebug = new File(output, "apk" + separator + "shrink-debug.apk");
    File apkProguardOnly = new File(output, "apk" + separator + "shrink-proguardNoShrink-unsigned.apk");
    assertTrue(apkDebug + " is not a file", apkDebug.isFile());
    assertTrue(apkRelease + " is not a file", apkRelease.isFile());
    assertTrue(apkProguardOnly + " is not a file", apkProguardOnly.isFile());
    File compressed = new File(intermediates, "res" + separator + "resources-release-stripped.ap_");
    File uncompressed = new File(intermediates, "res" + separator + "resources-release.ap_");
    assertTrue(compressed + " is not a file", compressed.isFile());
    assertTrue(uncompressed + " is not a file", uncompressed.isFile());
    // Check that there is no shrinking in the other two targets:
    assertTrue(new File(intermediates, "res" + separator + "resources-debug.ap_").exists());
    assertFalse(new File(intermediates, "res" + separator + "resources-debug-stripped.ap_").exists());
    assertTrue(new File(intermediates, "res" + separator + "resources-proguardNoShrink.ap_").exists());
    assertFalse(new File(intermediates, "res" + separator + "resources-proguardNoShrink-stripped.ap_").exists());
    String expectedUnstrippedApk = "" + "AndroidManifest.xml\n" + "classes.dex\n" + "resources.arsc\n" + "res/layout/unused1.xml\n" + "res/layout/unused2.xml\n" + "res/drawable/unused9.xml\n" + "res/drawable/unused10.xml\n" + "res/drawable/unused11.xml\n" + "res/menu/unused12.xml\n" + "res/layout/unused13.xml\n" + "res/layout/used1.xml\n" + "res/layout/used2.xml\n" + "res/layout/used3.xml\n" + "res/layout/used4.xml\n" + "res/layout/used5.xml\n" + "res/layout/used6.xml\n" + "res/layout/used7.xml\n" + "res/layout/used8.xml\n" + "res/drawable/used9.xml\n" + "res/drawable/used10.xml\n" + "res/drawable/used11.xml\n" + "res/drawable/used12.xml\n" + "res/menu/used13.xml\n" + "res/layout/used14.xml";
    String expectedStrippedApkContents = "" + "AndroidManifest.xml\n" + "classes.dex\n" + "resources.arsc\n" + "res/layout/used1.xml\n" + "res/layout/used2.xml\n" + "res/layout/used3.xml\n" + "res/layout/used4.xml\n" + "res/layout/used5.xml\n" + "res/layout/used6.xml\n" + "res/layout/used7.xml\n" + "res/layout/used8.xml\n" + "res/drawable/used9.xml\n" + "res/drawable/used10.xml\n" + "res/drawable/used11.xml\n" + "res/drawable/used12.xml\n" + "res/menu/used13.xml\n" + "res/layout/used14.xml";
    // Should not have any unused resources in the compressed list
    assertFalse(expectedStrippedApkContents, expectedStrippedApkContents.contains("unused"));
    // Should have *all* the used resources, currently 1-14
    for (int i = 1; i <= 14; i++) {
        assertTrue("Missing used" + i + " in " + expectedStrippedApkContents, expectedStrippedApkContents.contains("/used" + i + "."));
    }
    // Check that the uncompressed resources (.ap_) for the release target have everything
    // we expect
    String expectedUncompressed = expectedUnstrippedApk.replace("classes.dex\n", "");
    assertEquals(expectedUncompressed, dumpZipContents(uncompressed).trim());
    // The debug target should have everything there in the APK
    assertEquals(expectedUnstrippedApk, dumpZipContents(apkDebug));
    assertEquals(expectedUnstrippedApk, dumpZipContents(apkProguardOnly));
    // Check the compressed .ap_:
    String actualCompressed = dumpZipContents(compressed);
    String expectedCompressed = expectedStrippedApkContents.replace("classes.dex\n", "");
    assertEquals(expectedCompressed, actualCompressed);
    assertFalse(expectedCompressed, expectedCompressed.contains("unused"));
    assertEquals(expectedStrippedApkContents, dumpZipContents(apkRelease));
}
#end_block

#method_before
public void testAnnotations() throws Exception {
    File project = new File(testDir, "extractAnnotations");
    File debugFileOutput = new File(project, "build/" + FD_INTERMEDIATES + "/annotations/debug");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    File file = new File(debugFileOutput, "annotations.zip");
    Map<String, String> map = Maps.newHashMap();
    // noinspection SpellCheckingInspection
    map.put("com/android/tests/extractannotations/annotations.xml", "" + "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<root>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest ExtractTest(int, java.lang.String) 0\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + // This item should be removed when I start supporting @hide
    "  <item name=\"com.android.tests.extractannotations.ExtractTest int getHiddenMethod()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + // This item should be removed when I start supporting @hide
    "  <item name=\"com.android.tests.extractannotations.ExtractTest int getPrivate()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int getVisibility()\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.ExtractTest.VISIBLE, com.android.tests.extractannotations.ExtractTest.INVISIBLE, com.android.tests.extractannotations.ExtractTest.GONE, 5, 17, com.android.tests.extractannotations.Constants.CONSTANT_1}\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int resourceTypeMethod(int, int)\">\n" + "    <annotation name=\"android.support.annotation.StringRes\" />\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int resourceTypeMethod(int, int) 0\">\n" + "    <annotation name=\"android.support.annotation.DrawableRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int resourceTypeMethod(int, int) 1\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "    <annotation name=\"android.support.annotation.ColorRes\" />\n" + "  </item>\n" + // This item should be removed when I start supporting @hide
    "  <item name=\"com.android.tests.extractannotations.ExtractTest java.lang.Object getPackagePrivate()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest java.lang.String getStringMode(int)\">\n" + "    <annotation name=\"android.support.annotation.StringDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.ExtractTest.STRING_1, com.android.tests.extractannotations.ExtractTest.STRING_2, &quot;literalValue&quot;, &quot;concatenated&quot;}\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest java.lang.String getStringMode(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.ExtractTest.VISIBLE, com.android.tests.extractannotations.ExtractTest.INVISIBLE, com.android.tests.extractannotations.ExtractTest.GONE, 5, 17, com.android.tests.extractannotations.Constants.CONSTANT_1}\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void checkForeignTypeDef(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.Constants.CONSTANT_1, com.android.tests.extractannotations.Constants.CONSTANT_2}\" />\n" + "      <val name=\"flag\" val=\"true\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void resourceTypeMethodWithTypeArgs(java.util.Map&lt;java.lang.String,? extends java.lang.Number&gt;, T, int) 0\">\n" + "    <annotation name=\"android.support.annotation.StringRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void resourceTypeMethodWithTypeArgs(java.util.Map&lt;java.lang.String,? extends java.lang.Number&gt;, T, int) 1\">\n" + "    <annotation name=\"android.support.annotation.DrawableRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void resourceTypeMethodWithTypeArgs(java.util.Map&lt;java.lang.String,? extends java.lang.Number&gt;, T, int) 2\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void testMask(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{0, com.android.tests.extractannotations.Constants.FLAG_VALUE_1, com.android.tests.extractannotations.Constants.FLAG_VALUE_2}\" />\n" + "      <val name=\"flag\" val=\"true\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void testNonMask(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{0, com.android.tests.extractannotations.Constants.CONSTANT_1, com.android.tests.extractannotations.Constants.CONSTANT_3}\" />\n" + "    </annotation>\n" + "  </item>\n" + // This should be hidden when we start filtering out hidden classes on @hide!
    "  <item name=\"com.android.tests.extractannotations.ExtractTest.HiddenClass int getHiddenMember()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "</root>");
    checkJar(file, map);
    // check the resulting .aar file to ensure annotations.zip inclusion.
    File archiveFile = new File(project, "build/outputs/aar/extractAnnotations-debug.aar");
    assertTrue(archiveFile.isFile());
    ZipFile archive = null;
    try {
        archive = new ZipFile(archiveFile);
        ZipEntry entry = archive.getEntry("annotations.zip");
        assertNotNull(entry);
    } finally {
        if (archive != null) {
            archive.close();
        }
    }
}
#method_after
public void testAnnotations() throws Exception {
    File project = new File(regularDir, "extractAnnotations");
    File debugFileOutput = new File(project, "build/" + FD_INTERMEDIATES + "/annotations/debug");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    File file = new File(debugFileOutput, "annotations.zip");
    Map<String, String> map = Maps.newHashMap();
    // noinspection SpellCheckingInspection
    map.put("com/android/tests/extractannotations/annotations.xml", "" + "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<root>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest ExtractTest(int, java.lang.String) 0\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + // This item should be removed when I start supporting @hide
    "  <item name=\"com.android.tests.extractannotations.ExtractTest int getHiddenMethod()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + // This item should be removed when I start supporting @hide
    "  <item name=\"com.android.tests.extractannotations.ExtractTest int getPrivate()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int getVisibility()\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.ExtractTest.VISIBLE, com.android.tests.extractannotations.ExtractTest.INVISIBLE, com.android.tests.extractannotations.ExtractTest.GONE, 5, 17, com.android.tests.extractannotations.Constants.CONSTANT_1}\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int resourceTypeMethod(int, int)\">\n" + "    <annotation name=\"android.support.annotation.StringRes\" />\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int resourceTypeMethod(int, int) 0\">\n" + "    <annotation name=\"android.support.annotation.DrawableRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest int resourceTypeMethod(int, int) 1\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "    <annotation name=\"android.support.annotation.ColorRes\" />\n" + "  </item>\n" + // This item should be removed when I start supporting @hide
    "  <item name=\"com.android.tests.extractannotations.ExtractTest java.lang.Object getPackagePrivate()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest java.lang.String getStringMode(int)\">\n" + "    <annotation name=\"android.support.annotation.StringDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.ExtractTest.STRING_1, com.android.tests.extractannotations.ExtractTest.STRING_2, &quot;literalValue&quot;, &quot;concatenated&quot;}\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest java.lang.String getStringMode(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.ExtractTest.VISIBLE, com.android.tests.extractannotations.ExtractTest.INVISIBLE, com.android.tests.extractannotations.ExtractTest.GONE, 5, 17, com.android.tests.extractannotations.Constants.CONSTANT_1}\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void checkForeignTypeDef(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{com.android.tests.extractannotations.Constants.CONSTANT_1, com.android.tests.extractannotations.Constants.CONSTANT_2}\" />\n" + "      <val name=\"flag\" val=\"true\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void resourceTypeMethodWithTypeArgs(java.util.Map&lt;java.lang.String,? extends java.lang.Number&gt;, T, int) 0\">\n" + "    <annotation name=\"android.support.annotation.StringRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void resourceTypeMethodWithTypeArgs(java.util.Map&lt;java.lang.String,? extends java.lang.Number&gt;, T, int) 1\">\n" + "    <annotation name=\"android.support.annotation.DrawableRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void resourceTypeMethodWithTypeArgs(java.util.Map&lt;java.lang.String,? extends java.lang.Number&gt;, T, int) 2\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void testMask(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{0, com.android.tests.extractannotations.Constants.FLAG_VALUE_1, com.android.tests.extractannotations.Constants.FLAG_VALUE_2}\" />\n" + "      <val name=\"flag\" val=\"true\" />\n" + "    </annotation>\n" + "  </item>\n" + "  <item name=\"com.android.tests.extractannotations.ExtractTest void testNonMask(int) 0\">\n" + "    <annotation name=\"android.support.annotation.IntDef\">\n" + "      <val name=\"value\" val=\"{0, com.android.tests.extractannotations.Constants.CONSTANT_1, com.android.tests.extractannotations.Constants.CONSTANT_3}\" />\n" + "    </annotation>\n" + "  </item>\n" + // This should be hidden when we start filtering out hidden classes on @hide!
    "  <item name=\"com.android.tests.extractannotations.ExtractTest.HiddenClass int getHiddenMember()\">\n" + "    <annotation name=\"android.support.annotation.IdRes\" />\n" + "  </item>\n" + "</root>");
    checkJar(file, map);
    // check the resulting .aar file to ensure annotations.zip inclusion.
    File archiveFile = new File(project, "build/outputs/aar/extractAnnotations-debug.aar");
    assertTrue(archiveFile.isFile());
    ZipFile archive = null;
    try {
        archive = new ZipFile(archiveFile);
        ZipEntry entry = archive.getEntry("annotations.zip");
        assertNotNull(entry);
    } finally {
        if (archive != null) {
            archive.close();
        }
    }
}
#end_block

#method_before
public void testRsEnabledAnnotations() throws IOException {
    File project = new File(testDir, "extractRsEnabledAnnotations");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    // check the resulting .aar file to ensure annotations.zip inclusion.
    File archiveFile = new File(project, "build/outputs/aar/extractRsEnabledAnnotations-debug.aar");
    assertTrue(archiveFile.isFile());
    ZipFile archive = null;
    try {
        archive = new ZipFile(archiveFile);
        ZipEntry entry = archive.getEntry("annotations.zip");
        assertNotNull(entry);
    } finally {
        if (archive != null) {
            archive.close();
        }
    }
}
#method_after
public void testRsEnabledAnnotations() throws IOException {
    File project = new File(regularDir, "extractRsEnabledAnnotations");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    // check the resulting .aar file to ensure annotations.zip inclusion.
    File archiveFile = new File(project, "build/outputs/aar/extractRsEnabledAnnotations-debug.aar");
    assertTrue(archiveFile.isFile());
    ZipFile archive = null;
    try {
        archive = new ZipFile(archiveFile);
        ZipEntry entry = archive.getEntry("annotations.zip");
        assertNotNull(entry);
    } finally {
        if (archive != null) {
            archive.close();
        }
    }
}
#end_block

#method_before
public void testSimpleManifestMerger() throws IOException {
    File project = new File(testDir, "simpleManifestMergingTask");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "manifestMerger");
}
#method_after
public void testSimpleManifestMerger() throws IOException {
    File project = new File(manualDir, "simpleManifestMergingTask");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "manifestMerger");
}
#end_block

#method_before
public void test3rdPartyTests() throws Exception {
    // custom because we want to run deviceCheck even without devices, since we use
    // a fake DeviceProvider that doesn't use a device, but only record the calls made
    // to the DeviceProvider and the DeviceConnector.
    runTasksOn(new File(testDir, "3rdPartyTests"), BasePlugin.GRADLE_TEST_VERSION, "clean", "deviceCheck");
}
#method_after
public void test3rdPartyTests() throws Exception {
    // custom because we want to run deviceCheck even without devices, since we use
    // a fake DeviceProvider that doesn't use a device, but only record the calls made
    // to the DeviceProvider and the DeviceConnector.
    runTasksOn(new File(manualDir, "3rdPartyTests"), BasePlugin.GRADLE_TEST_VERSION, "clean", "deviceCheck");
}
#end_block

#method_before
public void testEmbedded() throws Exception {
    File project = new File(testDir, "embedded");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", ":main:assembleRelease");
    File mainApk = new File(project, "main/build/" + FD_OUTPUTS + "/apk/main-release-unsigned.apk");
    checkJar(mainApk, Collections.<String, String>singletonMap(FD_RES + '/' + FD_RES_RAW + '/' + ANDROID_WEAR_MICRO_APK + DOT_ANDROID_PACKAGE, null));
}
#method_after
public void testEmbedded() throws Exception {
    File project = new File(regularDir, "embedded");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", ":main:assembleRelease");
    File mainApk = new File(project, "main/build/" + FD_OUTPUTS + "/apk/main-release-unsigned.apk");
    checkJar(mainApk, Collections.<String, String>singletonMap(FD_RES + '/' + FD_RES_RAW + '/' + ANDROID_WEAR_MICRO_APK + DOT_ANDROID_PACKAGE, null));
}
#end_block

#method_before
public void testUserProvidedTestAndroidManifest() throws Exception {
    File project = new File(testDir, "androidManifestInTest");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebugTest");
    File testApk = new File(project, "build/" + FD_OUTPUTS + "/apk/androidManifestInTest-debug-test-unaligned.apk");
    File aapt = new File(sdkDir, "build-tools/19.1.0/aapt");
    assertTrue("Test requires build-tools 19.1.0", aapt.isFile());
    String[] command = new String[4];
    command[0] = aapt.getPath();
    command[1] = "l";
    command[2] = "-a";
    command[3] = testApk.getPath();
    CommandLineRunner commandLineRunner = new CommandLineRunner(new StdLogger(StdLogger.Level.ERROR));
    final List<String> aaptOutput = Lists.newArrayList();
    commandLineRunner.runCmdLine(command, new CommandLineRunner.CommandLineOutput() {

        @Override
        public void out(@Nullable String line) {
            if (line != null) {
                aaptOutput.add(line);
            }
        }

        @Override
        public void err(@Nullable String line) {
            super.err(line);
        }
    }, null);
    System.out.println("Beginning dump");
    boolean foundPermission = false;
    boolean foundMetadata = false;
    for (String line : aaptOutput) {
        if (line.contains("foo.permission-group.COST_MONEY")) {
            foundPermission = true;
        }
        if (line.contains("meta-data")) {
            foundMetadata = true;
        }
    }
    if (!foundPermission) {
        fail("Could not find user-specified permission group.");
    }
    if (!foundMetadata) {
        fail("Could not find meta-data under instrumentation ");
    }
}
#method_after
public void testUserProvidedTestAndroidManifest() throws Exception {
    File project = new File(regularDir, "androidManifestInTest");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebugTest");
    File testApk = new File(project, "build/" + FD_OUTPUTS + "/apk/androidManifestInTest-debug-test-unaligned.apk");
    File aapt = new File(sdkDir, "build-tools/19.1.0/aapt");
    assertTrue("Test requires build-tools 19.1.0", aapt.isFile());
    String[] command = new String[4];
    command[0] = aapt.getPath();
    command[1] = "l";
    command[2] = "-a";
    command[3] = testApk.getPath();
    CommandLineRunner commandLineRunner = new CommandLineRunner(new StdLogger(StdLogger.Level.ERROR));
    final List<String> aaptOutput = Lists.newArrayList();
    commandLineRunner.runCmdLine(command, new CommandLineRunner.CommandLineOutput() {

        @Override
        public void out(@Nullable String line) {
            if (line != null) {
                aaptOutput.add(line);
            }
        }

        @Override
        public void err(@Nullable String line) {
            super.err(line);
        }
    }, null);
    System.out.println("Beginning dump");
    boolean foundPermission = false;
    boolean foundMetadata = false;
    for (String line : aaptOutput) {
        if (line.contains("foo.permission-group.COST_MONEY")) {
            foundPermission = true;
        }
        if (line.contains("meta-data")) {
            foundMetadata = true;
        }
    }
    if (!foundPermission) {
        fail("Could not find user-specified permission group.");
    }
    if (!foundMetadata) {
        fail("Could not find meta-data under instrumentation ");
    }
}
#end_block

#method_before
public void testDensitySplits() throws Exception {
    File project = new File(testDir, "densitySplit");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    Map<String, Integer> expected = Maps.newHashMapWithExpectedSize(5);
    expected.put("universal", 112);
    expected.put("mdpi", 212);
    expected.put("hdpi", 312);
    expected.put("xhdpi", 412);
    expected.put("xxhdpi", 512);
    checkVersionCode(project, null, expected, "densitySplit");
}
#method_after
public void testDensitySplits() throws Exception {
    File project = new File(regularDir, "densitySplit");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    Map<String, Integer> expected = Maps.newHashMapWithExpectedSize(5);
    expected.put("universal", 112);
    expected.put("mdpi", 212);
    expected.put("hdpi", 312);
    expected.put("xhdpi", 412);
    expected.put("xxhdpi", 512);
    checkVersionCode(project, null, expected, "densitySplit");
}
#end_block

#method_before
public void testAbiSplits() throws Exception {
    File project = new File(testDir, "ndkJniLib");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "app:assembleDebug");
    Map<String, Integer> expected = Maps.newHashMapWithExpectedSize(5);
    expected.put("gingerbread-universal", 1000123);
    expected.put("gingerbread-armeabi-v7a", 1100123);
    expected.put("gingerbread-mips", 1200123);
    expected.put("gingerbread-x86", 1300123);
    expected.put("icecreamSandwich-universal", 2000123);
    expected.put("icecreamSandwich-armeabi-v7a", 2100123);
    expected.put("icecreamSandwich-mips", 2200123);
    expected.put("icecreamSandwich-x86", 2300123);
    checkVersionCode(project, "app/", expected, "app");
}
#method_after
public void testAbiSplits() throws Exception {
    File project = new File(regularDir, "ndkJniLib");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "app:assembleDebug");
    Map<String, Integer> expected = Maps.newHashMapWithExpectedSize(5);
    expected.put("gingerbread-universal", 1000123);
    expected.put("gingerbread-armeabi-v7a", 1100123);
    expected.put("gingerbread-mips", 1200123);
    expected.put("gingerbread-x86", 1300123);
    expected.put("icecreamSandwich-universal", 2000123);
    expected.put("icecreamSandwich-armeabi-v7a", 2100123);
    expected.put("icecreamSandwich-mips", 2200123);
    expected.put("icecreamSandwich-x86", 2300123);
    checkVersionCode(project, "app/", expected, "app");
}
#end_block

#method_before
public void testBasicWithSigningOverride() throws Exception {
    File project = new File(testDir, "basic");
    // add prop args for signing override.
    List<String> args = Lists.newArrayListWithExpectedSize(4);
    args.add("-P" + PROPERTY_SIGNING_STORE_FILE + "=" + new File(project, "debug.keystore").getPath());
    args.add("-P" + PROPERTY_SIGNING_STORE_PASSWORD + "=android");
    args.add("-P" + PROPERTY_SIGNING_KEY_ALIAS + "=AndroidDebugKey");
    args.add("-P" + PROPERTY_SIGNING_KEY_PASSWORD + "=android");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, args, "clean", ":assembleRelease");
    // check that the output exist. Since the filename is tried to signing/zipaligning
    // this gives us a fairly good idea about signing already.
    File releaseApk = new File(project, "build/" + FD_OUTPUTS + "/apk/basic-release.apk");
    assertTrue(releaseApk.isFile());
    // now check for signing file inside the archive.
    checkJar(releaseApk, Collections.<String, String>singletonMap("META-INF/CERT.RSA", null));
}
#method_after
public void testBasicWithSigningOverride() throws Exception {
    File project = new File(regularDir, "basic");
    // add prop args for signing override.
    List<String> args = Lists.newArrayListWithExpectedSize(4);
    args.add("-P" + PROPERTY_SIGNING_STORE_FILE + "=" + new File(project, "debug.keystore").getPath());
    args.add("-P" + PROPERTY_SIGNING_STORE_PASSWORD + "=android");
    args.add("-P" + PROPERTY_SIGNING_KEY_ALIAS + "=AndroidDebugKey");
    args.add("-P" + PROPERTY_SIGNING_KEY_PASSWORD + "=android");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, args, Collections.<String, String>emptyMap(), "clean", ":assembleRelease");
    // check that the output exist. Since the filename is tried to signing/zipaligning
    // this gives us a fairly good idea about signing already.
    File releaseApk = new File(project, "build/" + FD_OUTPUTS + "/apk/basic-release.apk");
    assertTrue(releaseApk.isFile());
    // now check for signing file inside the archive.
    checkJar(releaseApk, Collections.<String, String>singletonMap("META-INF/CERT.RSA", null));
}
#end_block

#method_before
public void testMaxSdkVersion() throws Exception {
    File project = new File(testDir, "maxSdkVersion");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    checkMaxSdkVersion(new File(project, "build/" + FD_OUTPUTS + "/apk/maxSdkVersion-f1-debug.apk"), "21");
    checkMaxSdkVersion(new File(project, "build/" + FD_OUTPUTS + "/apk/maxSdkVersion-f2-debug.apk"), "19");
}
#method_after
public void testMaxSdkVersion() throws Exception {
    File project = new File(regularDir, "maxSdkVersion");
    runTasksOn(project, BasePlugin.GRADLE_TEST_VERSION, "clean", "assembleDebug");
    checkMaxSdkVersion(new File(project, "build/" + FD_OUTPUTS + "/apk/maxSdkVersion-f1-debug.apk"), "21");
    checkMaxSdkVersion(new File(project, "build/" + FD_OUTPUTS + "/apk/maxSdkVersion-f2-debug.apk"), "19");
}
#end_block

#method_before
@NonNull
public List<String> getBootClasspath() {
    checkState(mTargetInfo != null, "Cannot call getBootClasspath() before setTargetInfo() is called.");
    List<String> classpath = Lists.newArrayList();
    IAndroidTarget target = mTargetInfo.getTarget();
    classpath.addAll(target.getBootClasspath());
    // add optional libraries if any
    IAndroidTarget.IOptionalLibrary[] libs = target.getOptionalLibraries();
    if (libs != null) {
        for (IAndroidTarget.IOptionalLibrary lib : libs) {
            classpath.add(lib.getJarPath());
        }
    }
    // add annotations.jar if needed.
    if (target.getVersion().getApiLevel() <= 15) {
        classpath.add(mSdkInfo.getAnnotationsJar().getPath());
    }
    return classpath;
}
#method_after
@NonNull
public List<File> getBootClasspath() {
    checkState(mTargetInfo != null, "Cannot call getBootClasspath() before setTargetInfo() is called.");
    List<File> classpath = Lists.newArrayList();
    IAndroidTarget target = mTargetInfo.getTarget();
    for (String p : target.getBootClasspath()) {
        classpath.add(new File(p));
    }
    // add optional libraries if any
    IAndroidTarget.IOptionalLibrary[] libs = target.getOptionalLibraries();
    if (libs != null) {
        for (IAndroidTarget.IOptionalLibrary lib : libs) {
            classpath.add(new File(lib.getJarPath()));
        }
    }
    // add annotations.jar if needed.
    if (target.getVersion().getApiLevel() <= 15) {
        classpath.add(mSdkInfo.getAnnotationsJar());
    }
    return classpath;
}
#end_block

#method_before
@NonNull
public Set<File> getCompileClasspath(@NonNull VariantConfiguration variantConfiguration) {
    Set<File> compileClasspath = variantConfiguration.getCompileClasspath();
    ProductFlavor mergedFlavor = variantConfiguration.getMergedFlavor();
    if (mergedFlavor.getRenderscriptSupportMode()) {
        File renderScriptSupportJar = getRenderScriptSupportJar();
        Set<File> fullJars = Sets.newHashSetWithExpectedSize(compileClasspath.size() + 1);
        fullJars.addAll(compileClasspath);
        if (renderScriptSupportJar != null) {
            fullJars.add(renderScriptSupportJar);
        }
        compileClasspath = fullJars;
    }
    return compileClasspath;
}
#method_after
@NonNull
public Set<File> getCompileClasspath(@NonNull VariantConfiguration<?, ?, ?> variantConfiguration) {
    Set<File> compileClasspath = variantConfiguration.getCompileClasspath();
    if (variantConfiguration.getRenderscriptSupportMode()) {
        File renderScriptSupportJar = getRenderScriptSupportJar();
        Set<File> fullJars = Sets.newHashSetWithExpectedSize(compileClasspath.size() + 1);
        fullJars.addAll(compileClasspath);
        if (renderScriptSupportJar != null) {
            fullJars.add(renderScriptSupportJar);
        }
        compileClasspath = fullJars;
    }
    return compileClasspath;
}
#end_block

#method_before
@NonNull
public Set<File> getPackagedJars(@NonNull VariantConfiguration variantConfiguration) {
    Set<File> packagedJars = variantConfiguration.getPackagedJars();
    ProductFlavor mergedFlavor = variantConfiguration.getMergedFlavor();
    if (mergedFlavor.getRenderscriptSupportMode()) {
        File renderScriptSupportJar = getRenderScriptSupportJar();
        Set<File> fullJars = Sets.newHashSetWithExpectedSize(packagedJars.size() + 1);
        fullJars.addAll(packagedJars);
        if (renderScriptSupportJar != null) {
            fullJars.add(renderScriptSupportJar);
        }
        packagedJars = fullJars;
    }
    return packagedJars;
}
#method_after
@NonNull
public Set<File> getPackagedJars(@NonNull VariantConfiguration<?, ?, ?> variantConfiguration) {
    Set<File> packagedJars = Sets.newHashSet(variantConfiguration.getPackagedJars());
    if (variantConfiguration.getRenderscriptSupportMode()) {
        File renderScriptSupportJar = getRenderScriptSupportJar();
        if (renderScriptSupportJar != null) {
            packagedJars.add(renderScriptSupportJar);
        }
    }
    if (variantConfiguration.isLegacyMultiDexMode()) {
        File supportJar = getMultiDexSupportJar();
        if (supportJar != null) {
            packagedJars.add(supportJar);
        }
    }
    return packagedJars;
}
#end_block

#method_before
public void processTestManifest(@NonNull String testApplicationId, @Nullable String minSdkVersion, @Nullable String targetSdkVersion, @NonNull String testedApplicationId, @NonNull String instrumentationRunner, @NonNull Boolean handleProfiling, @NonNull Boolean functionalTest, @NonNull List<? extends ManifestDependency> libraries, @NonNull File outManifest) {
    checkNotNull(testApplicationId, "testApplicationId cannot be null.");
    checkNotNull(testedApplicationId, "testedApplicationId cannot be null.");
    checkNotNull(instrumentationRunner, "instrumentationRunner cannot be null.");
    checkNotNull(handleProfiling, "handleProfiling cannot be null.");
    checkNotNull(functionalTest, "functionalTest cannot be null.");
    checkNotNull(libraries, "libraries cannot be null.");
    checkNotNull(outManifest, "outManifestLocation cannot be null.");
    checkState(mTargetInfo != null, "Cannot call processTestManifest() before setTargetInfo() is called.");
    final IAndroidTarget target = mTargetInfo.getTarget();
    ICallback callback = new ICallback() {

        @Override
        public int queryCodenameApiLevel(@NonNull String codename) {
            if (codename.equals(target.getVersion().getCodename())) {
                return target.getVersion().getApiLevel();
            }
            return ICallback.UNKNOWN_CODENAME;
        }
    };
    if (!libraries.isEmpty()) {
        try {
            // create the test manifest, merge the libraries in it
            File generatedTestManifest = File.createTempFile("manifestMerge", ".xml");
            generateTestManifest(testApplicationId, minSdkVersion, targetSdkVersion, testedApplicationId, instrumentationRunner, handleProfiling, functionalTest, generatedTestManifest);
            mergeLibraryManifests(generatedTestManifest, libraries, outManifest, null, null, callback);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    } else {
        generateTestManifest(testApplicationId, minSdkVersion, targetSdkVersion, testedApplicationId, instrumentationRunner, handleProfiling, functionalTest, outManifest);
    }
}
#method_after
public void processTestManifest(@NonNull String testApplicationId, @Nullable String minSdkVersion, @Nullable String targetSdkVersion, @NonNull String testedApplicationId, @NonNull String instrumentationRunner, @NonNull Boolean handleProfiling, @NonNull Boolean functionalTest, @Nullable File testManifestFile, @NonNull List<? extends ManifestDependency> libraries, @NonNull File outManifest, @NonNull File tmpDir) {
    checkNotNull(testApplicationId, "testApplicationId cannot be null.");
    checkNotNull(testedApplicationId, "testedApplicationId cannot be null.");
    checkNotNull(instrumentationRunner, "instrumentationRunner cannot be null.");
    checkNotNull(handleProfiling, "handleProfiling cannot be null.");
    checkNotNull(functionalTest, "functionalTest cannot be null.");
    checkNotNull(libraries, "libraries cannot be null.");
    checkNotNull(outManifest, "outManifestLocation cannot be null.");
    try {
        tmpDir.mkdirs();
        File generatedTestManifest = libraries.isEmpty() && testManifestFile == null ? outManifest : File.createTempFile("manifestMerger", ".xml", tmpDir);
        mLogger.verbose("Generating in %1$s", generatedTestManifest.getAbsolutePath());
        generateTestManifest(testApplicationId, minSdkVersion, targetSdkVersion.equals("-1") ? null : targetSdkVersion, testedApplicationId, instrumentationRunner, handleProfiling, functionalTest, generatedTestManifest);
        if (testManifestFile != null) {
            File mergedTestManifest = File.createTempFile("manifestMerger", ".xml", tmpDir);
            mLogger.verbose("Merging user supplied manifest in %1$s", generatedTestManifest.getAbsolutePath());
            Invoker invoker = ManifestMerger2.newMerger(testManifestFile, mLogger, ManifestMerger2.MergeType.APPLICATION).setOverride(SystemProperty.PACKAGE, testApplicationId).setPlaceHolderValue(PlaceholderHandler.INSTRUMENTATION_RUNNER, instrumentationRunner).addLibraryManifests(generatedTestManifest);
            if (minSdkVersion != null) {
                invoker.setOverride(SystemProperty.MIN_SDK_VERSION, minSdkVersion);
            }
            if (!targetSdkVersion.equals("-1")) {
                invoker.setOverride(SystemProperty.TARGET_SDK_VERSION, targetSdkVersion);
            }
            MergingReport mergingReport = invoker.merge();
            if (libraries.isEmpty()) {
                handleMergingResult(mergingReport, outManifest);
            } else {
                handleMergingResult(mergingReport, mergedTestManifest);
                generatedTestManifest = mergedTestManifest;
            }
        }
        if (!libraries.isEmpty()) {
            MergingReport mergingReport = ManifestMerger2.newMerger(generatedTestManifest, mLogger, ManifestMerger2.MergeType.APPLICATION).withFeatures(Invoker.Feature.REMOVE_TOOLS_DECLARATIONS).setOverride(SystemProperty.PACKAGE, testApplicationId).addLibraryManifests(collectLibraries(libraries)).merge();
            handleMergingResult(mergingReport, outManifest);
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public void convertByteCode(@NonNull Iterable<File> inputs, @NonNull Iterable<File> preDexedLibraries, @NonNull File outDexFolder, @NonNull DexOptions dexOptions, @Nullable List<String> additionalParameters, boolean incremental) throws IOException, InterruptedException, LoggedErrorException {
    checkNotNull(inputs, "inputs cannot be null.");
    checkNotNull(preDexedLibraries, "preDexedLibraries cannot be null.");
    checkNotNull(outDexFolder, "outDexFolder cannot be null.");
    checkNotNull(dexOptions, "dexOptions cannot be null.");
    checkArgument(outDexFolder.isDirectory(), "outDexFolder must be a folder");
    checkState(mTargetInfo != null, "Cannot call convertByteCode() before setTargetInfo() is called.");
    BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();
    // launch dx: create the command line
    ArrayList<String> command = Lists.newArrayList();
    String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX);
    if (dx == null || !new File(dx).isFile()) {
        throw new IllegalStateException("dx is missing");
    }
    command.add(dx);
    if (dexOptions.getJavaMaxHeapSize() != null) {
        command.add("-JXmx" + dexOptions.getJavaMaxHeapSize());
    }
    command.add("--dex");
    if (mVerboseExec) {
        command.add("--verbose");
    }
    if (dexOptions.getJumboMode()) {
        command.add("--force-jumbo");
    }
    if (incremental) {
        command.add("--incremental");
        command.add("--no-strict");
    }
    if (additionalParameters != null) {
        for (String arg : additionalParameters) {
            command.add(arg);
        }
    }
    command.add("--output");
    command.add(outDexFolder.getAbsolutePath());
    // clean up input list
    List<String> inputList = Lists.newArrayList();
    for (File f : inputs) {
        if (f != null && f.exists()) {
            inputList.add(f.getAbsolutePath());
        }
    }
    if (!inputList.isEmpty()) {
        mLogger.verbose("Dex inputs: " + inputList);
        command.addAll(inputList);
    }
    // clean up and add library inputs.
    List<String> libraryList = Lists.newArrayList();
    for (File f : preDexedLibraries) {
        if (f != null && f.exists()) {
            libraryList.add(f.getAbsolutePath());
        }
    }
    if (!libraryList.isEmpty()) {
        mLogger.verbose("Dex pre-dexed inputs: " + libraryList);
        command.addAll(libraryList);
    }
    mCmdLineRunner.runCmdLine(command, null);
}
#method_after
public void convertByteCode(@NonNull Iterable<File> inputs, @NonNull Iterable<File> preDexedLibraries, @NonNull File outDexFolder, boolean multidex, @NonNull DexOptions dexOptions, @Nullable List<String> additionalParameters, boolean incremental) throws IOException, InterruptedException, LoggedErrorException {
    checkNotNull(inputs, "inputs cannot be null.");
    checkNotNull(preDexedLibraries, "preDexedLibraries cannot be null.");
    checkNotNull(outDexFolder, "outDexFolder cannot be null.");
    checkNotNull(dexOptions, "dexOptions cannot be null.");
    checkArgument(outDexFolder.isDirectory(), "outDexFolder must be a folder");
    checkState(mTargetInfo != null, "Cannot call convertByteCode() before setTargetInfo() is called.");
    BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();
    checkState(!multidex || buildToolInfo.getRevision().compareTo(MIN_MULTIDEX_BUILD_TOOLS_REV) >= 0, "Multi dex requires Build Tools " + MIN_MULTIDEX_BUILD_TOOLS_REV.toString() + " / Current: " + buildToolInfo.getRevision().toShortString());
    // launch dx: create the command line
    ArrayList<String> command = Lists.newArrayList();
    String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX);
    if (dx == null || !new File(dx).isFile()) {
        throw new IllegalStateException("dx is missing");
    }
    command.add(dx);
    if (dexOptions.getJavaMaxHeapSize() != null) {
        command.add("-JXmx" + dexOptions.getJavaMaxHeapSize());
    }
    command.add("--dex");
    if (mVerboseExec) {
        command.add("--verbose");
    }
    if (dexOptions.getJumboMode()) {
        command.add("--force-jumbo");
    }
    if (incremental) {
        command.add("--incremental");
        command.add("--no-strict");
    }
    if (multidex) {
        command.add("--multi-dex");
    }
    if (additionalParameters != null) {
        for (String arg : additionalParameters) {
            command.add(arg);
        }
    }
    command.add("--output");
    command.add(outDexFolder.getAbsolutePath());
    // clean up input list
    List<String> inputList = Lists.newArrayList();
    for (File f : inputs) {
        if (f != null && f.exists()) {
            inputList.add(f.getAbsolutePath());
        }
    }
    if (!inputList.isEmpty()) {
        mLogger.verbose("Dex inputs: " + inputList);
        command.addAll(inputList);
    }
    // clean up and add library inputs.
    List<String> libraryList = Lists.newArrayList();
    for (File f : preDexedLibraries) {
        if (f != null && f.exists()) {
            libraryList.add(f.getAbsolutePath());
        }
    }
    if (!libraryList.isEmpty()) {
        mLogger.verbose("Dex pre-dexed inputs: " + libraryList);
        command.addAll(libraryList);
    }
    mCmdLineRunner.runCmdLine(command, null);
}
#end_block

#method_before
public static void preDexLibrary(@NonNull File inputFile, @NonNull File outFile, @NonNull DexOptions dexOptions, @NonNull BuildToolInfo buildToolInfo, boolean verbose, @NonNull CommandLineRunner commandLineRunner) throws IOException, InterruptedException, LoggedErrorException {
    checkNotNull(inputFile, "inputFile cannot be null.");
    checkNotNull(outFile, "outFile cannot be null.");
    checkNotNull(dexOptions, "dexOptions cannot be null.");
    // launch dx: create the command line
    ArrayList<String> command = Lists.newArrayList();
    String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX);
    if (dx == null || !new File(dx).isFile()) {
        throw new IllegalStateException("dx is missing");
    }
    command.add(dx);
    if (dexOptions.getJavaMaxHeapSize() != null) {
        command.add("-JXmx" + dexOptions.getJavaMaxHeapSize());
    }
    command.add("--dex");
    if (verbose) {
        command.add("--verbose");
    }
    if (dexOptions.getJumboMode()) {
        command.add("--force-jumbo");
    }
    command.add("--output");
    command.add(outFile.getAbsolutePath());
    command.add(inputFile.getAbsolutePath());
    commandLineRunner.runCmdLine(command, null);
}
#method_after
public void preDexLibrary(@NonNull File inputFile, @NonNull File outFile, boolean multiDex, @NonNull DexOptions dexOptions) throws IOException, InterruptedException, LoggedErrorException {
    checkState(mTargetInfo != null, "Cannot call preDexLibrary() before setTargetInfo() is called.");
    BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();
    PreDexCache.getCache().preDexLibrary(inputFile, outFile, multiDex, dexOptions, buildToolInfo, mVerboseExec, mCmdLineRunner);
}
#end_block

#method_before
public void packageApk(@NonNull String androidResPkgLocation, @NonNull File dexFolder, @NonNull Collection<File> packagedJars, @Nullable String javaResourcesLocation, @Nullable Collection<File> jniLibsFolders, @Nullable Set<String> abiFilters, boolean jniDebugBuild, @Nullable SigningConfig signingConfig, @Nullable PackagingOptions packagingOptions, @NonNull String outApkLocation) throws DuplicateFileException, FileNotFoundException, KeytoolException, PackagerException, SigningException {
    checkNotNull(androidResPkgLocation, "androidResPkgLocation cannot be null.");
    checkNotNull(dexFolder, "dexFolder cannot be null.");
    checkArgument(dexFolder.isDirectory(), "dexFolder is not a directory");
    checkNotNull(outApkLocation, "outApkLocation cannot be null.");
    CertificateInfo certificateInfo = null;
    if (signingConfig != null && signingConfig.isSigningReady()) {
        certificateInfo = KeystoreHelper.getCertificateInfo(signingConfig.getStoreType(), signingConfig.getStoreFile(), signingConfig.getStorePassword(), signingConfig.getKeyPassword(), signingConfig.getKeyAlias());
        if (certificateInfo == null) {
            throw new SigningException("Failed to read key from keystore");
        }
    }
    try {
        Packager packager = new Packager(outApkLocation, androidResPkgLocation, dexFolder, certificateInfo, mCreatedBy, packagingOptions, mLogger);
        packager.setJniDebugMode(jniDebugBuild);
        // figure out conflicts!
        JavaResourceProcessor resProcessor = new JavaResourceProcessor(packager);
        if (javaResourcesLocation != null) {
            resProcessor.addSourceFolder(javaResourcesLocation);
        }
        // add the resources from the jar files.
        Set<String> hashs = Sets.newHashSet();
        for (File jar : packagedJars) {
            // TODO remove once we can properly add a library as a dependency of its test.
            String hash = getFileHash(jar);
            if (hash == null) {
                throw new PackagerException("Unable to compute hash of " + jar.getAbsolutePath());
            }
            if (hashs.contains(hash)) {
                continue;
            }
            hashs.add(hash);
            packager.addResourcesFromJar(jar);
        }
        // also add resources from library projects and jars
        if (jniLibsFolders != null) {
            for (File jniFolder : jniLibsFolders) {
                if (jniFolder.isDirectory()) {
                    packager.addNativeLibraries(jniFolder, abiFilters);
                }
            }
        }
        packager.sealApk();
    } catch (SealedPackageException e) {
        // shouldn't happen since we control the package from start to end.
        throw new RuntimeException(e);
    }
}
#method_after
public void packageApk(@NonNull String androidResPkgLocation, @NonNull File dexFolder, @Nullable Collection<File> dexedLibraries, @NonNull Collection<File> packagedJars, @Nullable String javaResourcesLocation, @Nullable Collection<File> jniLibsFolders, @Nullable Set<String> abiFilters, boolean jniDebugBuild, @Nullable SigningConfig signingConfig, @Nullable PackagingOptions packagingOptions, @NonNull String outApkLocation) throws DuplicateFileException, FileNotFoundException, KeytoolException, PackagerException, SigningException {
    checkNotNull(androidResPkgLocation, "androidResPkgLocation cannot be null.");
    checkNotNull(dexFolder, "dexFolder cannot be null.");
    checkArgument(dexFolder.isDirectory(), "dexFolder is not a directory");
    checkNotNull(outApkLocation, "outApkLocation cannot be null.");
    CertificateInfo certificateInfo = null;
    if (signingConfig != null && signingConfig.isSigningReady()) {
        // noinspection ConstantConditions
        certificateInfo = KeystoreHelper.getCertificateInfo(signingConfig.getStoreType(), signingConfig.getStoreFile(), signingConfig.getStorePassword(), signingConfig.getKeyPassword(), signingConfig.getKeyAlias());
        if (certificateInfo == null) {
            throw new SigningException("Failed to read key from keystore");
        }
    }
    try {
        Packager packager = new Packager(outApkLocation, androidResPkgLocation, dexFolder, certificateInfo, mCreatedBy, packagingOptions, mLogger);
        if (dexedLibraries != null) {
            for (File dexedLibrary : dexedLibraries) {
                packager.addDexFile(dexedLibrary);
            }
        }
        packager.setJniDebugMode(jniDebugBuild);
        // figure out conflicts!
        JavaResourceProcessor resProcessor = new JavaResourceProcessor(packager);
        if (javaResourcesLocation != null) {
            resProcessor.addSourceFolder(javaResourcesLocation);
        }
        // add the resources from the jar files.
        Set<String> hashs = Sets.newHashSet();
        for (File jar : packagedJars) {
            // TODO remove once we can properly add a library as a dependency of its test.
            String hash = getFileHash(jar);
            if (hash == null) {
                throw new PackagerException("Unable to compute hash of " + jar.getAbsolutePath());
            }
            if (hashs.contains(hash)) {
                continue;
            }
            hashs.add(hash);
            packager.addResourcesFromJar(jar);
        }
        // also add resources from library projects and jars
        if (jniLibsFolders != null) {
            for (File jniFolder : jniLibsFolders) {
                if (jniFolder.isDirectory()) {
                    packager.addNativeLibraries(jniFolder, abiFilters);
                }
            }
        }
        packager.sealApk();
    } catch (SealedPackageException e) {
        // shouldn't happen since we control the package from start to end.
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@NonNull
public String getDirName() {
    if (!multiOutput) {
        return variantData.getVariantConfiguration().getDirName();
    }
    return variantData.getVariantConfiguration().computeDirNameWithSplits(densityFilter, abiFilter);
}
#method_after
@NonNull
public String getDirName() {
    if (!multiOutput) {
        return variantData.getVariantConfiguration().getDirName();
    }
    return variantData.getVariantConfiguration().computeDirNameWithSplits(mainApkOutputFile.getFilter(OutputFile.DENSITY), mainApkOutputFile.getFilter(OutputFile.ABI));
}
#end_block

#method_before
@NonNull
private String getFilterName() {
    if (densityFilter == null && abiFilter == null) {
        return UNIVERSAL;
    }
    StringBuilder sb = new StringBuilder();
    if (densityFilter != null) {
        sb.append(densityFilter);
    }
    if (abiFilter != null) {
        if (sb.length() > 0) {
            sb.append(StringHelper.capitalize(abiFilter));
        } else {
            sb.append(abiFilter);
        }
    }
    return sb.toString();
}
#method_after
@NonNull
private String getFilterName() {
    if (mainApkOutputFile.getFilters().isEmpty()) {
        return UNIVERSAL;
    }
    StringBuilder sb = new StringBuilder();
    String densityFilter = mainApkOutputFile.getFilter(OutputFile.DENSITY);
    if (densityFilter != null) {
        sb.append(densityFilter);
    }
    String abiFilter = mainApkOutputFile.getFilter(OutputFile.ABI);
    if (abiFilter != null) {
        if (sb.length() > 0) {
            sb.append(StringHelper.capitalize(abiFilter));
        } else {
            sb.append(abiFilter);
        }
    }
    return sb.toString();
}
#end_block

#method_before
public void test_SSLEngine_Multiple_Thread_Success() throws Exception {
    TestSSLEnginePair pair = null;
    try {
        pair = TestSSLEnginePair.create(null);
        assertConnected(pair);
        final CountDownLatch startUpSync = new CountDownLatch(2);
        final TestSSLEnginePair ourPair = pair;
        ExecutorService executor = Executors.newFixedThreadPool(2);
        Future<Void> client = executor.submit(new Callable<Void>() {

            public Void call() throws Exception {
                startUpSync.countDown();
                for (int i = 0; i < NUM_STRESS_ITERATIONS; i++) {
                    assertSendsCorrectly("This is the client. Hello!".getBytes(), ourPair.client, ourPair.server, false);
                }
                return null;
            }
        });
        Future<Void> server = executor.submit(new Callable<Void>() {

            public Void call() throws Exception {
                startUpSync.countDown();
                for (int i = 0; i < NUM_STRESS_ITERATIONS; i++) {
                    assertSendsCorrectly("This is the server. Hi!".getBytes(), ourPair.server, ourPair.client, false);
                }
                return null;
            }
        });
        executor.shutdown();
        client.get();
        server.get();
    } finally {
        if (pair != null) {
            pair.close();
        }
    }
}
#method_after
public void test_SSLEngine_Multiple_Thread_Success() throws Exception {
    try (final TestSSLEnginePair pair = TestSSLEnginePair.create()) {
        assertConnected(pair);
        final CountDownLatch startUpSync = new CountDownLatch(2);
        ExecutorService executor = Executors.newFixedThreadPool(2);
        Future<Void> client = executor.submit(new Callable<Void>() {

            public Void call() throws Exception {
                startUpSync.countDown();
                for (int i = 0; i < NUM_STRESS_ITERATIONS; i++) {
                    assertSendsCorrectly("This is the client. Hello!".getBytes(), pair.client, pair.server, false);
                }
                return null;
            }
        });
        Future<Void> server = executor.submit(new Callable<Void>() {

            public Void call() throws Exception {
                startUpSync.countDown();
                for (int i = 0; i < NUM_STRESS_ITERATIONS; i++) {
                    assertSendsCorrectly("This is the server. Hi!".getBytes(), pair.server, pair.client, false);
                }
                return null;
            }
        });
        executor.shutdown();
        client.get();
        server.get();
    }
}
#end_block

#method_before
public static Matcher<View> hasBackground(final int drawableId) {
    return new TypeSafeMatcher<View>() {

        @Override
        protected boolean matchesSafely(View view) {
            return assertDrawable(view.getBackground(), drawableId, view);
        }

        @Override
        public void describeTo(Description description) {
            description.appendText("has background with drawable ID: " + drawableId);
        }
    };
}
#method_after
@Beta
public static Matcher<View> hasBackground(final int drawableId) {
    return new HasBackgroundMatcher(drawableId);
}
#end_block

#method_before
public void testHasBackground() {
    View viewWithBackground = new View(context);
    viewWithBackground.setBackground(context.getDrawable(R.drawable.drawable_1));
    assertTrue(hasBackground(R.drawable.drawable_1).matches(viewWithBackground));
    assertFalse(hasBackground(R.drawable.drawable_2).matches(viewWithBackground));
    View viewWithoutBackground = new View(context);
    viewWithBackground.setBackground(null);
    assertFalse(hasBackground(R.drawable.drawable_1).matches(viewWithoutBackground));
}
#method_after
public void testHasBackground() {
    View viewWithBackground = new View(context);
    viewWithBackground.setBackground(context.getDrawable(R.drawable.drawable_1));
    assertTrue(hasBackground(R.drawable.drawable_1).matches(viewWithBackground));
}
#end_block

#method_before
public AbstractStringBuilder append(CharSequence s, int start, int end) {
    if (s == null)
        s = "null";
    if ((start < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException("start " + start + ", end " + end + ", s.length() " + s.length());
    int len = end - start;
    ensureCapacityInternal(count + len);
    if (s instanceof String) {
        ((String) s).getCharsNoCheck(start, end, value, count);
    } else if (s instanceof AbstractStringBuilder) {
        AbstractStringBuilder other = (AbstractStringBuilder) s;
        System.arraycopy(other.value, start, value, count, end - start);
    } else {
        for (int i = start, j = count; i < end; i++, j++) value[j] = s.charAt(i);
    }
    count += len;
    return this;
}
#method_after
public AbstractStringBuilder append(CharSequence s, int start, int end) {
    if (s == null)
        s = "null";
    if ((start < 0) || (start > end) || (end > s.length()))
        throw new IndexOutOfBoundsException("start " + start + ", end " + end + ", s.length() " + s.length());
    int len = end - start;
    ensureCapacityInternal(count + len);
    if (s instanceof String) {
        ((String) s).getCharsNoCheck(start, end, value, count);
    } else if (s instanceof AbstractStringBuilder) {
        AbstractStringBuilder other = (AbstractStringBuilder) s;
        System.arraycopy(other.value, start, value, count, len);
    } else {
        for (int i = start, j = count; i < end; i++, j++) {
            value[j] = s.charAt(i);
        }
    }
    count += len;
    return this;
}
#end_block

#method_before
@Override
public Matcher<View> getConstraints() {
    return action.getConstraints();
}
#method_after
@Override
public Matcher<View> getConstraints() {
    return mAction.getConstraints();
}
#end_block

#method_before
@Override
public String getDescription() {
    StringDescription stringDescription = new StringDescription();
    desiredStateMatcher.describeTo(stringDescription);
    return String.format("%s until: %s", action.getDescription(), stringDescription);
}
#method_after
@Override
public String getDescription() {
    StringDescription stringDescription = new StringDescription();
    mDesiredStateMatcher.describeTo(stringDescription);
    return String.format("%s until: %s", mAction.getDescription(), stringDescription);
}
#end_block

#method_before
@Override
public void perform(UiController uiController, View view) {
    int noOfAttempts = 0;
    do {
        action.perform(uiController, view);
        uiController.loopMainThreadUntilIdle();
        noOfAttempts++;
    } while (!desiredStateMatcher.matches(view) && noOfAttempts < maxAttempts);
    assertThat(view, desiredStateMatcher);
}
#method_after
@Override
public void perform(UiController uiController, View view) {
    int noOfAttempts = 1;
    for (; !mDesiredStateMatcher.matches(view) && noOfAttempts <= mMaxAttempts; noOfAttempts++) {
        mAction.perform(uiController, view);
        uiController.loopMainThreadUntilIdle();
    }
    if (noOfAttempts > mMaxAttempts) {
        throw new PerformException.Builder().withActionDescription(this.getDescription()).withViewDescription(HumanReadables.describe(view)).withCause(new RuntimeException(String.format("Failed to achieve view state after %d attempts", mMaxAttempts))).build();
    }
}
#end_block

#method_before
private synchronized void onAppAdded(String appName, int appUid) {
    if (TextUtils.isEmpty(appName) || appUid < 0) {
        loge("Invalid app in onAppAdded: " + appName + " | " + appUid);
        return;
    }
    try {
        PackageInfo app = mPackageManager.getPackageInfo(appName, GET_PERMISSIONS);
        boolean isNetwork = hasNetworkPermission(app);
        boolean isSystem = hasSystemPermission(app);
        if (isNetwork || isSystem) {
            Boolean permission = mApps.get(appUid);
            // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
            if (permission == null || permission == NETWORK) {
                mApps.put(appUid, isSystem);
                Map<Integer, Boolean> apps = new HashMap<Integer, Boolean>();
                apps.put(appUid, isSystem);
                update(mUsers, apps, true);
            }
        }
    } catch (NameNotFoundException e) {
        loge("NameNotFoundException in onAppAdded: " + e);
    }
}
#method_after
private synchronized void onAppAdded(String appName, int appUid) {
    if (TextUtils.isEmpty(appName) || appUid < 0) {
        loge("Invalid app in onAppAdded: " + appName + " | " + appUid);
        return;
    }
    // If multiple packages share a UID (cf: android:sharedUserId) and ask for different
    // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
    final Boolean permission = highestPermissionForUid(mApps.get(appUid), appName);
    if (permission != mApps.get(appUid)) {
        mApps.put(appUid, permission);
        Map<Integer, Boolean> apps = new HashMap<Integer, Boolean>();
        apps.put(appUid, permission);
        update(mUsers, apps, true);
    }
}
#end_block

#method_before
private synchronized void onAppRemoved(int appUid) {
    if (appUid < 0) {
        loge("Invalid app in onAppRemoved: " + appUid);
        return;
    }
    Map<Integer, Boolean> apps = new HashMap<Integer, Boolean>();
    String[] packages = mPackageManager.getPackagesForUid(appUid);
    if (packages != null && packages.length > 0) {
        Boolean permission = null;
        for (String name : packages) {
            try {
                PackageInfo app = mPackageManager.getPackageInfo(name, GET_PERMISSIONS);
                boolean isNetwork = hasNetworkPermission(app);
                boolean isSystem = hasSystemPermission(app);
                if (isNetwork || isSystem) {
                    permission = isSystem;
                }
                // 1. If there are SYSTEM permissions, then the original is SYSTEM permissions, do not update, return.
                if (permission == SYSTEM) {
                    return;
                }
            } catch (NameNotFoundException e) {
                loge("NameNotFoundException in onAppAdded: " + e);
            }
        }
        if (permission != null) {
            // 3. If other app of this uid have NETWORK permissions and the original is SYSTEM permissions, update permissions.
            if (permission != mApps.get(appUid)) {
                mApps.put(appUid, permission);
                apps.put(appUid, permission);
                update(mUsers, apps, true);
            }
            return;
        }
    }
    // 4. If all app of this uid do not have any network permission to remove permissions.
    mApps.remove(appUid);
    // doesn't matter which permission we pick here
    apps.put(appUid, NETWORK);
    update(mUsers, apps, false);
}
#method_after
private synchronized void onAppRemoved(int appUid) {
    if (appUid < 0) {
        loge("Invalid app in onAppRemoved: " + appUid);
        return;
    }
    Map<Integer, Boolean> apps = new HashMap<Integer, Boolean>();
    Boolean permission = null;
    String[] packages = mPackageManager.getPackagesForUid(appUid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            permission = highestPermissionForUid(permission, name);
            if (permission == SYSTEM) {
                // Nothing to do.
                return;
            }
        }
    }
    if (permission == mApps.get(appUid)) {
        // The permissions of this UID have not changed. Nothing to do.
        return;
    } else if (permission != null) {
        mApps.put(appUid, permission);
        apps.put(appUid, permission);
        update(mUsers, apps, true);
    } else {
        mApps.remove(appUid);
        // doesn't matter which permission we pick here
        apps.put(appUid, NETWORK);
        update(mUsers, apps, false);
    }
}
#end_block

#method_before
private void runOCSPStapledTest(CertificateStatus certStatus, final boolean goodStatus) throws Exception {
    X509Certificate serverCert = (X509Certificate) TestKeyStore.getServer().getPrivateKey("RSA", "RSA").getCertificate();
    OCSPResp ocspResponse = generateOCSPResponse(serverCert, (X509Certificate) TestKeyStore.getIntermediateCa().getPrivateKey("RSA", "RSA").getCertificate(), TestKeyStore.getIntermediateCa().getPrivateKey("RSA", "RSA").getPrivateKey(), certStatus);
    PKIXParameters params = new PKIXParameters(Collections.singleton(new TrustAnchor((X509Certificate) TestKeyStore.getRootCa().getPrivateKey("RSA", "RSA").getCertificate(), null)));
    for (PKIXCertPathChecker checker : params.getCertPathCheckers()) {
        assertFalse(checker instanceof PKIXRevocationChecker);
    }
    CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
    PKIXRevocationChecker revChecker = (PKIXRevocationChecker) cpv.getRevocationChecker();
    revChecker.setOptions(Collections.singleton(Option.ONLY_END_ENTITY));
    revChecker.setOcspResponses(Collections.singletonMap(serverCert, ocspResponse.getEncoded()));
    List<PKIXCertPathChecker> checkers = new ArrayList<>(params.getCertPathCheckers());
    checkers.add(revChecker);
    params.setCertPathCheckers(checkers);
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    ArrayList<X509Certificate> chain = new ArrayList<>();
    chain.add(serverCert);
    chain.add((X509Certificate) TestKeyStore.getIntermediateCa().getPrivateKey("RSA", "RSA").getCertificate());
    TestKeyStore.getServer().getPrivateKey("RSA", "RSA").getCertificateChain();
    CertPath certPath = cf.generateCertPath(chain);
    try {
        cpv.validate(certPath, params);
        if (!goodStatus) {
            fail("should not validate CertPath with rejected OCSP data");
        }
    } catch (CertPathValidatorException maybeExpected) {
        if (goodStatus) {
            fail("should validate CertPath with good OCSP data");
        }
    }
}
#method_after
private void runOCSPStapledTest(CertificateStatus certStatus, final boolean goodStatus) throws Exception {
    PrivateKeyEntry serverEntry = TestKeyStore.getServer().getPrivateKey("RSA", "RSA");
    PrivateKeyEntry caEntry = TestKeyStore.getIntermediateCa().getPrivateKey("RSA", "RSA");
    PrivateKeyEntry rootCaEntry = TestKeyStore.getRootCa().getPrivateKey("RSA", "RSA");
    X509Certificate serverCert = (X509Certificate) serverEntry.getCertificate();
    OCSPResp ocspResponse = generateOCSPResponse(serverCert, (X509Certificate) caEntry.getCertificate(), caEntry.getPrivateKey(), certStatus);
    PKIXParameters params = new PKIXParameters(Collections.singleton(new TrustAnchor((X509Certificate) rootCaEntry.getCertificate(), null)));
    // By default we shouldn't have a PKIXRevocationChecker already.
    for (PKIXCertPathChecker checker : params.getCertPathCheckers()) {
        assertFalse(checker instanceof PKIXRevocationChecker);
    }
    CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
    PKIXRevocationChecker revChecker = (PKIXRevocationChecker) cpv.getRevocationChecker();
    revChecker.setOptions(Collections.singleton(Option.ONLY_END_ENTITY));
    revChecker.setOcspResponses(Collections.singletonMap(serverCert, ocspResponse.getEncoded()));
    List<PKIXCertPathChecker> checkers = new ArrayList<>(params.getCertPathCheckers());
    checkers.add(revChecker);
    params.setCertPathCheckers(checkers);
    ArrayList<X509Certificate> chain = new ArrayList<>();
    chain.add(serverCert);
    chain.add((X509Certificate) caEntry.getCertificate());
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    CertPath certPath = cf.generateCertPath(chain);
    try {
        cpv.validate(certPath, params);
        assertTrue("should fail with failure OCSP status", goodStatus);
    } catch (CertPathValidatorException maybeExpected) {
        assertFalse("should not fail with good OCSP status", goodStatus);
    }
}
#end_block

#method_before
@Nonnull
private DalvCode createCode(@Nonnull JMethod method, @Nonnull RopMethod ropMethod) {
    DexOptions options = new DexOptions();
    options.forceJumbo = forceJumbo;
    options.targetApiLevel = ThreadConfig.get(Options.ANDROID_MIN_API_LEVEL).intValue();
    int paramSize = getParameterWordCount(method);
    int positionListKind;
    LocalVariableInfo lvInfo;
    if (emitLocalDebugInfo) {
        lvInfo = LocalVariableExtractor.extract(ropMethod);
    } else {
        lvInfo = null;
    }
    if (emitLineNumberTable) {
        positionListKind = PositionList.LINES;
    } else {
        positionListKind = PositionList.NONE;
    }
    return RopTranslator.translate(ropMethod, positionListKind, lvInfo, paramSize, options);
}
#method_after
@Nonnull
private DalvCode createCode(@Nonnull JMethod method, @Nonnull RopMethod ropMethod) {
    DexOptions options = new DexOptions();
    options.forceJumbo = forceJumbo;
    options.targetApiLevel = apiLevel;
    int paramSize = getParameterWordCount(method);
    int positionListKind;
    LocalVariableInfo lvInfo;
    if (emitLocalDebugInfo) {
        lvInfo = LocalVariableExtractor.extract(ropMethod);
    } else {
        lvInfo = null;
    }
    if (emitLineNumberTable) {
        positionListKind = PositionList.LINES;
    } else {
        positionListKind = PositionList.NONE;
    }
    return RopTranslator.translate(ropMethod, positionListKind, lvInfo, paramSize, options);
}
#end_block

#method_before
@Nonnull
protected DexFile createDexFile() {
    DexOptions options = new DexOptions();
    options.targetApiLevel = ThreadConfig.get(Options.ANDROID_MIN_API_LEVEL).intValue();
    options.forceJumbo = forceJumbo;
    return new DexFile(options);
}
#method_after
@Nonnull
protected DexFile createDexFile() {
    DexOptions options = new DexOptions();
    options.forceJumbo = forceJumbo;
    options.targetApiLevel = apiLevel;
    return new DexFile(options);
}
#end_block

#method_before
public static int magicToApi(byte[] magic) {
    if (magic.length != 8) {
        return -1;
    }
    if ((magic[0] != 'd') || (magic[1] != 'e') || (magic[2] != 'x') || (magic[3] != '\n') || (magic[7] != '\0')) {
        return -1;
    }
    String version = "" + ((char) magic[4]) + ((char) magic[5]) + ((char) magic[6]);
    if (version.equals(VERSION_CURRENT)) {
        return API_CURRENT;
    } else if (version.equals(VERSION_FOR_API_23)) {
        return API_NO_DEFAULT_METHOD;
    } else if (version.equals(VERSION_FOR_API_13)) {
        return API_NO_EXTENDED_OPCODES;
    }
    return -1;
}
#method_after
public static int magicToApi(byte[] magic) {
    if (magic.length != 8) {
        return -1;
    }
    if ((magic[0] != 'd') || (magic[1] != 'e') || (magic[2] != 'x') || (magic[3] != '\n') || (magic[7] != '\0')) {
        return -1;
    }
    String version = "" + ((char) magic[4]) + ((char) magic[5]) + ((char) magic[6]);
    if (version.equals(VERSION_CURRENT)) {
        return API_CURRENT;
    } else if (version.equals(VERSION_FOR_API_13)) {
        return API_NO_EXTENDED_OPCODES;
    }
    return -1;
}
#end_block

#method_before
public static String apiToMagic(int targetApiLevel) {
    String version;
    if (targetApiLevel >= API_CURRENT) {
        version = VERSION_CURRENT;
    } else if (targetApiLevel > API_NO_EXTENDED_OPCODES) {
        version = VERSION_FOR_API_23;
    } else {
        version = VERSION_FOR_API_13;
    }
    return MAGIC_PREFIX + version + MAGIC_SUFFIX;
}
#method_after
public static String apiToMagic(int targetApiLevel) {
    String version;
    if (targetApiLevel >= API_CURRENT) {
        version = VERSION_CURRENT;
    } else {
        version = VERSION_FOR_API_13;
    }
    return MAGIC_PREFIX + version + MAGIC_SUFFIX;
}
#end_block

#method_before
@Override
public void run(@Nonnull JDefinedClassOrInterface type) throws Exception {
    OutputVFile vFile;
    if (usePrebuilts) {
        Location loc = type.getLocation();
        if (loc instanceof TypeInInputLibraryLocation) {
            InputVFile in;
            InputLibraryLocation inputLibraryLocation = ((TypeInInputLibraryLocation) loc).getInputLibraryLocation();
            InputLibrary inputLibrary = inputLibraryLocation.getInputLibrary();
            if (outputLibrary.containsLibraryLocation(inputLibraryLocation)) {
                return;
            }
            try {
                in = inputLibrary.getFile(FileType.PREBUILT, new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'));
                vFile = outputLibrary.createFile(FileType.PREBUILT, new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'));
                InputStream is = in.getInputStream();
                OutputStream os = vFile.getOutputStream();
                try {
                    new ByteStreamSucker(is, os, true).suck();
                } finally {
                    // is != null or check before
                    is.close();
                }
                return;
            } catch (FileTypeDoesNotExistException e) {
            // Pre-dex is not accessible, thus write dex file from type
            }
        }
    }
    ClassDefItemMarker cdiMarker = type.getMarker(ClassDefItemMarker.class);
    assert cdiMarker != null;
    DexOptions options = new DexOptions();
    options.forceJumbo = forceJumbo;
    options.targetApiLevel = ThreadConfig.get(Options.ANDROID_MIN_API_LEVEL).intValue();
    DexFile typeDex = new DexFile(options);
    typeDex.add(cdiMarker.getClassDefItem());
    OutputStream outStream = null;
    try {
        vFile = outputLibrary.createFile(FileType.PREBUILT, new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'));
    } catch (IOException e) {
        throw new JackIOException("Could not create Dex file in output " + outputLibrary.getLocation().getDescription() + " for type " + Jack.getUserFriendlyFormatter().getName(type), e);
    }
    try {
        outStream = vFile.getOutputStream();
        typeDex.getStringIds().intern(DexWriter.getJackDexTag());
        typeDex.prepare();
        typeDex.writeTo(outStream, null, false);
    } catch (IOException e) {
        throw new JackIOException("Could not write Dex file to output " + vFile.getLocation().getDescription(), e);
    } finally {
        if (outStream != null) {
            outStream.close();
        }
    }
}
#method_after
@Override
public void run(@Nonnull JDefinedClassOrInterface type) throws Exception {
    OutputVFile vFile;
    if (usePrebuilts) {
        Location loc = type.getLocation();
        if (loc instanceof TypeInInputLibraryLocation) {
            InputVFile in;
            InputLibraryLocation inputLibraryLocation = ((TypeInInputLibraryLocation) loc).getInputLibraryLocation();
            InputLibrary inputLibrary = inputLibraryLocation.getInputLibrary();
            if (outputLibrary.containsLibraryLocation(inputLibraryLocation)) {
                return;
            }
            try {
                in = inputLibrary.getFile(FileType.PREBUILT, new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'));
                vFile = outputLibrary.createFile(FileType.PREBUILT, new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'));
                InputStream is = in.getInputStream();
                OutputStream os = vFile.getOutputStream();
                try {
                    new ByteStreamSucker(is, os, true).suck();
                } finally {
                    // is != null or check before
                    is.close();
                }
                return;
            } catch (FileTypeDoesNotExistException e) {
            // Pre-dex is not accessible, thus write dex file from type
            }
        }
    }
    ClassDefItemMarker cdiMarker = type.getMarker(ClassDefItemMarker.class);
    assert cdiMarker != null;
    DexOptions options = new DexOptions();
    options.forceJumbo = forceJumbo;
    options.targetApiLevel = apiLevel;
    DexFile typeDex = new DexFile(options);
    typeDex.add(cdiMarker.getClassDefItem());
    OutputStream outStream = null;
    try {
        vFile = outputLibrary.createFile(FileType.PREBUILT, new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'));
    } catch (IOException e) {
        throw new JackIOException("Could not create Dex file in output " + outputLibrary.getLocation().getDescription() + " for type " + Jack.getUserFriendlyFormatter().getName(type), e);
    }
    try {
        outStream = vFile.getOutputStream();
        typeDex.getStringIds().intern(DexWriter.getJackDexTag());
        typeDex.prepare();
        typeDex.writeTo(outStream, null, false);
    } catch (IOException e) {
        throw new JackIOException("Could not write Dex file to output " + vFile.getLocation().getDescription(), e);
    } finally {
        if (outStream != null) {
            outStream.close();
        }
    }
}
#end_block

#method_before
public void test_open$java_net_ProtocolFamily() throws IOException {
    DatagramChannel channel = DatagramChannel.open(StandardProtocolFamily.INET);
    channel.bind(new InetSocketAddress(Inet4Address.LOOPBACK, 0));
    assertEquals(SelectorProvider.provider(), channel.provider());
    try {
        // Should not support IPV6 Address
        DatagramChannel.open(StandardProtocolFamily.INET).bind(new InetSocketAddress(0));
        fail();
    } catch (UnsupportedAddressTypeException expected) {
    }
    try {
        DatagramChannel.open(StandardProtocolFamily.INET6).bind(new InetSocketAddress(0));
    } catch (UnsupportedOperationException IPV6IsNotEnabled) {
    }
    try {
        DatagramChannel.open(MockProtocolFamily.MOCK);
        fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
        DatagramChannel.open(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_open$java_net_ProtocolFamily() throws IOException {
    DatagramChannel channel = DatagramChannel.open(StandardProtocolFamily.INET);
    channel.bind(new InetSocketAddress(Inet4Address.LOOPBACK, 0));
    assertEquals(SelectorProvider.provider(), channel.provider());
    try {
        // Should not support IPv6 Address
        // InetSocketAddress(int) returns IPv6 ANY  address
        DatagramChannel.open(StandardProtocolFamily.INET).bind(new InetSocketAddress(0));
        fail();
    } catch (UnsupportedAddressTypeException expected) {
    }
    DatagramChannel.open(StandardProtocolFamily.INET6).bind(new InetSocketAddress(0));
    try {
        DatagramChannel.open(MockProtocolFamily.MOCK);
        fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
        DatagramChannel.open(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void onPreviewFrame(byte[] data, Camera camera) {
    if (mProcessInProgress || mState != STATE_PREVIEW) {
        mCamera.addCallbackBuffer(data);
        return;
    }
    if (data == null) {
        return;
    }
    int expectedBytes = mPreviewSize.width * mPreviewSize.height * ImageFormat.getBitsPerPixel(ImageFormat.NV21) / 8;
    if (expectedBytes != data.length) {
        Log.e(TAG, "Mismatched size of buffer! Expected ");
        // mCamera.setPreviewCallbackWithBuffer(null);
        return;
    }
    mProcessInProgress = true;
    if ((mFilterYuv == null) || (mPreviewSize.width != mFilterYuv.getWidth()) || (mPreviewSize.height != mFilterYuv.getHeight())) {
        mFilterYuv.reset(mPreviewSize.width, mPreviewSize.height);
    }
    mProcessInProgress = true;
    new ProcessPreviewDataTask().execute(data);
}
#method_after
public void onPreviewFrame(byte[] data, Camera camera) {
    if (mProcessInProgress || mState != STATE_PREVIEW) {
        mCamera.addCallbackBuffer(data);
        return;
    }
    if (data == null) {
        return;
    }
    int expectedBytes = mPreviewSize.width * mPreviewSize.height * ImageFormat.getBitsPerPixel(ImageFormat.NV21) / 8;
    if (expectedBytes != data.length) {
        Log.e(TAG, "Mismatched size of buffer! Expected ");
        return;
    }
    mProcessInProgress = true;
    if ((mFilterYuv == null) || (mPreviewSize.width != mFilterYuv.getWidth()) || (mPreviewSize.height != mFilterYuv.getHeight())) {
        mFilterYuv.reset(mPreviewSize.width, mPreviewSize.height);
    }
    mProcessInProgress = true;
    new ProcessPreviewDataTask().execute(data);
}
#end_block

#method_before
private void checkKernelWakelock(String[] parts) {
    assertTrue(parts.length >= 7);
    for (int i = 4; i < parts.length - 2; i++) {
        // Kernel wakelock
        assertNotNull(parts[i]);
    }
    // totalTime
    assertInteger(parts[parts.length - 2]);
    // count
    assertInteger(parts[parts.length - 1]);
}
#method_after
private void checkKernelWakelock(String[] parts) {
    assertTrue(parts.length >= 7);
    // Kernel wakelock
    assertNotNull(parts[4]);
    // totalTime
    assertInteger(parts[parts.length - 2]);
    // count
    assertInteger(parts[parts.length - 1]);
}
#end_block

#method_before
@Override
protected int getIssueCapacity(@NonNull EnumSet<Scope> scope) {
    if (scope.equals(Scope.ALL)) {
        return getIssues().size();
    } else {
        int initialSize = 12;
        if (scope.contains(Scope.RESOURCE_FILE)) {
            initialSize += 75;
        } else if (scope.contains(Scope.ALL_RESOURCE_FILES)) {
            initialSize += 10;
        }
        if (scope.contains(Scope.JAVA_FILE)) {
            initialSize += 55;
        } else if (scope.contains(Scope.CLASS_FILE)) {
            initialSize += 15;
        } else if (scope.contains(Scope.MANIFEST)) {
            initialSize += 30;
        } else if (scope.contains(Scope.GRADLE_FILE)) {
            initialSize += 5;
        }
        return initialSize;
    }
}
#method_after
@Override
protected int getIssueCapacity(@NonNull EnumSet<Scope> scope) {
    if (scope.equals(Scope.ALL)) {
        return getIssues().size();
    } else {
        int initialSize = 12;
        if (scope.contains(Scope.RESOURCE_FILE)) {
            initialSize += 75;
        } else if (scope.contains(Scope.ALL_RESOURCE_FILES)) {
            initialSize += 10;
        }
        if (scope.contains(Scope.JAVA_FILE)) {
            initialSize += 60;
        } else if (scope.contains(Scope.CLASS_FILE)) {
            initialSize += 15;
        } else if (scope.contains(Scope.MANIFEST)) {
            initialSize += 37;
        } else if (scope.contains(Scope.GRADLE_FILE)) {
            initialSize += 5;
        }
        return initialSize;
    }
}
#end_block

#method_before
@Override
public void visitMethod(@NonNull JavaContext context, @Nullable AstVisitor visitor, @NonNull MethodInvocation node) {
    ResolvedNode resolved = context.resolve(node);
    if (resolved instanceof ResolvedMethod) {
        String methodName = node.astName().astValue();
        ResolvedClass resolvedClass = ((ResolvedMethod) resolved).getContainingClass();
        if ((resolvedClass.isSubclassOf(RUNTIME_CLASS, false)) || (resolvedClass.isSubclassOf(SYSTEM_CLASS, false))) {
            // Report calls to Runtime.load() and System.load()
            if ("load".equals(methodName)) {
                context.report(LOAD, node, context.getLocation(node), "Dynamically loading code using `load` is risky, please use " + "`loadLibrary` instead when possible");
                return;
            }
        }
    }
}
#method_after
@Override
public void visitMethod(@NonNull JavaContext context, @Nullable AstVisitor visitor, @NonNull MethodInvocation node) {
    ResolvedNode resolved = context.resolve(node);
    if (resolved instanceof ResolvedMethod) {
        String methodName = node.astName().astValue();
        ResolvedClass resolvedClass = ((ResolvedMethod) resolved).getContainingClass();
        if ((resolvedClass.isSubclassOf(RUNTIME_CLASS, false)) || (resolvedClass.matches(SYSTEM_CLASS))) {
            // Report calls to Runtime.load() and System.load()
            if ("load".equals(methodName)) {
                context.report(LOAD, node, context.getLocation(node), "Dynamically loading code using `load` is risky, please use " + "`loadLibrary` instead when possible");
                return;
            }
        }
    }
}
#end_block

#method_before
synchronized void setTriangles(FloatBuffer v) {
    vertexBuffer = v;
    // vertexBuffer.position(0);
    // vertexBuffer.put(mTriArray);
    mGLSurfaceView.requestRender();
}
#method_after
synchronized void setTriangles(FloatBuffer v) {
    vertexBuffer = v;
    mGLSurfaceView.requestRender();
}
#end_block

#method_before
public synchronized void draw(float[] mvpMatrix) {
    // Log.v(TAG, "Draw "+mTriArray);
    if (!mDrawSwarm || vertexBuffer == null)
        return;
    mTriArray[2] = 0;
    synchronized (vertexBuffer) {
        vertexBuffer.position(0);
        GLES20.glUseProgram(mProgram);
        mPositionHandle = GLES20.glGetAttribLocation(mProgram, "a_Position");
        GLES20.glEnableVertexAttribArray(mPositionHandle);
        GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer);
        mColorHandle = GLES20.glGetAttribLocation(mProgram, "a_Color");
        GLES20.glEnableVertexAttribArray(mColorHandle);
        GLES20.glVertexAttribPointer(mColorHandle, FLOATS_PER_COLOR, GLES20.GL_FLOAT, false, colorStride, mColorBuffer);
        mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "u_MVP");
        checkGlError("glGetUniformLocation");
        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);
        checkGlError("glUniformMatrix4fv");
        GLES20.glDrawElements(GLES20.GL_TRIANGLES, mIndexArray.length, GLES20.GL_UNSIGNED_SHORT, drawListBuffer);
        GLES20.glDisableVertexAttribArray(mPositionHandle);
        GLES20.glFinish();
    }
    count++;
    if (count > 100) {
        Log.v(TAG, " gl " + count / ((System.nanoTime() - time) * 1E-9) + " fps");
        count = 0;
        time = System.nanoTime();
    }
}
#method_after
public synchronized void draw(float[] mvpMatrix) {
    if (!mDrawSwarm || vertexBuffer == null)
        return;
    mTriArray[2] = 0;
    synchronized (vertexBuffer) {
        vertexBuffer.position(0);
        GLES20.glUseProgram(mProgram);
        mPositionHandle = GLES20.glGetAttribLocation(mProgram, "a_Position");
        GLES20.glEnableVertexAttribArray(mPositionHandle);
        GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer);
        mColorHandle = GLES20.glGetAttribLocation(mProgram, "a_Color");
        GLES20.glEnableVertexAttribArray(mColorHandle);
        GLES20.glVertexAttribPointer(mColorHandle, FLOATS_PER_COLOR, GLES20.GL_FLOAT, false, colorStride, mColorBuffer);
        mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "u_MVP");
        checkGlError("glGetUniformLocation");
        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);
        checkGlError("glUniformMatrix4fv");
        GLES20.glDrawElements(GLES20.GL_TRIANGLES, mIndexArray.length, GLES20.GL_UNSIGNED_SHORT, drawListBuffer);
        GLES20.glDisableVertexAttribArray(mPositionHandle);
        GLES20.glFinish();
    }
    count++;
    if (count > 100) {
        Log.v(TAG, " gl " + count / ((System.nanoTime() - time) * 1E-9) + " fps");
        count = 0;
        time = System.nanoTime();
    }
}
#end_block

#method_before
@Override
protected Void doInBackground(Void... params) {
    RenderScript rs = RenderScript.create(mContext);
    float[] hsv = new float[3];
    hsv[1] = 0.8f;
    hsv[2] = 0.9f;
    Allocation posAlloc = Allocation.createSized(rs, Element.F32_4(rs), SWARM_SIZE);
    Allocation velAlloc = Allocation.createSized(rs, Element.F32_4(rs), SWARM_SIZE);
    int triAllocSize = mTriArray.length / 4;
    Type.Builder builder = new Type.Builder(rs, Element.F32_4(rs));
    // builder.setX(triAllocSize);
    // builder.setY(1);
    // Allocation triAlloc = Allocation.createTyped(rs, builder.create());
    Allocation triAlloc1 = Allocation.createSized(rs, Element.F32_4(rs), triAllocSize);
    Allocation triAlloc2 = Allocation.createSized(rs, Element.F32_4(rs), triAllocSize);
    FloatBuffer triBuff1 = triAlloc1.getByteBuffer().order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();
    FloatBuffer triBuff2 = triAlloc2.getByteBuffer().order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();
    dblBuff = new float[mTriArray.length];
    ScriptC_nbody nbody = new ScriptC_nbody(rs);
    nbody.set_positions(posAlloc);
    nbody.set_velocities(velAlloc);
    nbody.set_triangles1(triAlloc1);
    nbody.set_triangles2(triAlloc2);
    Log.v(TAG, " node = " + mMode + "  " + sModes[mModeNo] + " " + mModeNo);
    nbody.set_CENTER_MASS(mMode[P_CTR_M]);
    nbody.set_OBJECT_MAX_MASS(mMode[P_MAX_M]);
    nbody.set_OBJECT_MIN_MASS(mMode[P_MIN_M]);
    nbody.set_INITAL_VEL(mMode[P_INIT_V]);
    nbody.set_INITAL_DIR(new Float3(mMode[P_DIR_X], mMode[P_DIR_Y], mMode[P_DIR_Z]));
    nbody.set_RADIUS_RANGE(new Float2(mMode[P_RAD_MIN], mMode[P_RAD_MAX]));
    nbody.forEach_fill_pos(posAlloc);
    boolean dir = false;
    try {
        Thread.sleep(500);
        int triBufferPos = 0;
        while (keepRunning) {
            count++;
            dir = !dir;
            FloatBuffer triBuff = (dir) ? triBuff1 : triBuff2;
            long time = System.nanoTime();
            if (mDrag) {
                Log.v(TAG, "Drag =  ... " + mDrag_x + ", " + mDrag_y);
                nbody.invoke_setCenterMassPos(mDrag_x, mDrag_y, mDrag_z);
                mDrag = false;
            }
            synchronized (triBuff) {
                if (dir)
                    nbody.forEach_simulate1(posAlloc, posAlloc);
                else
                    nbody.forEach_simulate2(posAlloc, posAlloc);
                rs.finish();
                publishProgress(triBuff);
                time = (System.nanoTime() - time);
                if (time < (15 * 1000000)) {
                    time = 15 * 1000000 - time;
                    Thread.sleep(time / 1000000, (int) (time % 1000000));
                }
            }
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    posAlloc.destroy();
    velAlloc.destroy();
    triAlloc1.destroy();
    triAlloc2.destroy();
    nbody.destroy();
    return null;
}
#method_after
@Override
protected Void doInBackground(Void... params) {
    RenderScript rs = RenderScript.create(mContext);
    float[] hsv = new float[3];
    hsv[1] = 0.8f;
    hsv[2] = 0.9f;
    Allocation posAlloc = Allocation.createSized(rs, Element.F32_4(rs), SWARM_SIZE);
    Allocation velAlloc = Allocation.createSized(rs, Element.F32_4(rs), SWARM_SIZE);
    int triAllocSize = mTriArray.length / 4;
    Type.Builder builder = new Type.Builder(rs, Element.F32_4(rs));
    Allocation triAlloc1 = Allocation.createSized(rs, Element.F32_4(rs), triAllocSize);
    Allocation triAlloc2 = triAlloc1;
    FloatBuffer triBuff1, triBuff2, triBuff;
    if (USE_BB) {
        triAlloc2 = Allocation.createSized(rs, Element.F32_4(rs), triAllocSize);
        triBuff1 = triAlloc1.getByteBuffer().order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();
        triBuff2 = triAlloc2.getByteBuffer().order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();
    } else {
        triBuff1 = ByteBuffer.allocateDirect(mTriArray.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer();
        triBuff2 = ByteBuffer.allocateDirect(mTriArray.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer();
    }
    ScriptC_nbody nbody = new ScriptC_nbody(rs);
    nbody.set_positions(posAlloc);
    nbody.set_velocities(velAlloc);
    nbody.set_triangles1(triAlloc1);
    nbody.set_triangles2(triAlloc2);
    Log.v(TAG, " node = " + mMode + "  " + sModes[mModeNo] + " " + mModeNo);
    nbody.set_CENTER_MASS(mMode[P_CTR_M]);
    nbody.set_OBJECT_MAX_MASS(mMode[P_MAX_M]);
    nbody.set_OBJECT_MIN_MASS(mMode[P_MIN_M]);
    nbody.set_INITAL_VEL(mMode[P_INIT_V]);
    nbody.set_INITAL_DIR(new Float3(mMode[P_DIR_X], mMode[P_DIR_Y], mMode[P_DIR_Z]));
    nbody.set_RADIUS_RANGE(new Float2(mMode[P_RAD_MIN], mMode[P_RAD_MAX]));
    nbody.forEach_fill_pos(posAlloc);
    boolean dir = false;
    try {
        Thread.sleep(500);
        int triBufferPos = 0;
        while (keepRunning) {
            count++;
            dir = !dir;
            triBuff = (dir) ? triBuff1 : triBuff2;
            long time = System.nanoTime();
            if (mDrag) {
                Log.v(TAG, "Drag =  ... " + mDrag_x + ", " + mDrag_y);
                nbody.invoke_setCenterMassPos(mDrag_x, mDrag_y, mDrag_z);
                mDrag = false;
            }
            synchronized (triBuff) {
                if (dir)
                    nbody.forEach_simulate1(posAlloc, posAlloc);
                else
                    nbody.forEach_simulate2(posAlloc, posAlloc);
                rs.finish();
                if (!USE_BB) {
                    ((dir) ? triAlloc1 : triAlloc1).copyTo(mTriArray);
                    triBuff.position(0);
                    triBuff.put(mTriArray);
                    triBuff.position(0);
                }
                publishProgress(triBuff);
            }
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    posAlloc.destroy();
    velAlloc.destroy();
    triAlloc1.destroy();
    if (triAlloc1 != triAlloc2) {
        triAlloc2.destroy();
    }
    nbody.destroy();
    return null;
}
#end_block

#method_before
public String getHexString() {
    String out = "0x";
    byte[] ssidbytes = getOctets();
    for (int i = 0; i < octets.size(); i++) {
        out += String.format(Locale.US, "%02x", ssidbytes[i]);
    }
    return i ? out : NONE;
}
#method_after
public String getHexString() {
    String out = "0x";
    byte[] ssidbytes = getOctets();
    for (int i = 0; i < octets.size(); i++) {
        out += String.format(Locale.US, "%02x", ssidbytes[i]);
    }
    return (octets.size() > 0) ? out : null;
}
#end_block

#method_before
public static EventBasicVerification getDefault(TestSensorEnvironment environment, long testDurationUs) {
    // The calculation is still OK if sampleUs is not the actual sensor hardware
    // sample period since the actual sample period by definition only goes smaller, which
    // result in more samples.
    long sampleUs = environment.getExpectedSamplingPeriodUs();
    long askedBatchUs = environment.getMaxReportLatencyUs();
    // >=0
    long reservedFifoUs = sampleUs * environment.getSensor().getFifoReservedEventCount();
    long maximumFifoUs = Math.max(sampleUs * environment.getSensor().getFifoMaxEventCount(), // >=0
    reservedFifoUs);
    long effectiveDurationUs = Math.max(testDurationUs - ALLOWED_SENSOR_START_DELAY_US - ALLOWED_SENSOR_EVENT_LATENCY_US, 0);
    long minBatchUs = Math.min(reservedFifoUs, askedBatchUs);
    long maxBatchUs = Math.min(maximumFifoUs, askedBatchUs);
    // If it is actually no batching, allow it to be as slow as 80% of the asked rate
    long t0 = (minBatchUs == 0 && maxBatchUs == 0) ? effectiveDurationUs * 4 / 5 : Long.MAX_VALUE;
    // For batching mode, the smaller actual sampleUs is, the smaller batchUs will be, which
    // leads to larger t1 and t2. Use original batchUs is more liberal.
    long t1 = (minBatchUs > 0) ? Math.max(effectiveDurationUs / minBatchUs * minBatchUs - minBatchUs / 5, 0) : Long.MAX_VALUE;
    long t2 = (maxBatchUs > 0) ? Math.max(effectiveDurationUs / maxBatchUs * maxBatchUs - maxBatchUs / 5, 0) : Long.MAX_VALUE;
    long expectedMinUs = Math.min(Math.min(t1, t2), t0);
    long expectedMinNumEvent = expectedMinUs / sampleUs;
    return new EventBasicVerification(expectedMinNumEvent, environment.getSensor());
}
#method_after
public static EventBasicVerification getDefault(TestSensorEnvironment environment, long testDurationUs) {
    // The calculation is still OK if sampleUs is not the actual sensor hardware
    // sample period since the actual sample period by definition only goes smaller, which
    // result in more samples.
    long sampleUs = environment.getExpectedSamplingPeriodUs();
    long askedBatchUs = environment.getMaxReportLatencyUs();
    // >=0
    long reservedFifoUs = sampleUs * environment.getSensor().getFifoReservedEventCount();
    // max() prevent loop-hole if HAL specify smaller max fifo than reserved fifo.
    long maximumFifoUs = Math.max(sampleUs * environment.getSensor().getFifoMaxEventCount(), // >=0
    reservedFifoUs);
    long effectiveDurationUs = Math.max(testDurationUs - Math.max(ALLOWED_SENSOR_START_DELAY_US, environment.getAllowedSensorStartDelay()) - ALLOWED_SENSOR_EVENT_LATENCY_US, 0);
    boolean isSingleSensorTest = !environment.isIntegrationTest();
    long expectedMinUs;
    if (isSingleSensorTest) {
        // When the sensor under test is the only one active, max fifo size is assumed to be
        // available.
        long expectedBatchUs = Math.min(maximumFifoUs, askedBatchUs);
        if (expectedBatchUs > 0) {
            // This sensor should be running in batching mode.
            expectedMinUs = effectiveDurationUs / expectedBatchUs * expectedBatchUs - expectedBatchUs / 5;
        } else {
            // streaming, allow actual rate to be as slow as 80% of the asked rate.
            expectedMinUs = effectiveDurationUs * 4 / 5;
        }
    } else {
        // More convoluted case. Batch size can vary from reserved fifo length to max fifo size.
        long minBatchUs = Math.min(reservedFifoUs, askedBatchUs);
        long maxBatchUs = Math.min(maximumFifoUs, askedBatchUs);
        // The worst scenario happens when the sensor batch time being just above half of the
        // test time, then the test can only receive one batch which halves the expected number
        // of samples. The expected number of samples received have a lower bound like the
        // figure below.
        // 
        // expected samples
        // ^
        // |                          ______
        // |\                        /
        // |  \                    /
        // |    \                /
        // |      \            /
        // |        \        /
        // |          \    /
        // |            \/
        // |
        // |
        // |
        // |
        // +------------+-----------+------->  actual batch size in time
        // 0   1/2*testDuration   testDuration
        // 
        long worstBatchUs = effectiveDurationUs / 2 + 1;
        if ((minBatchUs > worstBatchUs) == (maxBatchUs > worstBatchUs)) {
            // same side
            double ratio = Math.min(Math.abs(worstBatchUs - minBatchUs), Math.abs(worstBatchUs - maxBatchUs)) / (double) worstBatchUs;
            expectedMinUs = (long) ((ratio + 1) / 2 * testDurationUs) * 4 / 5;
        } else {
            // the worst case is possible
            expectedMinUs = worstBatchUs * 4 / 5;
        }
    }
    long expectedMinNumEvent = expectedMinUs / sampleUs;
    return new EventBasicVerification(expectedMinNumEvent, environment.getSensor());
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (VERBOSE)
        Log.v(TAG, "onReceive");
    String action = intent.getAction();
    if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
        if (state == BluetoothAdapter.STATE_TURNING_OFF) {
            if (DEBUG)
                Log.d(TAG, "STATE_TURNING_OFF");
            sendShutdownMessage();
        } else if (state == BluetoothAdapter.STATE_ON) {
            if (DEBUG)
                Log.d(TAG, "STATE_ON");
            // start RFCOMM listener
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
        }
    } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
        Log.v(TAG, " - Received BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY");
        if (!mIsWaitingAuthorization) {
            // this reply is not for us
            return;
        }
        mIsWaitingAuthorization = false;
        if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT, BluetoothDevice.CONNECTION_ACCESS_NO) == BluetoothDevice.CONNECTION_ACCESS_YES) {
            // bluetooth connection accepted by user
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = mRemoteDevice.setSimAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                if (VERBOSE) {
                    Log.v(TAG, "setSimAccessPermission(ACCESS_ALLOWED) result=" + result);
                }
            }
            try {
                if (mConnSocket != null) {
                    // start obex server and rfcomm connection
                    startSapServerSession();
                } else {
                    stopSapServerSession();
                }
            } catch (IOException ex) {
                Log.e(TAG, "Caught the error: ", ex);
            }
        } else {
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = mRemoteDevice.setSimAccessPermission(BluetoothDevice.ACCESS_REJECTED);
                if (VERBOSE) {
                    Log.v(TAG, "setSimAccessPermission(ACCESS_REJECTED) result=" + result);
                }
            }
            // Ensure proper cleanup, and prepare for new connect.
            mSessionStatusHandler.sendEmptyMessage(MSG_SERVERSESSION_CLOSE);
        }
    } else if (action.equals(USER_CONFIRM_TIMEOUT_ACTION)) {
        if (DEBUG)
            Log.d(TAG, "USER_CONFIRM_TIMEOUT ACTION Received.");
        // send us self a message about the timeout.
        sendConnectTimeoutMessage();
    } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED) && mIsWaitingAuthorization) {
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (mRemoteDevice == null || device == null) {
            Log.i(TAG, "Unexpected error!");
            return;
        }
        if (DEBUG)
            Log.d(TAG, "ACL disconnected for " + device);
        if (mRemoteDevice.equals(device)) {
            if (mRemoveTimeoutMsg) {
                // Send any pending timeout now, as ACL got disconnected.
                cancelUserTimeoutAlarm();
                mSessionStatusHandler.removeMessages(USER_TIMEOUT);
                sendCancelUserConfirmationIntent(mRemoteDevice);
                mRemoveTimeoutMsg = false;
            }
            mIsWaitingAuthorization = false;
            setState(BluetoothSap.STATE_DISCONNECTED);
            // Ensure proper cleanup, and prepare for new connect.
            mSessionStatusHandler.sendEmptyMessage(MSG_SERVERSESSION_CLOSE);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (VERBOSE)
        Log.v(TAG, "onReceive");
    String action = intent.getAction();
    if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
        if (state == BluetoothAdapter.STATE_TURNING_OFF) {
            if (DEBUG)
                Log.d(TAG, "STATE_TURNING_OFF");
            sendShutdownMessage();
        } else if (state == BluetoothAdapter.STATE_ON) {
            if (DEBUG)
                Log.d(TAG, "STATE_ON");
            // start RFCOMM listener
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
        }
    } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
        Log.v(TAG, " - Received BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY");
        if (!mIsWaitingAuthorization) {
            // this reply is not for us
            return;
        }
        mIsWaitingAuthorization = false;
        if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT, BluetoothDevice.CONNECTION_ACCESS_NO) == BluetoothDevice.CONNECTION_ACCESS_YES) {
            // bluetooth connection accepted by user
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = mRemoteDevice.setSimAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                if (VERBOSE) {
                    Log.v(TAG, "setSimAccessPermission(ACCESS_ALLOWED) result=" + result);
                }
            }
            try {
                if (mConnSocket != null) {
                    // start obex server and rfcomm connection
                    startSapServerSession();
                } else {
                    stopSapServerSession();
                }
            } catch (IOException ex) {
                Log.e(TAG, "Caught the error: ", ex);
            }
        } else {
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = mRemoteDevice.setSimAccessPermission(BluetoothDevice.ACCESS_REJECTED);
                if (VERBOSE) {
                    Log.v(TAG, "setSimAccessPermission(ACCESS_REJECTED) result=" + result);
                }
            }
            // Ensure proper cleanup, and prepare for new connect.
            mSessionStatusHandler.sendEmptyMessage(MSG_SERVERSESSION_CLOSE);
        }
    } else if (action.equals(USER_CONFIRM_TIMEOUT_ACTION)) {
        if (DEBUG)
            Log.d(TAG, "USER_CONFIRM_TIMEOUT ACTION Received.");
        // send us self a message about the timeout.
        sendConnectTimeoutMessage();
    } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED) && mIsWaitingAuthorization) {
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (mRemoteDevice == null || device == null) {
            Log.i(TAG, "Unexpected error!");
            return;
        }
        if (DEBUG)
            Log.d(TAG, "ACL disconnected for " + device);
        if (mRemoteDevice.equals(device)) {
            if (mRemoveTimeoutMsg) {
                // Send any pending timeout now, as ACL got disconnected.
                cancelUserTimeoutAlarm();
                mSessionStatusHandler.removeMessages(USER_TIMEOUT);
                sendCancelUserConfirmationIntent(mRemoteDevice);
            }
            mIsWaitingAuthorization = false;
            setState(BluetoothSap.STATE_DISCONNECTED);
            // Ensure proper cleanup, and prepare for new connect.
            mSessionStatusHandler.sendEmptyMessage(MSG_SERVERSESSION_CLOSE);
        }
    }
}
#end_block

#method_before
public void writeToParcel(Parcel out, int flags) {
    out.writeParcelable(new ParcelUuid(mUuid), 0);
    out.writeInt(mInstanceId);
    out.writeInt(mServiceType);
    out.writeTypedArray(mCharacteristics.toArray(new BluetoothGattCharacteristic[0]), 0);
    BluetoothGattIncludedService[] includedServices = new BluetoothGattIncludedService[mIncludedServices.size()];
    int i = 0;
    for (BluetoothGattService s : mIncludedServices) {
        includedServices[i] = new BluetoothGattIncludedService(s.getUuid(), s.getInstanceId(), s.getType());
        i++;
    }
    out.writeTypedArray(includedServices, 0);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeParcelable(new ParcelUuid(mUuid), 0);
    out.writeInt(mInstanceId);
    out.writeInt(mServiceType);
    out.writeTypedList(mCharacteristics);
    ArrayList<BluetoothGattIncludedService> includedServices = new ArrayList<BluetoothGattIncludedService>(mIncludedServices.size());
    for (BluetoothGattService s : mIncludedServices) {
        includedServices.add(new BluetoothGattIncludedService(s.getUuid(), s.getInstanceId(), s.getType()));
    }
    out.writeTypedList(includedServices);
}
#end_block

#method_before
public void writeToParcel(Parcel out, int flags) {
    out.writeParcelable(new ParcelUuid(mUuid), 0);
    out.writeInt(mInstance);
    out.writeInt(mProperties);
    out.writeInt(mPermissions);
    out.writeTypedArray(mDescriptors.toArray(new BluetoothGattDescriptor[0]), 0);
}
#method_after
public void writeToParcel(Parcel out, int flags) {
    out.writeParcelable(new ParcelUuid(mUuid), 0);
    out.writeInt(mInstance);
    out.writeInt(mProperties);
    out.writeInt(mPermissions);
    out.writeTypedList(mDescriptors);
}
#end_block

#method_before
public void test_isInfiniteD() {
    // Test for method boolean java.lang.Double.isInfinite(double)
    assertTrue("Infinity check failed", Double.isInfinite(Double.NEGATIVE_INFINITY) && (Double.isInfinite(Double.POSITIVE_INFINITY)) && !(Double.isInfinite(Double.MAX_VALUE)) && !(Double.isInfinite(Double.MIN_VALUE)) && !(Double.isInfinite(Double.Nan)) && !(Double.isInfinite(0.0)));
}
#method_after
public void test_isInfiniteD() {
    // Test for method boolean java.lang.Double.isInfinite(double)
    assertTrue(Double.isInfinite(Double.NEGATIVE_INFINITY));
    assertTrue(Double.isInfinite(Double.POSITIVE_INFINITY));
    assertFalse(Double.isInfinite(Double.MAX_VALUE));
    assertFalse(Double.isInfinite(Double.MIN_VALUE));
    assertFalse(Double.isInfinite(Double.NaN));
    assertFalse(Double.isInfinite(0.0));
}
#end_block

#method_before
public void test_isFiniteD() {
    // Test for method boolean java.lang.Double.isFinite(double)
    assertTrue("Finity check failed", !Double.isFinite(Double.NEGATIVE_INFINITY) && (!Double.isFinite(Double.POSITIVE_INFINITY)) && (Double.isFinite(Double.MAX_VALUE)) && (Double.isFinite(Double.MIN_VALUE)) && !(Double.isFinite(Double.Nan)) && (Double.isFinite(0.0)));
}
#method_after
public void test_isFiniteD() {
    // Test for method boolean java.lang.Double.isFinite(double)
    assertFalse(Double.isFinite(Double.NEGATIVE_INFINITY));
    assertFalse(Double.isFinite(Double.POSITIVE_INFINITY));
    assertTrue(Double.isFinite(Double.MAX_VALUE));
    assertTrue(Double.isFinite(Double.MIN_VALUE));
    assertFalse(Double.isFinite(Double.NaN));
    assertTrue(Double.isFinite(0.0));
}
#end_block

#method_before
public void test_isInfiniteF() {
    // Test for method boolean java.lang.Float.isInfinite(float)
    assertTrue("Infinity check failed", Float.isInfinite(Float.POSITIVE_INFINITY) && (Float.isInfinite(Float.NEGATIVE_INFINITY)) && !(Float.isInfinite(Float.MAX_VALUE)) && !(Float.isInfinite(Float.MIN_VALUE)) && !(Float.isInfinite(Float.NaN)) && !(Float.isInfinite(1.0f)));
}
#method_after
public void test_isInfiniteF() {
    // Test for method boolean java.lang.Float.isInfinite(float)
    assertTrue(Float.isInfinite(Float.POSITIVE_INFINITY));
    assertTrue(Float.isInfinite(Float.NEGATIVE_INFINITY));
    assertFalse(Float.isInfinite(Float.MAX_VALUE));
    assertFalse(Float.isInfinite(Float.MIN_VALUE));
    assertFalse(Float.isInfinite(Float.NaN));
    assertFalse(Float.isInfinite(1.0f));
}
#end_block

#method_before
public void test_isFiniteF() {
    // Test for method boolean java.lang.Float.isInfinite(float)
    assertTrue("Finity check failed", !Float.isFinite(Float.POSITIVE_INFINITY) && !(Float.isFinite(Float.NEGATIVE_INFINITY)) && (Float.isFinite(Float.MAX_VALUE)) && (Float.isFinite(Float.MIN_VALUE)) && !(Float.isFinite(Float.NaN)) && (Float.isFinite(1.0f)));
}
#method_after
public void test_isFiniteF() {
    // Test for method boolean java.lang.Float.isInfinite(float)
    assertFalse(Float.isFinite(Float.POSITIVE_INFINITY));
    assertFalse(Float.isFinite(Float.NEGATIVE_INFINITY));
    assertTrue(Float.isFinite(Float.MAX_VALUE));
    assertTrue(Float.isFinite(Float.MIN_VALUE));
    assertFalse(Float.isFinite(Float.NaN));
    assertTrue(Float.isFinite(1.0f));
}
#end_block

#method_before
private void run(@Nonnull RuntimeTestInfo rti) throws Exception {
    new RuntimeTestHelper(rti).setSourceLevel(SourceLevel.JAVA_8).addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), "24").addIgnoredCandidateToolchain(JillBasedToolchain.class).addIgnoredCandidateToolchain(JackApiV01.class).compileAndRunTest();
}
#method_after
private void run(@Nonnull RuntimeTestInfo rti) throws Exception {
    new RuntimeTestHelper(rti).setSourceLevel(SourceLevel.JAVA_8).addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(AndroidCompatibilityChecker.N_API_LEVEL)).addIgnoredCandidateToolchain(JillBasedToolchain.class).addIgnoredCandidateToolchain(JackApiV01.class).compileAndRunTest();
}
#end_block

#method_before
@Override
public void runConformTest(String[] srcDescription) {
    List<Class<? extends IToolchain>> excludeList = new ArrayList<Class<? extends IToolchain>>(1);
    excludeList.add(LegacyJillToolchain.class);
    excludeList.add(JackApiV01.class);
    JackBasedToolchain jackToolchain = null;
    try {
        jackToolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeList);
    } catch (AssumptionViolatedException e) {
        // Handle JUnit4 feature in JUnit3 tests.
        return;
    }
    try {
        File sourceFolder = buildSourceFolder(srcDescription);
        File dexOutDir = AbstractTestTools.createTempDir();
        // Build dex file
        File[] bootclasspath = jackToolchain.getDefaultBootClasspath();
        jackToolchain.addToClasspath(bootclasspath);
        jackToolchain.setSourceLevel(SourceLevel.JAVA_8);
        jackToolchain.srcToExe(dexOutDir, /* zipFile = */
        false, sourceFolder);
    } catch (Exception e) {
        e.printStackTrace();
        Assert.fail();
    }
}
#method_after
@Override
public void runConformTest(String[] srcDescription) {
    List<Class<? extends IToolchain>> excludeList = new ArrayList<Class<? extends IToolchain>>(1);
    excludeList.add(JillBasedToolchain.class);
    excludeList.add(JackApiV01.class);
    JackBasedToolchain jackToolchain = null;
    try {
        jackToolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeList);
    } catch (AssumptionViolatedException e) {
        // Handle JUnit4 feature in JUnit3 tests.
        return;
    }
    try {
        File sourceFolder = buildSourceFolder(srcDescription);
        File dexOutDir = AbstractTestTools.createTempDir();
        // Build dex file
        File[] bootclasspath = jackToolchain.getDefaultBootClasspath();
        jackToolchain.addToClasspath(bootclasspath);
        jackToolchain.setSourceLevel(SourceLevel.JAVA_8);
        jackToolchain.addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(AndroidCompatibilityChecker.N_API_LEVEL));
        jackToolchain.srcToExe(dexOutDir, /* zipFile = */
        false, sourceFolder);
    } catch (Exception e) {
        e.printStackTrace();
        Assert.fail();
    }
}
#end_block

#method_before
@Override
public void runConformTest(String[] srcDescription, String expectedResult) {
    List<Class<? extends IToolchain>> excludeList = new ArrayList<Class<? extends IToolchain>>(1);
    excludeList.add(LegacyJillToolchain.class);
    excludeList.add(JackApiV01.class);
    JackBasedToolchain jackToolchain = null;
    try {
        jackToolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeList);
    } catch (AssumptionViolatedException e) {
        // Handle JUnit4 feature in JUnit3 tests.
        return;
    }
    try {
        File dexOutDir = AbstractTestTools.createTempDir();
        File sourceFolder = buildSourceFolder(srcDescription);
        // Build dex file
        File[] bootclasspath = jackToolchain.getDefaultBootClasspath();
        jackToolchain.addToClasspath(bootclasspath);
        jackToolchain.setSourceLevel(SourceLevel.JAVA_8);
        jackToolchain.addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), "24");
        jackToolchain.srcToExe(dexOutDir, /* zipFile = */
        false, sourceFolder);
        File dexFile = new File(dexOutDir, "classes.dex");
        List<RuntimeRunner> runnerList = AbstractTestTools.listRuntimeTestRunners(null);
        for (RuntimeRunner runner : runnerList) {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ((AbstractRuntimeRunner) runner).setOutputStream(out);
            String mainClass = srcDescription[0].substring(0, srcDescription[0].lastIndexOf('.'));
            Assert.assertEquals(0, runner.run(new String[0], mainClass, dexFile));
            Assert.assertEquals(expectedResult, out.toString().trim());
        }
    } catch (Exception e) {
        e.printStackTrace();
        Assert.fail();
    }
}
#method_after
@Override
public void runConformTest(String[] srcDescription, String expectedResult) {
    List<Class<? extends IToolchain>> excludeList = new ArrayList<Class<? extends IToolchain>>(1);
    excludeList.add(JillBasedToolchain.class);
    excludeList.add(JackApiV01.class);
    JackBasedToolchain jackToolchain = null;
    try {
        jackToolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeList);
    } catch (AssumptionViolatedException e) {
        // Handle JUnit4 feature in JUnit3 tests.
        return;
    }
    try {
        File dexOutDir = AbstractTestTools.createTempDir();
        File sourceFolder = buildSourceFolder(srcDescription);
        // Build dex file
        File[] bootclasspath = jackToolchain.getDefaultBootClasspath();
        jackToolchain.addToClasspath(bootclasspath);
        jackToolchain.setSourceLevel(SourceLevel.JAVA_8);
        jackToolchain.addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(AndroidCompatibilityChecker.N_API_LEVEL));
        jackToolchain.srcToExe(dexOutDir, /* zipFile = */
        false, sourceFolder);
        File dexFile = new File(dexOutDir, "classes.dex");
        List<RuntimeRunner> runnerList = AbstractTestTools.listRuntimeTestRunners(null);
        for (RuntimeRunner runner : runnerList) {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ((AbstractRuntimeRunner) runner).setOutputStream(out);
            String mainClass = srcDescription[0].substring(0, srcDescription[0].lastIndexOf('.'));
            Assert.assertEquals(0, runner.run(new String[0], mainClass, dexFile));
            Assert.assertEquals(expectedResult, out.toString().trim());
        }
    } catch (Exception e) {
        e.printStackTrace();
        Assert.fail();
    }
}
#end_block

#method_before
private void run(@Nonnull RuntimeTestInfo rti) throws Exception {
    new RuntimeTestHelper(rti).addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), "24").setSourceLevel(SourceLevel.JAVA_8).addIgnoredCandidateToolchain(JillBasedToolchain.class).addIgnoredCandidateToolchain(JackApiV01.class).compileAndRunTest();
}
#method_after
private void run(@Nonnull RuntimeTestInfo rti) throws Exception {
    new RuntimeTestHelper(rti).addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(AndroidCompatibilityChecker.N_API_LEVEL)).setSourceLevel(SourceLevel.JAVA_8).addIgnoredCandidateToolchain(JillBasedToolchain.class).addIgnoredCandidateToolchain(JackApiV01.class).compileAndRunTest();
}
#end_block

#method_before
private void run(@Nonnull RuntimeTestInfo rti) throws Exception {
    new RuntimeTestHelper(rti).setSourceLevel(SourceLevel.JAVA_8).addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), "24").addIgnoredCandidateToolchain(JillBasedToolchain.class).addIgnoredCandidateToolchain(JackApiV01.class).compileAndRunTest();
}
#method_after
private void run(@Nonnull RuntimeTestInfo rti) throws Exception {
    new RuntimeTestHelper(rti).setSourceLevel(SourceLevel.JAVA_8).addProperty(Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(AndroidCompatibilityChecker.N_API_LEVEL)).addIgnoredCandidateToolchain(JillBasedToolchain.class).addIgnoredCandidateToolchain(JackApiV01.class).compileAndRunTest();
}
#end_block

#method_before
public static void run(@Nonnull Options options, @Nonnull RunnableHooks hooks) throws JackUserException, ProcessException {
    Event event = null;
    try {
        Config config = options.getConfig();
        ThreadConfig.setConfig(config);
        event = TracerFactory.getTracer().start(JackEventType.JACK_RUN);
        ConfigPrinterFactory.getConfigPrinter().printConfig(config);
        JSession session = getSession();
        OutputJackLibrary outputJackLibrary = null;
        try {
            outputJackLibrary = createOutputJackLibrary();
            session.setJackOutputLibrary(outputJackLibrary);
            buildSession(session, options, hooks);
            Request request = createInitialRequest();
            request.addFeature(PreProcessor.class);
            request.addFeature(Resources.class);
            JavaVersion sourceVersion = config.get(Options.JAVA_SOURCE_VERSION);
            if (sourceVersion.compareTo(JavaVersion.JAVA_7) >= 0) {
                request.addFeature(SourceVersion7.class);
            }
            if (sourceVersion.compareTo(JavaVersion.JAVA_8) >= 0) {
                request.addFeature(SourceVersion8.class);
            }
            if (config.get(Options.DROP_METHOD_BODY).booleanValue()) {
                request.addFeature(DropMethodBody.class);
            }
            if (config.get(Options.ENABLE_COMPILED_FILES_STATISTICS).booleanValue()) {
                request.addFeature(CompiledTypeStats.class);
                request.addFeature(CodeStats.class);
            }
            if (config.get(Options.SANITY_CHECKS).booleanValue()) {
                request.addFeature(SanityChecks.class);
            }
            if (config.get(OriginDigestFeature.ORIGIN_DIGEST).booleanValue()) {
                request.addFeature(OriginDigestFeature.class);
            }
            if (config.get(PackageRenamer.JARJAR_ENABLED).booleanValue()) {
                request.addFeature(Jarjar.class);
            }
            if (config.get(VisibilityBridgeAdder.VISIBILITY_BRIDGE).booleanValue()) {
                request.addFeature(VisibilityBridge.class);
            }
            if (options.flags != null) {
                if (options.flags.shrink()) {
                    request.addFeature(Shrinking.class);
                }
                if (options.flags.obfuscate()) {
                    request.addFeature(Obfuscation.class);
                    if (!options.flags.keepAttribute("EnclosingMethod")) {
                        request.addFeature(RemoveEnclosingMethod.class);
                    }
                    if (!options.flags.keepAttribute("InnerClasses")) {
                        request.addFeature(RemoveEnclosingType.class);
                    }
                    if (!options.flags.keepAttribute("Signature")) {
                        request.addFeature(RemoveGenericSignature.class);
                    }
                    if (!options.flags.keepAttribute("AnnotationDefault")) {
                        request.addFeature(RemoveAnnotationDefaultValue.class);
                    }
                    if (!options.flags.keepAttribute("LocalVariableTypeTable")) {
                        request.addFeature(RemoveLocalVariableGenericSignature.class);
                    }
                    if (!options.flags.keepAttribute("Exceptions")) {
                        request.addFeature(RemoveThrownException.class);
                    }
                    if (!options.flags.keepAttribute("SourceFile")) {
                        request.addFeature(RemoveSourceFile.class);
                    }
                    if (!options.flags.keepAttribute("LineNumberTable")) {
                        request.addFeature(RemoveLineNumber.class);
                    }
                    if (!options.flags.keepAttribute("LocalVariableTable")) {
                        request.addFeature(RemoveLocalVariableName.class);
                        if (!options.flags.getKeepParameterNames()) {
                            request.addFeature(RemoveParameterName.class);
                        }
                    }
                }
                if (options.flags.printSeeds()) {
                    request.addProduction(SeedFile.class);
                }
                if (options.flags.getRenameSourceFileAttribute() != null) {
                    request.addFeature(SourceFileRenaming.class);
                }
                if (options.flags.getAdaptResourceFileContents() != null) {
                    request.addFeature(AdaptResourceFileContent.class);
                }
            }
            if (config.get(MappingPrinter.MAPPING_OUTPUT_ENABLED).booleanValue()) {
                request.addProduction(Mapping.class);
            }
            if (config.get(ShrinkStructurePrinter.STRUCTURE_PRINTING).booleanValue()) {
                request.addProduction(StructurePrinting.class);
            }
            if (config.get(MultiDexLegacy.MULTIDEX_LEGACY).booleanValue()) {
                request.addFeature(MultiDexLegacy.class);
            }
            DexWritingTool dexWritingTool = config.get(DexFileWriter.DEX_WRITING_POLICY);
            if (dexWritingTool instanceof MultiDexWritingTool) {
                request.addFeature(MultiDex.class);
            }
            if (config.get(Options.INCREMENTAL_MODE).booleanValue()) {
                request.addFeature(Incremental.class);
            }
            if (config.get(Options.GENERATE_LIBRARY_FROM_INCREMENTAL_FOLDER).booleanValue()) {
                request.addFeature(GenerateLibraryFromIncrementalFolder.class);
            }
            if (config.get(Options.OPTIMIZE_INNER_CLASSES_ACCESSORS).booleanValue()) {
                request.addFeature(AvoidSynthethicAccessors.class);
            }
            if (config.get(Options.OPTIMIZE_TAIL_RECURSION).booleanValue()) {
                request.addFeature(TailRecursionOptimization.class);
            }
            request.addInitialTagsOrMarkers(getJavaSourceInitialTagSet());
            request.addInitialTagsOrMarkers(getJackFormatInitialTagSet());
            if (config.get(Options.GENERATE_DEX_IN_LIBRARY).booleanValue()) {
                request.addProduction(DexInLibraryProduct.class);
            }
            if (config.get(Options.LAMBDA_TO_ANONYMOUS_CONVERTER).booleanValue()) {
                request.addFeature(LambdaToAnonymousConverter.class);
            }
            if (config.get(CodeItemBuilder.EXPERIMENTAL_LAMBDA_OPCODES).booleanValue()) {
                request.addFeature(LambdaUseExperimentalOpcodes.class);
            }
            if (config.get(Options.GENERATE_DEX_FILE).booleanValue()) {
                request.addProduction(DexFileProduct.class);
                session.addGeneratedFileType(FileType.PREBUILT);
            }
            if (config.get(Options.OPTIMIZED_ENUM_SWITCH) == SwitchEnumOptStrategy.FEEDBACK) {
                request.addFeature(OptimizedSwitchEnumFeedbackFeature.class);
            } else if (config.get(Options.OPTIMIZED_ENUM_SWITCH) == SwitchEnumOptStrategy.ALWAYS) {
                request.addFeature(OptimizedSwitchEnumNonFeedbackFeature.class);
            }
            if (config.get(Optimizations.DefUseSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.DefUseSimplifier.class);
            }
            if (config.get(Optimizations.UseDefSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.UseDefSimplifier.class);
            }
            if (config.get(Optimizations.ExpressionSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.ExpressionSimplifier.class);
            }
            if (config.get(Optimizations.IfSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.IfSimplifier.class);
            }
            if (config.get(Optimizations.NotSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.NotSimplifier.class);
            }
            if (config.get(Options.ASSERTION_POLICY) == AssertionPolicy.ENABLE) {
                request.addFeature(EnabledAssertionFeature.class);
            } else if (config.get(Options.ASSERTION_POLICY) == AssertionPolicy.DYNAMIC) {
                request.addFeature(DynamicAssertionFeature.class);
            } else if (config.get(Options.ASSERTION_POLICY) == AssertionPolicy.DISABLE) {
                request.addFeature(DisabledAssertionFeature.class);
            }
            if (config.get(Options.GENERATE_JAYCE_IN_LIBRARY).booleanValue()) {
                request.addProduction(JayceInLibraryProduct.class);
            }
            if (config.get(Options.GENERATE_DEPENDENCIES_IN_LIBRARY).booleanValue()) {
                request.addProduction(DependencyInLibraryProduct.class);
            }
            if (config.get(TypeDefRemover.REMOVE_TYPEDEF).booleanValue()) {
                request.addFeature(TypeDefRemover.RemoveTypeDef.class);
            }
            if (config.get(Options.CODE_COVERVAGE).booleanValue()) {
                request.addFeature(CodeCoverage.class);
                request.addProduction(CodeCoverageMetadataFile.class);
            }
            long nApiLevel = 24;
            if (config.get(Options.ANDROID_MIN_API_LEVEL).longValue() < nApiLevel) {
                request.addFeature(DetectUnsupportedJava8IR.class);
            }
            // TODO(jack-team): Remove this hack
            boolean preDexing = !getSession().getImportedLibraries().isEmpty();
            for (InputLibrary il : getSession().getImportedLibraries()) {
                if (!il.containsFileType(FileType.PREBUILT)) {
                    preDexing = false;
                }
            }
            logger.log(Level.INFO, "Jack pre-dexing is " + (preDexing ? "enabled" : "disabled"));
            for (InputLibrary il : getSession().getImportedLibraries()) {
                if (!config.get(Options.USE_PREBUILT_FROM_LIBRARY).booleanValue() || !((InputJackLibrary) il).hasCompliantPrebuilts()) {
                    ((InputJackLibrary) il).fileTypes.remove(FileType.PREBUILT);
                }
            }
            ProductionSet targetProduction = request.getTargetProductions();
            FeatureSet features = request.getFeatures();
            PlanBuilder<JSession> planBuilder;
            try {
                planBuilder = request.getPlanBuilder(JSession.class);
            } catch (IllegalRequestException e) {
                throw new AssertionError(e);
            }
            if (features.contains(OriginDigestFeature.class)) {
                SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
                typePlan.append(OriginDigestAdder.class);
            }
            planBuilder.append(PreProcessorApplier.class);
            fillDexPlan(planBuilder);
            if (targetProduction.contains(DexFileProduct.class)) {
                planBuilder.append(DexFileWriter.class);
            }
            if (features.contains(Resources.class)) {
                if (targetProduction.contains(DexFileProduct.class)) {
                    planBuilder.append(ResourceWriter.class);
                }
                if (targetProduction.contains(JayceInLibraryProduct.class)) {
                    planBuilder.append(LibraryResourceWriter.class);
                }
            }
            if (targetProduction.contains(JayceInLibraryProduct.class)) {
                planBuilder.append(LibraryMetaWriter.class);
            }
            Plan<JSession> plan;
            try {
                // Try to build an automatic plan ...
                try {
                    plan = request.buildPlan(JSession.class);
                } catch (PlanNotFoundException e) {
                    throw new AssertionError(e);
                } catch (IllegalRequestException e) {
                    throw new AssertionError(e);
                }
            } catch (UnsupportedOperationException e) {
                // ... but use a manual one if not supported
                plan = planBuilder.getPlan();
                assert !targetProduction.contains(JayceInLibraryProduct.class) || targetProduction.contains(DexFileProduct.class) || (plan.computeFinalTagsOrMarkers(request.getInitialTags()).contains(JackFormatIr.class) && !targetProduction.contains(DexInLibraryProduct.class)) || ((targetProduction.contains(DexInLibraryProduct.class) && targetProduction.contains(JayceInLibraryProduct.class)) || !config.get(Options.GENERATE_DEX_IN_LIBRARY).booleanValue());
            }
            PlanPrinterFactory.getPlanPrinter().printPlan(plan);
            plan.getScheduleInstance().process(session);
        } finally {
            try {
                if (outputJackLibrary != null) {
                    outputJackLibrary.close();
                }
                // TODO(jack-team): auto-close
                if (config.get(Options.GENERATE_DEX_FILE).booleanValue() && config.get(Options.DEX_OUTPUT_CONTAINER_TYPE) == Container.ZIP) {
                    config.get(Options.DEX_OUTPUT_ZIP).close();
                }
            } catch (LibraryIOException e) {
                throw new AssertionError(e);
            } catch (IOException e) {
                throw new AssertionError(e);
            }
        }
    } finally {
        if (event != null) {
            event.end();
        }
        ThreadConfig.unsetConfig();
    }
}
#method_after
public static void run(@Nonnull Options options, @Nonnull RunnableHooks hooks) throws JackUserException, ProcessException {
    Event event = null;
    try {
        Config config = options.getConfig();
        ThreadConfig.setConfig(config);
        event = TracerFactory.getTracer().start(JackEventType.JACK_RUN);
        ConfigPrinterFactory.getConfigPrinter().printConfig(config);
        JSession session = getSession();
        OutputJackLibrary outputJackLibrary = null;
        try {
            outputJackLibrary = createOutputJackLibrary();
            session.setJackOutputLibrary(outputJackLibrary);
            buildSession(session, options, hooks);
            Request request = createInitialRequest();
            request.addFeature(PreProcessor.class);
            request.addFeature(Resources.class);
            JavaVersion sourceVersion = config.get(Options.JAVA_SOURCE_VERSION);
            if (sourceVersion.compareTo(JavaVersion.JAVA_7) >= 0) {
                request.addFeature(SourceVersion7.class);
            }
            if (sourceVersion.compareTo(JavaVersion.JAVA_8) >= 0) {
                request.addFeature(SourceVersion8.class);
            }
            if (config.get(Options.DROP_METHOD_BODY).booleanValue()) {
                request.addFeature(DropMethodBody.class);
            }
            if (config.get(Options.ENABLE_COMPILED_FILES_STATISTICS).booleanValue()) {
                request.addFeature(CompiledTypeStats.class);
                request.addFeature(CodeStats.class);
            }
            if (config.get(Options.SANITY_CHECKS).booleanValue()) {
                request.addFeature(SanityChecks.class);
            }
            if (config.get(OriginDigestFeature.ORIGIN_DIGEST).booleanValue()) {
                request.addFeature(OriginDigestFeature.class);
            }
            if (config.get(PackageRenamer.JARJAR_ENABLED).booleanValue()) {
                request.addFeature(Jarjar.class);
            }
            if (config.get(VisibilityBridgeAdder.VISIBILITY_BRIDGE).booleanValue()) {
                request.addFeature(VisibilityBridge.class);
            }
            if (options.flags != null) {
                if (options.flags.shrink()) {
                    request.addFeature(Shrinking.class);
                }
                if (options.flags.obfuscate()) {
                    request.addFeature(Obfuscation.class);
                    if (!options.flags.keepAttribute("EnclosingMethod")) {
                        request.addFeature(RemoveEnclosingMethod.class);
                    }
                    if (!options.flags.keepAttribute("InnerClasses")) {
                        request.addFeature(RemoveEnclosingType.class);
                    }
                    if (!options.flags.keepAttribute("Signature")) {
                        request.addFeature(RemoveGenericSignature.class);
                    }
                    if (!options.flags.keepAttribute("AnnotationDefault")) {
                        request.addFeature(RemoveAnnotationDefaultValue.class);
                    }
                    if (!options.flags.keepAttribute("LocalVariableTypeTable")) {
                        request.addFeature(RemoveLocalVariableGenericSignature.class);
                    }
                    if (!options.flags.keepAttribute("Exceptions")) {
                        request.addFeature(RemoveThrownException.class);
                    }
                    if (!options.flags.keepAttribute("SourceFile")) {
                        request.addFeature(RemoveSourceFile.class);
                    }
                    if (!options.flags.keepAttribute("LineNumberTable")) {
                        request.addFeature(RemoveLineNumber.class);
                    }
                    if (!options.flags.keepAttribute("LocalVariableTable")) {
                        request.addFeature(RemoveLocalVariableName.class);
                        if (!options.flags.getKeepParameterNames()) {
                            request.addFeature(RemoveParameterName.class);
                        }
                    }
                }
                if (options.flags.printSeeds()) {
                    request.addProduction(SeedFile.class);
                }
                if (options.flags.getRenameSourceFileAttribute() != null) {
                    request.addFeature(SourceFileRenaming.class);
                }
                if (options.flags.getAdaptResourceFileContents() != null) {
                    request.addFeature(AdaptResourceFileContent.class);
                }
            }
            if (config.get(MappingPrinter.MAPPING_OUTPUT_ENABLED).booleanValue()) {
                request.addProduction(Mapping.class);
            }
            if (config.get(ShrinkStructurePrinter.STRUCTURE_PRINTING).booleanValue()) {
                request.addProduction(StructurePrinting.class);
            }
            if (config.get(MultiDexLegacy.MULTIDEX_LEGACY).booleanValue()) {
                request.addFeature(MultiDexLegacy.class);
            }
            DexWritingTool dexWritingTool = config.get(DexFileWriter.DEX_WRITING_POLICY);
            if (dexWritingTool instanceof MultiDexWritingTool) {
                request.addFeature(MultiDex.class);
            }
            if (config.get(Options.INCREMENTAL_MODE).booleanValue()) {
                request.addFeature(Incremental.class);
            }
            if (config.get(Options.GENERATE_LIBRARY_FROM_INCREMENTAL_FOLDER).booleanValue()) {
                request.addFeature(GenerateLibraryFromIncrementalFolder.class);
            }
            if (config.get(Options.OPTIMIZE_INNER_CLASSES_ACCESSORS).booleanValue()) {
                request.addFeature(AvoidSynthethicAccessors.class);
            }
            if (config.get(Options.OPTIMIZE_TAIL_RECURSION).booleanValue()) {
                request.addFeature(TailRecursionOptimization.class);
            }
            request.addInitialTagsOrMarkers(getJavaSourceInitialTagSet());
            request.addInitialTagsOrMarkers(getJackFormatInitialTagSet());
            if (config.get(Options.GENERATE_DEX_IN_LIBRARY).booleanValue()) {
                request.addProduction(DexInLibraryProduct.class);
            }
            if (config.get(Options.LAMBDA_TO_ANONYMOUS_CONVERTER).booleanValue()) {
                request.addFeature(LambdaToAnonymousConverter.class);
            }
            if (config.get(CodeItemBuilder.EXPERIMENTAL_LAMBDA_OPCODES).booleanValue()) {
                request.addFeature(LambdaUseExperimentalOpcodes.class);
            }
            if (config.get(Options.GENERATE_DEX_FILE).booleanValue()) {
                request.addProduction(DexFileProduct.class);
                session.addGeneratedFileType(FileType.PREBUILT);
            }
            if (config.get(AndroidCompatibilityChecker.CHECK_COMPATIBILITY).booleanValue()) {
                request.addFeature(CheckAndroidCompatibility.class);
            }
            if (config.get(Options.OPTIMIZED_ENUM_SWITCH) == SwitchEnumOptStrategy.FEEDBACK) {
                request.addFeature(OptimizedSwitchEnumFeedbackFeature.class);
            } else if (config.get(Options.OPTIMIZED_ENUM_SWITCH) == SwitchEnumOptStrategy.ALWAYS) {
                request.addFeature(OptimizedSwitchEnumNonFeedbackFeature.class);
            }
            if (config.get(Optimizations.DefUseSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.DefUseSimplifier.class);
            }
            if (config.get(Optimizations.UseDefSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.UseDefSimplifier.class);
            }
            if (config.get(Optimizations.ExpressionSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.ExpressionSimplifier.class);
            }
            if (config.get(Optimizations.IfSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.IfSimplifier.class);
            }
            if (config.get(Optimizations.NotSimplifier.ENABLE).booleanValue()) {
                request.addFeature(Optimizations.NotSimplifier.class);
            }
            if (config.get(Options.ASSERTION_POLICY) == AssertionPolicy.ENABLE) {
                request.addFeature(EnabledAssertionFeature.class);
            } else if (config.get(Options.ASSERTION_POLICY) == AssertionPolicy.DYNAMIC) {
                request.addFeature(DynamicAssertionFeature.class);
            } else if (config.get(Options.ASSERTION_POLICY) == AssertionPolicy.DISABLE) {
                request.addFeature(DisabledAssertionFeature.class);
            }
            if (config.get(Options.GENERATE_JAYCE_IN_LIBRARY).booleanValue()) {
                request.addProduction(JayceInLibraryProduct.class);
            }
            if (config.get(Options.GENERATE_DEPENDENCIES_IN_LIBRARY).booleanValue()) {
                request.addProduction(DependencyInLibraryProduct.class);
            }
            if (config.get(TypeDefRemover.REMOVE_TYPEDEF).booleanValue()) {
                request.addFeature(TypeDefRemover.RemoveTypeDef.class);
            }
            if (config.get(CodeCoverage.CODE_COVERVAGE).booleanValue()) {
                request.addFeature(CodeCoverage.class);
                request.addProduction(CodeCoverageMetadataFile.class);
            }
            // TODO(jack-team): Remove this hack
            List<InputLibrary> importedLibraries = session.getImportedLibraries();
            boolean preDexing = !importedLibraries.isEmpty();
            for (InputLibrary il : importedLibraries) {
                if (!il.containsFileType(FileType.PREBUILT)) {
                    preDexing = false;
                }
            }
            logger.log(Level.INFO, "Jack pre-dexing is " + (preDexing ? "enabled" : "disabled"));
            for (InputLibrary il : importedLibraries) {
                if (!config.get(Options.USE_PREBUILT_FROM_LIBRARY).booleanValue() || !((InputJackLibrary) il).hasCompliantPrebuilts()) {
                    ((InputJackLibrary) il).fileTypes.remove(FileType.PREBUILT);
                }
            }
            ProductionSet targetProduction = request.getTargetProductions();
            FeatureSet features = request.getFeatures();
            PlanBuilder<JSession> planBuilder;
            try {
                planBuilder = request.getPlanBuilder(JSession.class);
            } catch (IllegalRequestException e) {
                throw new AssertionError(e);
            }
            if (features.contains(OriginDigestFeature.class)) {
                SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
                typePlan.append(OriginDigestAdder.class);
            }
            planBuilder.append(PreProcessorApplier.class);
            fillDexPlan(planBuilder);
            if (targetProduction.contains(DexFileProduct.class)) {
                planBuilder.append(DexFileWriter.class);
            }
            if (features.contains(Resources.class)) {
                if (targetProduction.contains(DexFileProduct.class)) {
                    planBuilder.append(ResourceWriter.class);
                }
                if (targetProduction.contains(JayceInLibraryProduct.class)) {
                    planBuilder.append(LibraryResourceWriter.class);
                }
            }
            if (targetProduction.contains(JayceInLibraryProduct.class)) {
                planBuilder.append(LibraryMetaWriter.class);
            }
            Plan<JSession> plan;
            try {
                // Try to build an automatic plan ...
                try {
                    plan = request.buildPlan(JSession.class);
                } catch (PlanNotFoundException e) {
                    throw new AssertionError(e);
                } catch (IllegalRequestException e) {
                    throw new AssertionError(e);
                }
            } catch (UnsupportedOperationException e) {
                // ... but use a manual one if not supported
                plan = planBuilder.getPlan();
                assert !targetProduction.contains(JayceInLibraryProduct.class) || targetProduction.contains(DexFileProduct.class) || (plan.computeFinalTagsOrMarkers(request.getInitialTags()).contains(JackFormatIr.class) && !targetProduction.contains(DexInLibraryProduct.class)) || ((targetProduction.contains(DexInLibraryProduct.class) && targetProduction.contains(JayceInLibraryProduct.class)) || !config.get(Options.GENERATE_DEX_IN_LIBRARY).booleanValue());
            }
            PlanPrinterFactory.getPlanPrinter().printPlan(plan);
            plan.getScheduleInstance().process(session);
        } finally {
            try {
                if (outputJackLibrary != null) {
                    outputJackLibrary.close();
                }
                // TODO(jack-team): auto-close
                if (config.get(Options.GENERATE_DEX_FILE).booleanValue() && config.get(Options.DEX_OUTPUT_CONTAINER_TYPE) == Container.ZIP) {
                    config.get(Options.DEX_OUTPUT_ZIP).close();
                }
                for (InputLibrary importedLibrary : session.getImportedLibraries()) {
                    try {
                        importedLibrary.close();
                    } catch (LibraryIOException e) {
                        // ignore and log I/O errors when closing
                        logger.log(Level.FINE, "Cannot close input jack library " + importedLibrary.getLocation().getDescription());
                    }
                }
                for (InputLibrary classpathLibrary : session.getLibraryOnClasspath()) {
                    try {
                        classpathLibrary.close();
                    } catch (LibraryIOException e) {
                        // ignore and log I/O errors when closing
                        logger.log(Level.FINE, "Cannot close input jack library " + classpathLibrary.getLocation().getDescription());
                    }
                }
            } catch (LibraryIOException e) {
                throw new AssertionError(e);
            } catch (IOException e) {
                throw new AssertionError(e);
            }
        }
    } finally {
        if (event != null) {
            event.end();
        }
        ThreadConfig.unsetConfig();
    }
}
#end_block

#method_before
@Nonnull
private static void buildSession(@Nonnull JSession session, @Nonnull Options options, @Nonnull RunnableHooks hooks) throws JackUserException {
    Tracer tracer = TracerFactory.getTracer();
    session.setHooks(hooks);
    session.setReporter(ThreadConfig.get(Reporter.REPORTER));
    Config config = ThreadConfig.getConfig();
    InputFilter inputFilter;
    try {
        inputFilter = config.get(Options.INPUT_FILTER).create(options);
        session.setInputFilter(inputFilter);
    } catch (RuntimeException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JackAbortException) {
            throw (JackAbortException) cause;
        } else if (cause instanceof JackUserException) {
            throw (JackUserException) cause;
        } else {
            throw e;
        }
    }
    new MetaImporter(config.get(MetaImporter.IMPORTED_META)).doImport(session);
    List<InputJackLibrary> inputJackLibraries = new ArrayList<InputJackLibrary>();
    for (InputLibrary library : inputFilter.getImportedLibrary()) {
        if (library instanceof InputJackLibrary) {
            addPackageLoaderForLibrary(session, config.get(IMPORT_POLICY), (InputJackLibrary) library);
            inputJackLibraries.add((InputJackLibrary) library);
            session.addImportedLibrary(library);
        }
    }
    JayceFileImporter jayceImporter = new JayceFileImporter(inputJackLibraries);
    for (InputLibrary library : inputFilter.getClasspath()) {
        if (library instanceof InputJackLibrary) {
            addPackageLoaderForLibrary(session, config.get(CLASSPATH_POLICY), (InputJackLibrary) library);
            session.addLibraryOnClasspath(library);
        }
    }
    Set<String> fileNamesToCompile = inputFilter.getFileNamesToCompile();
    if (!fileNamesToCompile.isEmpty()) {
        JackBatchCompiler jbc = new JackBatchCompiler(session);
        Event event = tracer.start(JackEventType.ECJ_COMPILATION);
        List<String> ecjExtraArguments = options.getEcjExtraArguments();
        List<String> ecjArguments = new ArrayList<String>(ecjExtraArguments.size() + fileNamesToCompile.size());
        ecjArguments.addAll(ecjExtraArguments);
        ecjArguments.addAll(fileNamesToCompile);
        try {
            if (!jbc.compile(ecjArguments.toArray(new String[ecjArguments.size()]))) {
                throw new FrontendCompilationException("Failed to compile");
            }
        } catch (TransportExceptionAroundEcjError e) {
            throw e.getCause();
        } catch (TransportJUEAroundEcjError e) {
            throw e.getCause();
        } finally {
            event.end();
        }
    }
    try {
        new ResourceImporter(config.get(ResourceImporter.IMPORTED_RESOURCES)).doImport(session);
    } catch (ResourceReadingException e) {
        session.getReporter().report(Severity.FATAL, e);
        throw new JackAbortException(e);
    }
    try {
        jayceImporter.doJayceImport(session);
        jayceImporter.doResourceImport(session);
    } catch (LibraryReadingException e) {
        session.getReporter().report(Severity.FATAL, e);
        throw new JackAbortException(e);
    }
}
#method_after
@Nonnull
private static void buildSession(@Nonnull JSession session, @Nonnull Options options, @Nonnull RunnableHooks hooks) throws JackUserException {
    Tracer tracer = TracerFactory.getTracer();
    session.setHooks(hooks);
    session.setReporter(ThreadConfig.get(Reporter.REPORTER));
    Config config = ThreadConfig.getConfig();
    InputFilter inputFilter;
    try {
        inputFilter = config.get(Options.INPUT_FILTER).create(options);
        session.setInputFilter(inputFilter);
    } catch (RuntimeException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JackAbortException) {
            throw (JackAbortException) cause;
        } else if (cause instanceof JackUserException) {
            throw (JackUserException) cause;
        } else {
            throw e;
        }
    }
    new MetaImporter(config.get(MetaImporter.IMPORTED_META)).doImport(session);
    List<InputJackLibrary> inputJackLibraries = new ArrayList<InputJackLibrary>();
    for (InputLibrary library : inputFilter.getImportedLibraries()) {
        if (library instanceof InputJackLibrary) {
            addPackageLoaderForLibrary(session, config.get(IMPORT_POLICY), (InputJackLibrary) library);
            inputJackLibraries.add((InputJackLibrary) library);
            session.addImportedLibrary(library);
        }
    }
    JayceFileImporter jayceImporter = new JayceFileImporter(inputJackLibraries);
    for (InputLibrary library : inputFilter.getClasspath()) {
        if (library instanceof InputJackLibrary) {
            addPackageLoaderForLibrary(session, config.get(CLASSPATH_POLICY), (InputJackLibrary) library);
            session.addLibraryOnClasspath(library);
        }
    }
    Set<String> fileNamesToCompile = inputFilter.getFileNamesToCompile();
    if (!fileNamesToCompile.isEmpty()) {
        JackBatchCompiler jbc = new JackBatchCompiler(session);
        Event event = tracer.start(JackEventType.ECJ_COMPILATION);
        List<String> ecjExtraArguments = options.getEcjExtraArguments();
        List<String> ecjArguments = new ArrayList<String>(ecjExtraArguments.size() + fileNamesToCompile.size());
        ecjArguments.addAll(ecjExtraArguments);
        ecjArguments.addAll(fileNamesToCompile);
        try {
            if (!jbc.compile(ecjArguments.toArray(new String[ecjArguments.size()]))) {
                throw new FrontendCompilationException("Failed to compile");
            }
        } catch (TransportExceptionAroundEcjError e) {
            throw e.getCause();
        } catch (TransportJUEAroundEcjError e) {
            throw e.getCause();
        } finally {
            event.end();
        }
    }
    try {
        new ResourceImporter(config.get(ResourceImporter.IMPORTED_RESOURCES)).doImport(session);
    } catch (ResourceReadingException e) {
        session.getReporter().report(Severity.FATAL, e);
        throw new JackAbortException(e);
    }
    try {
        jayceImporter.doJayceImport(session);
        jayceImporter.doResourceImport(session);
    } catch (LibraryReadingException e) {
        session.getReporter().report(Severity.FATAL, e);
        throw new JackAbortException(e);
    }
}
#end_block

#method_before
static void fillDexPlan(@Nonnull PlanBuilder<JSession> planBuilder) {
    FeatureSet features = planBuilder.getRequest().getFeatures();
    ProductionSet productions = planBuilder.getRequest().getTargetProductions();
    boolean hasSanityChecks = features.contains(SanityChecks.class);
    // Build the plan
    if (features.contains(Shrinking.class) || features.contains(Obfuscation.class) || features.contains(MultiDexLegacy.class)) {
        planBuilder.append(MethodIdMerger.class);
        planBuilder.append(VirtualMethodsMarker.Remover.class);
        planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class).append(MethodIdDuplicateRemover.class);
    }
    if (hasSanityChecks) {
        planBuilder.append(TypeDuplicateRemoverChecker.class);
    }
    if (features.contains(RemoveTypeDef.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        typePlan.append(TypeDefRemover.class);
    }
    appendStringRefiners(planBuilder);
    if (features.contains(Jarjar.class)) {
        planBuilder.append(PackageRenamer.class);
    }
    if (hasSanityChecks) {
        planBuilder.append(AstChecker.class);
    }
    if (features.contains(CodeCoverage.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        typePlan.append(CodeCoverageSelector.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        {
            if (features.contains(CompiledTypeStats.class)) {
                SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
                methodPlan.append(MethodStats.class);
            }
        }
        {
            SubPlanBuilder<JField> fieldPlan = typePlan.appendSubPlan(JFieldAdapter.class);
            if (features.contains(CompiledTypeStats.class)) {
                fieldPlan.append(FieldStats.class);
            }
            fieldPlan.append(FieldInitializerRemover.class);
        }
    }
    appendMultiDexAndShrobStartPlan(planBuilder);
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        typePlan.append(UsedEnumFieldCollector.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan2 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        {
            if (features.contains(VisibilityBridge.class)) {
                typePlan2.append(VisibilityBridgeAdder.class);
            }
            if (features.contains(Optimizations.NotSimplifier.class) || features.contains(SourceVersion7.class)) {
                SubPlanBuilder<JMethod> methodPlan = typePlan2.appendSubPlan(JMethodAdapter.class);
                if (features.contains(Optimizations.NotSimplifier.class)) {
                    methodPlan.append(NotSimplifier.class);
                }
                if (features.contains(SourceVersion7.class)) {
                    methodPlan.append(TryWithResourcesTransformer.class);
                }
            }
        }
    }
    if (features.contains(DetectUnsupportedJava8IR.class)) {
        planBuilder.append(DefaultAndStaticMethodChecker.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan3 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        {
            {
                SubPlanBuilder<JMethod> methodPlan2 = typePlan3.appendSubPlan(JMethodAdapter.class);
                methodPlan2.append(ImplicitBlocks.class);
                if (hasSanityChecks) {
                    methodPlan2.append(ImplicitBlocksChecker.class);
                }
                if (hasSanityChecks) {
                    methodPlan2.append(UselessIfChecker.class);
                }
                methodPlan2.append(IncDecRemover.class);
                methodPlan2.append(CompoundAssignmentRemover.class);
                methodPlan2.append(ConcatRemover.class);
            }
        }
    }
    if (features.contains(OptimizedSwitchEnumFeedbackFeature.class)) {
        // add one more traversal at compile-time to collect the usage for each enum,
        // figure out how many classes use enum in switch statement.
        // this step is enabled only when feedback-based optimization is enabled
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        methodPlan.append(SwitchEnumUsageCollector.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        if (features.contains(OptimizedSwitchEnumFeedbackFeature.class) || features.contains(OptimizedSwitchEnumNonFeedbackFeature.class)) {
            methodPlan.append(OptimizedSwitchEnumSupport.class);
        } else {
            methodPlan.append(SwitchEnumSupport.class);
        }
    }
    if ((features.contains(OptimizedSwitchEnumFeedbackFeature.class) || features.contains(OptimizedSwitchEnumNonFeedbackFeature.class)) && hasSanityChecks) {
        // check the validity of instrumentation if switch enum optimization and
        // hasSanityCheck are both set
        planBuilder.append(AstChecker.class);
    }
    planBuilder.append(InnerAccessorGeneratorSchedulingSeparator.class);
    if (!features.contains(LambdaToAnonymousConverter.class)) {
        // InnerAccessor visits inner types while running on outer
        // types and therefore should be alone in its plan.
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        if (features.contains(AvoidSynthethicAccessors.class)) {
            typePlan.append(OptimizedInnerAccessorGenerator.class);
        } else {
            typePlan.append(InnerAccessorGenerator.class);
        }
    }
    if (!features.contains(LambdaToAnonymousConverter.class)) {
        planBuilder.append(InnerAccessorSchedulingSeparator.class);
    }
    planBuilder.append(TryStatementSchedulingSeparator.class);
    planBuilder.append(EnumMappingSchedulingSeparator.class);
    if (features.contains(AvoidSynthethicAccessors.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        typePlan.append(ReferencedOuterFieldsExposer.class);
        planBuilder.append(OptimizedInnerAccessorSchedulingSeparator.class);
        SubPlanBuilder<JDefinedClassOrInterface> typePlan2 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan2.appendSubPlan(JMethodAdapter.class);
        methodPlan.append(MethodCallDispatchAdjuster.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan4 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        if (!features.contains(LambdaToAnonymousConverter.class)) {
            typePlan4.append(InnerAccessorAdder.class);
        }
        typePlan4.append(UsedEnumFieldMarkerRemover.class);
        {
            SubPlanBuilder<JMethod> methodPlan = typePlan4.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(FlowNormalizer.class);
            if (features.contains(SourceVersion7.class)) {
                methodPlan.append(SwitchStringSupport.class);
            }
            methodPlan.append(EnumMappingMarkerRemover.class);
        }
        typePlan4.append(FlowNormalizerSchedulingSeparator.class);
        {
            SubPlanBuilder<JMethod> methodPlan3 = typePlan4.appendSubPlan(JMethodAdapter.class);
            methodPlan3.append(FieldInitMethodCallRemover.class);
            if (features.contains(TailRecursionOptimization.class)) {
                methodPlan3.append(TailRecursionOptimizer.class);
            }
        }
        typePlan4.append(FieldInitMethodRemover.class);
    }
    if (features.contains(Obfuscation.class)) {
        appendObfuscationPlan(planBuilder, features);
    } else {
        planBuilder.append(NameFinalizer.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan;
        // incremental mode
        if (features.contains(GenerateLibraryFromIncrementalFolder.class) || !features.contains(Incremental.class)) {
            typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        } else {
            typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        }
        if (productions.contains(JayceInLibraryProduct.class)) {
            typePlan.append(JayceInLibraryWriter.class);
        }
    }
    if (features.contains(LambdaToAnonymousConverter.class)) {
        {
            SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
            SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodOnlyAdapter.class);
            methodPlan.append(LambdaConverter.class);
        }
        {
            SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
            if (features.contains(AvoidSynthethicAccessors.class)) {
                typePlan.append(OptimizedInnerAccessorGenerator.class);
            } else {
                typePlan.append(InnerAccessorGenerator.class);
            }
        }
        planBuilder.append(InnerAccessorSchedulingSeparator.class);
        {
            SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
            if (features.contains(AvoidSynthethicAccessors.class)) {
                typePlan.append(ReferencedOuterFieldsExposer.class);
            }
            typePlan.append(InnerAccessorAdder.class);
        }
    }
    if (features.contains(LambdaUseExperimentalOpcodes.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodOnlyAdapter.class);
        methodPlan.append(LambdaNativeSupportConverter.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        if (productions.contains(DependencyInLibraryProduct.class)) {
            typePlan.append(TypeDependenciesCollector.class);
            typePlan.append(FileDependenciesCollector.class);
        }
    }
    if (features.contains(SourceFileRenaming.class)) {
        planBuilder.append(SourceFileRenamer.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        if (features.contains(DynamicAssertionFeature.class)) {
            methodPlan.append(DynamicAssertionTransformer.class);
        } else if (features.contains(EnabledAssertionFeature.class)) {
            methodPlan.append(EnabledAssertionTransformer.class);
        } else if (features.contains(DisabledAssertionFeature.class)) {
            methodPlan.append(AssertionRemover.class);
        }
    }
    if (features.contains(DynamicAssertionFeature.class)) {
        planBuilder.append(AssertionTransformerSchedulingSeparator.class);
    }
    {
        // After this point {@link JDcoiExcludeJackFileAdapter} must not be used since
        // schedulables are not executed into the Java to Jayce plan.
        SubPlanBuilder<JDefinedClassOrInterface> typePlan4 = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        if (features.contains(DynamicAssertionFeature.class)) {
            SubPlanBuilder<JField> fieldPlan = typePlan4.appendSubPlan(JFieldAdapter.class);
            fieldPlan.append(FieldInitializer.class);
        }
        {
            SubPlanBuilder<JMethod> methodPlan = typePlan4.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(ConditionalAndOrRemover.class);
            if (hasSanityChecks) {
                methodPlan.append(ConditionalAndOrRemoverChecker.class);
            }
            methodPlan.append(BooleanTestTransformer.class);
            methodPlan.append(SplitNewInstance.class);
            if (hasSanityChecks) {
                methodPlan.append(SplitNewInstanceChecker.class);
            }
            methodPlan.append(MultiDimensionNewArrayRemover.class);
            methodPlan.append(InitInNewArrayRemover.class);
            methodPlan.append(PrimitiveClassTransformer.class);
            methodPlan.append(SynchronizeTransformer.class);
            methodPlan.append(NestedAssignRemover.class);
            methodPlan.append(IntersectionTypeRemover.class);
            methodPlan.append(TypeLegalizer.class);
            methodPlan.append(RopCastLegalizer.class);
            if (features.contains(CodeStats.class)) {
                methodPlan.append(BinaryOperationWithCst.class);
            }
            methodPlan.append(UselessCaseRemover.class);
            methodPlan.append(UselessSwitchesRemover.class);
            if (hasSanityChecks) {
                methodPlan.append(UselessCaseChecker.class);
            }
            methodPlan.append(FinallyRemover.class);
            methodPlan.append(ExceptionRuntimeValueAdder.class);
            methodPlan.append(DefinitionMarkerAdder.class);
            methodPlan.append(ThreeAddressCodeBuilder.class);
            methodPlan.append(UselessCastRemover.class);
            methodPlan.append(DefinitionMarkerRemover.class);
            methodPlan.append(TryCatchRemover.class);
            methodPlan.append(ExpressionStatementLegalizer.class);
            if (hasSanityChecks) {
                methodPlan.append(NumericConversionChecker.class);
            }
            methodPlan.append(EmptyClinitRemover.class);
        }
    }
    if (productions.contains(DependencyInLibraryProduct.class)) {
        planBuilder.append(TypeDependenciesInLibraryWriter.class);
        planBuilder.append(FileDependenciesInLibraryWriter.class);
        planBuilder.append(LibraryDependenciesInLibraryWriter.class);
    }
    if (productions.contains(SeedFile.class)) {
        planBuilder.append(SeedPrinter.class);
    }
    if (productions.contains(Mapping.class)) {
        planBuilder.append(MappingPrinter.class);
    }
    if (productions.contains(StructurePrinting.class)) {
        planBuilder.append(ShrinkStructurePrinter.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        typePlan.append(ReflectAnnotationsAdder.class);
        {
            SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(DefaultValueAnnotationAdder.class);
        }
    }
    planBuilder.append(ClassAnnotationSchedulingSeparator.class);
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        typePlan.append(ClassDefItemBuilder.class);
        typePlan.append(ContainerAnnotationAdder.TypeContainerAnnotationAdder.class);
        typePlan.append(ClassAnnotationBuilder.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan5 = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        {
            {
                SubPlanBuilder<JMethod> methodPlan4 = typePlan5.appendSubPlan(JMethodAdapter.class);
                methodPlan4.append(RefAsStatementRemover.class);
                methodPlan4.append(CfgBuilder.class);
                methodPlan4.append(DefinitionMarkerAdder.class);
                methodPlan4.append(ReachingDefinitions.class);
                methodPlan4.append(UsedVariableAdder.class);
                methodPlan4.append(DefUsesAndUseDefsChainComputation.class);
                if (hasSanityChecks) {
                    methodPlan4.append(UseDefsChecker.class);
                }
                methodPlan4.append(ConstantRefinerAndVariableRemover.class);
                if (features.contains(Optimizations.UseDefSimplifier.class)) {
                    methodPlan4.append(UseDefsChainsSimplifier.class);
                }
                if (features.contains(Optimizations.DefUseSimplifier.class)) {
                    methodPlan4.append(DefUsesChainsSimplifier.class);
                }
                // Instructions are removed by DefUsesChainsSimplifier thus rebuild the cfg.
                methodPlan4.append(CfgMarkerRemover.class);
                methodPlan4.append(CfgBuilder.class);
                methodPlan4.append(UnusedDefinitionRemover.class);
                methodPlan4.append(RefAsStatementRemover.class);
                methodPlan4.append(CfgMarkerRemover.class);
                methodPlan4.append(CfgBuilder.class);
                if (features.contains(Optimizations.IfSimplifier.class)) {
                    methodPlan4.append(IfWithConstantSimplifier.class);
                }
                methodPlan4.append(UnusedLocalRemover.class);
                methodPlan4.append(DefUsesAndUseDefsChainRemover.class);
                methodPlan4.append(DefinitionMarkerRemover.class);
                methodPlan4.append(UsedVariableRemover.class);
                methodPlan4.append(ReachingDefinitionsRemover.class);
                if (features.contains(Optimizations.ExpressionSimplifier.class)) {
                    methodPlan4.append(ExpressionSimplifier.class);
                }
                methodPlan4.append(UselessIfRemover.class);
                methodPlan4.append(CfgMarkerRemover.class);
                methodPlan4.append(CfgBuilder.class);
                if (features.contains(CodeCoverage.class)) {
                    methodPlan4.append(CodeCoverageAnalyzer.class);
                }
            }
            // methods of the class).
            if (features.contains(CodeCoverage.class)) {
                typePlan5.append(CodeCoverageTransformer.class);
            }
            {
                SubPlanBuilder<JMethod> methodPlan5 = typePlan5.appendSubPlan(JMethodAdapter.class);
                if (features.contains(CodeCoverage.class)) {
                    // We instrumented the code with CodeCoverageTransformer so we need to update the
                    // control flow graph.
                    methodPlan5.append(CfgMarkerRemover.class);
                    methodPlan5.append(CfgBuilder.class);
                }
                methodPlan5.append(CodeItemBuilder.class);
                methodPlan5.append(CfgMarkerRemover.class);
                methodPlan5.append(EncodedMethodBuilder.class);
                methodPlan5.append(ContainerAnnotationAdder.MethodContainerAnnotationAdder.class);
                methodPlan5.append(MethodAnnotationBuilder.class);
                if (features.contains(DropMethodBody.class)) {
                    methodPlan5.append(MethodBodyRemover.class);
                }
            }
            {
                SubPlanBuilder<JField> fieldPlan2 = typePlan5.appendSubPlan(JFieldAdapter.class);
                fieldPlan2.append(ContainerAnnotationAdder.FieldContainerAnnotationAdder.class);
                fieldPlan2.append(EncodedFieldBuilder.class);
                fieldPlan2.append(FieldAnnotationBuilder.class);
            }
        }
        if (hasSanityChecks) {
            typePlan5.append(TypeAstChecker.class);
        }
    }
    if (productions.contains(CodeCoverageMetadataFile.class)) {
        planBuilder.append(CodeCoverageMetadataFileWriter.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan;
        // incremental mode
        if (features.contains(GenerateLibraryFromIncrementalFolder.class) || !features.contains(Incremental.class)) {
            typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        } else {
            typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        }
        if (productions.contains(DexInLibraryProduct.class)) {
            typePlan.append(DexInLibraryWriter.class);
        }
    }
    if (hasSanityChecks) {
        planBuilder.append(AstChecker.class);
    }
}
#method_after
static void fillDexPlan(@Nonnull PlanBuilder<JSession> planBuilder) {
    FeatureSet features = planBuilder.getRequest().getFeatures();
    ProductionSet productions = planBuilder.getRequest().getTargetProductions();
    boolean hasSanityChecks = features.contains(SanityChecks.class);
    // Build the plan
    if (features.contains(Shrinking.class) || features.contains(Obfuscation.class) || features.contains(MultiDexLegacy.class)) {
        planBuilder.append(MethodIdMerger.class);
        planBuilder.append(VirtualMethodsMarker.Remover.class);
        planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class).append(MethodIdDuplicateRemover.class);
    }
    if (hasSanityChecks) {
        planBuilder.append(TypeDuplicateRemoverChecker.class);
    }
    if (features.contains(RemoveTypeDef.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        typePlan.append(TypeDefRemover.class);
    }
    appendStringRefiners(planBuilder);
    if (features.contains(Jarjar.class)) {
        planBuilder.append(PackageRenamer.class);
    }
    if (hasSanityChecks) {
        planBuilder.append(AstChecker.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        if (features.contains(CodeCoverage.class)) {
            typePlan.append(CodeCoverageSelector.class);
        }
        if (features.contains(CheckAndroidCompatibility.class)) {
            SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(AndroidCompatibilityChecker.class);
        }
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        {
            if (features.contains(CompiledTypeStats.class)) {
                SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
                methodPlan.append(MethodStats.class);
            }
        }
        {
            SubPlanBuilder<JField> fieldPlan = typePlan.appendSubPlan(JFieldAdapter.class);
            if (features.contains(CompiledTypeStats.class)) {
                fieldPlan.append(FieldStats.class);
            }
            fieldPlan.append(FieldInitializerRemover.class);
        }
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        typePlan.append(UsedEnumFieldCollector.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan2 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        {
            if (features.contains(VisibilityBridge.class)) {
                typePlan2.append(VisibilityBridgeAdder.class);
            }
            if (features.contains(Optimizations.NotSimplifier.class) || features.contains(SourceVersion7.class)) {
                SubPlanBuilder<JMethod> methodPlan = typePlan2.appendSubPlan(JMethodAdapter.class);
                if (features.contains(Optimizations.NotSimplifier.class)) {
                    methodPlan.append(NotSimplifier.class);
                }
                if (features.contains(SourceVersion7.class)) {
                    methodPlan.append(TryWithResourcesTransformer.class);
                }
            }
        }
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan3 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        {
            {
                SubPlanBuilder<JMethod> methodPlan2 = typePlan3.appendSubPlan(JMethodAdapter.class);
                methodPlan2.append(ImplicitBlocks.class);
                if (hasSanityChecks) {
                    methodPlan2.append(ImplicitBlocksChecker.class);
                }
                if (hasSanityChecks) {
                    methodPlan2.append(UselessIfChecker.class);
                }
                methodPlan2.append(IncDecRemover.class);
                methodPlan2.append(CompoundAssignmentRemover.class);
                methodPlan2.append(ConcatRemover.class);
            }
        }
    }
    if (features.contains(OptimizedSwitchEnumFeedbackFeature.class)) {
        // add one more traversal at compile-time to collect the usage for each enum,
        // figure out how many classes use enum in switch statement.
        // this step is enabled only when feedback-based optimization is enabled
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        methodPlan.append(SwitchEnumUsageCollector.class);
    }
    if ((features.contains(OptimizedSwitchEnumFeedbackFeature.class) || features.contains(OptimizedSwitchEnumNonFeedbackFeature.class)) && hasSanityChecks) {
        // check the validity of instrumentation if switch enum optimization and
        // hasSanityCheck are both set
        planBuilder.append(AstChecker.class);
    }
    planBuilder.append(InnerAccessorGeneratorSchedulingSeparator.class);
    // InnerAccessor visits inner types while running on outer
    // types and therefore should be alone in its plan.
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        if (features.contains(AvoidSynthethicAccessors.class)) {
            typePlan.append(OptimizedInnerAccessorGenerator.class);
        } else {
            typePlan.append(InnerAccessorGenerator.class);
        }
    }
    planBuilder.append(InnerAccessorSchedulingSeparator.class);
    if (features.contains(AvoidSynthethicAccessors.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        typePlan.append(ReferencedOuterFieldsExposer.class);
        planBuilder.append(OptimizedInnerAccessorSchedulingSeparator.class);
        SubPlanBuilder<JDefinedClassOrInterface> typePlan2 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan2.appendSubPlan(JMethodAdapter.class);
        methodPlan.append(MethodCallDispatchAdjuster.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan4 = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        typePlan4.append(InnerAccessorAdder.class);
        {
            SubPlanBuilder<JMethod> methodPlan = typePlan4.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(FlowNormalizer.class);
            if (features.contains(SourceVersion7.class)) {
                methodPlan.append(SwitchStringSupport.class);
            }
        }
        typePlan4.append(FlowNormalizerSchedulingSeparator.class);
        {
            SubPlanBuilder<JMethod> methodPlan3 = typePlan4.appendSubPlan(JMethodAdapter.class);
            methodPlan3.append(FieldInitMethodCallRemover.class);
            if (features.contains(TailRecursionOptimization.class)) {
                methodPlan3.append(TailRecursionOptimizer.class);
            }
        }
        typePlan4.append(FieldInitMethodRemover.class);
    }
    appendMultiDexAndShrobStartPlan(planBuilder);
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        if (features.contains(OptimizedSwitchEnumFeedbackFeature.class) || features.contains(OptimizedSwitchEnumNonFeedbackFeature.class)) {
            methodPlan.append(OptimizedSwitchEnumSupport.class);
        } else {
            methodPlan.append(SwitchEnumSupport.class);
        }
        typePlan.append(UsedEnumFieldMarkerRemover.class);
    }
    planBuilder.append(EnumMappingSchedulingSeparator.class);
    planBuilder.append(TryStatementSchedulingSeparator.class);
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        methodPlan.append(EnumMappingMarkerRemover.class);
    }
    if (features.contains(Obfuscation.class)) {
        appendObfuscationPlan(planBuilder, features);
    } else {
        planBuilder.append(NameFinalizer.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan;
        // incremental mode
        if (features.contains(GenerateLibraryFromIncrementalFolder.class) || !features.contains(Incremental.class)) {
            typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        } else {
            typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        }
        if (productions.contains(JayceInLibraryProduct.class)) {
            typePlan.append(JayceInLibraryWriter.class);
        }
    }
    if (features.contains(LambdaToAnonymousConverter.class)) {
        {
            SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
            SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodOnlyAdapter.class);
            methodPlan.append(LambdaConverter.class);
        }
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        if (features.contains(AvoidSynthethicAccessors.class)) {
            typePlan.append(OptimizedInnerAccessorGenerator.class);
        } else {
            typePlan.append(InnerAccessorGenerator.class);
        }
    }
    planBuilder.append(InnerAccessorSchedulingSeparator.class);
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        if (features.contains(AvoidSynthethicAccessors.class)) {
            typePlan.append(ReferencedOuterFieldsExposer.class);
        }
        typePlan.append(InnerAccessorAdder.class);
    }
    if (features.contains(LambdaUseExperimentalOpcodes.class)) {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodOnlyAdapter.class);
        methodPlan.append(LambdaNativeSupportConverter.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibAdapter.class);
        if (productions.contains(DependencyInLibraryProduct.class)) {
            typePlan.append(TypeDependenciesCollector.class);
            typePlan.append(FileDependenciesCollector.class);
        }
    }
    if (features.contains(SourceFileRenaming.class)) {
        planBuilder.append(SourceFileRenamer.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
        if (features.contains(DynamicAssertionFeature.class)) {
            methodPlan.append(DynamicAssertionTransformer.class);
        } else if (features.contains(EnabledAssertionFeature.class)) {
            methodPlan.append(EnabledAssertionTransformer.class);
        } else if (features.contains(DisabledAssertionFeature.class)) {
            methodPlan.append(AssertionRemover.class);
        }
    }
    if (features.contains(DynamicAssertionFeature.class)) {
        planBuilder.append(AssertionTransformerSchedulingSeparator.class);
    }
    {
        // After this point {@link JDcoiExcludeJackFileAdapter} must not be used since
        // schedulables are not executed into the Java to Jayce plan.
        SubPlanBuilder<JDefinedClassOrInterface> typePlan4 = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        if (features.contains(DynamicAssertionFeature.class)) {
            SubPlanBuilder<JField> fieldPlan = typePlan4.appendSubPlan(JFieldAdapter.class);
            fieldPlan.append(FieldInitializer.class);
        }
        {
            SubPlanBuilder<JMethod> methodPlan = typePlan4.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(ConditionalAndOrRemover.class);
            if (hasSanityChecks) {
                methodPlan.append(ConditionalAndOrRemoverChecker.class);
            }
            methodPlan.append(BooleanTestTransformer.class);
            methodPlan.append(SplitNewInstance.class);
            if (hasSanityChecks) {
                methodPlan.append(SplitNewInstanceChecker.class);
            }
            methodPlan.append(MultiDimensionNewArrayRemover.class);
            methodPlan.append(InitInNewArrayRemover.class);
            methodPlan.append(PrimitiveClassTransformer.class);
            methodPlan.append(SynchronizeTransformer.class);
            methodPlan.append(NestedAssignRemover.class);
            methodPlan.append(IntersectionTypeRemover.class);
            methodPlan.append(TypeLegalizer.class);
            methodPlan.append(RopCastLegalizer.class);
            if (features.contains(CodeStats.class)) {
                methodPlan.append(BinaryOperationWithCst.class);
            }
            methodPlan.append(UselessCaseRemover.class);
            methodPlan.append(UselessSwitchesRemover.class);
            if (hasSanityChecks) {
                methodPlan.append(UselessCaseChecker.class);
            }
            methodPlan.append(FinallyRemover.class);
            methodPlan.append(ExceptionRuntimeValueAdder.class);
            methodPlan.append(DefinitionMarkerAdder.class);
            methodPlan.append(ThreeAddressCodeBuilder.class);
            methodPlan.append(UselessCastRemover.class);
            methodPlan.append(DefinitionMarkerRemover.class);
            methodPlan.append(TryCatchRemover.class);
            methodPlan.append(ExpressionStatementLegalizer.class);
            if (hasSanityChecks) {
                methodPlan.append(NumericConversionChecker.class);
            }
            methodPlan.append(EmptyClinitRemover.class);
        }
    }
    if (productions.contains(DependencyInLibraryProduct.class)) {
        planBuilder.append(TypeDependenciesInLibraryWriter.class);
        planBuilder.append(FileDependenciesInLibraryWriter.class);
        planBuilder.append(LibraryDependenciesInLibraryWriter.class);
    }
    if (productions.contains(SeedFile.class)) {
        planBuilder.append(SeedPrinter.class);
    }
    if (productions.contains(Mapping.class)) {
        planBuilder.append(MappingPrinter.class);
    }
    if (productions.contains(StructurePrinting.class)) {
        planBuilder.append(ShrinkStructurePrinter.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        typePlan.append(ReflectAnnotationsAdder.class);
        {
            SubPlanBuilder<JMethod> methodPlan = typePlan.appendSubPlan(JMethodAdapter.class);
            methodPlan.append(DefaultValueAnnotationAdder.class);
        }
    }
    planBuilder.append(ClassAnnotationSchedulingSeparator.class);
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        typePlan.append(ClassDefItemBuilder.class);
        typePlan.append(ContainerAnnotationAdder.TypeContainerAnnotationAdder.class);
        typePlan.append(ClassAnnotationBuilder.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan5 = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        {
            {
                SubPlanBuilder<JMethod> methodPlan4 = typePlan5.appendSubPlan(JMethodAdapter.class);
                methodPlan4.append(RefAsStatementRemover.class);
                methodPlan4.append(CfgBuilder.class);
                methodPlan4.append(DefinitionMarkerAdder.class);
                methodPlan4.append(ReachingDefinitions.class);
                methodPlan4.append(UsedVariableAdder.class);
                methodPlan4.append(DefUsesAndUseDefsChainComputation.class);
                if (hasSanityChecks) {
                    methodPlan4.append(UseDefsChecker.class);
                }
                methodPlan4.append(ConstantRefinerAndVariableRemover.class);
                if (features.contains(Optimizations.UseDefSimplifier.class)) {
                    methodPlan4.append(UseDefsChainsSimplifier.class);
                }
                if (features.contains(Optimizations.DefUseSimplifier.class)) {
                    methodPlan4.append(DefUsesChainsSimplifier.class);
                }
                // Instructions are removed by DefUsesChainsSimplifier thus rebuild the cfg.
                methodPlan4.append(CfgMarkerRemover.class);
                methodPlan4.append(CfgBuilder.class);
                methodPlan4.append(UnusedDefinitionRemover.class);
                methodPlan4.append(RefAsStatementRemover.class);
                methodPlan4.append(CfgMarkerRemover.class);
                methodPlan4.append(CfgBuilder.class);
                if (features.contains(Optimizations.IfSimplifier.class)) {
                    methodPlan4.append(IfWithConstantSimplifier.class);
                }
                methodPlan4.append(UnusedLocalRemover.class);
                methodPlan4.append(DefUsesAndUseDefsChainRemover.class);
                methodPlan4.append(DefinitionMarkerRemover.class);
                methodPlan4.append(UsedVariableRemover.class);
                methodPlan4.append(ReachingDefinitionsRemover.class);
                if (features.contains(Optimizations.ExpressionSimplifier.class)) {
                    methodPlan4.append(ExpressionSimplifier.class);
                }
                methodPlan4.append(UselessIfRemover.class);
                methodPlan4.append(CfgMarkerRemover.class);
                methodPlan4.append(CfgBuilder.class);
                if (features.contains(CodeCoverage.class)) {
                    methodPlan4.append(CodeCoverageAnalyzer.class);
                }
            }
            // methods of the class).
            if (features.contains(CodeCoverage.class)) {
                typePlan5.append(CodeCoverageTransformer.class);
            }
            {
                SubPlanBuilder<JMethod> methodPlan5 = typePlan5.appendSubPlan(JMethodAdapter.class);
                if (features.contains(CodeCoverage.class)) {
                    // We instrumented the code with CodeCoverageTransformer so we need to update the
                    // control flow graph.
                    methodPlan5.append(CfgMarkerRemover.class);
                    methodPlan5.append(CfgBuilder.class);
                }
                methodPlan5.append(CodeItemBuilder.class);
                methodPlan5.append(CfgMarkerRemover.class);
                methodPlan5.append(EncodedMethodBuilder.class);
                methodPlan5.append(ContainerAnnotationAdder.MethodContainerAnnotationAdder.class);
                methodPlan5.append(MethodAnnotationBuilder.class);
                if (features.contains(DropMethodBody.class)) {
                    methodPlan5.append(MethodBodyRemover.class);
                }
            }
            {
                SubPlanBuilder<JField> fieldPlan2 = typePlan5.appendSubPlan(JFieldAdapter.class);
                fieldPlan2.append(ContainerAnnotationAdder.FieldContainerAnnotationAdder.class);
                fieldPlan2.append(EncodedFieldBuilder.class);
                fieldPlan2.append(FieldAnnotationBuilder.class);
            }
        }
        if (hasSanityChecks) {
            typePlan5.append(TypeAstChecker.class);
        }
    }
    if (productions.contains(CodeCoverageMetadataFile.class)) {
        planBuilder.append(CodeCoverageMetadataFileWriter.class);
    }
    {
        SubPlanBuilder<JDefinedClassOrInterface> typePlan;
        // incremental mode
        if (features.contains(GenerateLibraryFromIncrementalFolder.class) || !features.contains(Incremental.class)) {
            typePlan = planBuilder.appendSubPlan(JDefinedClassOrInterfaceAdapter.class);
        } else {
            typePlan = planBuilder.appendSubPlan(ExcludeTypeFromLibWithBinaryAdapter.class);
        }
        if (productions.contains(DexInLibraryProduct.class)) {
            typePlan.append(DexInLibraryWriter.class);
        }
    }
    if (hasSanityChecks) {
        planBuilder.append(AstChecker.class);
    }
    planBuilder.append(Aborter.class);
}
#end_block

#method_before
@Test
public void test001() throws Exception {
    File testFolder = AbstractTestTools.getTestRootDir("com.android.jack.java8.variable.test001.jack");
    File out = AbstractTestTools.createTempDir();
    List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(2);
    excludeClazz.add(JackApiV01.class);
    IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz);
    toolchain.addToClasspath(toolchain.getDefaultBootClasspath()).setSourceLevel(SourceLevel.JAVA_8);
    try {
        toolchain.srcToExe(out, /* zipFile = */
        false, testFolder);
        Assert.fail();
    } catch (FrontendCompilationException e) {
    // Expected.
    }
}
#method_after
@Test
public void test001() throws Exception {
    File testFolder = AbstractTestTools.getTestRootDir("com.android.jack.java8.variable.test001.jack");
    File out = AbstractTestTools.createTempDir();
    ByteArrayOutputStream errOut = new ByteArrayOutputStream();
    List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(2);
    excludeClazz.add(JackApiV01.class);
    IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz);
    toolchain.addToClasspath(toolchain.getDefaultBootClasspath()).setErrorStream(errOut).setSourceLevel(SourceLevel.JAVA_8);
    try {
        toolchain.srcToExe(out, /* zipFile = */
        false, testFolder);
        Assert.fail();
    } catch (FrontendCompilationException e) {
        Assert.assertTrue(errOut.toString().contains("Local variable value defined in an enclosing scope must be final or effectively final"));
    }
}
#end_block

#method_before
@Test
public void test002() throws Exception {
    File testFolder = AbstractTestTools.getTestRootDir("com.android.jack.java8.variable.test002.jack");
    File out = AbstractTestTools.createTempDir();
    List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(2);
    excludeClazz.add(JackApiV01.class);
    IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz);
    toolchain.addToClasspath(toolchain.getDefaultBootClasspath()).setSourceLevel(SourceLevel.JAVA_8).srcToExe(out, /* zipFile = */
    false, testFolder);
}
#method_after
@Test
public void test002() throws Exception {
    File testFolder = AbstractTestTools.getTestRootDir("com.android.jack.java8.variable.test002.jack");
    File out = AbstractTestTools.createTempDir();
    List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(2);
    excludeClazz.add(JackApiV01.class);
    excludeClazz.add(JillBasedToolchain.class);
    IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeClazz);
    toolchain.addToClasspath(toolchain.getDefaultBootClasspath()).setSourceLevel(SourceLevel.JAVA_8).srcToExe(out, /* zipFile = */
    false, testFolder);
}
#end_block

#method_before
public void test_setAll$I() {
    int[] list = new int[3];
    list[0] = 0;
    list[1] = 1;
    list[2] = 2;
    Arrays.setAll(list, x -> x + 1);
    assertEquals(1, list[0]);
    assertEquals(2, list[1]);
    assertEquals(3, list[2]);
    try {
        Arrays.setAll(list, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#method_after
public void test_setAll$I() {
    int[] list = new int[3];
    list[0] = 0;
    list[1] = 1;
    list[2] = 2;
    Arrays.setAll(list, x -> x + 1);
    assertEquals(1, list[0]);
    assertEquals(2, list[1]);
    assertEquals(3, list[2]);
    try {
        Arrays.setAll(list, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
    try {
        Arrays.setAll((int[]) null, (x -> x + 1));
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#end_block

#method_before
public void test_setAll$L() {
    long[] list = new long[3];
    list[0] = 0;
    list[1] = 1;
    list[2] = 2;
    Arrays.setAll(list, x -> x + 1);
    assertEquals(1, list[0]);
    assertEquals(2, list[1]);
    assertEquals(3, list[2]);
    try {
        Arrays.setAll(list, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#method_after
public void test_setAll$L() {
    long[] list = new long[3];
    list[0] = 0;
    list[1] = 1;
    list[2] = 2;
    Arrays.setAll(list, x -> x + 1);
    assertEquals(1, list[0]);
    assertEquals(2, list[1]);
    assertEquals(3, list[2]);
    try {
        Arrays.setAll(list, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
    try {
        Arrays.setAll((long[]) null, (x -> x + 1));
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#end_block

#method_before
public void test_setAll$D() {
    double[] list = new double[3];
    list[0] = 0.0d;
    list[1] = 1.0d;
    list[2] = 2.0d;
    Arrays.setAll(list, x -> x + 0.5);
    assertEquals(0.5d, list[0]);
    assertEquals(1.5d, list[1]);
    assertEquals(2.5d, list[2]);
    try {
        Arrays.setAll(list, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#method_after
public void test_setAll$D() {
    double[] list = new double[3];
    list[0] = 0.0d;
    list[1] = 1.0d;
    list[2] = 2.0d;
    Arrays.setAll(list, x -> x + 0.5);
    assertEquals(0.5d, list[0]);
    assertEquals(1.5d, list[1]);
    assertEquals(2.5d, list[2]);
    try {
        Arrays.setAll(list, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
    try {
        Arrays.setAll((double[]) null, x -> x + 0.5);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#end_block

#method_before
public void test_setAll$T() {
    String[] strings = new String[3];
    strings[0] = "a";
    strings[0] = "b";
    strings[0] = "c";
    Arrays.setAll(strings, x -> "a" + x);
    assertEquals("a0", strings[0]);
    assertEquals("a1", strings[1]);
    assertEquals("a2", strings[2]);
    try {
        Arrays.setAll(strings, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#method_after
public void test_setAll$T() {
    String[] strings = new String[3];
    strings[0] = "a";
    strings[0] = "b";
    strings[0] = "c";
    Arrays.setAll(strings, x -> "a" + x);
    assertEquals("a0", strings[0]);
    assertEquals("a1", strings[1]);
    assertEquals("a2", strings[2]);
    try {
        Arrays.setAll(strings, null);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
    try {
        Arrays.setAll((String[]) null, x -> "a" + x);
        fail();
    } catch (NullPointerException e) {
    // expected
    }
}
#end_block

#method_before
public int size() {
    return a.length;
}
#method_after
@Override
public int size() {
    return a.length;
}
#end_block

#method_before
public Object[] toArray() {
    return a.clone();
}
#method_after
@Override
public Object[] toArray() {
    return a.clone();
}
#end_block

#method_before
public <T> T[] toArray(T[] a) {
    int size = size();
    if (a.length < size)
        return Arrays.copyOf(this.a, size, (Class<? extends T[]>) a.getClass());
    System.arraycopy(this.a, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}
#method_after
@Override
@SuppressWarnings("unchecked")
public <T> T[] toArray(T[] a) {
    int size = size();
    if (a.length < size)
        return Arrays.copyOf(this.a, size, (Class<? extends T[]>) a.getClass());
    System.arraycopy(this.a, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}
#end_block

#method_before
public E get(int index) {
    return a[index];
}
#method_after
@Override
public E get(int index) {
    return a[index];
}
#end_block

#method_before
public E set(int index, E element) {
    E oldValue = a[index];
    a[index] = element;
    return oldValue;
}
#method_after
@Override
public E set(int index, E element) {
    E oldValue = a[index];
    a[index] = element;
    return oldValue;
}
#end_block

#method_before
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < a.length; i++) if (a[i] == null)
            return i;
    } else {
        for (int i = 0; i < a.length; i++) if (o.equals(a[i]))
            return i;
    }
    return -1;
}
#method_after
@Override
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < a.length; i++) if (a[i] == null)
            return i;
    } else {
        for (int i = 0; i < a.length; i++) if (o.equals(a[i]))
            return i;
    }
    return -1;
}
#end_block

#method_before
public boolean contains(Object o) {
    return indexOf(o) != -1;
}
#method_after
@Override
public boolean contains(Object o) {
    return indexOf(o) != -1;
}
#end_block

#method_before
public int size() {
    return a.length;
}
#method_after
@Override
public int size() {
    return a.length;
}
#end_block

#method_before
public Object[] toArray() {
    return a.clone();
}
#method_after
@Override
public Object[] toArray() {
    return a.clone();
}
#end_block

#method_before
public <T> T[] toArray(T[] a) {
    int size = size();
    if (a.length < size)
        return Arrays.copyOf(this.a, size, (Class<? extends T[]>) a.getClass());
    System.arraycopy(this.a, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}
#method_after
@Override
@SuppressWarnings("unchecked")
public <T> T[] toArray(T[] a) {
    int size = size();
    if (a.length < size)
        return Arrays.copyOf(this.a, size, (Class<? extends T[]>) a.getClass());
    System.arraycopy(this.a, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}
#end_block

#method_before
public E get(int index) {
    return a[index];
}
#method_after
@Override
public E get(int index) {
    return a[index];
}
#end_block

#method_before
public E set(int index, E element) {
    E oldValue = a[index];
    a[index] = element;
    return oldValue;
}
#method_after
@Override
public E set(int index, E element) {
    E oldValue = a[index];
    a[index] = element;
    return oldValue;
}
#end_block

#method_before
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < a.length; i++) if (a[i] == null)
            return i;
    } else {
        for (int i = 0; i < a.length; i++) if (o.equals(a[i]))
            return i;
    }
    return -1;
}
#method_after
@Override
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < a.length; i++) if (a[i] == null)
            return i;
    } else {
        for (int i = 0; i < a.length; i++) if (o.equals(a[i]))
            return i;
    }
    return -1;
}
#end_block

#method_before
public boolean contains(Object o) {
    return indexOf(o) != -1;
}
#method_after
@Override
public boolean contains(Object o) {
    return indexOf(o) != -1;
}
#end_block

#method_before
public final void compute() {
    CountedCompleter<?> s = this;
    // localize all params
    double[] a = this.a, w = this.w;
    int b = this.base, n = this.size, wb = this.wbase, g = this.gran;
    while (n > g) {
        // quartiles
        int h = n >>> 1, q = h >>> 1, u = h + q;
        Relay fc = new Relay(new Merger(s, w, a, wb, h, wb + h, n - h, b, g));
        Relay rc = new Relay(new Merger(fc, a, w, b + h, q, b + u, n - u, wb + h, g));
        new Sorter(rc, a, w, b + u, n - u, wb + u, g).fork();
        new Sorter(rc, a, w, b + h, q, wb + h, g).fork();
        ;
        Relay bc = new Relay(new Merger(fc, a, w, b, q, b + q, h - q, wb, g));
        new Sorter(bc, a, w, b + q, h - q, wb + q, g).fork();
        s = new EmptyCompleter(bc);
        n = q;
    }
    DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);
    s.tryComplete();
}
#method_after
public final void compute() {
    CountedCompleter<?> s = this;
    Comparator<? super T> c = this.comparator;
    // localize all params
    T[] a = this.a, w = this.w;
    int b = this.base, n = this.size, wb = this.wbase, g = this.gran;
    while (n > g) {
        // quartiles
        int h = n >>> 1, q = h >>> 1, u = h + q;
        Relay fc = new Relay(new Merger<T>(s, w, a, wb, h, wb + h, n - h, b, g, c));
        Relay rc = new Relay(new Merger<T>(fc, a, w, b + h, q, b + u, n - u, wb + h, g, c));
        new Sorter<T>(rc, a, w, b + u, n - u, wb + u, g, c).fork();
        new Sorter<T>(rc, a, w, b + h, q, wb + h, g, c).fork();
        ;
        Relay bc = new Relay(new Merger<T>(fc, a, w, b, q, b + q, h - q, wb, g, c));
        new Sorter<T>(bc, a, w, b + q, h - q, wb + q, g, c).fork();
        s = new EmptyCompleter(bc);
        n = q;
    }
    TimSort.sort(a, b, b + n, c, w, wb, n);
    s.tryComplete();
}
#end_block

#method_before
public final void compute() {
    // localize all params
    double[] a = this.a, w = this.w;
    int lb = this.lbase, ln = this.lsize, rb = this.rbase, rn = this.rsize, k = this.wbase, g = this.gran;
    if (a == null || w == null || lb < 0 || rb < 0 || k < 0)
        // hoist checks
        throw new IllegalStateException();
    for (int lh, rh; ; ) {
        // split larger, find point in smaller
        if (ln >= rn) {
            if (ln <= g)
                break;
            rh = rn;
            double split = a[(lh = ln >>> 1) + lb];
            for (int lo = 0; lo < rh; ) {
                int rm = (lo + rh) >>> 1;
                if (split <= a[rm + rb])
                    rh = rm;
                else
                    lo = rm + 1;
            }
        } else {
            if (rn <= g)
                break;
            lh = ln;
            double split = a[(rh = rn >>> 1) + rb];
            for (int lo = 0; lo < lh; ) {
                int lm = (lo + lh) >>> 1;
                if (split <= a[lm + lb])
                    lh = lm;
                else
                    lo = lm + 1;
            }
        }
        Merger m = new Merger(this, a, w, lb + lh, ln - lh, rb + rh, rn - rh, k + lh + rh, g);
        rn = rh;
        ln = lh;
        addToPendingCount(1);
        m.fork();
    }
    // index bounds
    int lf = lb + ln, rf = rb + rn;
    while (lb < lf && rb < rf) {
        double t, al, ar;
        if ((al = a[lb]) <= (ar = a[rb])) {
            lb++;
            t = al;
        } else {
            rb++;
            t = ar;
        }
        w[k++] = t;
    }
    if (rb < rf)
        System.arraycopy(a, rb, w, k, rf - rb);
    else if (lb < lf)
        System.arraycopy(a, lb, w, k, lf - lb);
    tryComplete();
}
#method_after
public final void compute() {
    Comparator<? super T> c = this.comparator;
    // localize all params
    T[] a = this.a, w = this.w;
    int lb = this.lbase, ln = this.lsize, rb = this.rbase, rn = this.rsize, k = this.wbase, g = this.gran;
    if (a == null || w == null || lb < 0 || rb < 0 || k < 0 || c == null)
        // hoist checks
        throw new IllegalStateException();
    for (int lh, rh; ; ) {
        // split larger, find point in smaller
        if (ln >= rn) {
            if (ln <= g)
                break;
            rh = rn;
            T split = a[(lh = ln >>> 1) + lb];
            for (int lo = 0; lo < rh; ) {
                int rm = (lo + rh) >>> 1;
                if (c.compare(split, a[rm + rb]) <= 0)
                    rh = rm;
                else
                    lo = rm + 1;
            }
        } else {
            if (rn <= g)
                break;
            lh = ln;
            T split = a[(rh = rn >>> 1) + rb];
            for (int lo = 0; lo < lh; ) {
                int lm = (lo + lh) >>> 1;
                if (c.compare(split, a[lm + lb]) <= 0)
                    lh = lm;
                else
                    lo = lm + 1;
            }
        }
        Merger<T> m = new Merger<T>(this, a, w, lb + lh, ln - lh, rb + rh, rn - rh, k + lh + rh, g, c);
        rn = rh;
        ln = lh;
        addToPendingCount(1);
        m.fork();
    }
    // index bounds
    int lf = lb + ln, rf = rb + rn;
    while (lb < lf && rb < rf) {
        T t, al, ar;
        if (c.compare((al = a[lb]), (ar = a[rb])) <= 0) {
            lb++;
            t = al;
        } else {
            rb++;
            t = ar;
        }
        w[k++] = t;
    }
    if (rb < rf)
        System.arraycopy(a, rb, w, k, rf - rb);
    else if (lb < lf)
        System.arraycopy(a, lb, w, k, lf - lb);
    tryComplete();
}
#end_block

#method_before
public final void compute() {
    CountedCompleter<?> s = this;
    // localize all params
    double[] a = this.a, w = this.w;
    int b = this.base, n = this.size, wb = this.wbase, g = this.gran;
    while (n > g) {
        // quartiles
        int h = n >>> 1, q = h >>> 1, u = h + q;
        Relay fc = new Relay(new Merger(s, w, a, wb, h, wb + h, n - h, b, g));
        Relay rc = new Relay(new Merger(fc, a, w, b + h, q, b + u, n - u, wb + h, g));
        new Sorter(rc, a, w, b + u, n - u, wb + u, g).fork();
        new Sorter(rc, a, w, b + h, q, wb + h, g).fork();
        ;
        Relay bc = new Relay(new Merger(fc, a, w, b, q, b + q, h - q, wb, g));
        new Sorter(bc, a, w, b + q, h - q, wb + q, g).fork();
        s = new EmptyCompleter(bc);
        n = q;
    }
    DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);
    s.tryComplete();
}
#method_after
public final void compute() {
    CountedCompleter<?> s = this;
    // localize all params
    byte[] a = this.a, w = this.w;
    int b = this.base, n = this.size, wb = this.wbase, g = this.gran;
    while (n > g) {
        // quartiles
        int h = n >>> 1, q = h >>> 1, u = h + q;
        Relay fc = new Relay(new Merger(s, w, a, wb, h, wb + h, n - h, b, g));
        Relay rc = new Relay(new Merger(fc, a, w, b + h, q, b + u, n - u, wb + h, g));
        new Sorter(rc, a, w, b + u, n - u, wb + u, g).fork();
        new Sorter(rc, a, w, b + h, q, wb + h, g).fork();
        ;
        Relay bc = new Relay(new Merger(fc, a, w, b, q, b + q, h - q, wb, g));
        new Sorter(bc, a, w, b + q, h - q, wb + q, g).fork();
        s = new EmptyCompleter(bc);
        n = q;
    }
    DualPivotQuicksort.sort(a, b, b + n - 1);
    s.tryComplete();
}
#end_block

#method_before
public final void compute() {
    // localize all params
    double[] a = this.a, w = this.w;
    int lb = this.lbase, ln = this.lsize, rb = this.rbase, rn = this.rsize, k = this.wbase, g = this.gran;
    if (a == null || w == null || lb < 0 || rb < 0 || k < 0)
        // hoist checks
        throw new IllegalStateException();
    for (int lh, rh; ; ) {
        // split larger, find point in smaller
        if (ln >= rn) {
            if (ln <= g)
                break;
            rh = rn;
            double split = a[(lh = ln >>> 1) + lb];
            for (int lo = 0; lo < rh; ) {
                int rm = (lo + rh) >>> 1;
                if (split <= a[rm + rb])
                    rh = rm;
                else
                    lo = rm + 1;
            }
        } else {
            if (rn <= g)
                break;
            lh = ln;
            double split = a[(rh = rn >>> 1) + rb];
            for (int lo = 0; lo < lh; ) {
                int lm = (lo + lh) >>> 1;
                if (split <= a[lm + lb])
                    lh = lm;
                else
                    lo = lm + 1;
            }
        }
        Merger m = new Merger(this, a, w, lb + lh, ln - lh, rb + rh, rn - rh, k + lh + rh, g);
        rn = rh;
        ln = lh;
        addToPendingCount(1);
        m.fork();
    }
    // index bounds
    int lf = lb + ln, rf = rb + rn;
    while (lb < lf && rb < rf) {
        double t, al, ar;
        if ((al = a[lb]) <= (ar = a[rb])) {
            lb++;
            t = al;
        } else {
            rb++;
            t = ar;
        }
        w[k++] = t;
    }
    if (rb < rf)
        System.arraycopy(a, rb, w, k, rf - rb);
    else if (lb < lf)
        System.arraycopy(a, lb, w, k, lf - lb);
    tryComplete();
}
#method_after
public final void compute() {
    // localize all params
    byte[] a = this.a, w = this.w;
    int lb = this.lbase, ln = this.lsize, rb = this.rbase, rn = this.rsize, k = this.wbase, g = this.gran;
    if (a == null || w == null || lb < 0 || rb < 0 || k < 0)
        // hoist checks
        throw new IllegalStateException();
    for (int lh, rh; ; ) {
        // split larger, find point in smaller
        if (ln >= rn) {
            if (ln <= g)
                break;
            rh = rn;
            byte split = a[(lh = ln >>> 1) + lb];
            for (int lo = 0; lo < rh; ) {
                int rm = (lo + rh) >>> 1;
                if (split <= a[rm + rb])
                    rh = rm;
                else
                    lo = rm + 1;
            }
        } else {
            if (rn <= g)
                break;
            lh = ln;
            byte split = a[(rh = rn >>> 1) + rb];
            for (int lo = 0; lo < lh; ) {
                int lm = (lo + lh) >>> 1;
                if (split <= a[lm + lb])
                    lh = lm;
                else
                    lo = lm + 1;
            }
        }
        Merger m = new Merger(this, a, w, lb + lh, ln - lh, rb + rh, rn - rh, k + lh + rh, g);
        rn = rh;
        ln = lh;
        addToPendingCount(1);
        m.fork();
    }
    // index bounds
    int lf = lb + ln, rf = rb + rn;
    while (lb < lf && rb < rf) {
        byte t, al, ar;
        if ((al = a[lb]) <= (ar = a[rb])) {
            lb++;
            t = al;
        } else {
            rb++;
            t = ar;
        }
        w[k++] = t;
    }
    if (rb < rf)
        System.arraycopy(a, rb, w, k, rf - rb);
    else if (lb < lf)
        System.arraycopy(a, lb, w, k, lf - lb);
    tryComplete();
}
#end_block

#method_before
private void test_parallelSort$B(int mul256Count) {
    int size = 256 * mul256Count;
    byte[] reversedArray = new byte[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = (byte) (size - counter - 1);
    Arrays.parallelSort(reversedArray);
    HashMap<Byte, Integer> valCount = new HashMap<>();
    valCount.put(reversedArray[0], 1);
    for (int counter = 1; counter < size; counter++) {
        assertTrue(reversedArray[counter - 1] <= reversedArray[counter]);
        Integer prevVal = valCount.get(reversedArray[counter]);
        if (prevVal == null) {
            prevVal = new Integer(0);
        }
        valCount.put(reversedArray[counter], ++prevVal);
    }
    assertEquals(256, valCount.size());
    for (Map.Entry<Byte, Integer> entry : valCount.entrySet()) {
        assertEquals(mul256Count, (int) entry.getValue());
    }
}
#method_after
private void test_parallelSort$B(int size) {
    if (size % 256 != 0) {
        fail("test_parallelSort$B size needs to be dividable by 256");
    }
    int mul256Count = size / 256;
    byte[] sortedArray = new byte[size];
    byte curentValue = Byte.MIN_VALUE;
    for (int counter = 0; counter < size; counter++) {
        sortedArray[counter] = curentValue;
        if (counter != 0 && counter % mul256Count == 0) {
            curentValue++;
        }
    }
    byte[] reversedArray = new byte[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
}
#end_block

#method_before
public void test_parallelSort$B() {
    // This will result in single thread sort
    assertTrue(256 <= Arrays.MIN_ARRAY_SORT_GRAN);
    test_parallelSort$B(1);
    // This should trigger true parallel sort
    if (ForkJoinPool.getCommonPoolParallelism() > 1) {
        assertTrue(256 * 64 > Arrays.MIN_ARRAY_SORT_GRAN);
        test_parallelSort$B(64);
    }
}
#method_after
public void test_parallelSort$B() {
    // This will result in single thread sort
    assertTrue(256 <= Arrays.MIN_ARRAY_SORT_GRAN);
    test_parallelSort$B(256);
    // This should trigger true parallel sort
    if (ForkJoinPool.getCommonPoolParallelism() > 1) {
        assertTrue(256 * 64 > Arrays.MIN_ARRAY_SORT_GRAN);
        test_parallelSort$B(256 * 64);
    }
}
#end_block

#method_before
private void test_parallelSort$BII(int mul256Count) {
    int size = mul256Count * 256 + 256;
    int startIndex = 100;
    int endIndex = 100 + mul256Count * 256;
    byte[] reversedArray = new byte[size];
    byte[] originalReversedArray = new byte[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (byte) (100);
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (byte) (100);
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (byte) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$BII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    byte[] reversedArray = new byte[size];
    byte[] originalReversedArray = new byte[size];
    Arrays.fill(reversedArray, 0, startIndex, (byte) 100);
    Arrays.fill(reversedArray, endIndex, size, (byte) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (byte) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$BII() {
    // This will result in single thread sort
    assertTrue(256 <= Arrays.MIN_ARRAY_SORT_GRAN);
    test_parallelSort$BII(1);
    // This should trigger true parallel sort
    if (ForkJoinPool.getCommonPoolParallelism() > 1) {
        assertTrue(256 * 64 > Arrays.MIN_ARRAY_SORT_GRAN);
        test_parallelSort$BII(64);
    }
}
#method_after
public void test_parallelSort$BII() {
    // This will result in single thread sort
    assertTrue(256 <= Arrays.MIN_ARRAY_SORT_GRAN);
    test_parallelSort$BII(256);
    // This should trigger true parallel sort
    if (ForkJoinPool.getCommonPoolParallelism() > 1) {
        assertTrue(256 * 64 > Arrays.MIN_ARRAY_SORT_GRAN);
        test_parallelSort$BII(256 * 64);
    }
}
#end_block

#method_before
public void test_parallelSort$B_NPE() {
    byte[] byte_array_null = null;
    try {
        java.util.Arrays.parallelSort(byte_array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(byte_array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$B_NPE() {
    byte[] byte_array_null = null;
    try {
        java.util.Arrays.parallelSort(byte_array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(byte_array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$C(int size) {
    char[] reversedArray = new char[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = (char) (size - counter - 1);
    Arrays.parallelSort(reversedArray);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", reversedArray[counter] == (char) counter);
}
#method_after
private void test_parallelSort$C(int size) {
    char[] sortedArray = new char[size];
    for (int counter = 0; counter < size; counter++) sortedArray[counter] = (char) (Short.MIN_VALUE + counter);
    char[] reversedArray = new char[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
}
#end_block

#method_before
private void test_parallelSort$CII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    char[] reversedArray = new char[size];
    char[] originalReversedArray = new char[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (char) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (char) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (char) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$CII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    char[] reversedArray = new char[size];
    char[] originalReversedArray = new char[size];
    Arrays.fill(reversedArray, 0, startIndex, (char) 100);
    Arrays.fill(reversedArray, endIndex, size, (char) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (char) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$C_NPE() {
    char[] char_array_null = null;
    try {
        java.util.Arrays.parallelSort(char_array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(char_array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$C_NPE() {
    char[] char_array_null = null;
    try {
        java.util.Arrays.parallelSort(char_array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(char_array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$S(int size) {
    short[] reversedArray = new short[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = (short) (size - counter - 1);
    Arrays.parallelSort(reversedArray);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", reversedArray[counter] == (short) counter);
}
#method_after
private void test_parallelSort$S(int size) {
    short[] sortedArray = new short[size];
    for (int counter = 0; counter < size; counter++) sortedArray[counter] = (short) (Short.MIN_VALUE + counter);
    short[] reversedArray = new short[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
}
#end_block

#method_before
private void test_parallelSort$SII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    short[] reversedArray = new short[size];
    short[] originalReversedArray = new short[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (short) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (short) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (short) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$SII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    short[] reversedArray = new short[size];
    short[] originalReversedArray = new short[size];
    Arrays.fill(reversedArray, 0, startIndex, (short) 100);
    Arrays.fill(reversedArray, endIndex, size, (short) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (short) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$S_NPE() {
    short[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$S_NPE() {
    short[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$I(int size) {
    int[] reversedArray = new int[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = (int) (size - counter - 1);
    Arrays.parallelSort(reversedArray);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", reversedArray[counter] == (int) counter);
}
#method_after
private void test_parallelSort$I(int size) {
    int[] sortedArray = new int[size];
    for (int counter = 0; counter < size; counter++) sortedArray[counter] = (int) (Integer.MIN_VALUE + counter);
    int[] reversedArray = new int[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
}
#end_block

#method_before
private void test_parallelSort$III(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    int[] reversedArray = new int[size];
    int[] originalReversedArray = new int[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (int) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (int) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (int) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$III(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    int[] reversedArray = new int[size];
    int[] originalReversedArray = new int[size];
    Arrays.fill(reversedArray, 0, startIndex, (int) 100);
    Arrays.fill(reversedArray, endIndex, size, (int) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (int) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$I_NPE() {
    int[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$I_NPE() {
    int[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$JII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    long[] reversedArray = new long[size];
    long[] originalReversedArray = new long[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (long) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (long) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (long) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$JII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    long[] reversedArray = new long[size];
    long[] originalReversedArray = new long[size];
    Arrays.fill(reversedArray, 0, startIndex, (long) 100);
    Arrays.fill(reversedArray, endIndex, size, (long) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (long) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$J_NPE() {
    long[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$J_NPE() {
    long[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$D(int size) {
    double[] reversedArray = new double[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = (double) (size - counter - 1);
    Arrays.parallelSort(reversedArray);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", reversedArray[counter] == (double) counter);
}
#method_after
private void test_parallelSort$D(int size) {
    double[] sortedArray = new double[size];
    for (int counter = 0; counter < size; counter++) sortedArray[counter] = (double) (counter);
    double[] reversedArray = new double[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
}
#end_block

#method_before
private void test_parallelSort$DII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    double[] reversedArray = new double[size];
    double[] originalReversedArray = new double[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (double) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (double) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (double) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$DII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    double[] reversedArray = new double[size];
    double[] originalReversedArray = new double[size];
    Arrays.fill(reversedArray, 0, startIndex, (double) 100);
    Arrays.fill(reversedArray, endIndex, size, (double) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (double) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$D_NPE() {
    double[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$D_NPE() {
    double[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$F(int size) {
    float[] reversedArray = new float[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = (float) (size - counter - 1);
    Arrays.parallelSort(reversedArray);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", reversedArray[counter] == (float) counter);
}
#method_after
private void test_parallelSort$F(int size) {
    float[] sortedArray = new float[size];
    for (int counter = 0; counter < size; counter++) sortedArray[counter] = (float) (counter);
    float[] reversedArray = new float[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
}
#end_block

#method_before
private void test_parallelSort$FII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    float[] reversedArray = new float[size];
    float[] originalReversedArray = new float[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = (float) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = (float) 100;
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (float) (size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$FII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    float[] reversedArray = new float[size];
    float[] originalReversedArray = new float[size];
    Arrays.fill(reversedArray, 0, startIndex, (float) 100);
    Arrays.fill(reversedArray, endIndex, size, (float) 100);
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = (float) (size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", reversedArray[counter] <= reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$F_NPE() {
    float[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$F_NPE() {
    float[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$Ljava_lang_Comparable(int size) {
    Integer[] reversedArray = new Integer[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = new Integer(size - counter - 1);
    Arrays.parallelSort(reversedArray);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", (int) (reversedArray[counter]) == counter);
// Uncoment and change Integer array to Comparable array after b/27449372 is done
// Arrays.fill(reversedArray, 0, reversedArray.length/2, "String");
// Arrays.fill(reversedArray, reversedArray.length/2, reversedArray.length, new Integer(1));
// try {
// Arrays.sort(reversedArray);
// fail("ClassCastException expected");
// } catch (ClassCastException e) {
// //expected
// }
}
#method_after
private void test_parallelSort$Ljava_lang_Comparable(int size) {
    Comparable[] sortedArray = new Comparable[size];
    for (int counter = 0; counter < size; counter++) sortedArray[counter] = new Integer(counter);
    Comparable[] reversedArray = new Comparable[size];
    for (int counter = 0; counter < size; counter++) {
        reversedArray[counter] = sortedArray[size - counter - 1];
    }
    Arrays.parallelSort(reversedArray);
    assertTrue(Arrays.equals(sortedArray, reversedArray));
    Arrays.fill(reversedArray, 0, reversedArray.length / 2, "String");
    Arrays.fill(reversedArray, reversedArray.length / 2, reversedArray.length, new Integer(1));
    try {
        Arrays.sort(reversedArray);
        fail("ClassCastException expected");
    } catch (ClassCastException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$Ljava_lang_ComparableII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    Integer[] reversedArray = new Integer[size];
    Integer[] originalReversedArray = new Integer[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = new Integer(100);
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = new Integer(100);
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = new Integer(size - counter - startIndex - 1);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", (int) (Integer) reversedArray[counter] <= (int) reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$Ljava_lang_ComparableII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    Comparable[] reversedArray = new Comparable[size];
    Comparable[] originalReversedArray = new Comparable[size];
    Arrays.fill(reversedArray, 0, startIndex, new Integer(100));
    Arrays.fill(reversedArray, endIndex, size, new Integer(100));
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = new Integer(size - counter - startIndex - 1);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Arrays.parallelSort(reversedArray, startIndex, endIndex);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", (int) (Integer) reversedArray[counter] <= (int) reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$Ljava_lang_Comparable_NPE() {
    Comparable[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$Ljava_lang_Comparable_NPE() {
    Comparable[] array_null = null;
    try {
        java.util.Arrays.parallelSort(array_null);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$Ljava_lang_ObjectLjava_util_Comparator(int size) {
    Object[] reversedArray = new Object[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = new Integer(counter);
    Comparator comparator = new ReversedIntegerComparator();
    Arrays.parallelSort(reversedArray, comparator);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", (int) (reversedArray[counter]) == (size - counter - 1));
    Arrays.fill(reversedArray, 0, reversedArray.length / 2, "String");
    Arrays.fill(reversedArray, reversedArray.length / 2, reversedArray.length, new Integer(1));
    try {
        Arrays.sort(reversedArray, comparator);
        fail("ClassCastException expected");
    } catch (ClassCastException e) {
    // expected
    }
}
#method_after
private void test_parallelSort$Ljava_lang_ObjectLjava_util_Comparator(int size) {
    Object[] reversedArray = new Object[size];
    for (int counter = 0; counter < size; counter++) reversedArray[counter] = new Integer(counter);
    Comparator comparator = new ReversedIntegerComparator();
    Arrays.parallelSort(reversedArray, comparator);
    for (int counter = 0; counter < size; counter++) assertTrue("Resulting array not sorted", (int) (reversedArray[counter]) == (size - counter - 1));
    Arrays.fill(reversedArray, 0, reversedArray.length / 2, "String");
    Arrays.fill(reversedArray, reversedArray.length / 2, reversedArray.length, new Integer(1));
    try {
        Arrays.sort(reversedArray, comparator);
        fail("ClassCastException expected");
    } catch (ClassCastException expected) {
    }
}
#end_block

#method_before
private void test_parallelSort$Ljava_lang_ObjectLjava_util_ComparatorII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    Integer[] reversedArray = new Integer[size];
    Integer[] originalReversedArray = new Integer[size];
    for (int counter = 0; counter < startIndex; counter++) {
        reversedArray[counter] = new Integer(100);
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = endIndex; counter < size; counter++) {
        reversedArray[counter] = new Integer(100);
        originalReversedArray[counter] = reversedArray[counter];
    }
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = new Integer(counter - startIndex);
        originalReversedArray[counter] = reversedArray[counter];
    }
    Comparator comparator = new ReversedIntegerComparator();
    Arrays.parallelSort(reversedArray, startIndex, endIndex, comparator);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", (int) (Integer) reversedArray[counter] >= (int) reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex, comparator);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex, comparator);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1, comparator);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#method_after
private void test_parallelSort$Ljava_lang_ObjectLjava_util_ComparatorII(int size) {
    int startIndex = 100;
    int endIndex = size - 100;
    Integer[] reversedArray = new Integer[size];
    Integer[] originalReversedArray = new Integer[size];
    Arrays.fill(reversedArray, 0, startIndex, new Integer(100));
    Arrays.fill(reversedArray, endIndex, size, new Integer(100));
    for (int counter = startIndex; counter < endIndex; counter++) {
        reversedArray[counter] = new Integer(counter - startIndex);
    }
    System.arraycopy(reversedArray, 0, originalReversedArray, 0, size);
    Comparator comparator = new ReversedIntegerComparator();
    Arrays.parallelSort(reversedArray, startIndex, endIndex, comparator);
    for (int counter = 0; counter < startIndex; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    for (int counter = startIndex; counter < endIndex - 1; counter++) assertTrue("Array not sorted within bounds", (int) (Integer) reversedArray[counter] >= (int) reversedArray[counter + 1]);
    for (int counter = endIndex; counter < arraySize; counter++) assertTrue("Array modified outside of bounds", reversedArray[counter] == originalReversedArray[counter]);
    // exception testing
    try {
        Arrays.parallelSort(reversedArray, startIndex + 1, startIndex, comparator);
        fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, -1, startIndex, comparator);
        fail("ArrayIndexOutOfBoundsException expected (1)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
    try {
        Arrays.parallelSort(reversedArray, startIndex, reversedArray.length + 1, comparator);
        fail("ArrayIndexOutOfBoundsException expected (2)");
    } catch (ArrayIndexOutOfBoundsException ignore) {
    }
}
#end_block

#method_before
public void test_parallelSort$Ljava_lang_ObjectLjava_util_Comparator_NPE() {
    Object[] array_null = null;
    Comparator comparator = new ReversedIntegerComparator();
    try {
        java.util.Arrays.parallelSort(array_null, comparator);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
    try {
        // Regression for HARMONY-378
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1, comparator);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException e) {
    // Expected
    }
}
#method_after
public void test_parallelSort$Ljava_lang_ObjectLjava_util_Comparator_NPE() {
    Object[] array_null = null;
    Comparator comparator = new ReversedIntegerComparator();
    try {
        java.util.Arrays.parallelSort(array_null, comparator);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
    try {
        java.util.Arrays.parallelSort(array_null, (int) -1, (int) 1, comparator);
        fail("Should throw java.lang.NullPointerException");
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void createAllApnList() {
    mAllApnSettings = new ArrayList<ApnSetting>();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    if (operator != null) {
        String selection = "numeric = '" + operator + "'";
        // selection += " and carrier_enabled = 1";
        if (DBG)
            log("createAllApnList: selection=" + selection);
        // ORDER BY Telephony.Carriers._ID ("_id")
        Cursor cursor = mPhone.getContext().getContentResolver().query(Telephony.Carriers.CONTENT_URI, null, selection, null, Telephony.Carriers._ID);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }
    addEmergencyApnSetting();
    dedupeApnSettings();
    if (mAllApnSettings.isEmpty()) {
        if (DBG)
            log("createAllApnList: No APN found for carrier: " + operator);
        mPreferredApn = null;
    // TODO: What is the right behavior?
    // notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG)
            log("createAllApnList: mPreferredApn=" + mPreferredApn);
    }
    if (DBG)
        log("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
    setDataProfilesAsNeeded();
}
#method_after
private void createAllApnList() {
    mAllApnSettings = new ArrayList<ApnSetting>();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    if (operator != null) {
        String selection = Telephony.Carriers.NUMERIC + " = '" + operator + "'";
        // selection += " and carrier_enabled = 1";
        if (DBG)
            log("createAllApnList: selection=" + selection);
        // ORDER BY Telephony.Carriers._ID ("_id")
        Cursor cursor = mPhone.getContext().getContentResolver().query(Telephony.Carriers.CONTENT_URI, null, selection, null, Telephony.Carriers._ID);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }
    addEmergencyApnSetting();
    dedupeApnSettings();
    if (mAllApnSettings.isEmpty()) {
        if (DBG)
            log("createAllApnList: No APN found for carrier: " + operator);
        mPreferredApn = null;
    // TODO: What is the right behavior?
    // notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG)
            log("createAllApnList: mPreferredApn=" + mPreferredApn);
    }
    if (DBG)
        log("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
    setDataProfilesAsNeeded();
}
#end_block

#method_before
// http://b/27426743 - Commented due to conflict with Java 1.8 Map method.
/*public Object remove(String key, V item) {
        ArrayList<V> list = this.map.get(key);
        if (list == null) {
            return null;
        } else {
            return list.remove(item);
        }
    }*/
public List<V> get(Object key) {
    return map.get(key);
}
#method_after
// remove(K, V) conflicts with a Map method added in 1.8. http://b/27426743
/*public Object remove(String key, V item) {
        ArrayList<V> list = this.map.get(key);
        if (list == null) {
            return null;
        } else {
            return list.remove(item);
        }
    }*/
public List<V> get(Object key) {
    return map.get(key);
}
#end_block

#method_before
@Test
public void headerForbidsControlCharacters() throws Exception {
    assertForbiddenHeader(null);
    assertForbiddenHeader("\u0000");
    // Workaround for http://b/26422335
    // assertForbiddenHeader("\n");
    assertForbiddenHeader("a\nb");
    assertForbiddenHeader("\nb");
    // assertForbiddenHeader("\r");
    assertForbiddenHeader("a\rb");
    assertForbiddenHeader("\rb");
    // End of Android modification.
    assertForbiddenHeader("\t");
    assertForbiddenHeader("\u001f");
    assertForbiddenHeader("\u007f");
    assertForbiddenHeader("\u0080");
    assertForbiddenHeader("\ud83c\udf69");
}
#method_after
@Test
public void headerForbidsControlCharacters() throws Exception {
    assertForbiddenHeader(null);
    assertForbiddenHeader("\u0000");
    // Workaround for http://b/26422335 , http://b/26889631
    // assertForbiddenHeader("\n");
    assertForbiddenHeader("a\nb");
    assertForbiddenHeader("\nb");
    // assertForbiddenHeader("\r");
    assertForbiddenHeader("a\rb");
    assertForbiddenHeader("\rb");
    // End of Android modification.
    assertForbiddenHeader("\t");
    assertForbiddenHeader("\u001f");
    assertForbiddenHeader("\u007f");
    assertForbiddenHeader("\u0080");
    assertForbiddenHeader("\ud83c\udf69");
}
#end_block

#method_before
public void testSystem_setSecurityManager_notNull_throwsException() {
    try {
        System.setSecurityManager(new SecurityManager());
        fail("Expected " + SecurityException.class.getName());
    } catch (SecurityException e) {
    // Expected.
    }
}
#method_after
public void testSystem_setSecurityManager_notNull_throwsException() {
    try {
        System.setSecurityManager(new SecurityManager());
        fail("Expected " + SecurityException.class.getName());
    } catch (SecurityException expected) {
    }
}
#end_block

#method_before
public void testUnknownOptionalEnumValue() throws Exception {
    VersionA msgA = new VersionA();
    msgA.optionalA = VersionA.A_VAL_3;
    byte[] msgABytes = MessageNano.toByteArray(msgA);
    // When parsing and reading, the unknown value appears as UNKNOWN.
    VersionB msgB = new VersionB();
    MessageNano.mergeFrom(msgB, msgABytes);
    assertEquals(VersionB.B_UNKNOWN, msgB.optionalB);
    // When serializing and reparsing as A, the old, unknown value wins out (even if a new one is
    // set).
    msgB.optionalB = VersionB.B_VAL_2;
    byte[] msgBBytes = MessageNano.toByteArray(msgB);
    VersionA msgAFromB = new VersionA();
    MessageNano.mergeFrom(msgAFromB, msgBBytes);
    assertEquals(VersionA.A_VAL_3, msgAFromB.optionalA);
}
#method_after
public void testUnknownOptionalEnumValue() throws Exception {
    StandardVersion standardMsg = new StandardVersion();
    standardMsg.optionalField = StandardVersion.VAL_3;
    byte[] standardMsgBytes = MessageNano.toByteArray(standardMsg);
    // When parsing and reading, the unknown value appears as UNKNOWN.
    VersionWithoutVal3 withoutVal3Msg = new VersionWithoutVal3();
    MessageNano.mergeFrom(withoutVal3Msg, standardMsgBytes);
    assertEquals(VersionWithoutVal3.UNKNOWN, withoutVal3Msg.optionalField);
    // When serializing and reparsing as the standard version, the old, unknown value wins out (even
    // if a new one is set).
    withoutVal3Msg.optionalField = VersionWithoutVal3.VAL_2;
    byte[] withoutVal3MsgBytes = MessageNano.toByteArray(withoutVal3Msg);
    StandardVersion standardMsgFromWithoutVal3Msg = new StandardVersion();
    MessageNano.mergeFrom(standardMsgFromWithoutVal3Msg, withoutVal3MsgBytes);
    assertEquals(StandardVersion.VAL_3, standardMsgFromWithoutVal3Msg.optionalField);
}
#end_block

#method_before
public void testUnknownRepeatedEnumValue() throws Exception {
    VersionA msgA = new VersionA();
    msgA.repeatedA = new int[] { VersionA.A_VAL_3, VersionA.A_VAL_2 };
    byte[] msgABytes = MessageNano.toByteArray(msgA);
    // When parsing and reading, the unknown value is stripped out.
    VersionB msgB = new VersionB();
    MessageNano.mergeFrom(msgB, msgABytes);
    assertTrue(Arrays.equals(new int[] { VersionB.B_VAL_2 }, msgB.repeatedB));
    // When serializing and reparsing as A, the old, unknown value reappears, but at the end of
    // all entries (including any newly added ones).
    msgB.repeatedB = new int[] { VersionB.B_VAL_2, VersionB.B_VAL_1 };
    byte[] msgBBytes = MessageNano.toByteArray(msgB);
    VersionA msgAFromB = new VersionA();
    MessageNano.mergeFrom(msgAFromB, msgBBytes);
    assertTrue(Arrays.equals(new int[] { VersionA.A_VAL_2, VersionA.A_VAL_1, VersionA.A_VAL_3 }, msgAFromB.repeatedA));
}
#method_after
public void testUnknownRepeatedEnumValue() throws Exception {
    StandardVersion standardMsg = new StandardVersion();
    standardMsg.repeatedField = new int[] { StandardVersion.VAL_3, StandardVersion.VAL_2 };
    byte[] standardMsgBytes = MessageNano.toByteArray(standardMsg);
    // When parsing and reading, the unknown value is stripped out.
    VersionWithoutVal3 withoutVal3Msg = new VersionWithoutVal3();
    MessageNano.mergeFrom(withoutVal3Msg, standardMsgBytes);
    assertTrue(Arrays.equals(new int[] { VersionWithoutVal3.VAL_2 }, withoutVal3Msg.repeatedField));
    // When serializing and reparsing as the standard version, the old, unknown value reappears, but
    // at the end of all entries (including any newly added ones).
    withoutVal3Msg.repeatedField = new int[] { VersionWithoutVal3.VAL_2, VersionWithoutVal3.VAL_1 };
    byte[] withoutVal3MsgBytes = MessageNano.toByteArray(withoutVal3Msg);
    StandardVersion standardMsgFromWithoutVal3Msg = new StandardVersion();
    MessageNano.mergeFrom(standardMsgFromWithoutVal3Msg, withoutVal3MsgBytes);
    assertTrue(Arrays.equals(new int[] { StandardVersion.VAL_2, StandardVersion.VAL_1, StandardVersion.VAL_3 }, standardMsgFromWithoutVal3Msg.repeatedField));
}
#end_block

#method_before
public void testReverse2() {
    Comparator<Item> comparator = Comparator.naturalOrder();
    assertEquals(comparator, comparator.reversed().reversed());
}
#method_after
public void testReverse2() {
    Comparator<Item> comparator = Comparator.naturalOrder();
    assertSame(comparator, comparator.reversed().reversed());
}
#end_block

#method_before
public void testReverse3() {
    Comparator<Item> comparator = Comparator.comparingInt(Item::getOrderAsInt);
    assertEquals(comparator, comparator.reversed().reversed());
}
#method_after
public void testReverse3() {
    Comparator<Item> comparator = Comparator.comparing(Item::getOrderAsString);
    assertSame(comparator, comparator.reversed().reversed());
}
#end_block

#method_before
// The following contain CAS-based Java implementations used on
// platforms not supporting native instructions
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
#method_after
// The following contain CAS-based Java implementations used on
// platforms not supporting native instructions
/**
 * Atomically adds the given value to the current value of a field
 * or array element within the given object {@code o}
 * at the given {@code offset}.
 *
 * @param o object/array to update the field/element in
 * @param offset field/element offset
 * @param delta the value to add
 * @return the previous value
 * @since 1.8
 */
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
#end_block

#method_before
public final long getAndAddLong(Object o, long offset, long delta) {
    long v;
    do {
        v = getLongVolatile(o, offset);
    } while (!compareAndSwapLong(o, offset, v, v + delta));
    return v;
}
#method_after
/**
 * Atomically adds the given value to the current value of a field
 * or array element within the given object {@code o}
 * at the given {@code offset}.
 *
 * @param o object/array to update the field/element in
 * @param offset field/element offset
 * @param delta the value to add
 * @return the previous value
 * @since 1.8
 */
public final long getAndAddLong(Object o, long offset, long delta) {
    long v;
    do {
        v = getLongVolatile(o, offset);
    } while (!compareAndSwapLong(o, offset, v, v + delta));
    return v;
}
#end_block

#method_before
public final int getAndSetInt(Object o, long offset, int newValue) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, newValue));
    return v;
}
#method_after
/**
 * Atomically exchanges the given value with the current value of
 * a field or array element within the given object {@code o}
 * at the given {@code offset}.
 *
 * @param o object/array to update the field/element in
 * @param offset field/element offset
 * @param newValue new value
 * @return the previous value
 * @since 1.8
 */
public final int getAndSetInt(Object o, long offset, int newValue) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, newValue));
    return v;
}
#end_block

#method_before
public final long getAndSetLong(Object o, long offset, long newValue) {
    long v;
    do {
        v = getLongVolatile(o, offset);
    } while (!compareAndSwapLong(o, offset, v, newValue));
    return v;
}
#method_after
/**
 * Atomically exchanges the given value with the current value of
 * a field or array element within the given object {@code o}
 * at the given {@code offset}.
 *
 * @param o object/array to update the field/element in
 * @param offset field/element offset
 * @param newValue new value
 * @return the previous value
 * @since 1.8
 */
public final long getAndSetLong(Object o, long offset, long newValue) {
    long v;
    do {
        v = getLongVolatile(o, offset);
    } while (!compareAndSwapLong(o, offset, v, newValue));
    return v;
}
#end_block

#method_before
public final Object getAndSetObject(Object o, long offset, Object newValue) {
    Object v;
    do {
        v = getObjectVolatile(o, offset);
    } while (!compareAndSwapObject(o, offset, v, newValue));
    return v;
}
#method_after
/**
 * Atomically exchanges the given reference value with the current
 * reference value of a field or array element within the given
 * object {@code o} at the given {@code offset}.
 *
 * @param o object/array to update the field/element in
 * @param offset field/element offset
 * @param newValue new value
 * @return the previous value
 * @since 1.8
 */
public final Object getAndSetObject(Object o, long offset, Object newValue) {
    Object v;
    do {
        v = getObjectVolatile(o, offset);
    } while (!compareAndSwapObject(o, offset, v, newValue));
    return v;
}
#end_block

#method_before
public static void test_Math_round_D() {
    Math.round(2.1d);
    Assert.assertEquals(Math.round(+0.0d), (long) +0.0);
    Assert.assertEquals(Math.round(-0.0d), (long) +0.0);
    Assert.assertEquals(Math.round(2.0d), 2l);
    Assert.assertEquals(Math.round(2.1d), 2l);
    Assert.assertEquals(Math.round(2.5d), 3l);
    Assert.assertEquals(Math.round(2.9d), 3l);
    Assert.assertEquals(Math.round(3.0d), 3l);
    Assert.assertEquals(Math.round(-2.0d), -2l);
    Assert.assertEquals(Math.round(-2.1d), -2l);
    Assert.assertEquals(Math.round(-2.5d), -2l);
    Assert.assertEquals(Math.round(-2.9d), -3l);
    Assert.assertEquals(Math.round(-3.0d), -3l);
    Assert.assertEquals(Math.round(0.49999999999999994d), 0l);
    Assert.assertEquals(Math.round(Double.NaN), (long) +0.0d);
    Assert.assertEquals(Math.round(Long.MAX_VALUE + 1.0d), Long.MAX_VALUE);
    Assert.assertEquals(Math.round(Long.MIN_VALUE - 1.0d), Long.MIN_VALUE);
    Assert.assertEquals(Math.round(Double.POSITIVE_INFINITY), Long.MAX_VALUE);
    Assert.assertEquals(Math.round(Double.NEGATIVE_INFINITY), Long.MIN_VALUE);
}
#method_after
public static void test_Math_round_D() {
    Math.round(2.1d);
    Assert.assertEquals(Math.round(+0.0d), (long) +0.0);
    Assert.assertEquals(Math.round(-0.0d), (long) +0.0);
    Assert.assertEquals(Math.round(2.0d), 2l);
    Assert.assertEquals(Math.round(2.1d), 2l);
    Assert.assertEquals(Math.round(2.5d), 3l);
    Assert.assertEquals(Math.round(2.9d), 3l);
    Assert.assertEquals(Math.round(3.0d), 3l);
    Assert.assertEquals(Math.round(-2.0d), -2l);
    Assert.assertEquals(Math.round(-2.1d), -2l);
    Assert.assertEquals(Math.round(-2.5d), -2l);
    Assert.assertEquals(Math.round(-2.9d), -3l);
    Assert.assertEquals(Math.round(-3.0d), -3l);
    Assert.assertEquals(Math.round(0.49999999999999994d), 0l);
    // 2^53 - 1
    Assert.assertEquals(Math.round(9007199254740991.0d), 9007199254740991l);
    Assert.assertEquals(Math.round(Double.NaN), (long) +0.0d);
    Assert.assertEquals(Math.round(Long.MAX_VALUE + 1.0d), Long.MAX_VALUE);
    Assert.assertEquals(Math.round(Long.MIN_VALUE - 1.0d), Long.MIN_VALUE);
    Assert.assertEquals(Math.round(Double.POSITIVE_INFINITY), Long.MAX_VALUE);
    Assert.assertEquals(Math.round(Double.NEGATIVE_INFINITY), Long.MIN_VALUE);
}
#end_block

#method_before
public static void test_Math_round_F() {
    Math.round(2.1f);
    Assert.assertEquals(Math.round(+0.0f), (int) +0.0);
    Assert.assertEquals(Math.round(-0.0f), (int) +0.0);
    Assert.assertEquals(Math.round(2.0f), 2);
    Assert.assertEquals(Math.round(2.1f), 2);
    Assert.assertEquals(Math.round(2.5f), 3);
    Assert.assertEquals(Math.round(2.9f), 3);
    Assert.assertEquals(Math.round(3.0f), 3);
    Assert.assertEquals(Math.round(-2.0f), -2);
    Assert.assertEquals(Math.round(-2.1f), -2);
    Assert.assertEquals(Math.round(-2.5f), -2);
    Assert.assertEquals(Math.round(-2.9f), -3);
    Assert.assertEquals(Math.round(-3.0f), -3);
    // 0.4999999701976776123046875
    Assert.assertEquals(Math.round(Float.intBitsToFloat(0x3EFFFFFF)), (int) +0.0f);
    Assert.assertEquals(Math.round(Float.NaN), (int) +0.0f);
    Assert.assertEquals(Math.round(Integer.MAX_VALUE + 1.0f), Integer.MAX_VALUE);
    Assert.assertEquals(Math.round(Integer.MIN_VALUE - 1.0f), Integer.MIN_VALUE);
    Assert.assertEquals(Math.round(Float.POSITIVE_INFINITY), Integer.MAX_VALUE);
    Assert.assertEquals(Math.round(Float.NEGATIVE_INFINITY), Integer.MIN_VALUE);
}
#method_after
public static void test_Math_round_F() {
    Math.round(2.1f);
    Assert.assertEquals(Math.round(+0.0f), (int) +0.0);
    Assert.assertEquals(Math.round(-0.0f), (int) +0.0);
    Assert.assertEquals(Math.round(2.0f), 2);
    Assert.assertEquals(Math.round(2.1f), 2);
    Assert.assertEquals(Math.round(2.5f), 3);
    Assert.assertEquals(Math.round(2.9f), 3);
    Assert.assertEquals(Math.round(3.0f), 3);
    Assert.assertEquals(Math.round(-2.0f), -2);
    Assert.assertEquals(Math.round(-2.1f), -2);
    Assert.assertEquals(Math.round(-2.5f), -2);
    Assert.assertEquals(Math.round(-2.9f), -3);
    Assert.assertEquals(Math.round(-3.0f), -3);
    // 0.4999999701976776123046875
    Assert.assertEquals(Math.round(Float.intBitsToFloat(0x3EFFFFFF)), (int) +0.0f);
    // 2^24 - 1
    Assert.assertEquals(Math.round(16777215.0f), 16777215);
    Assert.assertEquals(Math.round(Float.NaN), (int) +0.0f);
    Assert.assertEquals(Math.round(Integer.MAX_VALUE + 1.0f), Integer.MAX_VALUE);
    Assert.assertEquals(Math.round(Integer.MIN_VALUE - 1.0f), Integer.MIN_VALUE);
    Assert.assertEquals(Math.round(Float.POSITIVE_INFINITY), Integer.MAX_VALUE);
    Assert.assertEquals(Math.round(Float.NEGATIVE_INFINITY), Integer.MIN_VALUE);
}
#end_block

#method_before
public static void test_Math_isNaN_D() {
    // Quiet NaN
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0x7FF4000000000000l)));
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0xFFF4000000000000l)));
    // Signaling NaN
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0x7FF8000000000000l)));
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0xFFF8000000000000l)));
    // Distinct from +/- infinity
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x7FF0000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0xFFF0000000000000l)));
    // Distinct from normal numbers
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x7FE0000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0xFFE0000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0010000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8010000000000000l)));
    // Distinct from +/- zero
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0000000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8000000000000000l)));
    // Distinct from subnormal numbers
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0008000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8008000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0000000000000001l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8000000000000001l)));
}
#method_after
public static void test_Math_isNaN_D() {
    // Quiet NaN.
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0x7FF4000000000000l)));
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0xFFF4000000000000l)));
    // Signaling NaN.
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0x7FF8000000000000l)));
    Assert.assertTrue(Double.isNaN(Double.longBitsToDouble(0xFFF8000000000000l)));
    // Distinct from +/- infinity.
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x7FF0000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0xFFF0000000000000l)));
    // Distinct from normal numbers.
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x7FE0000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0xFFE0000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0010000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8010000000000000l)));
    // Distinct from +/- zero.
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0000000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8000000000000000l)));
    // Distinct from subnormal numbers.
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0008000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8008000000000000l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x0000000000000001l)));
    Assert.assertFalse(Double.isNaN(Double.longBitsToDouble(0x8000000000000001l)));
}
#end_block

#method_before
public static void test_Math_isNaN_F() {
    // Quiet NaN
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0x7FA00000)));
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0xFFA00000)));
    // Signaling NaN
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0x7FC00000)));
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0xFFC00000)));
    // Distinct from +/- infinity
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x7F800000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0xFF800000)));
    // Distinct from normal numbers
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x7F000000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0xFF000000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00800000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80800000)));
    // Distinct from +/- zero
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00000000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80000000)));
    // Distinct from subnormal numbers
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00400000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80400000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00000001)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80000001)));
}
#method_after
public static void test_Math_isNaN_F() {
    // Quiet NaN.
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0x7FA00000)));
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0xFFA00000)));
    // Signaling NaN.
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0x7FC00000)));
    Assert.assertTrue(Float.isNaN(Float.intBitsToFloat(0xFFC00000)));
    // Distinct from +/- infinity.
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x7F800000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0xFF800000)));
    // Distinct from normal numbers.
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x7F000000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0xFF000000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00800000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80800000)));
    // Distinct from +/- zero.
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00000000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80000000)));
    // Distinct from subnormal numbers.
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00400000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80400000)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x00000001)));
    Assert.assertFalse(Float.isNaN(Float.intBitsToFloat(0x80000001)));
}
#end_block

#method_before
public static void test_Math_isInfinite_D() {
    // Distinct from Quiet NaN
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x7FF4000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0xFFF4000000000000l)));
    // Distinct from Signaling NaN
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x7FF8000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0xFFF8000000000000l)));
    // +/- infinity
    Assert.assertTrue(Double.isInfinite(Double.longBitsToDouble(0x7FF0000000000000l)));
    Assert.assertTrue(Double.isInfinite(Double.longBitsToDouble(0xFFF0000000000000l)));
    // Distinct from normal numbers
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x7FE0000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0xFFE0000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0010000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8010000000000000l)));
    // Distinct from +/- zero
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0000000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8000000000000000l)));
    // Distinct from subnormal numbers
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0008000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8008000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0000000000000001l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8000000000000001l)));
}
#method_after
public static void test_Math_isInfinite_D() {
    // Distinct from Quiet NaN.
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x7FF4000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0xFFF4000000000000l)));
    // Distinct from Signaling NaN.
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x7FF8000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0xFFF8000000000000l)));
    // +/- infinity.
    Assert.assertTrue(Double.isInfinite(Double.longBitsToDouble(0x7FF0000000000000l)));
    Assert.assertTrue(Double.isInfinite(Double.longBitsToDouble(0xFFF0000000000000l)));
    // Distinct from normal numbers.
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x7FE0000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0xFFE0000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0010000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8010000000000000l)));
    // Distinct from +/- zero.
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0000000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8000000000000000l)));
    // Distinct from subnormal numbers.
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0008000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8008000000000000l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x0000000000000001l)));
    Assert.assertFalse(Double.isInfinite(Double.longBitsToDouble(0x8000000000000001l)));
}
#end_block

#method_before
public static void test_Math_isInfinite_F() {
    // Distinct from Quiet NaN
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x7FA00000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0xFFA00000)));
    // Distinct from Signaling NaN
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x7FC00000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0xFFC00000)));
    // +/- infinity
    Assert.assertTrue(Float.isInfinite(Float.intBitsToFloat(0x7F800000)));
    Assert.assertTrue(Float.isInfinite(Float.intBitsToFloat(0xFF800000)));
    // Distinct from normal numbers
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x7F000000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0xFF000000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00800000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80800000)));
    // Distinct from +/- zero
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00000000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80000000)));
    // Distinct from subnormal numbers
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00400000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80400000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00000001)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80000001)));
}
#method_after
public static void test_Math_isInfinite_F() {
    // Distinct from Quiet NaN.
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x7FA00000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0xFFA00000)));
    // Distinct from Signaling NaN.
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x7FC00000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0xFFC00000)));
    // +/- infinity.
    Assert.assertTrue(Float.isInfinite(Float.intBitsToFloat(0x7F800000)));
    Assert.assertTrue(Float.isInfinite(Float.intBitsToFloat(0xFF800000)));
    // Distinct from normal numbers.
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x7F000000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0xFF000000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00800000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80800000)));
    // Distinct from +/- zero.
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00000000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80000000)));
    // Distinct from subnormal numbers.
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00400000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80400000)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x00000001)));
    Assert.assertFalse(Float.isInfinite(Float.intBitsToFloat(0x80000001)));
}
#end_block

#method_before
public static void test_StrictMath_round_D() {
    StrictMath.round(2.1d);
    Assert.assertEquals(StrictMath.round(+0.0d), (long) +0.0);
    Assert.assertEquals(StrictMath.round(-0.0d), (long) +0.0);
    Assert.assertEquals(StrictMath.round(2.0d), 2l);
    Assert.assertEquals(StrictMath.round(2.1d), 2l);
    Assert.assertEquals(StrictMath.round(2.5d), 3l);
    Assert.assertEquals(StrictMath.round(2.9d), 3l);
    Assert.assertEquals(StrictMath.round(3.0d), 3l);
    Assert.assertEquals(StrictMath.round(-2.0d), -2l);
    Assert.assertEquals(StrictMath.round(-2.1d), -2l);
    Assert.assertEquals(StrictMath.round(-2.5d), -2l);
    Assert.assertEquals(StrictMath.round(-2.9d), -3l);
    Assert.assertEquals(StrictMath.round(-3.0d), -3l);
    Assert.assertEquals(StrictMath.round(0.49999999999999994d), 0l);
    Assert.assertEquals(StrictMath.round(Double.NaN), (long) +0.0d);
    Assert.assertEquals(StrictMath.round(Long.MAX_VALUE + 1.0d), Long.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Long.MIN_VALUE - 1.0d), Long.MIN_VALUE);
    Assert.assertEquals(StrictMath.round(Double.POSITIVE_INFINITY), Long.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Double.NEGATIVE_INFINITY), Long.MIN_VALUE);
}
#method_after
public static void test_StrictMath_round_D() {
    StrictMath.round(2.1d);
    Assert.assertEquals(StrictMath.round(+0.0d), (long) +0.0);
    Assert.assertEquals(StrictMath.round(-0.0d), (long) +0.0);
    Assert.assertEquals(StrictMath.round(2.0d), 2l);
    Assert.assertEquals(StrictMath.round(2.1d), 2l);
    Assert.assertEquals(StrictMath.round(2.5d), 3l);
    Assert.assertEquals(StrictMath.round(2.9d), 3l);
    Assert.assertEquals(StrictMath.round(3.0d), 3l);
    Assert.assertEquals(StrictMath.round(-2.0d), -2l);
    Assert.assertEquals(StrictMath.round(-2.1d), -2l);
    Assert.assertEquals(StrictMath.round(-2.5d), -2l);
    Assert.assertEquals(StrictMath.round(-2.9d), -3l);
    Assert.assertEquals(StrictMath.round(-3.0d), -3l);
    Assert.assertEquals(StrictMath.round(0.49999999999999994d), 0l);
    // 2^53 - 1
    Assert.assertEquals(StrictMath.round(9007199254740991.0d), 9007199254740991l);
    Assert.assertEquals(StrictMath.round(Double.NaN), (long) +0.0d);
    Assert.assertEquals(StrictMath.round(Long.MAX_VALUE + 1.0d), Long.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Long.MIN_VALUE - 1.0d), Long.MIN_VALUE);
    Assert.assertEquals(StrictMath.round(Double.POSITIVE_INFINITY), Long.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Double.NEGATIVE_INFINITY), Long.MIN_VALUE);
}
#end_block

#method_before
public static void test_StrictMath_round_F() {
    StrictMath.round(2.1f);
    Assert.assertEquals(StrictMath.round(+0.0f), (int) +0.0);
    Assert.assertEquals(StrictMath.round(-0.0f), (int) +0.0);
    Assert.assertEquals(StrictMath.round(2.0f), 2);
    Assert.assertEquals(StrictMath.round(2.1f), 2);
    Assert.assertEquals(StrictMath.round(2.5f), 3);
    Assert.assertEquals(StrictMath.round(2.9f), 3);
    Assert.assertEquals(StrictMath.round(3.0f), 3);
    Assert.assertEquals(StrictMath.round(-2.0f), -2);
    Assert.assertEquals(StrictMath.round(-2.1f), -2);
    Assert.assertEquals(StrictMath.round(-2.5f), -2);
    Assert.assertEquals(StrictMath.round(-2.9f), -3);
    Assert.assertEquals(StrictMath.round(-3.0f), -3);
    Assert.assertEquals(StrictMath.round(Float.NaN), (int) +0.0f);
    Assert.assertEquals(StrictMath.round(Integer.MAX_VALUE + 1.0f), Integer.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Integer.MIN_VALUE - 1.0f), Integer.MIN_VALUE);
    Assert.assertEquals(StrictMath.round(Float.POSITIVE_INFINITY), Integer.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Float.NEGATIVE_INFINITY), Integer.MIN_VALUE);
}
#method_after
public static void test_StrictMath_round_F() {
    StrictMath.round(2.1f);
    Assert.assertEquals(StrictMath.round(+0.0f), (int) +0.0);
    Assert.assertEquals(StrictMath.round(-0.0f), (int) +0.0);
    Assert.assertEquals(StrictMath.round(2.0f), 2);
    Assert.assertEquals(StrictMath.round(2.1f), 2);
    Assert.assertEquals(StrictMath.round(2.5f), 3);
    Assert.assertEquals(StrictMath.round(2.9f), 3);
    Assert.assertEquals(StrictMath.round(3.0f), 3);
    Assert.assertEquals(StrictMath.round(-2.0f), -2);
    Assert.assertEquals(StrictMath.round(-2.1f), -2);
    Assert.assertEquals(StrictMath.round(-2.5f), -2);
    Assert.assertEquals(StrictMath.round(-2.9f), -3);
    Assert.assertEquals(StrictMath.round(-3.0f), -3);
    // 0.4999999701976776123046875
    Assert.assertEquals(StrictMath.round(Float.intBitsToFloat(0x3EFFFFFF)), (int) +0.0f);
    // 2^24 - 1
    Assert.assertEquals(StrictMath.round(16777215.0f), 16777215);
    Assert.assertEquals(StrictMath.round(Float.NaN), (int) +0.0f);
    Assert.assertEquals(StrictMath.round(Integer.MAX_VALUE + 1.0f), Integer.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Integer.MIN_VALUE - 1.0f), Integer.MIN_VALUE);
    Assert.assertEquals(StrictMath.round(Float.POSITIVE_INFINITY), Integer.MAX_VALUE);
    Assert.assertEquals(StrictMath.round(Float.NEGATIVE_INFINITY), Integer.MIN_VALUE);
}
#end_block

#method_before
public void addDexPath(String dexPath) {
    this.pathList.addDexPath(dexPath, null);
}
#method_after
public void addDexPath(String dexPath) {
    pathList.addDexPath(dexPath, null);
}
#end_block

#method_before
// ******  Array allocation and resizing utilities ******
private void allocateElements(int numElements) {
    int initialCapacity = MIN_INITIAL_CAPACITY;
    // Tests "<=" because arrays aren't kept full.
    if (numElements >= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity >>> 1);
        initialCapacity |= (initialCapacity >>> 2);
        initialCapacity |= (initialCapacity >>> 4);
        initialCapacity |= (initialCapacity >>> 8);
        initialCapacity |= (initialCapacity >>> 16);
        initialCapacity++;
        if (// Too many elements, must back off
        initialCapacity < 0)
            // Good luck allocating 2 ^ 30 elements
            initialCapacity >>>= 1;
    }
    elements = (E[]) new Object[initialCapacity];
}
#method_after
// ******  Array allocation and resizing utilities ******
private void allocateElements(int numElements) {
    int initialCapacity = MIN_INITIAL_CAPACITY;
    // Tests "<=" because arrays aren't kept full.
    if (numElements >= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity >>> 1);
        initialCapacity |= (initialCapacity >>> 2);
        initialCapacity |= (initialCapacity >>> 4);
        initialCapacity |= (initialCapacity >>> 8);
        initialCapacity |= (initialCapacity >>> 16);
        initialCapacity++;
        if (// Too many elements, must back off
        initialCapacity < 0)
            // Good luck allocating 2 ^ 30 elements
            initialCapacity >>>= 1;
    }
    elements = new Object[initialCapacity];
}
#end_block

#method_before
private void doubleCapacity() {
    assert head == tail;
    int p = head;
    int n = elements.length;
    // number of elements to the right of p
    int r = n - p;
    int newCapacity = n << 1;
    if (newCapacity < 0)
        throw new IllegalStateException("Sorry, deque too big");
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);
    System.arraycopy(elements, 0, a, r, p);
    elements = (E[]) a;
    head = 0;
    tail = n;
}
#method_after
private void doubleCapacity() {
    assert head == tail;
    int p = head;
    int n = elements.length;
    // number of elements to the right of p
    int r = n - p;
    int newCapacity = n << 1;
    if (newCapacity < 0)
        throw new IllegalStateException("Sorry, deque too big");
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);
    System.arraycopy(elements, 0, a, r, p);
    elements = a;
    head = 0;
    tail = n;
}
#end_block

#method_before
public E pollFirst() {
    int h = head;
    // Element is null if deque empty
    E result = elements[h];
    if (result == null)
        return null;
    // Must null out slot
    elements[h] = null;
    head = (h + 1) & (elements.length - 1);
    return result;
}
#method_after
public E pollFirst() {
    int h = head;
    @SuppressWarnings("unchecked")
    E result = (E) elements[h];
    // Element is null if deque empty
    if (result == null)
        return null;
    // Must null out slot
    elements[h] = null;
    head = (h + 1) & (elements.length - 1);
    return result;
}
#end_block

#method_before
public E pollLast() {
    int t = (tail - 1) & (elements.length - 1);
    E result = elements[t];
    if (result == null)
        return null;
    elements[t] = null;
    tail = t;
    return result;
}
#method_after
public E pollLast() {
    int t = (tail - 1) & (elements.length - 1);
    @SuppressWarnings("unchecked")
    E result = (E) elements[t];
    if (result == null)
        return null;
    elements[t] = null;
    tail = t;
    return result;
}
#end_block

#method_before
public E getFirst() {
    E x = elements[head];
    if (x == null)
        throw new NoSuchElementException();
    return x;
}
#method_after
public E getFirst() {
    @SuppressWarnings("unchecked")
    E result = (E) elements[head];
    if (result == null)
        throw new NoSuchElementException();
    return result;
}
#end_block

#method_before
public E getLast() {
    E x = elements[(tail - 1) & (elements.length - 1)];
    if (x == null)
        throw new NoSuchElementException();
    return x;
}
#method_after
public E getLast() {
    @SuppressWarnings("unchecked")
    E result = (E) elements[(tail - 1) & (elements.length - 1)];
    if (result == null)
        throw new NoSuchElementException();
    return result;
}
#end_block

#method_before
public E peekFirst() {
    // elements[head] is null if deque empty
    return elements[head];
}
#method_after
@SuppressWarnings("unchecked")
public E peekFirst() {
    // elements[head] is null if deque empty
    return (E) elements[head];
}
#end_block

#method_before
public E peekLast() {
    return elements[(tail - 1) & (elements.length - 1)];
}
#method_after
@SuppressWarnings("unchecked")
public E peekLast() {
    return (E) elements[(tail - 1) & (elements.length - 1)];
}
#end_block

#method_before
public boolean removeFirstOccurrence(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = head;
    E x;
    while ((x = elements[i]) != null) {
        if (o.equals(x)) {
            delete(i);
            return true;
        }
        i = (i + 1) & mask;
    }
    return false;
}
#method_after
public boolean removeFirstOccurrence(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = head;
    Object x;
    while ((x = elements[i]) != null) {
        if (o.equals(x)) {
            delete(i);
            return true;
        }
        i = (i + 1) & mask;
    }
    return false;
}
#end_block

#method_before
public boolean removeLastOccurrence(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = (tail - 1) & mask;
    E x;
    while ((x = elements[i]) != null) {
        if (o.equals(x)) {
            delete(i);
            return true;
        }
        i = (i - 1) & mask;
    }
    return false;
}
#method_after
public boolean removeLastOccurrence(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = (tail - 1) & mask;
    Object x;
    while ((x = elements[i]) != null) {
        if (o.equals(x)) {
            delete(i);
            return true;
        }
        i = (i - 1) & mask;
    }
    return false;
}
#end_block

#method_before
private void checkInvariants() {
    assert elements[tail] == null;
    assert head == tail ? elements[head] == null : (elements[head] != null && elements[(tail - 1) & (elements.length - 1)] != null);
    assert elements[(head - 1) & (elements.length - 1)] == null;
}
#method_after
private void checkInvariants() {
// assert elements[tail] == null;
// assert head == tail ? elements[head] == null :
// (elements[head] != null &&
// elements[(tail - 1) & (elements.length - 1)] != null);
// assert elements[(head - 1) & (elements.length - 1)] == null;
}
#end_block

#method_before
private boolean delete(int i) {
    checkInvariants();
    final E[] elements = this.elements;
    final int mask = elements.length - 1;
    final int h = head;
    final int t = tail;
    final int front = (i - h) & mask;
    final int back = (t - i) & mask;
    // Invariant: head <= i < tail mod circularity
    if (front >= ((t - h) & mask))
        throw new ConcurrentModificationException();
    // Optimize for least element motion
    if (front < back) {
        if (h <= i) {
            System.arraycopy(elements, h, elements, h + 1, front);
        } else {
            // Wrap around
            System.arraycopy(elements, 0, elements, 1, i);
            elements[0] = elements[mask];
            System.arraycopy(elements, h, elements, h + 1, mask - h);
        }
        elements[h] = null;
        head = (h + 1) & mask;
        return false;
    } else {
        if (i < t) {
            // Copy the null tail as well
            System.arraycopy(elements, i + 1, elements, i, back);
            tail = t - 1;
        } else {
            // Wrap around
            System.arraycopy(elements, i + 1, elements, i, mask - i);
            elements[mask] = elements[0];
            System.arraycopy(elements, 1, elements, 0, t);
            tail = (t - 1) & mask;
        }
        return true;
    }
}
#method_after
private boolean delete(int i) {
    // checkInvariants();
    final Object[] elements = this.elements;
    final int mask = elements.length - 1;
    final int h = head;
    final int t = tail;
    final int front = (i - h) & mask;
    final int back = (t - i) & mask;
    // Invariant: head <= i < tail mod circularity
    if (front >= ((t - h) & mask))
        throw new ConcurrentModificationException();
    // Optimize for least element motion
    if (front < back) {
        if (h <= i) {
            System.arraycopy(elements, h, elements, h + 1, front);
        } else {
            // Wrap around
            System.arraycopy(elements, 0, elements, 1, i);
            elements[0] = elements[mask];
            System.arraycopy(elements, h, elements, h + 1, mask - h);
        }
        elements[h] = null;
        head = (h + 1) & mask;
        return false;
    } else {
        if (i < t) {
            // Copy the null tail as well
            System.arraycopy(elements, i + 1, elements, i, back);
            tail = t - 1;
        } else {
            // Wrap around
            System.arraycopy(elements, i + 1, elements, i, mask - i);
            elements[mask] = elements[0];
            System.arraycopy(elements, 1, elements, 0, t);
            tail = (t - 1) & mask;
        }
        return true;
    }
}
#end_block

#method_before
public E next() {
    if (cursor == fence)
        throw new NoSuchElementException();
    E result = elements[cursor];
    // but does catch the ones that corrupt traversal
    if (tail != fence || result == null)
        throw new ConcurrentModificationException();
    lastRet = cursor;
    cursor = (cursor + 1) & (elements.length - 1);
    return result;
}
#method_after
public E next() {
    if (cursor == fence)
        throw new NoSuchElementException();
    @SuppressWarnings("unchecked")
    E result = (E) elements[cursor];
    // but does catch the ones that corrupt traversal
    if (tail != fence || result == null)
        throw new ConcurrentModificationException();
    lastRet = cursor;
    cursor = (cursor + 1) & (elements.length - 1);
    return result;
}
#end_block

#method_before
public E next() {
    if (cursor == fence)
        throw new NoSuchElementException();
    cursor = (cursor - 1) & (elements.length - 1);
    E result = elements[cursor];
    if (head != fence || result == null)
        throw new ConcurrentModificationException();
    lastRet = cursor;
    return result;
}
#method_after
public E next() {
    if (cursor == fence)
        throw new NoSuchElementException();
    cursor = (cursor - 1) & (elements.length - 1);
    @SuppressWarnings("unchecked")
    E result = (E) elements[cursor];
    if (head != fence || result == null)
        throw new ConcurrentModificationException();
    lastRet = cursor;
    return result;
}
#end_block

#method_before
public boolean contains(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = head;
    E x;
    while ((x = elements[i]) != null) {
        if (o.equals(x))
            return true;
        i = (i + 1) & mask;
    }
    return false;
}
#method_after
public boolean contains(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = head;
    Object x;
    while ((x = elements[i]) != null) {
        if (o.equals(x))
            return true;
        i = (i + 1) & mask;
    }
    return false;
}
#end_block

#method_before
public Object[] toArray() {
    return copyElements(new Object[size()]);
}
#method_after
public Object[] toArray() {
    final int head = this.head;
    final int tail = this.tail;
    boolean wrap = (tail < head);
    int end = wrap ? tail + elements.length : tail;
    Object[] a = Arrays.copyOfRange(elements, head, end);
    if (wrap)
        System.arraycopy(elements, 0, a, elements.length - head, tail);
    return a;
}
#end_block

#method_before
public <T> T[] toArray(T[] a) {
    int size = size();
    if (a.length < size)
        a = (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);
    copyElements(a);
    if (a.length > size)
        a[size] = null;
    return a;
}
#method_after
@SuppressWarnings("unchecked")
public <T> T[] toArray(T[] a) {
    final int head = this.head;
    final int tail = this.tail;
    boolean wrap = (tail < head);
    int size = (tail - head) + (wrap ? elements.length : 0);
    int firstLeg = size - (wrap ? tail : 0);
    int len = a.length;
    if (size > len) {
        a = (T[]) Arrays.copyOfRange(elements, head, head + size, a.getClass());
    } else {
        System.arraycopy(elements, head, a, 0, firstLeg);
        if (size < len)
            a[size] = null;
    }
    if (wrap)
        System.arraycopy(elements, 0, a, firstLeg, tail);
    return a;
}
#end_block

#method_before
// *** Object methods ***
public ArrayDeque<E> clone() {
    try {
        ArrayDeque<E> result = (ArrayDeque<E>) super.clone();
        result.elements = Arrays.copyOf(elements, elements.length);
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
#method_after
// *** Object methods ***
public ArrayDeque<E> clone() {
    try {
        @SuppressWarnings("unchecked")
        ArrayDeque<E> result = (ArrayDeque<E>) super.clone();
        result.elements = Arrays.copyOf(elements, elements.length);
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
#end_block

#method_before
private void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
    // Write out size
    s.writeInt(size());
    // Write out elements in order.
    int mask = elements.length - 1;
    for (int i = head; i != tail; i = (i + 1) & mask) s.writeObject(elements[i]);
}
#method_after
private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
    s.defaultWriteObject();
    // Write out size
    s.writeInt(size());
    // Write out elements in order.
    int mask = elements.length - 1;
    for (int i = head; i != tail; i = (i + 1) & mask) s.writeObject(elements[i]);
}
#end_block

#method_before
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();
    // Read in size and allocate array
    int size = s.readInt();
    allocateElements(size);
    head = 0;
    tail = size;
    // Read in all elements in the proper order.
    for (int i = 0; i < size; i++) elements[i] = (E) s.readObject();
}
#method_after
private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
    s.defaultReadObject();
    // Read in size and allocate array
    int size = s.readInt();
    allocateElements(size);
    head = 0;
    tail = size;
    // Read in all elements in the proper order.
    for (int i = 0; i < size; i++) elements[i] = s.readObject();
}
#end_block

#method_before
public String SayHi() {
    return iface2.super.SayHi() + " and welcome ";
}
#method_after
public String SayHi() {
    return Iface2.super.SayHi() + " and welcome ";
}
#end_block

#method_before
public static void main(String[] args) {
    System.out.println(iface.SayHi());
}
#method_after
public static void main(String[] args) {
    System.out.println(Iface.SayHi());
}
#end_block

#method_before
public static void main(String[] args) {
    A a = new A();
    System.out.println(a.SayHi("a string 0", "a string 1", "a string 2", "a string 3", "a string 4", "a string 5", "a string 6", "a string 7", "a string 8", "a string 9"));
    iface b = (iface) a;
    System.out.println(b.SayHi("a string 0", "a string 1", "a string 2", "a string 3", "a string 4", "a string 5", "a string 6", "a string 7", "a string 8", "a string 9"));
}
#method_after
public static void main(String[] args) {
    A a = new A();
    System.out.println(a.SayHi("a string 0", "a string 1", "a string 2", "a string 3", "a string 4", "a string 5", "a string 6", "a string 7", "a string 8", "a string 9"));
    Iface b = a;
    System.out.println(b.SayHi("a string 0", "a string 1", "a string 2", "a string 3", "a string 4", "a string 5", "a string 6", "a string 7", "a string 8", "a string 9"));
}
#end_block

#method_before
public String SayHi() {
    return iface.super.SayHi() + " and welcome ";
}
#method_after
public String SayHi() {
    return Iface.super.SayHi() + " and welcome ";
}
#end_block

#method_before
public String SayHi() {
    return iface3.super.SayHi() + " there!";
}
#method_after
public String SayHi() {
    return Iface3.super.SayHi() + " there!";
}
#end_block

#method_before
public static void sort(Object[] a, int fromIndex, int toIndex) {
    if (LegacyMergeSort.userRequested)
        legacyMergeSort(a, fromIndex, toIndex);
    else
        ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
}
#method_after
public static void sort(Object[] a, int fromIndex, int toIndex) {
    rangeCheck(a.length, fromIndex, toIndex);
    if (LegacyMergeSort.userRequested)
        legacyMergeSort(a, fromIndex, toIndex);
    else
        ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
}
#end_block

#method_before
public void run() {
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    logWriter.println("Breakpoint003Debuggee started");
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    callFrameworkMethod(VALUE_STRING);
    logWriter.println("Breakpoint003Debuggee finished");
}
#method_after
public void run() {
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    logWriter.println("Breakpoint003Debuggee started");
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    callFrameworkMethod1(VALUE_STRING);
    callFrameworkMethod2(VALUE_LONG);
    logWriter.println("Breakpoint003Debuggee finished");
}
#end_block

#method_before
public void testBreakPointInFrameworkCode() {
    test("testBreakPointInIntegerParseInt");
}
#method_after
public void testBreakPointInFrameworkCode() {
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    int breakpoint1 = setBreakPoint("Ljava/lang/Integer;", "parseInt");
    int breakpoint2 = setBreakPoint("Ljava/lang/Long;", "toString");
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    test("testBreakPointInIntegerParseInt", "parseInt", breakpoint1, 0, JDWPConstants.Tag.STRING_TAG, Breakpoint003Debuggee.VALUE_STRING);
    resumeDebuggee();
    test("testBreakPointInLongToString", "toString", breakpoint2, 0, JDWPConstants.Tag.LONG_TAG, Breakpoint003Debuggee.VALUE_LONG);
}
#end_block

#method_before
private void test(String testName) {
    logWriter.println(testName + " started");
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    long classID = debuggeeWrapper.vmMirror.getClassID("Ljava/lang/Integer;");
    assertTrue("Failed to find String class", classID != -1);
    int breakpointReqID = debuggeeWrapper.vmMirror.setBreakpointAtMethodBegin(classID, "parseInt");
    assertTrue("Failed to install breakpoint in Integer.parseInt ", breakpointReqID != -1);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    long eventThreadID = debuggeeWrapper.vmMirror.waitForBreakpoint(breakpointReqID);
    checkThreadState(eventThreadID, JDWPConstants.ThreadStatus.RUNNING, JDWPConstants.SuspendStatus.SUSPEND_STATUS_SUSPENDED);
    // Get and check top frame's method name.
    CommandPacket packet = new CommandPacket(JDWPCommands.ThreadReferenceCommandSet.CommandSetID, JDWPCommands.ThreadReferenceCommandSet.FramesCommand);
    packet.setNextValueAsThreadID(eventThreadID);
    // start from frame 0
    packet.setNextValueAsInt(0);
    // length of frames
    packet.setNextValueAsInt(1);
    ReplyPacket reply = debuggeeWrapper.vmMirror.performCommand(packet);
    checkReplyPacket(reply, "ThreadReference::FramesCommand command");
    int frames = reply.getNextValueAsInt();
    assertEquals("Invalid number of frames", frames, 1);
    long frameID = reply.getNextValueAsLong();
    Location location = reply.getNextValueAsLocation();
    String methodName = getMethodName(location.classID, location.methodID);
    assertEquals("Invalid method name", methodName, "parseInt");
    // Get and check top frame's incoming String argument.
    packet = new CommandPacket(JDWPCommands.StackFrameCommandSet.CommandSetID, JDWPCommands.StackFrameCommandSet.GetValuesCommand);
    packet.setNextValueAsThreadID(eventThreadID);
    packet.setNextValueAsFrameID(frameID);
    // Get 1 value.
    packet.setNextValueAsInt(1);
    // Slot 0.
    packet.setNextValueAsInt(0);
    packet.setNextValueAsByte(JDWPConstants.Tag.STRING_TAG);
    // check reply for errors
    reply = debuggeeWrapper.vmMirror.performCommand(packet);
    checkReplyPacket(reply, "StackFrame::GetValues command");
    // check number of retrieved values
    int numberOfValues = reply.getNextValueAsInt();
    assertEquals("Invalid number of values", numberOfValues, 1);
    Value val = reply.getNextValueAsValue();
    assertEquals("Invalid valud tag", val.getTag(), JDWPConstants.Tag.STRING_TAG);
    long strLocalVariableID = val.getLongValue();
    String strLocalVariable = getStringValue(strLocalVariableID);
    assertEquals("Invalid valud tag", strLocalVariable, Breakpoint003Debuggee.VALUE_STRING);
    logWriter.println(testName + " done");
}
#method_after
private void test(String testName, String methodName, int breakpointReqID, int slot, byte tag, Object expectedValue) {
    logWriter.println(testName + " started");
    long eventThreadID = debuggeeWrapper.vmMirror.waitForBreakpoint(breakpointReqID);
    checkThreadState(eventThreadID, JDWPConstants.ThreadStatus.RUNNING, JDWPConstants.SuspendStatus.SUSPEND_STATUS_SUSPENDED);
    // Get and check top frame's method name.
    CommandPacket packet = new CommandPacket(JDWPCommands.ThreadReferenceCommandSet.CommandSetID, JDWPCommands.ThreadReferenceCommandSet.FramesCommand);
    packet.setNextValueAsThreadID(eventThreadID);
    // start from frame 0
    packet.setNextValueAsInt(0);
    // length of frames
    packet.setNextValueAsInt(1);
    ReplyPacket reply = debuggeeWrapper.vmMirror.performCommand(packet);
    checkReplyPacket(reply, "ThreadReference::FramesCommand command");
    int frames = reply.getNextValueAsInt();
    assertEquals("Invalid number of frames", frames, 1);
    long frameID = reply.getNextValueAsLong();
    Location location = reply.getNextValueAsLocation();
    String receivedMethodName = getMethodName(location.classID, location.methodID);
    assertEquals("Invalid method name", receivedMethodName, methodName);
    // Get and check top frame's incoming argument.
    packet = new CommandPacket(JDWPCommands.StackFrameCommandSet.CommandSetID, JDWPCommands.StackFrameCommandSet.GetValuesCommand);
    packet.setNextValueAsThreadID(eventThreadID);
    packet.setNextValueAsFrameID(frameID);
    // Get 1 value.
    packet.setNextValueAsInt(1);
    // Slot 0.
    packet.setNextValueAsInt(0);
    packet.setNextValueAsByte(tag);
    // check reply for errors
    reply = debuggeeWrapper.vmMirror.performCommand(packet);
    checkReplyPacket(reply, "StackFrame::GetValues command");
    // check number of retrieved values
    int numberOfValues = reply.getNextValueAsInt();
    assertEquals("Invalid number of values", numberOfValues, 1);
    Value val = reply.getNextValueAsValue();
    assertTagEquals("Invalid value tag", val.getTag(), tag);
    long longVal = val.getLongValue();
    if (tag == JDWPConstants.Tag.STRING_TAG) {
        String strLocalVariable = getStringValue(longVal);
        assertEquals("Invalid String value", strLocalVariable, expectedValue);
    } else if (tag == JDWPConstants.Tag.LONG_TAG) {
        assertEquals("Invalid long value", longVal, expectedValue);
    }
    logWriter.println(testName + " done");
}
#end_block

#method_before
public void storeCameraInfo(InfoStore store, String cameraId) throws Exception {
    try {
        CameraCharacteristics chars = mCameraManager.getCameraCharacteristics(cameraId);
        // per camera chars
        store.startGroup();
        store.addResult("cameraId", cameraId);
        storeCameraChars(store, chars);
        // per camera chars
        store.endGroup();
    } catch (CameraAccessException e) {
        Log.e(TAG, "Unable to get camera camera static info, skip this camera, error: " + e.getMessage());
    }
    return;
}
#method_after
public void storeCameraInfo(String cameraId) throws Exception {
    try {
        CameraCharacteristics chars = mCameraManager.getCameraCharacteristics(cameraId);
        // per camera chars
        mStore.startGroup();
        mStore.addResult("cameraId", cameraId);
        storeCameraChars(chars);
        // per camera chars
        mStore.endGroup();
    } catch (CameraAccessException e) {
        Log.e(TAG, "Unable to get camera camera static info, skip this camera, error: " + e.getMessage());
    }
    return;
}
#end_block

#method_before
private static void storeRational(Rational rat, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.addResult("numerator", rat.getNumerator());
    store.addResult("denominator", rat.getDenominator());
    store.endGroup();
}
#method_after
private void storeRational(Rational rat, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.addResult("numerator", rat.getNumerator());
    mStore.addResult("denominator", rat.getDenominator());
    mStore.endGroup();
}
#end_block

#method_before
private static void storeSize(Size size, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.addResult("width", size.getWidth());
    store.addResult("height", size.getHeight());
    store.endGroup();
}
#method_after
private void storeSize(Size size, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.addResult("width", size.getWidth());
    mStore.addResult("height", size.getHeight());
    mStore.endGroup();
}
#end_block

#method_before
private static void storeSizeF(SizeF size, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.addResult("width", size.getWidth());
    store.addResult("height", size.getHeight());
    store.endGroup();
}
#method_after
private void storeSizeF(SizeF size, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.addResult("width", size.getWidth());
    mStore.addResult("height", size.getHeight());
    mStore.endGroup();
}
#end_block

#method_before
private static void storeRect(Rect rect, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.addResult("left", rect.left);
    store.addResult("right", rect.right);
    store.addResult("top", rect.top);
    store.addResult("bottom", rect.bottom);
    store.endGroup();
}
#method_after
private void storeRect(Rect rect, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.addResult("left", rect.left);
    mStore.addResult("right", rect.right);
    mStore.addResult("top", rect.top);
    mStore.addResult("bottom", rect.bottom);
    mStore.endGroup();
}
#end_block

#method_before
private static void storeStreamConfigurationMap(StreamConfigurationMap map, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    int[] fmts = map.getOutputFormats();
    if (fmts != null) {
        store.startArray("availableStreamConfigurations");
        for (int fi = 0; fi < Array.getLength(fmts); fi++) {
            Size[] sizes = map.getOutputSizes(fmts[fi]);
            if (sizes != null) {
                for (int si = 0; si < Array.getLength(sizes); si++) {
                    store.startGroup();
                    store.addResult("format", fmts[fi]);
                    store.addResult("width", sizes[si].getWidth());
                    store.addResult("height", sizes[si].getHeight());
                    store.addResult("input", false);
                    store.addResult("minFrameDuration", map.getOutputMinFrameDuration(fmts[fi], sizes[si]));
                    store.endGroup();
                }
            }
        }
        store.endArray();
    }
    store.endGroup();
}
#method_after
private void storeStreamConfigurationMap(StreamConfigurationMap map, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    int[] fmts = map.getOutputFormats();
    if (fmts != null) {
        mStore.startArray("availableStreamConfigurations");
        for (int fi = 0; fi < Array.getLength(fmts); fi++) {
            Size[] sizes = map.getOutputSizes(fmts[fi]);
            if (sizes != null) {
                for (int si = 0; si < Array.getLength(sizes); si++) {
                    mStore.startGroup();
                    mStore.addResult("format", fmts[fi]);
                    mStore.addResult("width", sizes[si].getWidth());
                    mStore.addResult("height", sizes[si].getHeight());
                    mStore.addResult("input", false);
                    mStore.addResult("minFrameDuration", map.getOutputMinFrameDuration(fmts[fi], sizes[si]));
                    mStore.endGroup();
                }
            }
        }
        mStore.endArray();
    }
    mStore.endGroup();
}
#end_block

#method_before
private static void storeRangeInt(Range<Integer> range, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.addResult("lower", range.getLower());
    store.addResult("upper", range.getUpper());
    store.endGroup();
}
#method_after
private void storeRangeInt(Range<Integer> range, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.addResult("lower", range.getLower());
    mStore.addResult("upper", range.getUpper());
    mStore.endGroup();
}
#end_block

#method_before
private static void storeRangeLong(Range<Long> range, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.addResult("lower", range.getLower());
    store.addResult("upper", range.getUpper());
    store.endGroup();
}
#method_after
private void storeRangeLong(Range<Long> range, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.addResult("lower", range.getLower());
    mStore.addResult("upper", range.getUpper());
    mStore.endGroup();
}
#end_block

#method_before
private static void storeColorSpaceTransform(ColorSpaceTransform xform, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    store.startArray("elements");
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            storeRational((Rational) xform.getElement(col, row), store, null);
        }
    }
    store.endArray();
    store.endGroup();
}
#method_after
private void storeColorSpaceTransform(ColorSpaceTransform xform, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    mStore.startArray("elements");
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            storeRational((Rational) xform.getElement(col, row), null);
        }
    }
    mStore.endArray();
    mStore.endGroup();
}
#end_block

#method_before
private static void storeBlackLevelPattern(BlackLevelPattern pat, InfoStore store, String protoName) throws Exception {
    if (protoName == null) {
        store.startGroup();
    } else {
        store.startGroup(protoName);
    }
    int[] patVals = new int[4];
    pat.copyTo(patVals, 0);
    store.addArrayResult("black_level_pattern", patVals);
    store.endGroup();
}
#method_after
private void storeBlackLevelPattern(BlackLevelPattern pat, String protoName) throws Exception {
    if (protoName == null) {
        mStore.startGroup();
    } else {
        mStore.startGroup(protoName);
    }
    int[] patVals = new int[4];
    pat.copyTo(patVals, 0);
    mStore.addArrayResult("black_level_pattern", patVals);
    mStore.endGroup();
}
#end_block

#method_before
private static void storeEntry(Type keyType, Object keyObj, InfoStore store, CameraCharacteristics chars) throws Exception {
    String keyName = getKeyName(keyObj);
    String protoName = keyName.replace('.', '_');
    Object keyValue = getKeyValue(chars, keyObj);
    if (keyValue == null) {
        return;
    }
    if (keyType == int.class || keyType == Integer.class) {
        store.addResult(protoName, (int) keyValue);
        return;
    } else if (keyType == float.class || keyType == Float.class) {
        store.addResult(protoName, (float) keyValue);
        return;
    } else if (keyType == long.class || keyType == Long.class) {
        store.addResult(protoName, (long) keyValue);
        return;
    } else if (keyType == double.class || keyType == Double.class) {
        store.addResult(protoName, (double) keyValue);
        return;
    } else if (keyType == boolean.class || keyType == Boolean.class) {
        store.addResult(protoName, (boolean) keyValue);
        return;
    } else if (keyType == byte.class || keyType == Byte.class) {
        // Infostore does not support byte, convert to int32 and save
        // TODO: codegen part also need to do the same trick
        int intValue = (int) ((byte) keyValue);
        store.addResult(protoName, intValue);
        return;
    } else if (keyType == Rational.class) {
        storeRational((Rational) keyValue, store, protoName);
        return;
    } else if (keyType == Size.class) {
        storeSize((Size) keyValue, store, protoName);
        return;
    } else if (keyType == SizeF.class) {
        storeSizeF((SizeF) keyValue, store, protoName);
        return;
    } else if (keyType == Rect.class) {
        storeRect((Rect) keyValue, store, protoName);
        return;
    } else if (keyType == StreamConfigurationMap.class) {
        storeStreamConfigurationMap((StreamConfigurationMap) keyValue, store, protoName);
        return;
    } else if (keyType instanceof ParameterizedType && ((ParameterizedType) keyType).getRawType() == Range.class && ((ParameterizedType) keyType).getActualTypeArguments()[0] == Integer.class) {
        storeRangeInt((Range<Integer>) keyValue, store, protoName);
        return;
    } else if (keyType instanceof ParameterizedType && ((ParameterizedType) keyType).getRawType() == Range.class && ((ParameterizedType) keyType).getActualTypeArguments()[0] == Long.class) {
        storeRangeLong((Range<Long>) keyValue, store, protoName);
        return;
    } else if (keyType == ColorSpaceTransform.class) {
        storeColorSpaceTransform((ColorSpaceTransform) keyValue, store, protoName);
        return;
    } else if (keyType == BlackLevelPattern.class) {
        storeBlackLevelPattern((BlackLevelPattern) keyValue, store, protoName);
        return;
    } else {
        Log.w(TAG, "Storing unsupported key type: " + keyType + " for keyName: " + keyName);
        return;
    }
}
#method_after
private void storeEntry(Type keyType, Object keyObj, CameraCharacteristics chars) throws Exception {
    String keyName = getKeyName(keyObj);
    String protoName = keyName.replace('.', '_');
    Object keyValue = getKeyValue(chars, keyObj);
    if (keyValue == null) {
        return;
    }
    if (keyType == int.class || keyType == Integer.class) {
        mStore.addResult(protoName, (int) keyValue);
        return;
    } else if (keyType == float.class || keyType == Float.class) {
        mStore.addResult(protoName, (float) keyValue);
        return;
    } else if (keyType == long.class || keyType == Long.class) {
        mStore.addResult(protoName, (long) keyValue);
        return;
    } else if (keyType == double.class || keyType == Double.class) {
        mStore.addResult(protoName, (double) keyValue);
        return;
    } else if (keyType == boolean.class || keyType == Boolean.class) {
        mStore.addResult(protoName, (boolean) keyValue);
        return;
    } else if (keyType == byte.class || keyType == Byte.class) {
        // Infostore does not support byte, convert to int32 and save
        int intValue = (int) ((byte) keyValue);
        mStore.addResult(protoName, intValue);
        return;
    } else if (keyType == Rational.class) {
        storeRational((Rational) keyValue, protoName);
        return;
    } else if (keyType == Size.class) {
        storeSize((Size) keyValue, protoName);
        return;
    } else if (keyType == SizeF.class) {
        storeSizeF((SizeF) keyValue, protoName);
        return;
    } else if (keyType == Rect.class) {
        storeRect((Rect) keyValue, protoName);
        return;
    } else if (keyType == StreamConfigurationMap.class) {
        storeStreamConfigurationMap((StreamConfigurationMap) keyValue, protoName);
        return;
    } else if (keyType instanceof ParameterizedType && ((ParameterizedType) keyType).getRawType() == Range.class && ((ParameterizedType) keyType).getActualTypeArguments()[0] == Integer.class) {
        storeRangeInt((Range<Integer>) keyValue, protoName);
        return;
    } else if (keyType instanceof ParameterizedType && ((ParameterizedType) keyType).getRawType() == Range.class && ((ParameterizedType) keyType).getActualTypeArguments()[0] == Long.class) {
        storeRangeLong((Range<Long>) keyValue, protoName);
        return;
    } else if (keyType == ColorSpaceTransform.class) {
        storeColorSpaceTransform((ColorSpaceTransform) keyValue, protoName);
        return;
    } else if (keyType == BlackLevelPattern.class) {
        storeBlackLevelPattern((BlackLevelPattern) keyValue, protoName);
        return;
    } else {
        Log.w(TAG, "Storing unsupported key type: " + keyType + " for keyName: " + keyName);
        return;
    }
}
#end_block

#method_before
private static void storeArrayEntry(Type keyType, Object keyObj, InfoStore store, CameraCharacteristics chars) throws Exception {
    String keyName = getKeyName(keyObj);
    String protoName = keyName.replace('.', '_');
    Object keyValue = getKeyValue(chars, keyObj);
    if (keyValue == null) {
        return;
    }
    int arrayLen = Array.getLength(keyValue);
    if (arrayLen == 0) {
        return;
    }
    Type elmtType = ((GenericArrayType) keyType).getGenericComponentType();
    if (elmtType == int.class) {
        store.addArrayResult(protoName, (int[]) keyValue);
        return;
    } else if (elmtType == float.class) {
        store.addArrayResult(protoName, (float[]) keyValue);
        return;
    } else if (elmtType == long.class) {
        store.addArrayResult(protoName, (long[]) keyValue);
        return;
    } else if (elmtType == double.class) {
        store.addArrayResult(protoName, (double[]) keyValue);
        return;
    } else if (elmtType == boolean.class) {
        store.addArrayResult(protoName, (boolean[]) keyValue);
        return;
    } else if (elmtType == byte.class) {
        // Infostore does not support byte, convert to int32 and save
        // TODO: codegen proto buf spec also needs the same trick
        int[] intValues = new int[arrayLen];
        for (int i = 0; i < arrayLen; i++) {
            intValues[i] = (int) ((byte) Array.get(keyValue, i));
        }
        store.addArrayResult(protoName, intValues);
        return;
    } else if (elmtType == Rational.class) {
        store.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeRational((Rational) Array.get(keyValue, i), store, null);
        }
        store.endArray();
        return;
    } else if (elmtType == Size.class) {
        store.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeSize((Size) Array.get(keyValue, i), store, null);
        }
        store.endArray();
        return;
    } else if (elmtType == Rect.class) {
        store.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeRect((Rect) Array.get(keyValue, i), store, null);
        }
        store.endArray();
        return;
    } else if (elmtType instanceof ParameterizedType && ((ParameterizedType) elmtType).getRawType() == Range.class && ((ParameterizedType) elmtType).getActualTypeArguments()[0] == Integer.class) {
        store.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeRangeInt((Range<Integer>) Array.get(keyValue, i), store, null);
        }
        store.endArray();
        return;
    } else if (elmtType == BlackLevelPattern.class) {
        store.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeBlackLevelPattern((BlackLevelPattern) Array.get(keyValue, i), store, null);
        }
        store.endArray();
        return;
    } else {
        Log.w(TAG, "Storing unsupported array type: " + elmtType + " for keyName: " + keyName);
        return;
    }
}
#method_after
private void storeArrayEntry(Type keyType, Object keyObj, CameraCharacteristics chars) throws Exception {
    String keyName = getKeyName(keyObj);
    String protoName = keyName.replace('.', '_');
    Object keyValue = getKeyValue(chars, keyObj);
    if (keyValue == null) {
        return;
    }
    int arrayLen = Array.getLength(keyValue);
    if (arrayLen == 0) {
        return;
    }
    Type elmtType = ((GenericArrayType) keyType).getGenericComponentType();
    if (elmtType == int.class) {
        mStore.addArrayResult(protoName, (int[]) keyValue);
        return;
    } else if (elmtType == float.class) {
        mStore.addArrayResult(protoName, (float[]) keyValue);
        return;
    } else if (elmtType == long.class) {
        mStore.addArrayResult(protoName, (long[]) keyValue);
        return;
    } else if (elmtType == double.class) {
        mStore.addArrayResult(protoName, (double[]) keyValue);
        return;
    } else if (elmtType == boolean.class) {
        mStore.addArrayResult(protoName, (boolean[]) keyValue);
        return;
    } else if (elmtType == byte.class) {
        // Infostore does not support byte, convert to int32 and save
        int[] intValues = new int[arrayLen];
        for (int i = 0; i < arrayLen; i++) {
            intValues[i] = (int) ((byte) Array.get(keyValue, i));
        }
        mStore.addArrayResult(protoName, intValues);
        return;
    } else if (elmtType == Rational.class) {
        mStore.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeRational((Rational) Array.get(keyValue, i), null);
        }
        mStore.endArray();
        return;
    } else if (elmtType == Size.class) {
        mStore.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeSize((Size) Array.get(keyValue, i), null);
        }
        mStore.endArray();
        return;
    } else if (elmtType == Rect.class) {
        mStore.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeRect((Rect) Array.get(keyValue, i), null);
        }
        mStore.endArray();
        return;
    } else if (elmtType instanceof ParameterizedType && ((ParameterizedType) elmtType).getRawType() == Range.class && ((ParameterizedType) elmtType).getActualTypeArguments()[0] == Integer.class) {
        mStore.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeRangeInt((Range<Integer>) Array.get(keyValue, i), null);
        }
        mStore.endArray();
        return;
    } else if (elmtType == BlackLevelPattern.class) {
        mStore.startArray(protoName);
        for (int i = 0; i < arrayLen; i++) {
            storeBlackLevelPattern((BlackLevelPattern) Array.get(keyValue, i), null);
        }
        mStore.endArray();
        return;
    } else {
        Log.w(TAG, "Storing unsupported array type: " + elmtType + " for keyName: " + keyName);
        return;
    }
}
#end_block

#method_before
private static void storeCameraChars(InfoStore store, CameraCharacteristics chars) throws Exception {
    HashSet<String> charsKeyNames = getAllCharacteristicsKeyNames();
    Field[] allFields = chars.getClass().getDeclaredFields();
    for (Field field : allFields) {
        if (Modifier.isPublic(field.getModifiers()) && Modifier.isStatic(field.getModifiers()) && field.getType() == CameraCharacteristics.Key.class && field.getGenericType() instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType) field.getGenericType();
            Type[] argTypes = paramType.getActualTypeArguments();
            if (argTypes.length > 0) {
                try {
                    Type keyType = argTypes[0];
                    Object keyObj = field.get(chars);
                    String keyName = getKeyName(keyObj);
                    if (charsKeyNames.contains(keyName)) {
                        if (keyType instanceof GenericArrayType) {
                            storeArrayEntry(keyType, keyObj, store, chars);
                        } else {
                            storeEntry(keyType, keyObj, store, chars);
                        }
                    }
                } catch (IllegalAccessException e) {
                    throw new IllegalStateException("Access error for field: " + field + ": ", e);
                }
            }
        }
    }
}
#method_after
private void storeCameraChars(CameraCharacteristics chars) throws Exception {
    HashSet<String> charsKeyNames = getAllCharacteristicsKeyNames();
    Field[] allFields = chars.getClass().getDeclaredFields();
    for (Field field : allFields) {
        if (Modifier.isPublic(field.getModifiers()) && Modifier.isStatic(field.getModifiers()) && field.getType() == CameraCharacteristics.Key.class && field.getGenericType() instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType) field.getGenericType();
            Type[] argTypes = paramType.getActualTypeArguments();
            if (argTypes.length > 0) {
                try {
                    Type keyType = argTypes[0];
                    Object keyObj = field.get(chars);
                    String keyName = getKeyName(keyObj);
                    if (charsKeyNames.contains(keyName)) {
                        if (keyType instanceof GenericArrayType) {
                            storeArrayEntry(keyType, keyObj, chars);
                        } else {
                            storeEntry(keyType, keyObj, chars);
                        }
                    }
                } catch (IllegalAccessException e) {
                    throw new IllegalStateException("Access error for field: " + field + ": ", e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void collectDeviceInfo(InfoStore store) throws Exception {
    store.addResult("profile_480p", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_480P));
    store.addResult("profile_720p", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_720P));
    store.addResult("profile_1080p", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_1080P));
    store.addResult("profile_cif", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_CIF));
    store.addResult("profile_qcif", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_QCIF));
    store.addResult("profile_qvga", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_QVGA));
    // query camera devices and store each camera's characteristics
    CameraManager cameraManager = (CameraManager) getContext().getSystemService(Context.CAMERA_SERVICE);
    try {
        String[] cameraIdList = cameraManager.getCameraIdList();
        if (cameraIdList.length > 0) {
            CameraCharacteristicsStorer charsStorer = new CameraCharacteristicsStorer(cameraManager);
            store.startArray("per_camera_info");
            for (int i = 0; i < cameraIdList.length; i++) {
                charsStorer.storeCameraInfo(store, cameraIdList[i]);
            }
            // per_camera_info
            store.endArray();
        }
    } catch (CameraAccessException e) {
        Log.e(TAG, "Unable to get camera camera ID list, error: " + e.getMessage());
    }
}
#method_after
@Override
protected void collectDeviceInfo(InfoStore store) throws Exception {
    store.addResult("profile_480p", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_480P));
    store.addResult("profile_720p", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_720P));
    store.addResult("profile_1080p", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_1080P));
    store.addResult("profile_cif", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_CIF));
    store.addResult("profile_qcif", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_QCIF));
    store.addResult("profile_qvga", CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_QVGA));
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.L) {
        // query camera devices and store each camera's characteristics
        CameraManager cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
        try {
            String[] cameraIdList = cameraManager.getCameraIdList();
            store.addResult("num_of_camera", cameraIdList.length);
            if (cameraIdList.length > 0) {
                CameraCharacteristicsStorer charsStorer = new CameraCharacteristicsStorer(cameraManager, store);
                store.startArray("per_camera_info");
                for (int i = 0; i < cameraIdList.length; i++) {
                    charsStorer.storeCameraInfo(cameraIdList[i]);
                }
                // per_camera_info
                store.endArray();
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Unable to get camera camera ID list, error: " + e.getMessage());
        }
    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
        // Only supports Camera API1
        int numCameras = Camera.getNumberOfCameras();
        store.addResult("num_of_camera", numCameras);
    } else {
        // No Camera number query support
        store.addResult("num_of_camera", 0);
    }
}
#end_block

#method_before
/*@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
     * The key entries below this point are generated from metadata
     * definitions in /system/media/camera/docs. Do not modify by hand or
     * modify the comment blocks at the start or end.
     *~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~*/
/*
     * Start of protocol buffer definition.
     * Note: keep internal protocol buffer definition in sync with this one
     * TODO: figure out how to unit test devices in the wild where
     *       required metadata could vary in different Android versions
     *
    // Camera related device information
    // Next Id: 8
    message CameraDeviceInfo {
      // Supported profiles from CamcorderProfile.hasProfile
      optional bool profile_480p = 1;
      optional bool profile_720p = 2;
      optional bool profile_1080p = 3;
      optional bool profile_cif = 4;
      optional bool profile_qcif = 5;
      optional bool profile_qvga = 6;
      message PerCameraInfo {
        message Rational {
            optional int32 numerator = 1;
            optional int32 denominator = 2;
        }

        message Size {
            optional int32 width = 1;
            optional int32 height = 2;
        }

        message SizeF {
            optional float width = 1;
            optional float height = 2;
        }

        message Rect {
            optional int32 left = 1;
            optional int32 right = 2;
            optional int32 top = 3;
            optional int32 bottom = 4;
        }

        message StreamConfigurations {
            message StreamConfig {
                optional int32 format = 1;
                optional int32 width = 2;
                optional int32 height = 3;
                optional bool input = 4;
                optional int64 minFrameDuration = 5;
            }
            repeated StreamConfig availableStreamConfigurations = 1;
        }

        message RangeInt {
            optional int32 lower = 1;
            optional int32 upper = 2;
        }

        message RangeLong {
            optional int64 lower = 1;
            optional int64 upper = 2;
        }

        message ColorSpaceTransform {
            repeated Rational elements = 1;
        }

        message BlackLevelPattern {
            repeated int32 black_level_pattern = 1;
        }

        optional string cameraId = 1;


        repeated int32 android_colorCorrection_availableAberrationModes = 65536;


        repeated int32 android_control_aeAvailableAntibandingModes = 131072;

        repeated int32 android_control_aeAvailableModes = 131073;

        repeated RangeInt android_control_aeAvailableTargetFpsRanges = 131074;

        optional RangeInt android_control_aeCompensationRange = 131075;

        optional Rational android_control_aeCompensationStep = 131076;

        repeated int32 android_control_afAvailableModes = 131077;

        repeated int32 android_control_availableEffects = 131078;

        repeated int32 android_control_availableSceneModes = 131079;

        repeated int32 android_control_availableVideoStabilizationModes = 131080;

        repeated int32 android_control_awbAvailableModes = 131081;

        optional int32 android_control_maxRegionsAe = 131082;

        optional int32 android_control_maxRegionsAwb = 131083;

        optional int32 android_control_maxRegionsAf = 131084;

        optional bool android_control_aeLockAvailable = 131085;

        optional bool android_control_awbLockAvailable = 131086;

        repeated int32 android_control_availableModes = 131087;



        repeated int32 android_edge_availableEdgeModes = 262144;



        optional bool android_flash_info_available = 393216;


        repeated int32 android_hotPixel_availableHotPixelModes = 458752;


        repeated Size android_jpeg_availableThumbnailSizes = 524288;


        optional int32 android_lens_facing = 589824;


        repeated float android_lens_info_availableApertures = 655360;

        repeated float android_lens_info_availableFilterDensities = 655361;

        repeated float android_lens_info_availableFocalLengths = 655362;

        repeated int32 android_lens_info_availableOpticalStabilization = 655363;

        optional float android_lens_info_hyperfocalDistance = 655364;

        optional float android_lens_info_minimumFocusDistance = 655365;

        optional int32 android_lens_info_focusDistanceCalibration = 655366;


        repeated int32 android_noiseReduction_availableNoiseReductionModes = 720896;



        optional int32 android_request_maxNumOutputRaw = 851968;

        optional int32 android_request_maxNumOutputProc = 851969;

        optional int32 android_request_maxNumOutputProcStalling = 851970;

        optional int32 android_request_maxNumInputStreams = 851971;

        optional int32 android_request_pipelineMaxDepth = 851972;

        optional int32 android_request_partialResultCount = 851973;

        repeated int32 android_request_availableCapabilities = 851974;


        optional float android_scaler_availableMaxDigitalZoom = 917504;

        optional StreamConfigurations android_scaler_streamConfigurationMap = 917505;

        optional int32 android_scaler_croppingType = 917506;


        optional int32 android_sensor_referenceIlluminant1 = 983040;

        optional int32 android_sensor_referenceIlluminant2 = 983041;

        optional ColorSpaceTransform android_sensor_calibrationTransform1 = 983042;

        optional ColorSpaceTransform android_sensor_calibrationTransform2 = 983043;

        optional ColorSpaceTransform android_sensor_colorTransform1 = 983044;

        optional ColorSpaceTransform android_sensor_colorTransform2 = 983045;

        optional ColorSpaceTransform android_sensor_forwardMatrix1 = 983046;

        optional ColorSpaceTransform android_sensor_forwardMatrix2 = 983047;

        optional BlackLevelPattern android_sensor_blackLevelPattern = 983048;

        optional int32 android_sensor_maxAnalogSensitivity = 983049;

        optional int32 android_sensor_orientation = 983050;

        repeated int32 android_sensor_availableTestPatternModes = 983051;


        optional Rect android_sensor_info_activeArraySize = 1048576;

        optional RangeInt android_sensor_info_sensitivityRange = 1048577;

        optional int32 android_sensor_info_colorFilterArrangement = 1048578;

        optional RangeLong android_sensor_info_exposureTimeRange = 1048579;

        optional int64 android_sensor_info_maxFrameDuration = 1048580;

        optional SizeF android_sensor_info_physicalSize = 1048581;

        optional Size android_sensor_info_pixelArraySize = 1048582;

        optional int32 android_sensor_info_whiteLevel = 1048583;

        optional int32 android_sensor_info_timestampSource = 1048584;

        optional bool android_sensor_info_lensShadingApplied = 1048585;

        optional Rect android_sensor_info_preCorrectionActiveArraySize = 1048586;


        repeated int32 android_shading_availableModes = 1114112;



        repeated int32 android_statistics_info_availableFaceDetectModes = 1245184;

        optional int32 android_statistics_info_maxFaceCount = 1245185;

        repeated bool android_statistics_info_availableHotPixelMapModes = 1245186;

        repeated int32 android_statistics_info_availableLensShadingMapModes = 1245187;


        optional int32 android_tonemap_maxCurvePoints = 1310720;

        repeated int32 android_tonemap_availableToneMapModes = 1310721;



        optional int32 android_info_supportedHardwareLevel = 1441792;



        optional int32 android_sync_maxLatency = 1572864;


        optional int32 android_reprocess_maxCaptureStall = 1638400;


        optional bool android_depth_depthIsExclusive = 1703936;

      }
      // Per camera (front/back) informations
      repeated PerCameraInfo per_camera_info = 7;
    } // CameraDeviceInfo


     *
     * End of protocol buffer definition
     */
private static HashSet<String> getAllCharacteristicsKeyNames() {
    HashSet<String> charsKeyNames = new HashSet<String>();
    charsKeyNames.add(CameraCharacteristics.COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_AVAILABLE_ANTIBANDING_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_COMPENSATION_RANGE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_COMPENSATION_STEP.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_EFFECTS.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_SCENE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_MAX_REGIONS_AE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_MAX_REGIONS_AWB.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_MAX_REGIONS_AF.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_LOCK_AVAILABLE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AWB_LOCK_AVAILABLE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.EDGE_AVAILABLE_EDGE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.FLASH_INFO_AVAILABLE.getName());
    charsKeyNames.add(CameraCharacteristics.HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_FACING.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_FILTER_DENSITIES.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_FOCUS_DISTANCE_CALIBRATION.getName());
    charsKeyNames.add(CameraCharacteristics.NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_RAW.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC_STALLING.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_INPUT_STREAMS.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_PARTIAL_RESULT_COUNT.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES.getName());
    charsKeyNames.add(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM.getName());
    charsKeyNames.add(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP.getName());
    charsKeyNames.add(CameraCharacteristics.SCALER_CROPPING_TYPE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_FORWARD_MATRIX1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_FORWARD_MATRIX2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_BLACK_LEVEL_PATTERN.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_MAX_ANALOG_SENSITIVITY.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_ORIENTATION.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_AVAILABLE_TEST_PATTERN_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_MAX_FRAME_DURATION.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_WHITE_LEVEL.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_LENS_SHADING_APPLIED.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SHADING_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_MAX_FACE_COUNT.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.TONEMAP_MAX_CURVE_POINTS.getName());
    charsKeyNames.add(CameraCharacteristics.TONEMAP_AVAILABLE_TONE_MAP_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL.getName());
    charsKeyNames.add(CameraCharacteristics.SYNC_MAX_LATENCY.getName());
    charsKeyNames.add(CameraCharacteristics.REPROCESS_MAX_CAPTURE_STALL.getName());
    charsKeyNames.add(CameraCharacteristics.DEPTH_DEPTH_IS_EXCLUSIVE.getName());
    return charsKeyNames;
}
#method_after
/*@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
     * The key entries below this point are generated from metadata
     * definitions in /system/media/camera/docs. Do not modify by hand or
     * modify the comment blocks at the start or end.
     *~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~*/
private static HashSet<String> getAllCharacteristicsKeyNames() {
    HashSet<String> charsKeyNames = new HashSet<String>();
    charsKeyNames.add(CameraCharacteristics.COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_AVAILABLE_ANTIBANDING_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_COMPENSATION_RANGE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_COMPENSATION_STEP.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_EFFECTS.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_SCENE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_MAX_REGIONS_AE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_MAX_REGIONS_AWB.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_MAX_REGIONS_AF.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AE_LOCK_AVAILABLE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AWB_LOCK_AVAILABLE.getName());
    charsKeyNames.add(CameraCharacteristics.CONTROL_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.EDGE_AVAILABLE_EDGE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.FLASH_INFO_AVAILABLE.getName());
    charsKeyNames.add(CameraCharacteristics.HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_FACING.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_FILTER_DENSITIES.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE.getName());
    charsKeyNames.add(CameraCharacteristics.LENS_INFO_FOCUS_DISTANCE_CALIBRATION.getName());
    charsKeyNames.add(CameraCharacteristics.NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_RAW.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC_STALLING.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_MAX_NUM_INPUT_STREAMS.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_PARTIAL_RESULT_COUNT.getName());
    charsKeyNames.add(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES.getName());
    charsKeyNames.add(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM.getName());
    charsKeyNames.add(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP.getName());
    charsKeyNames.add(CameraCharacteristics.SCALER_CROPPING_TYPE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_FORWARD_MATRIX1.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_FORWARD_MATRIX2.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_BLACK_LEVEL_PATTERN.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_MAX_ANALOG_SENSITIVITY.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_ORIENTATION.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_AVAILABLE_TEST_PATTERN_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_MAX_FRAME_DURATION.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_WHITE_LEVEL.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_LENS_SHADING_APPLIED.getName());
    charsKeyNames.add(CameraCharacteristics.SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.getName());
    charsKeyNames.add(CameraCharacteristics.SHADING_AVAILABLE_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_MAX_FACE_COUNT.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.TONEMAP_MAX_CURVE_POINTS.getName());
    charsKeyNames.add(CameraCharacteristics.TONEMAP_AVAILABLE_TONE_MAP_MODES.getName());
    charsKeyNames.add(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL.getName());
    charsKeyNames.add(CameraCharacteristics.SYNC_MAX_LATENCY.getName());
    charsKeyNames.add(CameraCharacteristics.REPROCESS_MAX_CAPTURE_STALL.getName());
    charsKeyNames.add(CameraCharacteristics.DEPTH_DEPTH_IS_EXCLUSIVE.getName());
    return charsKeyNames;
}
#end_block

#method_before
public void test_forEach() throws Exception {
    TreeMap<String, String> map = new TreeMap<String, String>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    TreeMap<String, String> output = new TreeMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(3, output.size());
    assertEquals(map.get("one"), output.get("one"));
    assertEquals(map.get("two"), output.get("two"));
    assertEquals(map.get("three"), output.get("three"));
}
#method_after
public void test_forEach() throws Exception {
    TreeMap<String, String> map = new TreeMap<>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    TreeMap<String, String> output = new TreeMap<>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map, output);
    HashSet<String> setOutput = new HashSet<>();
    map.keySet().forEach((k) -> setOutput.add(k));
    assertEquals(map.keySet(), setOutput);
    setOutput.clear();
    map.values().forEach((v) -> setOutput.add(v));
    assertEquals(new HashSet<>(map.values()), setOutput);
    HashSet<Map.Entry<String, String>> entrySetOutput = new HashSet<>();
    map.entrySet().forEach((v) -> entrySetOutput.add(v));
    assertEquals(map.entrySet(), entrySetOutput);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    Hashtable<String, String> ht = new Hashtable<String, String>();
    ht.put("1", "one");
    ht.put("2", "two");
    ht.put("3", "three");
    Hashtable<String, String> output = new Hashtable<String, String>();
    ht.forEach((k, v) -> output.put(k, v));
    assertEquals(3, output.size());
    assertEquals(ht.get("one"), output.get("one"));
    assertEquals(ht.get("two"), output.get("two"));
    assertEquals(ht.get("three"), output.get("three"));
}
#method_after
public void test_forEach() throws Exception {
    Hashtable<String, String> ht = new Hashtable<>();
    ht.put("1", "one");
    ht.put("2", "two");
    ht.put("3", "three");
    Hashtable<String, String> output = new Hashtable<>();
    ht.forEach((k, v) -> output.put(k, v));
    assertEquals(ht, output);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    Vector<Integer> vector = new Vector<Integer>();
    vector.add(0);
    vector.add(1);
    vector.add(2);
    Vector<Integer> output = new Vector<Integer>();
    vector.forEach(k -> output.add(k));
    assertEquals(3, output.size());
    assertEquals(0, (int) output.get(0));
    assertEquals(1, (int) output.get(1));
    assertEquals(2, (int) output.get(2));
}
#method_after
public void test_forEach() throws Exception {
    Vector<Integer> vector = new Vector<Integer>();
    vector.add(0);
    vector.add(1);
    vector.add(2);
    Vector<Integer> output = new Vector<Integer>();
    vector.forEach(k -> output.add(k));
    assertEquals(vector, output);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    HashSet<Integer> hs = new HashSet<Integer>();
    hs.add(0);
    hs.add(1);
    hs.add(2);
    HashSet<Integer> output = new HashSet<Integer>();
    hs.forEach(k -> output.add(k));
    assertEquals(3, output.size());
    assertTrue(output.contains(0));
    assertTrue(output.contains(1));
    assertTrue(output.contains(2));
}
#method_after
public void test_forEach() throws Exception {
    HashSet<Integer> hs = new HashSet<>();
    hs.add(0);
    hs.add(1);
    hs.add(2);
    HashSet<Integer> output = new HashSet<>();
    hs.forEach(k -> output.add(k));
    assertEquals(hs, output);
}
#end_block

#method_before
void testCollectionForEach(Collection<Integer> collection) {
    ArrayList<Integer> output = new ArrayList<Integer>();
    collection.forEach(k -> output.add(k));
    assertEquals(collection.size(), output.size());
    assertEquals(0, (int) output.get(0));
    if (output.size() > 1) {
        assertEquals(1, (int) output.get(1));
        assertEquals(2, (int) output.get(2));
    }
}
#method_after
void testCollectionForEach(Collection<Integer> collection) {
    ArrayList<Integer> output = new ArrayList<Integer>();
    collection.forEach(k -> output.add(k));
    assertEquals(new ArrayList<>(collection), output);
}
#end_block

#method_before
void testMapForEach(Map<String, String> map) {
    HashMap<String, String> output = new HashMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map.size(), output.size());
    for (String key : map.keySet()) {
        assertEquals(map.get(key), output.get(key));
    }
    output.clear();
    Set<Map.Entry<String, String>> entrySet = map.entrySet();
    entrySet.forEach((entry) -> output.put(entry.getKey(), entry.getValue()));
    assertEquals(map.size(), output.size());
    for (String key : map.keySet()) {
        assertEquals(map.get(key), output.get(key));
    }
}
#method_after
void testMapForEach(Map<String, String> map) {
    HashMap<String, String> output = new HashMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map, output);
    output.clear();
    map.entrySet().forEach(entry -> output.put(entry.getKey(), entry.getValue()));
    assertEquals(map, output);
    HashSet<String> setOutput = new HashSet<>();
    map.values().forEach(value -> setOutput.add(value));
    assertEquals(new HashSet<>(map.values()), setOutput);
    setOutput.clear();
    map.keySet().forEach((k) -> setOutput.add(k));
    assertEquals(map.keySet(), setOutput);
}
#end_block

#method_before
public final void forEach(Consumer<? super K> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) action.accept(e.key);
        }
        if (modCount != mc)
            throw new ConcurrentModificationException();
    }
}
#method_after
public final void forEach(Consumer<? super K> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) {
                action.accept(e.key);
                // collections
                if (modCount != mc) {
                    throw new ConcurrentModificationException();
                }
            }
        }
    }
}
#end_block

#method_before
public final void forEach(Consumer<? super V> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) action.accept(e.value);
        }
        if (modCount != mc)
            throw new ConcurrentModificationException();
    }
}
#method_after
public final void forEach(Consumer<? super V> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) {
                action.accept(e.value);
                // collections
                if (modCount != mc) {
                    throw new ConcurrentModificationException();
                }
            }
        }
    }
}
#end_block

#method_before
public final void forEach(Consumer<? super Map.Entry<K, V>> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) action.accept(e);
        }
        if (modCount != mc)
            throw new ConcurrentModificationException();
    }
}
#method_after
public final void forEach(Consumer<? super Map.Entry<K, V>> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) {
                action.accept(e);
                // collections
                if (modCount != mc) {
                    throw new ConcurrentModificationException();
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void forEach(BiConsumer<? super K, ? super V> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value);
        }
        if (modCount != mc)
            throw new ConcurrentModificationException();
    }
}
#method_after
@Override
public void forEach(BiConsumer<? super K, ? super V> action) {
    HashMapEntry<K, V>[] tab;
    if (action == null)
        throw new NullPointerException();
    if (size > 0 && (tab = table) != null) {
        int mc = modCount;
        for (int i = 0; i < tab.length; ++i) {
            for (HashMapEntry<K, V> e = tab[i]; e != null; e = e.next) {
                action.accept(e.key, e.value);
                // collections
                if (modCount != mc) {
                    throw new ConcurrentModificationException();
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void forEach(Consumer<? super E> action) {
    Objects.requireNonNull(action);
    final int expectedModCount = modCount;
    @SuppressWarnings("unchecked")
    final E[] elementData = (E[]) this.elementData;
    final int size = this.size;
    for (int i = 0; modCount == expectedModCount && i < size; i++) {
        action.accept(elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
#method_after
@Override
public void forEach(Consumer<? super E> action) {
    Objects.requireNonNull(action);
    final int expectedModCount = modCount;
    @SuppressWarnings("unchecked")
    final E[] elementData = (E[]) this.elementData;
    final int size = this.size;
    for (int i = 0; modCount == expectedModCount && i < size; i++) {
        action.accept(elementData[i]);
    }
    // forEach will throw a CME in this case.
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
#end_block

#method_before
public void test_forEach() throws Exception {
    WeakHashMap<String, String> map = new WeakHashMap<String, String>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    WeakHashMap<String, String> output = new WeakHashMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(3, output.size());
    assertEquals(map.get("one"), output.get("one"));
    assertEquals(map.get("two"), output.get("two"));
    assertEquals(map.get("three"), output.get("three"));
}
#method_after
public void test_forEach() throws Exception {
    WeakHashMap map = new WeakHashMap();
    for (int i = 0; i < 100; i++) map.put(keyArray[i], valueArray[i]);
    WeakHashMap output = new WeakHashMap();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map, output);
    HashSet setOutput = new HashSet();
    map.keySet().forEach((k) -> setOutput.add(k));
    assertEquals(map.keySet(), setOutput);
    setOutput.clear();
    map.values().forEach((v) -> setOutput.add(v));
    assertEquals(new HashSet(map.values()), setOutput);
    HashSet entrySetOutput = new HashSet();
    map.entrySet().forEach((v) -> entrySetOutput.add(v));
    assertEquals(map.entrySet(), entrySetOutput);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    HashMap<String, String> map = new HashMap<String, String>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    HashMap<String, String> output = new HashMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(3, output.size());
    assertEquals(map.get("one"), output.get("one"));
    assertEquals(map.get("two"), output.get("two"));
    assertEquals(map.get("three"), output.get("three"));
}
#method_after
public void test_forEach() throws Exception {
    HashMap<String, String> map = new HashMap<>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    HashMap<String, String> output = new HashMap<>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map, output);
    HashSet<String> setOutput = new HashSet<>();
    map.keySet().forEach((k) -> setOutput.add(k));
    assertEquals(map.keySet(), setOutput);
    setOutput.clear();
    map.values().forEach((v) -> setOutput.add(v));
    assertEquals(new HashSet<>(map.values()), setOutput);
    HashSet<Map.Entry<String, String>> entrySetOutput = new HashSet<>();
    map.entrySet().forEach((v) -> entrySetOutput.add(v));
    assertEquals(map.entrySet(), entrySetOutput);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    LinkedHashMap<String, String> map = new LinkedHashMap<String, String>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    LinkedHashMap<String, String> output = new LinkedHashMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(3, output.size());
    assertEquals(map.get("one"), output.get("one"));
    assertEquals(map.get("two"), output.get("two"));
    assertEquals(map.get("three"), output.get("three"));
}
#method_after
public void test_forEach() throws Exception {
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put("three", "3");
    map.put("two", "2");
    map.put("one", "1");
    LinkedHashMap<String, String> output = new LinkedHashMap<>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map, output);
    LinkedHashSet<String> setOutput = new LinkedHashSet<>();
    map.keySet().forEach((k) -> setOutput.add(k));
    assertEquals(map.keySet(), setOutput);
    setOutput.clear();
    map.values().forEach((v) -> setOutput.add(v));
    assertEquals(new LinkedHashSet<>(map.values()), setOutput);
    LinkedHashSet<Map.Entry<String, String>> entrySetOutput = new LinkedHashSet<>();
    map.entrySet().forEach((v) -> entrySetOutput.add(v));
    assertEquals(map.entrySet(), entrySetOutput);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    ArrayList<Integer> list = new ArrayList<Integer>();
    list.add(0);
    list.add(1);
    list.add(2);
    ArrayList<Integer> output = new ArrayList<Integer>();
    list.forEach(k -> output.add(k));
    assertEquals(3, output.size());
    assertEquals(0, (int) output.get(0));
    assertEquals(1, (int) output.get(1));
    assertEquals(2, (int) output.get(2));
}
#method_after
public void test_forEach() throws Exception {
    ArrayList<Integer> list = new ArrayList<>();
    list.add(0);
    list.add(1);
    list.add(2);
    ArrayList<Integer> output = new ArrayList<>();
    list.forEach(k -> output.add(k));
    assertEquals(list, output);
}
#end_block

#method_before
public void test_forEach() throws Exception {
    IdentityHashMap<String, String> map = new IdentityHashMap<String, String>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    IdentityHashMap<String, String> output = new IdentityHashMap<String, String>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(3, output.size());
    assertEquals(map.get("one"), output.get("one"));
    assertEquals(map.get("two"), output.get("two"));
    assertEquals(map.get("three"), output.get("three"));
}
#method_after
public void test_forEach() throws Exception {
    IdentityHashMap<String, String> map = new IdentityHashMap<>();
    map.put("one", "1");
    map.put("two", "2");
    map.put("three", "3");
    IdentityHashMap<String, String> output = new IdentityHashMap<>();
    map.forEach((k, v) -> output.put(k, v));
    assertEquals(map, output);
    HashSet<String> setOutput = new HashSet<>();
    map.keySet().forEach((k) -> setOutput.add(k));
    assertEquals(map.keySet(), setOutput);
    setOutput.clear();
    map.values().forEach((v) -> setOutput.add(v));
    assertEquals(new HashSet<>(map.values()), setOutput);
    HashSet<Map.Entry<String, String>> entrySetOutput = new HashSet<>();
    map.entrySet().forEach((v) -> entrySetOutput.add(v));
    assertEquals(map.entrySet(), entrySetOutput);
}
#end_block

#method_before
private void initialize(ULocale locale) {
    this.requestedLocale = locale.toLocale();
    this.ulocale = locale;
    String nsName;
    // Attempt to set the zero digit based on the numbering system for the locale requested
    NumberingSystem ns = NumberingSystem.getInstance(locale);
    digits = new char[10];
    if (ns != null && ns.getRadix() == 10 && !ns.isAlgorithmic() && NumberingSystem.isValidDigitString(ns.getDescription())) {
        String digitString = ns.getDescription();
        digits[0] = digitString.charAt(0);
        digits[1] = digitString.charAt(1);
        digits[2] = digitString.charAt(2);
        digits[3] = digitString.charAt(3);
        digits[4] = digitString.charAt(4);
        digits[5] = digitString.charAt(5);
        digits[6] = digitString.charAt(6);
        digits[7] = digitString.charAt(7);
        digits[8] = digitString.charAt(8);
        digits[9] = digitString.charAt(9);
        nsName = ns.getName();
    } else {
        digits[0] = DecimalFormat.PATTERN_ZERO_DIGIT;
        digits[1] = DecimalFormat.PATTERN_ONE_DIGIT;
        digits[2] = DecimalFormat.PATTERN_TWO_DIGIT;
        digits[3] = DecimalFormat.PATTERN_THREE_DIGIT;
        digits[4] = DecimalFormat.PATTERN_FOUR_DIGIT;
        digits[5] = DecimalFormat.PATTERN_FIVE_DIGIT;
        digits[6] = DecimalFormat.PATTERN_SIX_DIGIT;
        digits[7] = DecimalFormat.PATTERN_SEVEN_DIGIT;
        digits[8] = DecimalFormat.PATTERN_EIGHT_DIGIT;
        digits[9] = DecimalFormat.PATTERN_NINE_DIGIT;
        // Default numbering system
        nsName = "latn";
    }
    /* try the cache first */
    String[][] data = cachedLocaleData.get(locale);
    String[] numberElements;
    if (data == null) {
        /* cache miss */
        data = new String[1][];
        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
        boolean isLatn = nsName.equals("latn");
        String baseKey = "NumberElements/" + nsName + "/symbols/";
        String latnKey = "NumberElements/latn/symbols/";
        String[] symbolKeys = { "decimal", "group", "list", "percentSign", "minusSign", "plusSign", "exponential", "perMille", "infinity", "nan", "currencyDecimal", "currencyGroup", "superscriptingExponent" };
        String[] fallbackElements = { ".", ",", ";", "%", "-", "+", "E", "\u2030", "\u221e", "NaN", null, null };
        String[] symbolsArray = new String[symbolKeys.length];
        for (int i = 0; i < symbolKeys.length; i++) {
            try {
                symbolsArray[i] = rb.getStringWithFallback(baseKey + symbolKeys[i]);
            } catch (MissingResourceException ex) {
                if (!isLatn) {
                    // Fall back to latn numbering system for symbols if desired symbol isn't found.
                    try {
                        symbolsArray[i] = rb.getStringWithFallback(latnKey + symbolKeys[i]);
                    } catch (MissingResourceException ex1) {
                        symbolsArray[i] = fallbackElements[i];
                    }
                } else {
                    symbolsArray[i] = fallbackElements[i];
                }
            }
        }
        data[0] = symbolsArray;
        /* update cache */
        cachedLocaleData.put(locale, data);
    }
    numberElements = data[0];
    ICUResourceBundle r = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
    // TODO: Determine actual and valid locale correctly.
    ULocale uloc = r.getULocale();
    setLocale(uloc, uloc);
    decimalSeparator = numberElements[0].charAt(0);
    groupingSeparator = numberElements[1].charAt(0);
    patternSeparator = numberElements[2].charAt(0);
    percent = numberElements[3].charAt(0);
    minusString = numberElements[4];
    minusSign = (minusString.length() > 1 && isBidiMark(minusString.charAt(0))) ? minusString.charAt(1) : minusString.charAt(0);
    plusString = numberElements[5];
    plusSign = (plusString.length() > 1 && isBidiMark(plusString.charAt(0))) ? plusString.charAt(1) : plusString.charAt(0);
    exponentSeparator = numberElements[6];
    perMill = numberElements[7].charAt(0);
    infinity = numberElements[8];
    NaN = numberElements[9];
    if (numberElements[10] != null) {
        monetarySeparator = numberElements[10].charAt(0);
    } else {
        monetarySeparator = decimalSeparator;
    }
    if (numberElements[11] != null) {
        monetaryGroupingSeparator = numberElements[11].charAt(0);
    } else {
        monetaryGroupingSeparator = groupingSeparator;
    }
    if (numberElements[12] != null) {
        exponentMultiplicationSign = numberElements[12];
    } else {
        exponentMultiplicationSign = "\u00D7";
    }
    // Localized pattern character no longer in CLDR
    digit = DecimalFormat.PATTERN_DIGIT;
    padEscape = DecimalFormat.PATTERN_PAD_ESCAPE;
    sigDigit = DecimalFormat.PATTERN_SIGNIFICANT_DIGIT;
    CurrencyDisplayInfo info = CurrencyData.provider.getInstance(locale, true);
    // Obtain currency data from the currency API.  This is strictly
    // for backward compatibility; we don't use DecimalFormatSymbols
    // for currency data anymore.
    String currname = null;
    currency = Currency.getInstance(locale);
    if (currency != null) {
        intlCurrencySymbol = currency.getCurrencyCode();
        boolean[] isChoiceFormat = new boolean[1];
        currname = currency.getName(locale, Currency.SYMBOL_NAME, isChoiceFormat);
        // If this is a ChoiceFormat currency, then format an
        // arbitrary value; pick something != 1; more common.
        currencySymbol = isChoiceFormat[0] ? new ChoiceFormat(currname).format(2.0) : currname;
        CurrencyFormatInfo fmtInfo = info.getFormatInfo(intlCurrencySymbol);
        if (fmtInfo != null) {
            currencyPattern = fmtInfo.currencyPattern;
            monetarySeparator = fmtInfo.monetarySeparator;
            monetaryGroupingSeparator = fmtInfo.monetaryGroupingSeparator;
        }
    } else {
        intlCurrencySymbol = "XXX";
        // 'OX' currency symbol
        currencySymbol = "\u00A4";
    }
    // Get currency spacing data.
    currencySpcBeforeSym = new String[3];
    currencySpcAfterSym = new String[3];
    initSpacingInfo(info.getSpacingInfo());
}
#method_after
private void initialize(ULocale locale) {
    this.requestedLocale = locale.toLocale();
    this.ulocale = locale;
    String nsName;
    // Attempt to set the zero digit based on the numbering system for the locale requested
    NumberingSystem ns = NumberingSystem.getInstance(locale);
    digits = new char[10];
    if (ns != null && ns.getRadix() == 10 && !ns.isAlgorithmic() && NumberingSystem.isValidDigitString(ns.getDescription())) {
        String digitString = ns.getDescription();
        digits[0] = digitString.charAt(0);
        digits[1] = digitString.charAt(1);
        digits[2] = digitString.charAt(2);
        digits[3] = digitString.charAt(3);
        digits[4] = digitString.charAt(4);
        digits[5] = digitString.charAt(5);
        digits[6] = digitString.charAt(6);
        digits[7] = digitString.charAt(7);
        digits[8] = digitString.charAt(8);
        digits[9] = digitString.charAt(9);
        nsName = ns.getName();
    } else {
        digits[0] = DecimalFormat.PATTERN_ZERO_DIGIT;
        digits[1] = DecimalFormat.PATTERN_ONE_DIGIT;
        digits[2] = DecimalFormat.PATTERN_TWO_DIGIT;
        digits[3] = DecimalFormat.PATTERN_THREE_DIGIT;
        digits[4] = DecimalFormat.PATTERN_FOUR_DIGIT;
        digits[5] = DecimalFormat.PATTERN_FIVE_DIGIT;
        digits[6] = DecimalFormat.PATTERN_SIX_DIGIT;
        digits[7] = DecimalFormat.PATTERN_SEVEN_DIGIT;
        digits[8] = DecimalFormat.PATTERN_EIGHT_DIGIT;
        digits[9] = DecimalFormat.PATTERN_NINE_DIGIT;
        // Default numbering system
        nsName = "latn";
    }
    /* try the cache first */
    String[][] data = cachedLocaleData.get(locale);
    String[] numberElements;
    if (data == null) {
        /* cache miss */
        data = new String[1][];
        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
        boolean isLatn = nsName.equals("latn");
        String baseKey = "NumberElements/" + nsName + "/symbols/";
        String latnKey = "NumberElements/latn/symbols/";
        String[] symbolKeys = { "decimal", "group", "list", "percentSign", "minusSign", "plusSign", "exponential", "perMille", "infinity", "nan", "currencyDecimal", "currencyGroup", "superscriptingExponent" };
        String[] fallbackElements = { ".", ",", ";", "%", "-", "+", "E", "\u2030", "\u221e", "NaN", null, null };
        String[] symbolsArray = new String[symbolKeys.length];
        for (int i = 0; i < symbolKeys.length; i++) {
            try {
                symbolsArray[i] = rb.getStringWithFallback(baseKey + symbolKeys[i]);
            } catch (MissingResourceException ex) {
                if (!isLatn) {
                    // Fall back to latn numbering system for symbols if desired symbol isn't found.
                    try {
                        symbolsArray[i] = rb.getStringWithFallback(latnKey + symbolKeys[i]);
                    } catch (MissingResourceException ex1) {
                        symbolsArray[i] = fallbackElements[i];
                    }
                } else {
                    symbolsArray[i] = fallbackElements[i];
                }
            }
        }
        data[0] = symbolsArray;
        /* update cache */
        cachedLocaleData.put(locale, data);
    }
    numberElements = data[0];
    ICUResourceBundle r = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
    // TODO: Determine actual and valid locale correctly.
    ULocale uloc = r.getULocale();
    setLocale(uloc, uloc);
    decimalSeparator = numberElements[0].charAt(0);
    groupingSeparator = numberElements[1].charAt(0);
    patternSeparator = numberElements[2].charAt(0);
    // Android patch (http://b/15476051) begin.
    percent = numberElements[3].charAt(numberElements[3].length() - 1);
    // Android patch (http://b/15476051) end.
    minusString = numberElements[4];
    minusSign = (minusString.length() > 1 && isBidiMark(minusString.charAt(0))) ? minusString.charAt(1) : minusString.charAt(0);
    plusString = numberElements[5];
    plusSign = (plusString.length() > 1 && isBidiMark(plusString.charAt(0))) ? plusString.charAt(1) : plusString.charAt(0);
    exponentSeparator = numberElements[6];
    perMill = numberElements[7].charAt(0);
    infinity = numberElements[8];
    NaN = numberElements[9];
    if (numberElements[10] != null) {
        monetarySeparator = numberElements[10].charAt(0);
    } else {
        monetarySeparator = decimalSeparator;
    }
    if (numberElements[11] != null) {
        monetaryGroupingSeparator = numberElements[11].charAt(0);
    } else {
        monetaryGroupingSeparator = groupingSeparator;
    }
    if (numberElements[12] != null) {
        exponentMultiplicationSign = numberElements[12];
    } else {
        exponentMultiplicationSign = "\u00D7";
    }
    // Localized pattern character no longer in CLDR
    digit = DecimalFormat.PATTERN_DIGIT;
    padEscape = DecimalFormat.PATTERN_PAD_ESCAPE;
    sigDigit = DecimalFormat.PATTERN_SIGNIFICANT_DIGIT;
    CurrencyDisplayInfo info = CurrencyData.provider.getInstance(locale, true);
    // Obtain currency data from the currency API.  This is strictly
    // for backward compatibility; we don't use DecimalFormatSymbols
    // for currency data anymore.
    String currname = null;
    currency = Currency.getInstance(locale);
    if (currency != null) {
        intlCurrencySymbol = currency.getCurrencyCode();
        boolean[] isChoiceFormat = new boolean[1];
        currname = currency.getName(locale, Currency.SYMBOL_NAME, isChoiceFormat);
        // If this is a ChoiceFormat currency, then format an
        // arbitrary value; pick something != 1; more common.
        currencySymbol = isChoiceFormat[0] ? new ChoiceFormat(currname).format(2.0) : currname;
        CurrencyFormatInfo fmtInfo = info.getFormatInfo(intlCurrencySymbol);
        if (fmtInfo != null) {
            currencyPattern = fmtInfo.currencyPattern;
            monetarySeparator = fmtInfo.monetarySeparator;
            monetaryGroupingSeparator = fmtInfo.monetaryGroupingSeparator;
        }
    } else {
        intlCurrencySymbol = "XXX";
        // 'OX' currency symbol
        currencySymbol = "\u00A4";
    }
    // Get currency spacing data.
    currencySpcBeforeSym = new String[3];
    currencySpcAfterSym = new String[3];
    initSpacingInfo(info.getSpacingInfo());
}
#end_block

#method_before
private static void removeUnferencedCanonicalAddresses(SQLiteDatabase db) {
    Cursor c = db.query(MmsSmsProvider.TABLE_THREADS, new String[] { "recipient_ids" }, null, null, null, null, null);
    if (c != null) {
        try {
            if (c.getCount() == 0) {
                // no threads, delete all addresses
                int rows = db.delete("canonical_addresses", null, null);
            } else {
                // Find all the referenced recipient_ids from the threads. recipientIds is
                // a space-separated list of recipient ids: "1 14 21"
                HashSet<Integer> recipientIds = new HashSet<Integer>();
                while (c.moveToNext()) {
                    String[] recips = c.getString(0).split(" ");
                    for (String recip : recips) {
                        try {
                            int recipientId = Integer.parseInt(recip);
                            recipientIds.add(recipientId);
                        } catch (Exception e) {
                        }
                    }
                }
                // Now build a selection string of all the unique recipient ids
                StringBuilder sb = new StringBuilder();
                Iterator<Integer> iter = recipientIds.iterator();
                while (iter.hasNext()) {
                    sb.append("_id != " + iter.next());
                    if (iter.hasNext()) {
                        sb.append(" AND ");
                    }
                }
                if (sb.length() > 0) {
                    int rows = db.delete("canonical_addresses", sb.toString(), null);
                }
            }
        } finally {
            c.close();
        }
    }
}
#method_after
private static void removeUnferencedCanonicalAddresses(SQLiteDatabase db) {
    Cursor c = db.query(MmsSmsProvider.TABLE_THREADS, new String[] { "recipient_ids" }, null, null, null, null, null);
    if (c != null) {
        try {
            if (c.getCount() == 0) {
                // no threads, delete all addresses
                int rows = db.delete("canonical_addresses", null, null);
            } else {
                // Find all the referenced recipient_ids from the threads. recipientIds is
                // a space-separated list of recipient ids: "1 14 21"
                HashSet<Integer> recipientIds = new HashSet<Integer>();
                while (c.moveToNext()) {
                    String[] recips = c.getString(0).split(" ");
                    for (String recip : recips) {
                        try {
                            int recipientId = Integer.parseInt(recip);
                            recipientIds.add(recipientId);
                        } catch (Exception e) {
                        }
                    }
                }
                // Now build a selection string of all the unique recipient ids
                StringBuilder sb = new StringBuilder();
                Iterator<Integer> iter = recipientIds.iterator();
                sb.append("_id NOT IN (");
                while (iter.hasNext()) {
                    sb.append(iter.next());
                    if (iter.hasNext()) {
                        sb.append(",");
                    }
                }
                sb.append(")");
                int rows = db.delete("canonical_addresses", sb.toString(), null);
            }
        } finally {
            c.close();
        }
    }
}
#end_block

#method_before
public static void updateThread(SQLiteDatabase db, long thread_id) {
    if (thread_id < 0) {
        updateAllThreads(db, null, null);
        return;
    }
    updateAllThreads(db, "(thread_id = ?)", new String[] { String.valueOf(thread_id) });
}
#method_after
public static void updateThread(SQLiteDatabase db, long thread_id) {
    if (thread_id < 0) {
        updateThreads(db, null, null);
        return;
    }
    updateThreads(db, "(thread_id = ?)", new String[] { String.valueOf(thread_id) });
}
#end_block

#method_before
// / CHECK-START: int Main.f2int(float) instruction_simplifier (before)
// / CHECK-DAG: <<Result:i\d+>> InvokeStaticOrDirect intrinsic:FloatFloatToIntBits
// / CHECK-DAG: Return [<<Result>>]
// 
// / CHECK-START: int Main.f2int(float) instruction_simplifier (after)
// / CHECK-DAG: <<Cond:z\d+>> NotEqual [<<Arg:f\d+>>,<<Arg>>]
// / CHECK-DAG: <<Raw:i\d+>> InvokeStaticOrDirect [<<Arg>>] intrinsic:FloatFloatToRawIntBits
// / CHECK-DAG: <<Result:i\d+>> Select [<<Raw>>,{{i\d+}},<<Cond>>]
private static int f2int(float f) {
    return Float.floatToIntBits(f);
}
#method_after
// / CHECK-START: int Main.f2int(float) instruction_simplifier (before)
// / CHECK-DAG: <<Result:i\d+>> InvokeStaticOrDirect intrinsic:FloatFloatToIntBits
// / CHECK-DAG: Return [<<Result>>]
// 
// / CHECK-START: int Main.f2int(float) instruction_simplifier (after)
// / CHECK-DAG: <<Raw:i\d+>> InvokeStaticOrDirect [<<Arg:f\d+>>] intrinsic:FloatFloatToRawIntBits
// / CHECK-DAG: <<Cond:z\d+>> NotEqual [<<Arg>>,<<Arg>>]
// / CHECK-DAG: <<Result:i\d+>> Select [<<Raw>>,{{i\d+}},<<Cond>>]
private static int f2int(float f) {
    return Float.floatToIntBits(f);
}
#end_block

#method_before
// / CHECK-START: long Main.d2long(double) instruction_simplifier (before)
// / CHECK-DAG: <<Result:j\d+>> InvokeStaticOrDirect intrinsic:DoubleDoubleToLongBits
// / CHECK-DAG: Return [<<Result>>]
// 
// / CHECK-START: long Main.d2long(double) instruction_simplifier (after)
// / CHECK-DAG: <<Cond:z\d+>> NotEqual [<<Arg:d\d+>>,<<Arg>>]
// / CHECK-DAG: <<Raw:j\d+>> InvokeStaticOrDirect [<<Arg>>] intrinsic:DoubleDoubleToRawLongBits
// / CHECK-DAG: <<Result:j\d+>> Select [<<Raw>>,{{j\d+}},<<Cond>>]
private static long d2long(double d) {
    return Double.doubleToLongBits(d);
}
#method_after
// / CHECK-START: long Main.d2long(double) instruction_simplifier (before)
// / CHECK-DAG: <<Result:j\d+>> InvokeStaticOrDirect intrinsic:DoubleDoubleToLongBits
// / CHECK-DAG: Return [<<Result>>]
// 
// / CHECK-START: long Main.d2long(double) instruction_simplifier (after)
// / CHECK-DAG: <<Raw:j\d+>> InvokeStaticOrDirect [<<Arg:d\d+>>] intrinsic:DoubleDoubleToRawLongBits
// / CHECK-DAG: <<Cond:z\d+>> NotEqual [<<Arg>>,<<Arg>>]
// / CHECK-DAG: <<Result:j\d+>> Select [<<Raw>>,{{j\d+}},<<Cond>>]
private static long d2long(double d) {
    return Double.doubleToLongBits(d);
}
#end_block

#method_before
public SSLSession getSession(String host, int port) {
    if (host == null) {
        return null;
    }
    SSLSession session;
    HostAndPort hostAndPortKey = new HostAndPort(host, port);
    synchronized (sessionsByHostAndPort) {
        session = sessionsByHostAndPort.get(hostAndPortKey);
    }
    if (session != null && session.isValid()) {
        if (session instanceof OpenSSLSessionImpl) {
            return Platform.wrapSSLSession((OpenSSLSessionImpl) session);
        } else {
            return session;
        }
    }
    // Look in persistent cache.
    if (persistentCache != null) {
        byte[] data = persistentCache.getSessionData(host, port);
        if (data != null) {
            session = toSession(data, host, port);
            if (session != null && session.isValid()) {
                super.putSession(session);
                synchronized (sessionsByHostAndPort) {
                    sessionsByHostAndPort.put(hostAndPortKey, session);
                }
                if (session instanceof OpenSSLSessionImpl) {
                    return Platform.wrapSSLSession((OpenSSLSessionImpl) session);
                } else {
                    return session;
                }
            }
        }
    }
    return null;
}
#method_after
public SSLSession getSession(String host, int port) {
    if (host == null) {
        return null;
    }
    SSLSession session;
    HostAndPort hostAndPortKey = new HostAndPort(host, port);
    synchronized (sessionsByHostAndPort) {
        session = sessionsByHostAndPort.get(hostAndPortKey);
    }
    if (session != null && session.isValid()) {
        return wrapSSLSessionIfNeeded(session);
    }
    // Look in persistent cache.
    if (persistentCache != null) {
        byte[] data = persistentCache.getSessionData(host, port);
        if (data != null) {
            session = toSession(data, host, port);
            if (session != null && session.isValid()) {
                super.putSession(session);
                synchronized (sessionsByHostAndPort) {
                    sessionsByHostAndPort.put(hostAndPortKey, session);
                }
                return wrapSSLSessionIfNeeded(session);
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public SSLSession getSession(byte[] sessionId) {
    // First see if AbstractSessionContext can satisfy the request.
    {
        SSLSession session = super.getSession(sessionId);
        if (session != null) {
            // This will already have gone through Platform#wrapSSLSession
            return session;
        }
    }
    // Then check the persistent cache.
    if (persistentCache != null) {
        byte[] data = persistentCache.getSessionData(sessionId);
        if (data != null) {
            OpenSSLSessionImpl session = toSession(data, null, -1);
            if (session != null && session.isValid()) {
                super.putSession(session);
                return Platform.wrapSSLSession(session);
            }
        }
    }
    return null;
}
#method_after
@Override
public SSLSession getSession(byte[] sessionId) {
    // First see if AbstractSessionContext can satisfy the request.
    SSLSession cachedSession = super.getSession(sessionId);
    if (cachedSession != null) {
        // This will already have gone through Platform#wrapSSLSession
        return cachedSession;
    }
    // Then check the persistent cache.
    if (persistentCache != null) {
        byte[] data = persistentCache.getSessionData(sessionId);
        if (data != null) {
            OpenSSLSessionImpl session = toSession(data, null, -1);
            if (session != null && session.isValid()) {
                super.putSession(session);
                return Platform.wrapSSLSession(session);
            }
        }
    }
    return null;
}
#end_block

#method_before
private Size[] getInternalFormatSizes(int format, int dataspace, boolean output, boolean highRes) {
    SparseIntArray formatsMap = !output ? mInputFormats : dataspace == HAL_DATASPACE_DEPTH ? mDepthOutputFormats : highRes ? mHighResOutputFormats : mOutputFormats;
    int sizesCount = formatsMap.get(format);
    if (((!output || dataspace == HAL_DATASPACE_DEPTH) && sizesCount == 0) || (output && dataspace != HAL_DATASPACE_DEPTH && mAllOutputFormats.get(format) == 0)) {
        // Only throw if this is really not supported at all
        throw new IllegalArgumentException("format not available");
    }
    Size[] sizes = new Size[sizesCount];
    int sizeIndex = 0;
    StreamConfiguration[] configurations = (dataspace == HAL_DATASPACE_DEPTH) ? mDepthConfigurations : mConfigurations;
    StreamConfigurationDuration[] minFrameDuration = (dataspace == HAL_DATASPACE_DEPTH) ? mDepthMinFrameDurations : mMinFrameDurations;
    for (StreamConfiguration config : configurations) {
        int fmt = config.getFormat();
        if (fmt == format && config.isOutput() == output) {
            if (output && mListHighResolution) {
                // Filter slow high-res output formats; include for
                // highRes, remove for !highRes
                long duration = 0;
                for (int i = 0; i < minFrameDuration.length; i++) {
                    StreamConfigurationDuration d = minFrameDuration[i];
                    if (d.getFormat() == fmt && d.getWidth() == config.getSize().getWidth() && d.getHeight() == config.getSize().getHeight()) {
                        duration = d.getDuration();
                        break;
                    }
                }
                if (highRes != (duration > DURATION_20FPS_NS)) {
                    continue;
                }
            }
            sizes[sizeIndex++] = config.getSize();
        }
    }
    if (sizeIndex != sizesCount) {
        throw new AssertionError("Too few sizes (expected " + sizesCount + ", actual " + sizeIndex + ")");
    }
    return sizes;
}
#method_after
private Size[] getInternalFormatSizes(int format, int dataspace, boolean output, boolean highRes) {
    // All depth formats are non-high-res.
    if (dataspace == HAL_DATASPACE_DEPTH && highRes) {
        return new Size[0];
    }
    SparseIntArray formatsMap = !output ? mInputFormats : dataspace == HAL_DATASPACE_DEPTH ? mDepthOutputFormats : highRes ? mHighResOutputFormats : mOutputFormats;
    int sizesCount = formatsMap.get(format);
    if (((!output || dataspace == HAL_DATASPACE_DEPTH) && sizesCount == 0) || (output && dataspace != HAL_DATASPACE_DEPTH && mAllOutputFormats.get(format) == 0)) {
        // Only throw if this is really not supported at all
        throw new IllegalArgumentException("format not available");
    }
    Size[] sizes = new Size[sizesCount];
    int sizeIndex = 0;
    StreamConfiguration[] configurations = (dataspace == HAL_DATASPACE_DEPTH) ? mDepthConfigurations : mConfigurations;
    StreamConfigurationDuration[] minFrameDurations = (dataspace == HAL_DATASPACE_DEPTH) ? mDepthMinFrameDurations : mMinFrameDurations;
    for (StreamConfiguration config : configurations) {
        int fmt = config.getFormat();
        if (fmt == format && config.isOutput() == output) {
            if (output && mListHighResolution) {
                // Filter slow high-res output formats; include for
                // highRes, remove for !highRes
                long duration = 0;
                for (int i = 0; i < minFrameDurations.length; i++) {
                    StreamConfigurationDuration d = minFrameDurations[i];
                    if (d.getFormat() == fmt && d.getWidth() == config.getSize().getWidth() && d.getHeight() == config.getSize().getHeight()) {
                        duration = d.getDuration();
                        break;
                    }
                }
                if (dataspace != HAL_DATASPACE_DEPTH && highRes != (duration > DURATION_20FPS_NS)) {
                    continue;
                }
            }
            sizes[sizeIndex++] = config.getSize();
        }
    }
    if (sizeIndex != sizesCount) {
        throw new AssertionError("Too few sizes (expected " + sizesCount + ", actual " + sizeIndex + ")");
    }
    return sizes;
}
#end_block

