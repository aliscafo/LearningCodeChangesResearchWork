470
#method_before
private VnetService create(ServiceKey serviceKey) {
    VirtualNetwork network = getVirtualNetwork(serviceKey.networkId());
    checkNotNull(network, NETWORK_NULL);
    VnetService service;
    if (serviceKey.serviceClass.equals(DeviceService.class)) {
        service = new VirtualNetworkDeviceManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(LinkService.class)) {
        service = new VirtualNetworkLinkManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(TopologyService.class)) {
        service = new VirtualNetworkTopologyManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(IntentService.class)) {
        service = new VirtualNetworkIntentManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(HostService.class)) {
        service = new VirtualNetworkHostManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PathService.class)) {
        service = new VirtualNetworkPathManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowRuleService.class)) {
        service = new VirtualNetworkFlowRuleManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PacketService.class)) {
        service = new VirtualNetworkPacketManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(GroupService.class)) {
        service = new VirtualNetworkGroupManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowObjectiveService.class)) {
        service = new VirtualNetworkFlowObjectiveManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(MastershipService.class)) {
        ServiceKey mastershipAdminServiceKey = networkServiceKey(serviceKey.networkId, MastershipAdminService.class);
        ServiceKey mastershipTermServiceKey = networkServiceKey(serviceKey.networkId, MastershipTermService.class);
        VnetService mastershipAdminService = networkServices.get(mastershipAdminServiceKey);
        VnetService mastershipTermService = networkServices.get(mastershipTermServiceKey);
        if (mastershipAdminService != null) {
            service = mastershipAdminService;
        } else if (mastershipTermService != null) {
            service = mastershipTermService;
        } else {
            service = new VirtualNetworkMastershipManager(this, network.id());
        }
    } else if (serviceKey.serviceClass.equals(MastershipAdminService.class)) {
        ServiceKey mastershipServiceKey = networkServiceKey(serviceKey.networkId, MastershipService.class);
        ServiceKey mastershipTermServiceKey = networkServiceKey(serviceKey.networkId, MastershipTermService.class);
        VnetService mastershipService = networkServices.get(mastershipServiceKey);
        VnetService mastershipTermService = networkServices.get(mastershipTermServiceKey);
        if (mastershipService != null) {
            service = mastershipService;
        } else if (mastershipTermService != null) {
            service = mastershipTermService;
        } else {
            service = new VirtualNetworkMastershipManager(this, network.id());
        }
    } else if (serviceKey.serviceClass.equals(MastershipTermService.class)) {
        ServiceKey mastershipServiceKey = networkServiceKey(serviceKey.networkId, MastershipService.class);
        ServiceKey mastershipAdminServiceKey = networkServiceKey(serviceKey.networkId, MastershipAdminService.class);
        VnetService mastershipService = networkServices.get(mastershipServiceKey);
        VnetService mastershipAdminService = networkServices.get(mastershipAdminServiceKey);
        if (mastershipService != null) {
            service = mastershipService;
        } else if (mastershipAdminService != null) {
            service = mastershipAdminService;
        } else {
            service = new VirtualNetworkMastershipManager(this, network.id());
        }
    } else {
        return null;
    }
    networkServices.put(serviceKey, service);
    return service;
}
#method_after
private VnetService create(ServiceKey serviceKey) {
    VirtualNetwork network = getVirtualNetwork(serviceKey.networkId());
    checkNotNull(network, NETWORK_NULL);
    VnetService service;
    if (serviceKey.serviceClass.equals(DeviceService.class)) {
        service = new VirtualNetworkDeviceManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(LinkService.class)) {
        service = new VirtualNetworkLinkManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(TopologyService.class)) {
        service = new VirtualNetworkTopologyManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(IntentService.class)) {
        service = new VirtualNetworkIntentManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(HostService.class)) {
        service = new VirtualNetworkHostManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PathService.class)) {
        service = new VirtualNetworkPathManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowRuleService.class)) {
        service = new VirtualNetworkFlowRuleManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PacketService.class)) {
        service = new VirtualNetworkPacketManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(GroupService.class)) {
        service = new VirtualNetworkGroupManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowObjectiveService.class)) {
        service = new VirtualNetworkFlowObjectiveManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(MastershipService.class) || serviceKey.serviceClass.equals(MastershipAdminService.class) || serviceKey.serviceClass.equals(MastershipTermService.class)) {
        service = new VirtualNetworkMastershipManager(this, network.id());
    } else {
        return null;
    }
    networkServices.put(serviceKey, service);
    return service;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int length = (short) (VXLAN_HEADER_LENGTH + (payloadData == null ? 0 : payloadData.length));
    final byte[] data = new byte[length];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.flags);
    bb.put(this.rsvd1);
    bb.put(this.vni);
    bb.put(this.rsvd2);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int length = VXLAN_HEADER_LENGTH + (payloadData == null ? 0 : payloadData.length);
    final byte[] data = new byte[length];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.flags);
    bb.put(this.rsvd1);
    bb.put(this.vni);
    bb.put(this.rsvd2);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    return data;
}
#end_block

#method_before
public int getVni() {
    return vni[0] * 256 * 256 + vni[1] * 256 + vni[2];
}
#method_after
public int getVni() {
    return (vni[0] << (BYTE_SHIFT * 2)) + (vni[1] << BYTE_SHIFT) + vni[2];
}
#end_block

#method_before
public VXLAN setVni(long vni) {
    this.vni[0] = (byte) ((vni >> 16) & 0xff);
    this.vni[1] = (byte) ((vni >> 8) & 0xff);
    this.vni[2] = (byte) (vni & 0xff);
    return this;
}
#method_after
public VXLAN setVni(int vni) {
    this.vni[0] = (byte) ((vni >> (BYTE_SHIFT * 2)) & BYTE_MASK);
    this.vni[1] = (byte) ((vni >> BYTE_SHIFT) & BYTE_MASK);
    this.vni[2] = (byte) (vni & BYTE_MASK);
    return this;
}
#end_block

#method_before
@BeforeClass
public static void setUpBeforeClass() throws Exception {
    deserializer = VXLAN.deserializer();
    udp.setSourcePort(0x50);
    udp.setDestinationPort(UDP.VXLAN_DST_PORT);
}
#method_after
@BeforeClass
public static void setUpBeforeClass() throws Exception {
    deserializer = VXLAN.deserializer();
    UDP_HDR.setSourcePort(TEST_UDP_SRCPORT);
    UDP_HDR.setDestinationPort(UDP.VXLAN_UDP_PORT);
}
#end_block

#method_before
@Test
public void testSerialize() {
    VXLAN vxlan = new VXLAN();
    vxlan.setFlag((byte) 0x08);
    vxlan.setRsvd1(0x0L);
    vxlan.setVni(0x123456);
    vxlan.setRsvd2((byte) 0x0);
    vxlan.setParent(udp);
    assertArrayEquals(bytePacketVXLAN, vxlan.serialize());
}
#method_after
@Test
public void testSerialize() {
    VXLAN vxlan = new VXLAN();
    vxlan.setFlag((byte) TEST_FLAGS);
    vxlan.setVni(TEST_VNI1);
    vxlan.setParent(UDP_HDR);
    assertArrayEquals("Serialized packet is not matched", BYTE_PACKET_VXLAN, vxlan.serialize());
}
#end_block

#method_before
@Test
public void testDeserializeTruncated() throws Exception {
    PacketTestUtils.testDeserializeTruncated(deserializer, bytePacketVXLAN);
}
#method_after
@Test
public void testDeserializeTruncated() throws Exception {
    PacketTestUtils.testDeserializeTruncated(deserializer, BYTE_PACKET_VXLAN);
}
#end_block

#method_before
@Test
public void testDeserialize() throws Exception {
    VXLAN vxlan = deserializer.deserialize(bytePacketVXLAN, 0, bytePacketVXLAN.length);
    assertThat(vxlan.getFlag(), is((byte) 0x08));
    assertThat(vxlan.getVni(), is(0x123456));
}
#method_after
@Test
public void testDeserialize() throws Exception {
    VXLAN vxlan = deserializer.deserialize(BYTE_PACKET_VXLAN, 0, BYTE_PACKET_VXLAN.length);
    assertThat(vxlan.getFlag(), is((byte) TEST_FLAGS));
    assertThat(vxlan.getVni(), is(TEST_VNI1));
}
#end_block

#method_before
@Test
public void testEqual() {
    VXLAN vxlan1 = new VXLAN();
    vxlan1.setFlag((byte) 0x08);
    vxlan1.setRsvd1(0x0L);
    vxlan1.setVni(0x123456);
    vxlan1.setRsvd2((byte) 0x0);
    VXLAN vxlan2 = new VXLAN();
    vxlan2.setFlag((byte) 0x08);
    vxlan2.setRsvd1(0x0L);
    vxlan2.setVni(0x654321);
    vxlan2.setRsvd2((byte) 0x0);
    assertTrue(vxlan1.equals(vxlan1));
    assertFalse(vxlan1.equals(vxlan2));
}
#method_after
@Test
public void testEqual() {
    VXLAN vxlan1 = new VXLAN();
    vxlan1.setFlag((byte) TEST_FLAGS);
    vxlan1.setVni(TEST_VNI1);
    VXLAN vxlan2 = new VXLAN();
    vxlan2.setFlag((byte) TEST_FLAGS);
    vxlan2.setVni(TEST_VNI2);
    new EqualsTester().addEqualityGroup(vxlan1, vxlan1).addEqualityGroup(vxlan2).testEquals();
}
#end_block

#method_before
@Test
public void testToStringVXLAN() throws Exception {
    VXLAN vxlan = deserializer.deserialize(bytePacketVXLAN, 0, bytePacketVXLAN.length);
    String str = vxlan.toString();
    assertTrue(StringUtils.contains(str, "flags=" + 0x08));
    assertTrue(StringUtils.contains(str, "vni=" + 0x123456));
}
#method_after
@Test
public void testToStringVXLAN() throws Exception {
    VXLAN vxlan = deserializer.deserialize(BYTE_PACKET_VXLAN, 0, BYTE_PACKET_VXLAN.length);
    String str = vxlan.toString();
    assertTrue(StringUtils.contains(str, "flags=" + TEST_FLAGS));
    assertTrue(StringUtils.contains(str, "vni=" + TEST_VNI1));
}
#end_block

#method_before
private Set<OutboundPacket> devirtualize(NetworkId networkId, OutboundPacket packet) {
    Set<OutboundPacket> outboundPackets = new HashSet<>();
    Set<VirtualPort> vPorts = vnaService.getVirtualPorts(networkId, packet.sendThrough());
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    packet.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    PortNumber vOutPortNum = packet.treatment().allInstructions().stream().filter(i -> i.type() == Instruction.Type.OUTPUT).map(i -> ((Instructions.OutputInstruction) i).port()).findFirst().get();
    if (!vOutPortNum.isLogical()) {
        Optional<ConnectPoint> optionalCpOut = vPorts.stream().filter(v -> v.number().equals(vOutPortNum)).map(v -> v.realizedBy()).findFirst();
        if (!optionalCpOut.isPresent()) {
            log.warn("Port {} is not realized yet, in Network {}, Device {}", vOutPortNum, networkId, packet.sendThrough());
            return outboundPackets;
        }
        ConnectPoint egressPoint = optionalCpOut.get();
        TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(egressPoint.port()).build();
        OutboundPacket outboundPacket = new DefaultOutboundPacket(egressPoint.deviceId(), treatment, packet.data());
        outboundPackets.add(outboundPacket);
    } else {
        if (vOutPortNum == PortNumber.FLOOD) {
            for (VirtualPort outPort : vPorts) {
                // Fixme: Should we handle the flood logic? But no inbound context.
                ConnectPoint cpOut = outPort.realizedBy();
                if (cpOut != null) {
                    TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(cpOut.port()).build();
                    OutboundPacket outboundPacket = new DefaultOutboundPacket(cpOut.deviceId(), treatment, packet.data());
                    outboundPackets.add(outboundPacket);
                } else {
                    log.warn("Port {} is not realized yet, in Network {}, Device {}", outPort.number(), networkId, packet.sendThrough());
                }
            }
        }
    }
    return outboundPackets;
}
#method_after
private Set<OutboundPacket> devirtualize(NetworkId networkId, OutboundPacket packet) {
    Set<OutboundPacket> outboundPackets = new HashSet<>();
    Set<VirtualPort> vPorts = vnaService.getVirtualPorts(networkId, packet.sendThrough());
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    packet.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    PortNumber vOutPortNum = packet.treatment().allInstructions().stream().filter(i -> i.type() == Instruction.Type.OUTPUT).map(i -> ((Instructions.OutputInstruction) i).port()).findFirst().get();
    if (!vOutPortNum.isLogical()) {
        Optional<ConnectPoint> optionalCpOut = vPorts.stream().filter(v -> v.number().equals(vOutPortNum)).map(v -> v.realizedBy()).findFirst();
        if (!optionalCpOut.isPresent()) {
            log.warn("Port {} is not realized yet, in Network {}, Device {}", vOutPortNum, networkId, packet.sendThrough());
            return outboundPackets;
        }
        ConnectPoint egressPoint = optionalCpOut.get();
        TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(egressPoint.port()).build();
        OutboundPacket outboundPacket = new DefaultOutboundPacket(egressPoint.deviceId(), treatment, packet.data());
        outboundPackets.add(outboundPacket);
    } else {
        if (vOutPortNum == PortNumber.FLOOD) {
            for (VirtualPort outPort : vPorts) {
                ConnectPoint cpOut = outPort.realizedBy();
                if (cpOut != null) {
                    TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(cpOut.port()).build();
                    OutboundPacket outboundPacket = new DefaultOutboundPacket(cpOut.deviceId(), treatment, packet.data());
                    outboundPackets.add(outboundPacket);
                } else {
                    log.warn("Port {} is not realized yet, in Network {}, Device {}", outPort.number(), networkId, packet.sendThrough());
                }
            }
        }
    }
    return outboundPackets;
}
#end_block

#method_before
@Override
public void event(VirtualNetworkEvent event) {
    switch(event.type()) {
        case NETWORK_ADDED:
            if (processor == null) {
                processor = new InternalPacketProcessor();
                packetService.addProcessor(processor, PACKET_PROCESSOR_PRIORITY);
                log.info("Packet processor {} for virtual network is added.", processor.getClass().getName());
            }
            break;
        case NETWORK_REMOVED:
            Set<TenantId> tenantSet = vnaService.getTenantIds();
            Set<VirtualNetwork> networkSet = Sets.newHashSet();
            tenantSet.forEach(tenantId -> networkSet.addAll(vnaService.getVirtualNetworks(tenantId)));
            if (networkSet.isEmpty()) {
                packetService.removeProcessor(processor);
                log.info("Packet processor {} for virtual network is removed.", processor.getClass().getName());
                processor = null;
            }
            break;
        default:
            // do nothing
            break;
    }
}
#method_after
@Override
public void event(VirtualNetworkEvent event) {
    switch(event.type()) {
        case NETWORK_ADDED:
            if (networkIdSet.isEmpty()) {
                processor = new InternalPacketProcessor();
                packetService.addProcessor(processor, PACKET_PROCESSOR_PRIORITY);
                log.info("Packet processor {} for virtual network is added.", processor.getClass().getName());
            }
            networkIdSet.add(event.subject());
            break;
        case NETWORK_REMOVED:
            networkIdSet.remove(event.subject());
            if (networkIdSet.isEmpty()) {
                packetService.removeProcessor(processor);
                log.info("Packet processor {} for virtual network is removed.", processor.getClass().getName());
                processor = null;
            }
            break;
        default:
            // do nothing
            break;
    }
}
#end_block

#method_before
private void startServer() {
    HashedWheelTimer timer = new HashedWheelTimer(groupedThreads("onos/fpm", "fpm-timer-%d", log));
    ChannelFactory channelFactory = new NioServerSocketChannelFactory(newCachedThreadPool(groupedThreads("onos/fpm", "sm-boss-%d", log)), newCachedThreadPool(groupedThreads("onos/fpm", "sm-worker-%d", log)));
    ChannelPipelineFactory pipelineFactory = () -> {
        // Allocate a new session per connection
        IdleStateHandler idleHandler = new IdleStateHandler(timer, IDLE_TIMEOUT, 0, 0);
        FpmSessionHandler fpmSessionHandler = new FpmSessionHandler(new InternalFpmListener());
        FpmFrameDecoder fpmFrameDecoder = new FpmFrameDecoder();
        // Setup the processing pipeline
        ChannelPipeline pipeline = Channels.pipeline();
        pipeline.addLast("FpmFrameDecoder", fpmFrameDecoder);
        pipeline.addLast("idle", idleHandler);
        pipeline.addLast("FpmSession", fpmSessionHandler);
        return pipeline;
    };
    InetSocketAddress listenAddress = new InetSocketAddress(FPM_PORT);
    serverBootstrap = new ServerBootstrap(channelFactory);
    serverBootstrap.setOption("child.reuseAddr", true);
    serverBootstrap.setOption("child.keepAlive", true);
    serverBootstrap.setOption("child.tcpNoDelay", true);
    serverBootstrap.setPipelineFactory(pipelineFactory);
    try {
        serverChannel = serverBootstrap.bind(listenAddress);
        allChannels.add(serverChannel);
    } catch (ChannelException e) {
        log.debug("Exception binding to FPM port {}: ", listenAddress.getPort(), e);
        stopServer();
    }
}
#method_after
private void startServer() {
    HashedWheelTimer timer = new HashedWheelTimer(groupedThreads("onos/fpm", "fpm-timer-%d", log));
    ChannelFactory channelFactory = new NioServerSocketChannelFactory(newCachedThreadPool(groupedThreads("onos/fpm", "sm-boss-%d", log)), newCachedThreadPool(groupedThreads("onos/fpm", "sm-worker-%d", log)));
    ChannelPipelineFactory pipelineFactory = () -> {
        // Allocate a new session per connection
        IdleStateHandler idleHandler = new IdleStateHandler(timer, IDLE_TIMEOUT_SECS, 0, 0);
        FpmSessionHandler fpmSessionHandler = new FpmSessionHandler(new InternalFpmListener());
        FpmFrameDecoder fpmFrameDecoder = new FpmFrameDecoder();
        // Setup the processing pipeline
        ChannelPipeline pipeline = Channels.pipeline();
        pipeline.addLast("FpmFrameDecoder", fpmFrameDecoder);
        pipeline.addLast("idle", idleHandler);
        pipeline.addLast("FpmSession", fpmSessionHandler);
        return pipeline;
    };
    InetSocketAddress listenAddress = new InetSocketAddress(FPM_PORT);
    serverBootstrap = new ServerBootstrap(channelFactory);
    serverBootstrap.setOption("child.reuseAddr", true);
    serverBootstrap.setOption("child.keepAlive", true);
    serverBootstrap.setOption("child.tcpNoDelay", true);
    serverBootstrap.setPipelineFactory(pipelineFactory);
    try {
        serverChannel = serverBootstrap.bind(listenAddress);
        allChannels.add(serverChannel);
    } catch (ChannelException e) {
        log.debug("Exception binding to FPM port {}: ", listenAddress.getPort(), e);
        stopServer();
    }
}
#end_block

#method_before
@Override
public void send() {
    if (!this.block()) {
        devirtualizeContext(this).forEach(outboundPacket -> packetService.emit(outboundPacket));
    }
}
#method_after
@Override
public void send() {
    if (!this.block()) {
        dvpp.send(this);
    }
}
#end_block

#method_before
private VirtualPacketContext virtualize(PacketContext context) {
    VirtualPort vPort = getMappedVirtualPort(context.inPacket().receivedFrom());
    if (vPort != null) {
        ConnectPoint cp = new ConnectPoint(vPort.element().id(), vPort.number());
        Ethernet eth = context.inPacket().parsed();
        eth.setVlanID(Ethernet.VLAN_UNTAGGED);
        InboundPacket inPacket = new DefaultInboundPacket(cp, eth, ByteBuffer.wrap(eth.serialize()));
        DefaultOutboundPacket outPkt = new DefaultOutboundPacket(cp.deviceId(), DefaultTrafficTreatment.builder().build(), ByteBuffer.wrap(eth.serialize()));
        VirtualPacketContext vContext = new DefaultVirtualPacketContext(context.time(), inPacket, outPkt, context.isHandled(), vPort.networkId(), packetService, vnaService);
        return vContext;
    } else {
        return null;
    }
}
#method_after
private VirtualPacketContext virtualize(PacketContext context) {
    VirtualPort vPort = getMappedVirtualPort(context.inPacket().receivedFrom());
    if (vPort != null) {
        ConnectPoint cp = new ConnectPoint(vPort.element().id(), vPort.number());
        Ethernet eth = context.inPacket().parsed();
        eth.setVlanID(Ethernet.VLAN_UNTAGGED);
        InboundPacket inPacket = new DefaultInboundPacket(cp, eth, ByteBuffer.wrap(eth.serialize()));
        DefaultOutboundPacket outPkt = new DefaultOutboundPacket(cp.deviceId(), DefaultTrafficTreatment.builder().build(), ByteBuffer.wrap(eth.serialize()));
        VirtualPacketContext vContext = new DefaultVirtualPacketContext(context.time(), inPacket, outPkt, context.isHandled(), vPort.networkId(), this);
        return vContext;
    } else {
        return null;
    }
}
#end_block

#method_before
private Set<OutboundPacket> devirtualize(NetworkId networkId, OutboundPacket packet) {
    Set<OutboundPacket> outboundPackets = new HashSet<>();
    Set<VirtualPort> vPorts = vnaService.getVirtualPorts(networkId, packet.sendThrough());
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    packet.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    PortNumber vOutPortNum = packet.treatment().allInstructions().stream().filter(i -> i.type() == Instruction.Type.OUTPUT).map(i -> ((Instructions.OutputInstruction) i).port()).findFirst().get();
    if (!vOutPortNum.isLogical()) {
        Optional<ConnectPoint> optionalCpOut = vPorts.stream().filter(v -> v.number().equals(vOutPortNum)).map(v -> v.realizedBy()).findFirst();
        if (!optionalCpOut.isPresent()) {
            log.warn("Port {} is not realized yet, in Network {}, Device {}", vOutPortNum, networkId, packet.sendThrough());
            return outboundPackets;
        }
        ConnectPoint egressPoint = optionalCpOut.get();
        TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(egressPoint.port()).build();
        OutboundPacket outboundPacket = new DefaultOutboundPacket(egressPoint.deviceId(), treatment, packet.data());
        outboundPackets.add(outboundPacket);
    } else {
        if (vOutPortNum == PortNumber.FLOOD) {
            for (VirtualPort outPort : vPorts) {
                // Fixme: Should we handle the flood logic? But no inbound context.
                ConnectPoint cpOut = outPort.realizedBy();
                if (cpOut != null) {
                    TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(cpOut.port()).build();
                    OutboundPacket outboundPacket = new DefaultOutboundPacket(cpOut.deviceId(), treatment, packet.data());
                    outboundPackets.add(outboundPacket);
                } else {
                    log.warn("Port {} is not realized yet, in Network {}, Device {}", outPort.number(), networkId, packet.sendThrough());
                }
            }
        }
    }
    return outboundPackets;
}
#method_after
private Set<OutboundPacket> devirtualize(NetworkId networkId, OutboundPacket packet) {
    Set<OutboundPacket> outboundPackets = new HashSet<>();
    Set<VirtualPort> vPorts = vnaService.getVirtualPorts(networkId, packet.sendThrough());
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    packet.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    PortNumber vOutPortNum = packet.treatment().allInstructions().stream().filter(i -> i.type() == Instruction.Type.OUTPUT).map(i -> ((Instructions.OutputInstruction) i).port()).findFirst().get();
    if (!vOutPortNum.isLogical()) {
        Optional<ConnectPoint> optionalCpOut = vPorts.stream().filter(v -> v.number().equals(vOutPortNum)).map(v -> v.realizedBy()).findFirst();
        if (!optionalCpOut.isPresent()) {
            log.warn("Port {} is not realized yet, in Network {}, Device {}", vOutPortNum, networkId, packet.sendThrough());
            return outboundPackets;
        }
        ConnectPoint egressPoint = optionalCpOut.get();
        TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(egressPoint.port()).build();
        OutboundPacket outboundPacket = new DefaultOutboundPacket(egressPoint.deviceId(), treatment, packet.data());
        outboundPackets.add(outboundPacket);
    } else {
        if (vOutPortNum == PortNumber.FLOOD) {
            for (VirtualPort outPort : vPorts) {
                ConnectPoint cpOut = outPort.realizedBy();
                if (cpOut != null) {
                    TrafficTreatment treatment = DefaultTrafficTreatment.builder(commonTreatment).setOutput(cpOut.port()).build();
                    OutboundPacket outboundPacket = new DefaultOutboundPacket(cpOut.deviceId(), treatment, packet.data());
                    outboundPackets.add(outboundPacket);
                } else {
                    log.warn("Port {} is not realized yet, in Network {}, Device {}", outPort.number(), networkId, packet.sendThrough());
                }
            }
        }
    }
    return outboundPackets;
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    VirtualPacketContext vContexts = virtualize(context);
    if (vContexts == null) {
        return;
    }
    VirtualPacketProviderService service = (VirtualPacketProviderService) providerRegistryService.getProviderService(vContexts.getNetworkId(), VirtualPacketProvider.class);
    if (service != null) {
        service.processPacket(vContexts);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    VirtualPacketContext vContexts = virtualize(context);
    if (vContexts == null) {
        return;
    }
    VirtualPacketProviderService service = (VirtualPacketProviderService) providerRegistryService.getProviderService(vContexts.networkId(), VirtualPacketProvider.class);
    if (service != null) {
        service.processPacket(vContexts);
    }
}
#end_block

#method_before
@Test
public void messagesInZhTw() {
    title("messagesInZhTW");
    Locale.setDefault(Locale.TRADITIONAL_CHINESE);
    checkLookups("電腦", "磁碟", "螢幕", "鍵盤");
}
#method_after
@Test
@Ignore("Jenkins not chinese friendly, yet...")
public void messagesInZhTw() {
    title("messagesInZhTW");
    Locale.setDefault(Locale.TRADITIONAL_CHINESE);
    checkLookups("電腦", "磁碟", "螢幕", "鍵盤");
}
#end_block

#method_before
@Test
public void testAppIdComparator() {
    assertEquals(0, Comparators.APP_ID_COMPARATOR.compare(appID(1, "a"), appID(1, "a")));
    assertTrue(Comparators.APP_ID_COMPARATOR.compare(appID(2, "a"), appID(0, "a")) > 0);
    assertTrue(Comparators.APP_ID_COMPARATOR.compare(appID(1, "b"), appID(3, "x")) < 0);
}
#method_after
@Test
public void testAppIdComparator() {
    assertEquals(0, APP_ID_COMPARATOR.compare(appID(1, "a"), appID(1, "a")));
    assertTrue(APP_ID_COMPARATOR.compare(appID(2, "a"), appID(0, "a")) > 0);
    assertTrue(APP_ID_COMPARATOR.compare(appID(1, "b"), appID(3, "x")) < 0);
}
#end_block

#method_before
@Test
public void testAppComparator() {
    assertEquals(0, Comparators.APP_COMPARATOR.compare(app(1, "foo"), app(1, "foo")));
    assertEquals(0, (Comparators.APP_COMPARATOR.compare(app(2, "foo"), app(2, "bar"))));
    assertNotEquals(0, Comparators.APP_COMPARATOR.compare(app(1, "foo"), app(2, "foo")));
    assertNotEquals(0, Comparators.APP_COMPARATOR.compare(app(1, "bar"), app(2, "foo")));
}
#method_after
@Test
public void testAppComparator() {
    assertEquals(0, APP_COMPARATOR.compare(app(1, "foo"), app(1, "foo")));
    assertEquals(0, (APP_COMPARATOR.compare(app(2, "foo"), app(2, "bar"))));
    assertNotEquals(0, APP_COMPARATOR.compare(app(1, "foo"), app(2, "foo")));
    assertNotEquals(0, APP_COMPARATOR.compare(app(1, "bar"), app(2, "foo")));
}
#end_block

#method_before
@Test
public void testElementIdComparator() {
    ElementId elementid1 = new ElementId() {
    };
    ElementId elementid2 = elementid1;
    ElementId elementid3 = new ElementId() {
    };
    while (elementid1 == elementid3) {
        elementid3 = new ElementId() {
        };
    }
    assertTrue(0 == Comparators.ELEMENT_ID_COMPARATOR.compare(elementid1, elementid2));
    assertFalse(0 == Comparators.ELEMENT_ID_COMPARATOR.compare(elementid3, elementid1));
}
#method_after
@Test
public void testElementIdComparator() {
    ElementId elementid1 = new ElementId() {
    };
    ElementId elementid2 = elementid1;
    ElementId elementid3 = new ElementId() {
    };
    while (elementid1 == elementid3) {
        elementid3 = new ElementId() {
        };
    }
    assertTrue(0 == ELEMENT_ID_COMPARATOR.compare(elementid1, elementid2));
    assertFalse(0 == ELEMENT_ID_COMPARATOR.compare(elementid3, elementid1));
}
#end_block

#method_before
@Test
public void testFlowRuleComparator() {
    assertEquals(0, Comparators.FLOW_RULE_COMPARATOR.compare(fRule(100, 10), fRule(100, 10)));
    assertEquals(-8, Comparators.FLOW_RULE_COMPARATOR.compare(fRule(100, 10), fRule(100, 2)));
    assertEquals(90, Comparators.FLOW_RULE_COMPARATOR.compare(fRule(100, 10), fRule(10, 10)));
    assertEquals(20, Comparators.FLOW_RULE_COMPARATOR.compare(fRule(40, 10), fRule(20, 2)));
}
#method_after
@Test
public void testFlowRuleComparator() {
    assertEquals(0, FLOW_RULE_COMPARATOR.compare(fRule(100, 10), fRule(100, 10)));
    assertEquals(-8, FLOW_RULE_COMPARATOR.compare(fRule(100, 10), fRule(100, 2)));
    assertEquals(90, FLOW_RULE_COMPARATOR.compare(fRule(100, 10), fRule(10, 10)));
    assertEquals(20, FLOW_RULE_COMPARATOR.compare(fRule(40, 10), fRule(20, 2)));
}
#end_block

#method_before
private FlowRule fRule(int tableID, int priority) {
    return DefaultFlowRule.builder().forDevice(did("1")).withPriority(priority).forTable(tableID).fromApp(APP_ID).makeTemporary(44).build();
}
#method_after
private FlowRule fRule(int tableID, int priority) {
    return DefaultFlowRule.builder().forDevice(did("id" + Integer.toString(10))).withPriority(priority).forTable(tableID).fromApp(APP_ID).makeTemporary(44).build();
}
#end_block

#method_before
@Test
public void testFlowEntryWithLoad() {
    // Rate = (current-previous)/interval
    assertEquals(0, Comparators.FLOWENTRY_WITHLOAD_COMPARATOR.compare(FWLoad(20, 10, 1), FWLoad(20, 10, 1)));
    assertEquals(0, Comparators.FLOWENTRY_WITHLOAD_COMPARATOR.compare(FWLoad(50, 30, 2), FWLoad(100, 50, 5)));
    assertEquals(-1, Comparators.FLOWENTRY_WITHLOAD_COMPARATOR.compare(FWLoad(200, 100, 4), FWLoad(300, 200, 10)));
}
#method_after
@Test
public void testFlowEntryWithLoad() {
    // Rate = (current-previous)/interval
    assertEquals(0, FLOWENTRY_WITHLOAD_COMPARATOR.compare(FWLoad(20, 10, 1), FWLoad(20, 10, 1)));
    assertEquals(0, FLOWENTRY_WITHLOAD_COMPARATOR.compare(FWLoad(50, 30, 2), FWLoad(100, 50, 5)));
    assertEquals(-1, FLOWENTRY_WITHLOAD_COMPARATOR.compare(FWLoad(200, 100, 4), FWLoad(300, 200, 10)));
}
#end_block

#method_before
@Test
public void testElementComparator() {
    Element e1 = new DefaultDevice(PID1, DID2, null, MFR1, HW1, SW1, SN2, CID1);
    Element e2 = new DefaultDevice(PID1, DID2, null, MFR1, HW1, SW1, SN2, CID1);
    Element e3 = new DefaultDevice(PID1, DID3, null, MFR1, HW1, SW1 + ".0.0", SN2, CID1);
    assertEquals(0, Comparators.ELEMENT_COMPARATOR.compare(e1, e2));
    assertNotEquals(0, Comparators.ELEMENT_COMPARATOR.compare(e1, e3));
}
#method_after
@Test
public void testElementComparator() {
    assertEquals(0, ELEMENT_COMPARATOR.compare(element("of", "foo", "of:foo"), element("of", "foo", "of:foo")));
    assertEquals(0, ELEMENT_COMPARATOR.compare(element("of", "bar", "of:bar"), element("of", "foo", "of:bar")));
    assertNotEquals(0, ELEMENT_COMPARATOR.compare(element("of", "foo", "of:foo"), element("of", "foo", "of:bar")));
}
#end_block

#method_before
@Test
public void testGroupComparator() {
    assertEquals(0, Comparators.GROUP_COMPARATOR.compare(group(10), group(10)));
    assertEquals(-1, Comparators.GROUP_COMPARATOR.compare(group(25), group(100)));
    assertEquals(1, Comparators.GROUP_COMPARATOR.compare(group(20), group(10)));
}
#method_after
@Test
public void testGroupComparator() {
    assertEquals(0, GROUP_COMPARATOR.compare(group(10), group(10)));
    assertEquals(-1, GROUP_COMPARATOR.compare(group(25), group(100)));
    assertEquals(1, GROUP_COMPARATOR.compare(group(20), group(10)));
}
#end_block

#method_before
private Group group(int id) {
    GroupBucket testBucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.emptyTreatment());
    GroupBuckets groupBuckets = new GroupBuckets(ImmutableList.of(testBucket));
    GroupDescription groupDesc1 = new DefaultGroupDescription(did("1"), GroupDescription.Type.ALL, groupBuckets);
    return new DefaultGroup(new GroupId(id), groupDesc1);
}
#method_after
private Group group(int id) {
    return new DefaultGroup(new GroupId(id), groupDesc1);
}
#end_block

#method_before
@Test
public void testPortComparator() {
    assertEquals(0, Comparators.PORT_COMPARATOR.compare(portTest(100), portTest(100)));
    assertNotEquals(0, Comparators.PORT_COMPARATOR.compare(portTest(100), portTest(200)));
}
#method_after
@Test
public void testPortComparator() {
    assertEquals(0, PORT_COMPARATOR.compare(portTest(100), portTest(100)));
    assertNotEquals(0, PORT_COMPARATOR.compare(portTest(100), portTest(200)));
}
#end_block

#method_before
@Test
public void testTopologyClusterTest() {
    assertEquals(0, Comparators.CLUSTER_COMPARATOR.compare(cluster(3, 2, 1, "of:1"), cluster(3, 2, 1, "of:1")));
    assertNotEquals(0, Comparators.CLUSTER_COMPARATOR.compare(cluster(5, 2, 1, "of:1"), cluster(3, 2, 1, "of:1")));
}
#method_after
@Test
public void testTopologyClusterTest() {
    assertEquals(0, CLUSTER_COMPARATOR.compare(cluster(3, 2, 1, "of:1"), cluster(3, 2, 1, "of:1")));
    assertNotEquals(0, CLUSTER_COMPARATOR.compare(cluster(5, 2, 1, "of:1"), cluster(3, 2, 1, "of:1")));
}
#end_block

#method_before
@Test
public void testControllerNode() {
    assertEquals(0, Comparators.NODE_COMPARATOR.compare(node("testId"), node("testId")));
    assertTrue(Comparators.NODE_COMPARATOR.compare(node("abc"), node("xyz")) < 0);
    assertTrue(Comparators.NODE_COMPARATOR.compare(node("xyz"), node("abc")) > 0);
}
#method_after
@Test
public void testControllerNode() {
    assertEquals(0, NODE_COMPARATOR.compare(node("testId"), node("testId")));
    assertTrue(NODE_COMPARATOR.compare(node("abc"), node("xyz")) < 0);
    assertTrue(NODE_COMPARATOR.compare(node("xyz"), node("abc")) > 0);
}
#end_block

#method_before
@Test
public void testInterfaceComparator() {
    assertEquals(0, Comparators.INTERFACES_COMPARATOR.compare(intface("of:0000000000000001", 100), intface("of:0000000000000001", 100)));
    assertTrue(Comparators.INTERFACES_COMPARATOR.compare(intface("of:0000000000000001", 2), intface("of:0000000000000001", 100)) < 0);
    assertTrue(Comparators.INTERFACES_COMPARATOR.compare(intface("of:0000000000000001", 2), intface("of:0000000000000002", 2)) < 0);
}
#method_after
@Test
public void testInterfaceComparator() {
    assertEquals(0, INTERFACES_COMPARATOR.compare(intface("of:0000000000000001", 100), intface("of:0000000000000001", 100)));
    assertTrue(INTERFACES_COMPARATOR.compare(intface("of:0000000000000001", 2), intface("of:0000000000000001", 100)) < 0);
    assertTrue(INTERFACES_COMPARATOR.compare(intface("of:0000000000000001", 2), intface("of:0000000000000002", 2)) < 0);
}
#end_block

#method_before
@Test
public void testDeviceKeyComparator() {
    assertEquals(0, Comparators.DEVICE_KEY_COMPARATOR.compare(testDK("ID1", "label", "name"), testDK("ID1", "label", "name")));
    assertEquals(0, Comparators.DEVICE_KEY_COMPARATOR.compare(testDK("ID2", "label", "name"), testDK("ID2", "label", "name")));
    assertNotEquals(0, Comparators.DEVICE_KEY_COMPARATOR.compare(testDK("ID1", "label", "name"), testDK("ID2", "label", "name")));
}
#method_after
@Test
public void testDeviceKeyComparator() {
    assertEquals(0, DEVICE_KEY_COMPARATOR.compare(testDK("ID1", "label", "name"), testDK("ID1", "label", "name")));
    assertEquals(0, DEVICE_KEY_COMPARATOR.compare(testDK("ID2", "label", "name"), testDK("ID2", "label", "name")));
    assertNotEquals(0, DEVICE_KEY_COMPARATOR.compare(testDK("ID1", "label", "name"), testDK("ID2", "label", "name")));
}
#end_block

#method_before
@Test
public void testRegionComparator() {
    assertEquals(0, Comparators.REGION_COMPARATOR.compare(region("id1"), region("id1")));
    assertNotEquals(0, Comparators.REGION_COMPARATOR.compare(region("id1"), region("id2")));
}
#method_after
@Test
public void testRegionComparator() {
    assertEquals(0, REGION_COMPARATOR.compare(region("id1"), region("id1")));
    assertNotEquals(0, REGION_COMPARATOR.compare(region("id1"), region("id2")));
}
#end_block

#method_before
@Test
public void testTopographicLayoutComparator() {
    assertEquals(0, Comparators.LAYOUT_COMPARATOR.compare(layout("test"), layout("test")));
    assertNotEquals(0, Comparators.LAYOUT_COMPARATOR.compare(layout("same"), layout("different")));
}
#method_after
@Test
public void testTopographicLayoutComparator() {
    assertEquals(0, LAYOUT_COMPARATOR.compare(layout("test"), layout("test")));
    assertNotEquals(0, LAYOUT_COMPARATOR.compare(layout("same"), layout("different")));
}
#end_block

#method_before
@Test
public void testTenantIdComparator() {
    assertEquals(0, Comparators.TENANT_ID_COMPARATOR.compare(id("1"), id("1")));
    assertEquals(0, Comparators.TENANT_ID_COMPARATOR.compare(id("tenant1"), id("tenant1")));
    assertNotEquals(0, Comparators.TENANT_ID_COMPARATOR.compare(id("tenant1"), id("tenant2")));
    assertTrue(Comparators.TENANT_ID_COMPARATOR.compare(id("1"), id("9")) < 0);
    assertTrue(Comparators.TENANT_ID_COMPARATOR.compare(id("Tenant5"), id("Tenant0")) > 0);
}
#method_after
@Test
public void testTenantIdComparator() {
    assertEquals(0, TENANT_ID_COMPARATOR.compare(id("1"), id("1")));
    assertEquals(0, TENANT_ID_COMPARATOR.compare(id("tenant1"), id("tenant1")));
    assertNotEquals(0, TENANT_ID_COMPARATOR.compare(id("tenant1"), id("tenant2")));
    assertTrue(TENANT_ID_COMPARATOR.compare(id("1"), id("9")) < 0);
    assertTrue(TENANT_ID_COMPARATOR.compare(id("Tenant5"), id("Tenant0")) > 0);
}
#end_block

#method_before
@Test
public void testVirtualNetworkComparator() {
    assertEquals(0, Comparators.VIRTUAL_NETWORK_COMPARATOR.compare(network(10, "tenantID"), network(10, "tenantID1")));
    assertNotEquals(0, Comparators.VIRTUAL_NETWORK_COMPARATOR.compare(network(10, "tenantID"), network(15, "tenantID1")));
    assertNotEquals(0, Comparators.VIRTUAL_NETWORK_COMPARATOR.compare(network(15, "tenantID1"), network(10, "tenantID1")));
    assertNotEquals(0, Comparators.VIRTUAL_NETWORK_COMPARATOR.compare(network(15, "tenantID"), network(10, "tenantID1")));
}
#method_after
@Test
public void testVirtualNetworkComparator() {
    assertNotEquals(0, VIRTUAL_NETWORK_COMPARATOR.compare(network(10, "tenantID"), network(10, "tenantID1")));
    assertNotEquals(0, VIRTUAL_NETWORK_COMPARATOR.compare(network(10, "tenantID"), network(15, "tenantID1")));
    assertEquals(0, VIRTUAL_NETWORK_COMPARATOR.compare(network(15, "tenantID1"), network(10, "tenantID1")));
    assertNotEquals(0, VIRTUAL_NETWORK_COMPARATOR.compare(network(15, "tenantID"), network(10, "tenantID1")));
}
#end_block

#method_before
@Test
public void testVirtualDeviceComparator() {
    assertEquals(0, Comparators.VIRTUAL_DEVICE_COMPARATOR.compare(VD(0, "of:foo"), VD(0, "of:foo")));
    assertEquals(0, Comparators.VIRTUAL_DEVICE_COMPARATOR.compare(VD(3, "of:foo"), VD(0, "of:foo")));
    assertNotEquals(0, Comparators.VIRTUAL_DEVICE_COMPARATOR.compare(VD(0, "of:bar"), VD(0, "of:foo")));
    assertNotEquals(0, Comparators.VIRTUAL_DEVICE_COMPARATOR.compare(VD(3, "of:bar"), VD(0, "of:foo")));
}
#method_after
@Test
public void testVirtualDeviceComparator() {
    assertEquals(0, VIRTUAL_DEVICE_COMPARATOR.compare(VD(0, "of:foo"), VD(0, "of:foo")));
    assertEquals(0, VIRTUAL_DEVICE_COMPARATOR.compare(VD(3, "of:foo"), VD(0, "of:foo")));
    assertNotEquals(0, VIRTUAL_DEVICE_COMPARATOR.compare(VD(0, "of:bar"), VD(0, "of:foo")));
    assertNotEquals(0, VIRTUAL_DEVICE_COMPARATOR.compare(VD(3, "of:bar"), VD(0, "of:foo")));
}
#end_block

#method_before
@Test
public void testVirtualPortComparator() {
    assertEquals(0, Comparators.VIRTUAL_PORT_COMPARATOR.compare(vPort(2), vPort(2)));
    assertEquals(4, Comparators.VIRTUAL_PORT_COMPARATOR.compare(vPort(900), vPort(5)));
    assertEquals(-8, Comparators.VIRTUAL_PORT_COMPARATOR.compare(vPort(0), vPort(8)));
}
#method_after
@Test
public void testVirtualPortComparator() {
    assertEquals(0, VIRTUAL_PORT_COMPARATOR.compare(vPort(2), vPort(2)));
    assertEquals(4, VIRTUAL_PORT_COMPARATOR.compare(vPort(900), vPort(5)));
    assertEquals(-8, VIRTUAL_PORT_COMPARATOR.compare(vPort(0), vPort(8)));
}
#end_block

#method_before
private VirtualPort vPort(int portNumber) {
    return new DefaultVirtualPort(NetworkId.networkId(20), new DefaultDevice(PID, DID1, null, MFR, HW, SW, SN1, CID), PortNumber.portNumber(portNumber), new ConnectPoint(DID1, PortNumber.portNumber(900)));
}
#method_after
private VirtualPort vPort(int portNumber) {
    return new DefaultVirtualPort(NetworkId.networkId(20), new DefaultDevice(PID, DID, null, MFR, HW, SW, SN, CID), PortNumber.portNumber(portNumber), new ConnectPoint(DID, PortNumber.portNumber(900)));
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/{key}/installables")
public Response getIntentWithInstallable(@PathParam("appId") String appId, @PathParam("key") String key) {
    final IntentService intentService = get(IntentService.class);
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = intentService.getIntent(Key.of(key, app));
    if (intent == null) {
        long numericalKey = Long.decode(key);
        intent = get(IntentService.class).getIntent(Key.of(numericalKey, app));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    final Iterable<Intent> installables = intentService.getInstallableIntents(intent.key());
    final ObjectNode root = encodeArray(Intent.class, "installables", installables);
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("installables/{appId}/{key}")
public Response getIntentWithInstallable(@PathParam("appId") String appId, @PathParam("key") String key) {
    final IntentService intentService = get(IntentService.class);
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    nullIsNotFound(app, APP_ID_NOT_FOUND);
    Intent intent = intentService.getIntent(Key.of(key, app));
    if (intent == null) {
        long numericalKey = Long.decode(key);
        intent = intentService.getIntent(Key.of(numericalKey, app));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    final Iterable<Intent> installables = intentService.getInstallableIntents(intent.key());
    final ObjectNode root = encodeArray(Intent.class, "installables", installables);
    return ok(root).build();
}
#end_block

#method_before
@Override
public void processSetConfigMessage(Channel channel, OFMessage msg) {
    if (msg.getType() != OFType.SET_CONFIG) {
        log.warn("Ignoring message of type {}.", msg.getType());
        return;
    }
    OFSetConfig ofSetConfig = (OFSetConfig) msg;
    if (missSendLen != ofSetConfig.getMissSendLen()) {
        log.trace("Changing missSendLen from {} to {}.", missSendLen, ofSetConfig.getMissSendLen());
        missSendLen = ofSetConfig.getMissSendLen();
    }
// SetConfig message is not acknowledged
}
#method_after
@Override
public void processSetConfigMessage(Channel channel, OFMessage msg) {
    OFSetConfig ofSetConfig = (OFSetConfig) msg;
    if (missSendLen != ofSetConfig.getMissSendLen()) {
        log.trace("Changing missSendLen from {} to {}.", missSendLen, ofSetConfig.getMissSendLen());
        missSendLen = ofSetConfig.getMissSendLen();
    }
// SetConfig message is not acknowledged
}
#end_block

#method_before
private void createStatsCollection(OpenFlowSwitch sw) {
    if (sw != null && isMeterSupported(sw)) {
        MeterStatsCollector msc = new MeterStatsCollector(sw, POLL_INTERVAL);
        msc.start();
        stopCollectorIfNeeded(collectors.put(new Dpid(sw.getId()), msc));
    }
}
#method_after
private void createStatsCollection(OpenFlowSwitch sw) {
    if (sw != null && isMeterSupported(sw)) {
        MeterStatsCollector msc = new MeterStatsCollector(sw, POLL_INTERVAL);
        stopCollectorIfNeeded(collectors.put(new Dpid(sw.getId()), msc));
        msc.start();
    }
}
#end_block

#method_before
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    print(FORMAT_MAPPING, srService.getNeighborSet());
}
#method_after
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    printNeighborSet(srService.getNeighborSet());
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("Neighborset Sw", neighbors).add("Label", edgeLabel).add("MplsSet", mplsSet).add("DstSw", dstSw).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("Neighbors", neighbors).add("Label", edgeLabel).add("MplsSet", mplsSet).add("DstSw", dstSw).toString();
}
#end_block

#method_before
@Override
public String getCurrentEcmpSpg() {
    if (defaultRoutingHandler != null) {
        return defaultRoutingHandler.getCurrentEmcpSpgMap();
    } else {
        return "No ECMP SPG found";
    }
}
#method_after
@Override
public ImmutableMap<DeviceId, EcmpShortestPathGraph> getCurrentEcmpSpg() {
    if (defaultRoutingHandler != null) {
        return defaultRoutingHandler.getCurrentEmcpSpgMap();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public String getNeighborSet() {
    if (nsNextObjStore != null) {
        StringBuilder ns = new StringBuilder();
        nsNextObjStore.entrySet().forEach(entry -> {
            ns.append("\n " + entry.getKey());
            ns.append(" --> NextId: " + entry.getValue());
        });
        return ns.toString();
    } else {
        return "NeighborSet store not found";
    }
}
#method_after
@Override
public ImmutableMap<NeighborSetNextObjectiveStoreKey, Integer> getNeighborSet() {
    if (nsNextObjStore != null) {
        return ImmutableMap.copyOf(nsNextObjStore.entrySet());
    } else {
        return ImmutableMap.of();
    }
}
#end_block

#method_before
public Boolean isSeenLinkUp(Link link) {
    if (!seenLinks.containsKey(link)) {
        return null;
    }
    return seenLinks.get(link);
}
#method_after
public Boolean isSeenLinkUp(Link link) {
    return seenLinks.get(link);
}
#end_block

#method_before
private void processLinkAdded(Link link) {
    log.info("** LINK ADDED {}", link.toString());
    if (!deviceConfiguration.isConfigured(link.src().deviceId())) {
        log.warn("Source device of this link is not configured.");
        return;
    }
    if (link.type() != Link.Type.DIRECT) {
        // NOTE: A DIRECT link might be transiently marked as INDIRECT
        // if BDDP is received before LLDP. We can safely ignore that
        // until the LLDP is received and the link is marked as DIRECT.
        log.info("Ignore link {}->{}. Link type is {} instead of DIRECT.", link.src(), link.dst(), link.type());
        return;
    }
    // Irrespective of whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules if needed,
    // as in a multi-instance setup, instances can initiate groups for any device.
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portUpForLink(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.portUpForLink(link);
        }
    }
    log.trace("Starting optimized route population process");
    boolean seenBefore = isSeenLink(link);
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, link, null);
    if (mastershipService.isLocalMaster(link.src().deviceId())) {
        if (!seenBefore) {
            // if link seen first time, we need to ensure hash-groups have all ports
            groupHandler.retryHash(link, false, true);
        } else {
            // seen before-link
            if (isCurrentParallelLink(link)) {
                groupHandler.retryHash(link, false, false);
            }
        }
    }
    mcastHandler.init();
}
#method_after
private void processLinkAdded(Link link) {
    log.info("** LINK ADDED {}", link.toString());
    if (!deviceConfiguration.isConfigured(link.src().deviceId())) {
        log.warn("Source device of this link is not configured.");
        return;
    }
    if (link.type() != Link.Type.DIRECT) {
        // NOTE: A DIRECT link might be transiently marked as INDIRECT
        // if BDDP is received before LLDP. We can safely ignore that
        // until the LLDP is received and the link is marked as DIRECT.
        log.info("Ignore link {}->{}. Link type is {} instead of DIRECT.", link.src(), link.dst(), link.type());
        return;
    }
    // Irrespective of whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules if needed,
    // as in a multi-instance setup, instances can initiate groups for any device.
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portUpForLink(link);
    } else {
        Device device = deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added " + "Notification without Device Added " + "event, still handling it");
            processDeviceAdded(device);
            groupHandler = groupHandlerMap.get(link.src().deviceId());
            groupHandler.portUpForLink(link);
        }
    }
    log.trace("Starting optimized route population process");
    boolean seenBefore = isSeenLink(link);
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, link, null);
    if (mastershipService.isLocalMaster(link.src().deviceId())) {
        if (!seenBefore) {
            // if link seen first time, we need to ensure hash-groups have all ports
            groupHandler.retryHash(link, false, true);
        } else {
            // seen before-link
            if (isParallelLink(link)) {
                groupHandler.retryHash(link, false, false);
            }
        }
    }
    mcastHandler.init();
}
#end_block

#method_before
private void processLinkRemoved(Link link) {
    log.info("** LINK REMOVED {}", link.toString());
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link, null, null);
    // update local groupHandler stores
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        if (mastershipService.isLocalMaster(link.src().deviceId()) && isCurrentParallelLink(link)) {
            groupHandler.retryHash(link, true, false);
        }
        // ensure local stores are updated
        groupHandler.portDown(link.src().port());
    } else {
        log.warn("group handler not found for dev:{} when removing link: {}", link.src().deviceId(), link);
    }
    mcastHandler.processLinkDown(link);
}
#method_after
private void processLinkRemoved(Link link) {
    log.info("** LINK REMOVED {}", link.toString());
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link, null, null);
    // update local groupHandler stores
    DefaultGroupHandler groupHandler = groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        if (mastershipService.isLocalMaster(link.src().deviceId()) && isParallelLink(link)) {
            groupHandler.retryHash(link, true, false);
        }
        // ensure local stores are updated
        groupHandler.portDown(link.src().port());
    } else {
        log.warn("group handler not found for dev:{} when removing link: {}", link.src().deviceId(), link);
    }
    mcastHandler.processLinkDown(link);
}
#end_block

#method_before
public boolean fixHashGroups(DeviceId targetSw, Set<DeviceId> nextHops, DeviceId destSw, boolean depopulate) {
    // temporary storage of keys to be updated
    Map<NeighborSetNextObjectiveStoreKey, Set<DeviceId>> tempStore = new HashMap<>();
    boolean foundNextObjective = false;
    // with different neighbors than the given next-hops
    for (NeighborSetNextObjectiveStoreKey nskey : nsNextObjStore.keySet()) {
        if (!nskey.deviceId().equals(targetSw) || !nskey.neighborSet().getDestinationSw().equals(destSw)) {
            continue;
        }
        foundNextObjective = true;
        Set<DeviceId> currNeighbors = nskey.neighborSet().getDeviceIds();
        Integer nextId = nsNextObjStore.get(nskey);
        Set<DeviceId> diff;
        if (depopulate) {
            diff = Sets.difference(currNeighbors, nextHops);
            log.debug("targetSw:{} -> dstSw:{} in nextId:{} has current next " + "hops:{} ..removing {}", targetSw, destSw, nextId, currNeighbors, diff);
        } else {
            diff = Sets.difference(nextHops, currNeighbors);
            log.debug("targetSw:{} -> dstSw:{} in nextId:{} has current next " + "hops:{} ..adding {}", targetSw, destSw, nextId, currNeighbors, diff);
        }
        for (DeviceId neighbor : diff) {
            MacAddress dstMac;
            try {
                dstMac = deviceConfig.getDeviceMac(neighbor);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting fixHashGroup for nextId:" + nskey);
                return false;
            }
            if (devicePortMap.get(neighbor) == null || devicePortMap.get(neighbor).isEmpty()) {
                log.warn("No ports found in dev:{} for neighbor:{} .. cannot " + "fix hash group for nextId: {}", deviceId, neighbor, nextId);
                return false;
            }
            if (depopulate) {
                for (PortNumber port : devicePortMap.get(neighbor)) {
                    log.info("fixHashGroup in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
                    removeFromHashedNextObjective(port, dstMac, nskey.neighborSet(), nextId);
                }
                // to update neighbor set with changes made
                tempStore.put(nskey, Sets.difference(currNeighbors, diff));
            } else {
                for (PortNumber port : devicePortMap.get(neighbor)) {
                    log.info("fixHashGroup in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
                    addToHashedNextObjective(port, dstMac, nskey.neighborSet(), nextId, false);
                }
                // to update neighbor set with changes made
                tempStore.put(nskey, Sets.union(currNeighbors, diff));
            }
        }
    }
    if (!foundNextObjective) {
        log.debug("Cannot find any nextObjectives for route targetSw:{} " + "-> dstSw:{}", targetSw, destSw);
        // nothing to do, return true so ECMPspg is updated
        return true;
    }
    // update the nsNextObjectiveStore with new neighborSets to nextId mappings
    for (NeighborSetNextObjectiveStoreKey oldkey : tempStore.keySet()) {
        Integer nextId = nsNextObjStore.get(oldkey);
        if (nextId == null) {
            continue;
        }
        Set<DeviceId> newNeighbors = tempStore.get(oldkey);
        NeighborSet newNs = new NeighborSet(newNeighbors, oldkey.neighborSet().mplsSet(), oldkey.neighborSet().getEdgeLabel(), oldkey.neighborSet().getDestinationSw());
        NeighborSetNextObjectiveStoreKey newkey = new NeighborSetNextObjectiveStoreKey(deviceId, newNs);
        log.debug("Updating nsNextObjStore: oldKey:{} -> newKey:{} :: nextId:{}", oldkey, newkey, nextId);
        synchronized (nsNextObjStore) {
            nsNextObjStore.remove(oldkey);
            nsNextObjStore.put(newkey, nextId);
        }
    }
    return true;
}
#method_after
public boolean fixHashGroups(DeviceId targetSw, Set<DeviceId> nextHops, DeviceId destSw, boolean revoke) {
    // temporary storage of keys to be updated
    Map<NeighborSetNextObjectiveStoreKey, Set<DeviceId>> tempStore = new HashMap<>();
    boolean foundNextObjective = false;
    // with different neighbors than the given next-hops
    for (NeighborSetNextObjectiveStoreKey nskey : nsNextObjStore.keySet()) {
        if (!nskey.deviceId().equals(targetSw) || !nskey.neighborSet().getDestinationSw().equals(destSw)) {
            continue;
        }
        foundNextObjective = true;
        Set<DeviceId> currNeighbors = nskey.neighborSet().getDeviceIds();
        Integer nextId = nsNextObjStore.get(nskey);
        Set<DeviceId> diff;
        if (revoke) {
            diff = Sets.difference(currNeighbors, nextHops);
            log.debug("targetSw:{} -> dstSw:{} in nextId:{} has current next " + "hops:{} ..removing {}", targetSw, destSw, nextId, currNeighbors, diff);
        } else {
            diff = Sets.difference(nextHops, currNeighbors);
            log.debug("targetSw:{} -> dstSw:{} in nextId:{} has current next " + "hops:{} ..adding {}", targetSw, destSw, nextId, currNeighbors, diff);
        }
        for (DeviceId neighbor : diff) {
            MacAddress dstMac;
            try {
                dstMac = deviceConfig.getDeviceMac(neighbor);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting fixHashGroup for nextId:" + nskey);
                return false;
            }
            if (devicePortMap.get(neighbor) == null || devicePortMap.get(neighbor).isEmpty()) {
                log.warn("No ports found in dev:{} for neighbor:{} .. cannot " + "fix hash group for nextId: {}", deviceId, neighbor, nextId);
                return false;
            }
            if (revoke) {
                for (PortNumber port : devicePortMap.get(neighbor)) {
                    log.info("fixHashGroup in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
                    removeFromHashedNextObjective(port, dstMac, nskey.neighborSet(), nextId);
                }
                // to update neighbor set with changes made
                tempStore.put(nskey, Sets.difference(currNeighbors, diff));
            } else {
                for (PortNumber port : devicePortMap.get(neighbor)) {
                    log.info("fixHashGroup in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
                    addToHashedNextObjective(port, dstMac, nskey.neighborSet(), nextId, false);
                }
                // to update neighbor set with changes made
                tempStore.put(nskey, Sets.union(currNeighbors, diff));
            }
        }
    }
    if (!foundNextObjective) {
        log.debug("Cannot find any nextObjectives for route targetSw:{} " + "-> dstSw:{}", targetSw, destSw);
        // nothing to do, return true so ECMPspg is updated
        return true;
    }
    // update the nsNextObjectiveStore with new neighborSets to nextId mappings
    for (NeighborSetNextObjectiveStoreKey oldkey : tempStore.keySet()) {
        Integer nextId = nsNextObjStore.get(oldkey);
        if (nextId == null) {
            continue;
        }
        Set<DeviceId> newNeighbors = tempStore.get(oldkey);
        NeighborSet newNs = new NeighborSet(newNeighbors, oldkey.neighborSet().mplsSet(), oldkey.neighborSet().getEdgeLabel(), oldkey.neighborSet().getDestinationSw());
        NeighborSetNextObjectiveStoreKey newkey = new NeighborSetNextObjectiveStoreKey(deviceId, newNs);
        log.debug("Updating nsNextObjStore: oldKey:{} -> newKey:{} :: nextId:{}", oldkey, newkey, nextId);
        synchronized (nsNextObjStore) {
            nsNextObjStore.remove(oldkey);
            nsNextObjStore.put(newkey, nextId);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    print(FORMAT_MAPPING, srService.getCurrentEcmpSpg());
}
#method_after
@Override
protected void execute() {
    SegmentRoutingService srService = AbstractShellCommand.get(SegmentRoutingService.class);
    printEcmpGraph(srService.getCurrentEcmpSpg());
}
#end_block

#method_before
protected void removeBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED && nextObjective.type() != NextObjective.Type.BROADCAST) {
        log.warn("RemoveBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    Set<PortNumber> portsToRemove = Sets.newHashSet();
    Collection<TrafficTreatment> treatments = nextObjective.next();
    for (TrafficTreatment treatment : treatments) {
        // find the bucket to remove by noting the outport, and figuring out the
        // top-level group in the group-chain that indirectly references the port
        PortNumber portToRemove = readOutPortFromTreatment(treatment);
        if (portToRemove == null) {
            log.warn("treatment {} of next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", treatment, nextObjective.id(), deviceId);
        } else {
            portsToRemove.add(portToRemove);
        }
    }
    if (portsToRemove.isEmpty()) {
        log.warn("next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", nextObjective.id(), deviceId);
        fail(nextObjective, ObjectiveError.BADPARAMS);
    }
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // last group in group chain should have a single bucket pointing to port
        GroupKey groupWithPort = gkeys.peekLast();
        Group group = groupService.getGroup(deviceId, groupWithPort);
        if (group == null) {
            log.warn("Inconsistent group chain found when removing bucket" + "for next:{} in dev:{}", nextObjective.id(), deviceId);
            continue;
        }
        if (group.buckets().buckets().isEmpty()) {
            log.warn("Can't get output port information from group {} " + "because there is no bucket in the group.", group.id().toString());
            continue;
        }
        PortNumber pout = readOutPortFromTreatment(group.buckets().buckets().get(0).treatment());
        if (portsToRemove.contains(pout)) {
            chainsToRemove.add(gkeys);
        }
    }
    if (chainsToRemove.isEmpty()) {
        log.warn("Could not find appropriate group-chain for removing bucket" + " for next id {} in dev:{}", nextObjective.id(), deviceId);
        fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    List<GroupBucket> bucketsToRemove = Lists.newArrayList();
    // first group key is the one we want to modify
    GroupKey modGroupKey = chainsToRemove.get(0).peekFirst();
    Group modGroup = groupService.getGroup(deviceId, modGroupKey);
    for (Deque<GroupKey> foundChain : chainsToRemove) {
        // second group key is the one we wish to remove the reference to
        if (foundChain.size() < 2) {
            // additional check to make sure second group key exist in
            // the chain.
            log.warn("Can't find second group key from chain {}", foundChain);
            continue;
        }
        GroupKey pointedGroupKey = foundChain.stream().collect(Collectors.toList()).get(1);
        Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
        if (pointedGroup == null) {
            continue;
        }
        GroupBucket bucket;
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        } else {
            bucket = DefaultGroupBucket.createAllGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        }
        bucketsToRemove.add(bucket);
    }
    GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
    // for debug log
    List<String> pointedGroupIds;
    pointedGroupIds = bucketsToRemove.stream().map(GroupBucket::treatment).map(TrafficTreatment::allInstructions).flatMap(List::stream).filter(inst -> inst instanceof Instructions.GroupInstruction).map(inst -> (Instructions.GroupInstruction) inst).map(Instructions.GroupInstruction::groupId).map(GroupId::id).map(Integer::toHexString).map(id -> HEX_PREFIX + id).collect(Collectors.toList());
    log.debug("Removing buckets from group id 0x{} pointing to group id(s) {} " + "for next id {} in device {}", Integer.toHexString(modGroup.id().id()), pointedGroupIds, nextObjective.id(), deviceId);
    addPendingUpdateNextObjective(modGroupKey, nextObjective);
    groupService.removeBucketsFromGroup(deviceId, modGroupKey, removeBuckets, modGroupKey, nextObjective.appId());
    // update store - synchronize access
    synchronized (flowObjectiveStore) {
        // get fresh copy of what the store holds
        next = flowObjectiveStore.getNextGroup(nextObjective.id());
        allActiveKeys = appKryo.deserialize(next.data());
        // So we have to check one by one
        for (Deque<GroupKey> chain : chainsToRemove) {
            int index = 0;
            for (Deque<GroupKey> active : allActiveKeys) {
                if (chain.peekLast().equals(active.peekLast())) {
                    break;
                }
                index++;
            }
            if (index < allActiveKeys.size()) {
                allActiveKeys.remove(index);
            }
        }
        // top level group which still exists.
        if (allActiveKeys.isEmpty()) {
            ArrayDeque<GroupKey> top = new ArrayDeque<>();
            top.add(modGroupKey);
            allActiveKeys.add(top);
        }
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allActiveKeys, nextObjective));
    }
}
#method_after
protected void removeBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED && nextObjective.type() != NextObjective.Type.BROADCAST) {
        log.warn("RemoveBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    Set<PortNumber> portsToRemove = Sets.newHashSet();
    Collection<TrafficTreatment> treatments = nextObjective.next();
    for (TrafficTreatment treatment : treatments) {
        // find the bucket to remove by noting the outport, and figuring out the
        // top-level group in the group-chain that indirectly references the port
        PortNumber portToRemove = readOutPortFromTreatment(treatment);
        if (portToRemove == null) {
            log.warn("treatment {} of next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", treatment, nextObjective.id(), deviceId);
        } else {
            portsToRemove.add(portToRemove);
        }
    }
    if (portsToRemove.isEmpty()) {
        log.warn("next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", nextObjective.id(), deviceId);
        fail(nextObjective, ObjectiveError.BADPARAMS);
    }
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // last group in group chain should have a single bucket pointing to port
        GroupKey groupWithPort = gkeys.peekLast();
        Group group = groupService.getGroup(deviceId, groupWithPort);
        if (group == null) {
            log.warn("Inconsistent group chain found when removing bucket" + "for next:{} in dev:{}", nextObjective.id(), deviceId);
            continue;
        }
        if (group.buckets().buckets().isEmpty()) {
            log.warn("Can't get output port information from group {} " + "because there is no bucket in the group.", group.id().toString());
            continue;
        }
        PortNumber pout = readOutPortFromTreatment(group.buckets().buckets().get(0).treatment());
        if (portsToRemove.contains(pout)) {
            chainsToRemove.add(gkeys);
        }
    }
    if (chainsToRemove.isEmpty()) {
        log.warn("Could not find appropriate group-chain for removing bucket" + " for next id {} in dev:{}", nextObjective.id(), deviceId);
        fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    List<GroupBucket> bucketsToRemove = Lists.newArrayList();
    // first group key is the one we want to modify
    GroupKey modGroupKey = chainsToRemove.get(0).peekFirst();
    Group modGroup = groupService.getGroup(deviceId, modGroupKey);
    for (Deque<GroupKey> foundChain : chainsToRemove) {
        // second group key is the one we wish to remove the reference to
        if (foundChain.size() < 2) {
            // additional check to make sure second group key exist in
            // the chain.
            log.warn("Can't find second group key from chain {}", foundChain);
            continue;
        }
        GroupKey pointedGroupKey = foundChain.stream().collect(Collectors.toList()).get(1);
        Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
        if (pointedGroup == null) {
            continue;
        }
        GroupBucket bucket;
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        } else {
            bucket = DefaultGroupBucket.createAllGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        }
        bucketsToRemove.add(bucket);
    }
    GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
    // for debug log
    List<String> pointedGroupIds;
    pointedGroupIds = bucketsToRemove.stream().map(GroupBucket::treatment).map(TrafficTreatment::allInstructions).flatMap(List::stream).filter(inst -> inst instanceof Instructions.GroupInstruction).map(inst -> (Instructions.GroupInstruction) inst).map(Instructions.GroupInstruction::groupId).map(GroupId::id).map(Integer::toHexString).map(id -> HEX_PREFIX + id).collect(Collectors.toList());
    log.debug("Removing buckets from group id 0x{} pointing to group id(s) {} " + "for next id {} in device {}", Integer.toHexString(modGroup.id().id()), pointedGroupIds, nextObjective.id(), deviceId);
    addPendingUpdateNextObjective(modGroupKey, nextObjective);
    groupService.removeBucketsFromGroup(deviceId, modGroupKey, removeBuckets, modGroupKey, nextObjective.appId());
    // update store - synchronize access
    synchronized (flowObjectiveStore) {
        // get fresh copy of what the store holds
        next = flowObjectiveStore.getNextGroup(nextObjective.id());
        allActiveKeys = appKryo.deserialize(next.data());
        // Note that since we got a new object, and ArrayDeque does not implement
        // Object.equals(), we have to check the deque last elems one by one
        allActiveKeys.removeIf(active -> chainsToRemove.stream().anyMatch(remove -> remove.peekLast().equals(active.peekLast())));
        // top level group which still exists.
        if (allActiveKeys.isEmpty()) {
            ArrayDeque<GroupKey> top = new ArrayDeque<>();
            top.add(modGroupKey);
            allActiveKeys.add(top);
        }
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allActiveKeys, nextObjective));
    }
}
#end_block

#method_before
public String getCurrentEmcpSpgMap() {
    StringBuilder ecmp = new StringBuilder();
    currentEcmpSpgMap.forEach((key, value) -> {
        ecmp.append("\nRoot Device: " + key + " ECMP Paths: " + value);
    });
    return ecmp.toString();
}
#method_after
public ImmutableMap<DeviceId, EcmpShortestPathGraph> getCurrentEmcpSpgMap() {
    Builder<DeviceId, EcmpShortestPathGraph> builder = ImmutableMap.builder();
    currentEcmpSpgMap.entrySet().forEach(entry -> {
        if (entry.getValue() != null) {
            builder.put(entry.getKey(), entry.getValue());
        }
    });
    return builder.build();
}
#end_block

#method_before
public void populateRoutingRulesForLinkStatusChange(Link linkDown, Link linkUp, DeviceId switchDown) {
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished.");
            return;
        }
        // Take the snapshots of the links
        updatedEcmpSpgMap = new HashMap<>();
        for (Device sw : srManager.deviceService.getDevices()) {
            if (!srManager.mastershipService.isLocalMaster(sw.id())) {
                continue;
            }
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(sw.id(), srManager);
            updatedEcmpSpgMap.put(sw.id(), ecmpSpgUpdated);
        }
        log.info("Starts rule population from link change");
        Set<ArrayList<DeviceId>> routeChanges;
        log.debug("populateRoutingRulesForLinkStatusChange: " + "populationStatus is STARTED");
        populationStatus = Status.STARTED;
        // try optimized re-routing
        if (linkDown == null) {
            // either a linkUp or a switchDown - compute all route changes by
            // comparing all routes of existing ECMP SPG to new ECMP SPG
            routeChanges = computeRouteChange();
            if (routeChanges != null) {
                // deal with linkUp of a seen-before link
                if (linkUp != null && srManager.isSeenLink(linkUp)) {
                    if (!bidiLink(linkUp)) {
                        log.warn("Not a bidirectional link yet .. not " + "processing link {}", linkUp);
                        srManager.updateSeenLink(linkUp, true);
                        populationStatus = Status.ABORTED;
                        return;
                    }
                    // link previously seen before
                    // do hash-bucket changes instead of a re-route
                    processHashGroupChange(routeChanges, false, null);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
                // deal with switchDown
                if (switchDown != null) {
                    processHashGroupChange(routeChanges, true, switchDown);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
            // for a linkUp of a never-seen-before link
            // let it fall through to a reroute of the routeChanges
            }
            // it is safe to update the store for the linkUp
            if (linkUp != null) {
                srManager.updateSeenLink(linkUp, true);
            }
        } else {
            // link has gone down
            // Compare existing ECMP SPG only with the link that went down
            routeChanges = computeDamagedRoutes(linkDown);
            if (routeChanges != null) {
                processHashGroupChange(routeChanges, true, null);
                // clear out routesChanges so a re-route is not attempted
                routeChanges = ImmutableSet.of();
            }
        }
        // do full re-routing if optimized routing returns null routeChanges
        if (routeChanges == null) {
            log.info("Optimized routing failed... doing full re-route");
            populateAllRoutingRules();
            return;
        }
        if (routeChanges.isEmpty()) {
            log.info("No re-route attempted for the link status change");
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            return;
        }
        // reroute of routeChanges
        if (repopulateRoutingRulesForRoutes(routeChanges)) {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            log.info("Completed repopulation of rules. # of rules populated : {}", rulePopulator.getCounter());
            return;
        } else {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules.");
            return;
        }
    } finally {
        statusLock.unlock();
    }
}
#method_after
public void populateRoutingRulesForLinkStatusChange(Link linkDown, Link linkUp, DeviceId switchDown) {
    if ((linkDown != null && (linkUp != null || switchDown != null)) || (linkUp != null && (linkDown != null || switchDown != null)) || (switchDown != null && (linkUp != null || linkDown != null))) {
        log.warn("Only one event can be handled for link status change .. aborting");
        return;
    }
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished.");
            return;
        }
        // Take the snapshots of the links
        updatedEcmpSpgMap = new HashMap<>();
        for (Device sw : srManager.deviceService.getDevices()) {
            if (!srManager.mastershipService.isLocalMaster(sw.id())) {
                continue;
            }
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(sw.id(), srManager);
            updatedEcmpSpgMap.put(sw.id(), ecmpSpgUpdated);
        }
        log.info("Starts rule population from link change");
        Set<ArrayList<DeviceId>> routeChanges;
        log.debug("populateRoutingRulesForLinkStatusChange: " + "populationStatus is STARTED");
        populationStatus = Status.STARTED;
        // try optimized re-routing
        if (linkDown == null) {
            // either a linkUp or a switchDown - compute all route changes by
            // comparing all routes of existing ECMP SPG to new ECMP SPG
            routeChanges = computeRouteChange();
            if (routeChanges != null) {
                // deal with linkUp of a seen-before link
                if (linkUp != null && srManager.isSeenLink(linkUp)) {
                    if (!isBidirectional(linkUp)) {
                        log.warn("Not a bidirectional link yet .. not " + "processing link {}", linkUp);
                        srManager.updateSeenLink(linkUp, true);
                        populationStatus = Status.ABORTED;
                        return;
                    }
                    // link previously seen before
                    // do hash-bucket changes instead of a re-route
                    processHashGroupChange(routeChanges, false, null);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
                // deal with switchDown
                if (switchDown != null) {
                    processHashGroupChange(routeChanges, true, switchDown);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
            // for a linkUp of a never-seen-before link
            // let it fall through to a reroute of the routeChanges
            }
            // it is safe to update the store for the linkUp
            if (linkUp != null) {
                srManager.updateSeenLink(linkUp, true);
            }
        } else {
            // link has gone down
            // Compare existing ECMP SPG only with the link that went down
            routeChanges = computeDamagedRoutes(linkDown);
            if (routeChanges != null) {
                processHashGroupChange(routeChanges, true, null);
                // clear out routesChanges so a re-route is not attempted
                routeChanges = ImmutableSet.of();
            }
        }
        // do full re-routing if optimized routing returns null routeChanges
        if (routeChanges == null) {
            log.info("Optimized routing failed... doing full re-route");
            populateAllRoutingRules();
            return;
        }
        if (routeChanges.isEmpty()) {
            log.info("No re-route attempted for the link status change");
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            return;
        }
        // reroute of routeChanges
        if (repopulateRoutingRulesForRoutes(routeChanges)) {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            log.info("Completed repopulation of rules. # of rules populated : {}", rulePopulator.getCounter());
            return;
        } else {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules.");
            return;
        }
    } finally {
        statusLock.unlock();
    }
}
#end_block

#method_before
private boolean fixHashGroupsForRoute(ArrayList<DeviceId> route, boolean depopulate) {
    DeviceId targetSw = route.get(0);
    if (route.size() < 2) {
        log.warn("Cannot fixHashGroupsForRoute - no dstSw in route {}", route);
        return false;
    }
    DeviceId destSw = route.get(1);
    log.debug("Processing fixHashGroupsForRoute: Target {} -> Dest {}", targetSw, destSw);
    boolean targetIsEdge = false;
    try {
        targetIsEdge = srManager.deviceConfiguration.isEdgeDevice(targetSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + "Cannot determine if targetIsEdge {}.. " + "continuing fixHash", targetSw);
    }
    // figure out the new next hops at the targetSw towards the destSw
    Set<DeviceId> nextHops = new HashSet<>();
    EcmpShortestPathGraph ecmpSpg = updatedEcmpSpgMap.get(destSw);
    HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
    for (Integer itrIdx : switchVia.keySet()) {
        HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
        for (DeviceId target : swViaMap.keySet()) {
            if (target.equals(targetSw)) {
                // found the iteration where targetSw is reached- get nextHops
                if (!targetIsEdge && itrIdx > 1) {
                    // optimization for spines to not use other leaves to get
                    // to a leaf to avoid loops
                    log.debug("Avoiding {} hop path for non-edge targetSw:{}" + " --> dstSw:{}", itrIdx, targetSw, destSw);
                    break;
                }
                for (ArrayList<DeviceId> via : swViaMap.get(target)) {
                    if (via.isEmpty()) {
                        nextHops.add(destSw);
                    } else {
                        // first elem is next-hop in each ECMP path
                        nextHops.add(via.get(0));
                    }
                }
                break;
            }
        }
    }
    // call group handler to change hash group at targetSw
    DefaultGroupHandler grpHandler = srManager.getGroupHandler(targetSw);
    if (grpHandler == null) {
        log.warn("Cannot find grouphandler for dev:{} .. aborting" + " {} hash group for route:{} ", targetSw, (depopulate) ? "depopulate" : "repopulate", route);
        return false;
    }
    log.debug("{} hash-groups For Route {} -> {} to next-hops {}", (depopulate) ? "depopulating" : "repopulating", targetSw, destSw, nextHops);
    return (depopulate) ? grpHandler.fixHashGroups(targetSw, nextHops, destSw, true) : grpHandler.fixHashGroups(targetSw, nextHops, destSw, false);
}
#method_after
private boolean fixHashGroupsForRoute(ArrayList<DeviceId> route, boolean revoke) {
    DeviceId targetSw = route.get(0);
    if (route.size() < 2) {
        log.warn("Cannot fixHashGroupsForRoute - no dstSw in route {}", route);
        return false;
    }
    DeviceId destSw = route.get(1);
    log.debug("Processing fixHashGroupsForRoute: Target {} -> Dest {}", targetSw, destSw);
    boolean targetIsEdge = false;
    try {
        targetIsEdge = srManager.deviceConfiguration.isEdgeDevice(targetSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + "Cannot determine if targetIsEdge {}.. " + "continuing fixHash", targetSw);
    }
    // figure out the new next hops at the targetSw towards the destSw
    Set<DeviceId> nextHops = new HashSet<>();
    EcmpShortestPathGraph ecmpSpg = updatedEcmpSpgMap.get(destSw);
    HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
    for (Integer itrIdx : switchVia.keySet()) {
        HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
        for (DeviceId target : swViaMap.keySet()) {
            if (target.equals(targetSw)) {
                // found the iteration where targetSw is reached- get nextHops
                if (!targetIsEdge && itrIdx > 1) {
                    // optimization for spines to not use other leaves to get
                    // to a leaf to avoid loops
                    log.debug("Avoiding {} hop path for non-edge targetSw:{}" + " --> dstSw:{}", itrIdx, targetSw, destSw);
                    break;
                }
                for (ArrayList<DeviceId> via : swViaMap.get(target)) {
                    if (via.isEmpty()) {
                        nextHops.add(destSw);
                    } else {
                        // first elem is next-hop in each ECMP path
                        nextHops.add(via.get(0));
                    }
                }
                break;
            }
        }
    }
    // call group handler to change hash group at targetSw
    DefaultGroupHandler grpHandler = srManager.getGroupHandler(targetSw);
    if (grpHandler == null) {
        log.warn("Cannot find grouphandler for dev:{} .. aborting" + " {} hash group buckets for route:{} ", targetSw, (revoke) ? "revoke" : "repopulate", route);
        return false;
    }
    log.debug("{} hash-groups buckets For Route {} -> {} to next-hops {}", (revoke) ? "revoke" : "repopulating", targetSw, destSw, nextHops);
    return (revoke) ? grpHandler.fixHashGroups(targetSw, nextHops, destSw, true) : grpHandler.fixHashGroups(targetSw, nextHops, destSw, false);
}
#end_block

#method_before
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops, Set<IpPrefix> subnets) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean destIsEdge;
    Ip4Address destRouterIpv4;
    Ip6Address destRouterIpv6;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        destIsEdge = config.isEdgeDevice(destSw);
        destRouterIpv4 = config.getRouterIpv4(destSw);
        destRouterIpv6 = config.getRouterIpv6(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && destIsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? subnets : config.getSubnets(destSw);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} " + "for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
    /* XXX saving on ECMP groups
            IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} "
                    + "for router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                           destSw, nextHops);
            if (!result) {
                return false;
            }
            // If present we deal with IPv6 loopback.
            if (destRouterIpv6 != null) {
                routerIpPrefix = destRouterIpv6.toIpPrefix();
                log.debug("* populateEcmpRoutingRulePartial in device {} towards {}"
                        + " for v6 router IP {}", targetSw, destSw, routerIpPrefix);
                result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                               destSw, nextHops);
                if (!result) {
                    return false;
                }
            }*/
    } else if (targetIsEdge) {
    /* XXX saving on ECMP groups
            // If the target switch is an edge router, then set IP rules for router IP.
            IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} "
                    + "for router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                           destSw, nextHops);
            if (!result) {
                return false;
            }
            if (destRouterIpv6 != null) {
                routerIpPrefix = destRouterIpv6.toIpPrefix();
                log.debug("* populateEcmpRoutingRulePartial in device {} towards {}"
                        + " for v6 router IP {}", targetSw, destSw, routerIpPrefix);
                result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                               destSw, nextHops);
                if (!result) {
                    return false;
                }
            } */
    }
    // Populates MPLS rules to all routers
    if (targetIsEdge) {
        // as well to save on ECMP groups
        return true;
    }
    if (!targetIsEdge && !destIsEdge) {
        // save on ECMP groups
        return true;
    }
    log.debug("* populateEcmpRoutingRulePartial in device{} towards {} for " + "all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv4);
    if (!result) {
        return false;
    }
    // If present we will populate the MPLS rules for the IPv6 sid.
    if (destRouterIpv6 != null) {
        result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv6);
        if (!result) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops, Set<IpPrefix> subnets) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean destIsEdge;
    Ip4Address destRouterIpv4;
    Ip6Address destRouterIpv6;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        destIsEdge = config.isEdgeDevice(destSw);
        destRouterIpv4 = config.getRouterIpv4(destSw);
        destRouterIpv6 = config.getRouterIpv6(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && destIsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? subnets : config.getSubnets(destSw);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} " + "for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} " + "for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
        // If present we deal with IPv6 loopback.
        if (destRouterIpv6 != null) {
            routerIpPrefix = destRouterIpv6.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {}" + " for v6 router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
            if (!result) {
                return false;
            }
        }
    }
    if (!targetIsEdge && destIsEdge) {
        // MPLS rules in all non-edge target devices
        log.debug("* populateEcmpRoutingRulePartial in device{} towards {} for " + "all MPLS rules", targetSw, destSw);
        result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv4);
        if (!result) {
            return false;
        }
        if (destRouterIpv6 != null) {
            result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv6);
            if (!result) {
                return false;
            }
        }
    }
    // avoid loopback IP rules in edge-devices to non-edge-devices
    return true;
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    componentConfigService.unregisterProperties(getClass(), false);
    deviceService.removeListener(deviceListener);
    active = false;
    controller.getNetconfDevices().forEach(id -> {
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(id.toString()));
        controller.disconnectDevice(id, true);
    });
    controller.removeDeviceListener(innerNodeListener);
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    providerService = null;
    factories.forEach(cfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    executor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    componentConfigService.unregisterProperties(getClass(), false);
    deviceService.removeListener(deviceListener);
    active = false;
    controller.getNetconfDevices().forEach(id -> {
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(id.toString()));
        controller.disconnectDevice(id, true);
    });
    controller.removeDeviceListener(innerNodeListener);
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    providerService = null;
    retriedPortDiscoveryMap.clear();
    factories.forEach(cfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    executor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        pollFrequency = Tools.getIntegerProperty(properties, "pollFrequency", DEFAULT_POLL_FREQUENCY_SECONDS);
        log.info("Configured. Poll frequency is configured to {} seconds", pollFrequency);
    }
    if (scheduledTask != null) {
        scheduledTask.cancel(false);
    }
    scheduledTask = schedulePolling();
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        pollFrequency = Tools.getIntegerProperty(properties, "pollFrequency", DEFAULT_POLL_FREQUENCY_SECONDS);
        log.info("Configured. Poll frequency is configured to {} seconds", pollFrequency);
        maxRetries = Tools.getIntegerProperty(properties, "maxRetries", DEFAULT_MAX_RETRIES);
        log.info("Configured. Number of retries is configured to {} times", maxRetries);
    }
    if (scheduledTask != null) {
        scheduledTask.cancel(false);
    }
    scheduledTask = schedulePolling();
}
#end_block

#method_before
@Override
public void deviceRemoved(DeviceId deviceId) {
    Preconditions.checkNotNull(deviceId, ISNULL);
    if (deviceService.getDevice(deviceId) != null) {
        providerService.deviceDisconnected(deviceId);
        log.debug("Netconf device {} removed from Netconf subController", deviceId);
    } else {
        log.warn("Netconf device {} does not exist in the store, " + "it may already have been removed", deviceId);
    }
}
#method_after
@Override
public void deviceRemoved(DeviceId deviceId) {
    Preconditions.checkNotNull(deviceId, ISNULL);
    if (deviceService.getDevice(deviceId) != null) {
        providerService.deviceDisconnected(deviceId);
        retriedPortDiscoveryMap.remove(deviceId);
        log.debug("Netconf device {} removed from Netconf subController", deviceId);
    } else {
        log.warn("Netconf device {} does not exist in the store, " + "it may already have been removed", deviceId);
    }
}
#end_block

#method_before
private void connectDevice(NetconfDeviceConfig config) {
    if (config == null) {
        return;
    }
    DeviceId deviceId = config.subject();
    if (!deviceId.uri().getScheme().equals(SCHEME_NAME)) {
        // not under my scheme, skipping
        log.trace("{} not my scheme, skipping", deviceId);
        return;
    }
    DeviceDescription deviceDescription = createDeviceRepresentation(deviceId, config);
    log.debug("Connecting NETCONF device {}, on {}:{} with username {}", deviceId, config.ip(), config.port(), config.username());
    storeDeviceKey(config.sshKey(), config.username(), config.password(), deviceId);
    if (deviceService.getDevice(deviceId) == null) {
        providerService.deviceConnected(deviceId, deviceDescription);
    }
    try {
        checkAndUpdateDevice(deviceId, deviceDescription);
    } catch (Exception e) {
        log.error("Unhandled exception checking {}", deviceId, e);
    }
}
#method_after
private void connectDevice(NetconfDeviceConfig config) {
    if (config == null) {
        return;
    }
    DeviceId deviceId = config.subject();
    if (!deviceId.uri().getScheme().equals(SCHEME_NAME)) {
        // not under my scheme, skipping
        log.trace("{} not my scheme, skipping", deviceId);
        return;
    }
    DeviceDescription deviceDescription = createDeviceRepresentation(deviceId, config);
    log.debug("Connecting NETCONF device {}, on {}:{} with username {}", deviceId, config.ip(), config.port(), config.username());
    storeDeviceKey(config.sshKey(), config.username(), config.password(), deviceId);
    retriedPortDiscoveryMap.putIfAbsent(deviceId, new AtomicInteger(0));
    if (deviceService.getDevice(deviceId) == null) {
        providerService.deviceConnected(deviceId, deviceDescription);
    }
    try {
        checkAndUpdateDevice(deviceId, deviceDescription);
    } catch (Exception e) {
        log.error("Unhandled exception checking {}", deviceId, e);
    }
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.debug("Device {} has not been added to store, " + "since it's not reachable", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    } else if (updatedDeviceDescription == null) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {} " + "using DefaultDeviceDescription", deviceId);
                providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        } else if (isReachable && deviceService.isAvailable(deviceId) && mastershipService.isLocalMaster(deviceId)) {
            updatePortStatistics(device);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.debug("Device {} has not been added to store, " + "since it's not reachable", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    } else if (updatedDeviceDescription == null) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {} " + "using DefaultDeviceDescription", deviceId);
                providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        } else if (isReachable && deviceService.isAvailable(deviceId) && mastershipService.isLocalMaster(deviceId)) {
            // if ports are not discovered, retry the discovery
            if (deviceService.getPorts(deviceId).isEmpty() && retriedPortDiscoveryMap.get(deviceId).getAndIncrement() < maxRetries) {
                discoverPorts(deviceId);
            }
            updatePortStatistics(device);
        }
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    if (mastershipService.getMasterFor(event.subject().id()) == null) {
        return true;
    }
    return SCHEME_NAME.toUpperCase().equals(event.subject().annotations().value(AnnotationKeys.PROTOCOL)) && mastershipService.isLocalMaster(event.subject().id());
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    if (mastershipService.getMasterFor(event.subject().id()) == null) {
        return true;
    }
    return (SCHEME_NAME.equalsIgnoreCase(event.subject().annotations().value(AnnotationKeys.PROTOCOL)) || (SCHEME_NAME.equalsIgnoreCase(event.subject().id().uri().getScheme()))) && mastershipService.isLocalMaster(event.subject().id());
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    if (mastershipService.getMasterFor(event.subject().id()) == null) {
        return true;
    }
    return SCHEME_NAME.toUpperCase().equals(event.subject().annotations().value(AnnotationKeys.PROTOCOL)) && mastershipService.isLocalMaster(event.subject().id());
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    if (mastershipService.getMasterFor(event.subject().id()) == null) {
        return true;
    }
    return (SCHEME_NAME.equalsIgnoreCase(event.subject().annotations().value(AnnotationKeys.PROTOCOL)) || (SCHEME_NAME.equalsIgnoreCase(event.subject().id().uri().getScheme()))) && mastershipService.isLocalMaster(event.subject().id());
}
#end_block

#method_before
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        if (dev.testUrl().isPresent()) {
            return controller.get(dev.deviceId(), dev.testUrl().get(), JSON) != null;
        }
        return controller.get(dev.deviceId(), "", JSON) != null;
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#method_after
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        Callable<Boolean> connectionSuccess;
        if (dev.testUrl().isPresent()) {
            connectionSuccess = new Callable<Boolean>() {

                @Override
                public Boolean call() throws Exception {
                    return controller.get(dev.deviceId(), dev.testUrl().get(), JSON) != null;
                }
            };
        } else {
            connectionSuccess = new Callable<Boolean>() {

                @Override
                public Boolean call() throws Exception {
                    return controller.get(dev.deviceId(), "", JSON) != null;
                }
            };
        }
        Future<Boolean> future = executor.submit(connectionSuccess);
        try {
            Boolean result = future.get(REST_TIMEOUT_SEC, TimeUnit.SECONDS);
            return result;
        } catch (TimeoutException ex) {
            log.warn("Connection to device {} timed out", dev.deviceId());
            return false;
        } catch (InterruptedException ex) {
            log.warn("Connection to device {} interrupted", dev.deviceId());
            return false;
        } catch (ExecutionException ex) {
            log.warn("Connection to device {} had a execution exception", dev.deviceId());
            return false;
        }
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#end_block

#method_before
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        Callable<Boolean> connectionSuccess;
        if (dev.testUrl().isPresent()) {
            connectionSuccess = new Callable<Boolean>() {

                @Override
                public Boolean call() throws Exception {
                    return controller.get(dev.deviceId(), dev.testUrl().get(), JSON) != null;
                }
            };
        } else {
            connectionSuccess = new Callable<Boolean>() {

                @Override
                public Boolean call() throws Exception {
                    return controller.get(dev.deviceId(), "", JSON) != null;
                }
            };
        }
        Future<Boolean> future = executor.submit(connectionSuccess);
        try {
            Boolean result = future.get(RESTTIMEOUT_SEC, TimeUnit.SECONDS);
            return result;
        } catch (TimeoutException ex) {
            log.warn("Connection to device {} timed out", dev.deviceId());
            return false;
        } catch (InterruptedException ex) {
            log.warn("Connection to device {} interrupted", dev.deviceId());
            return false;
        } catch (ExecutionException ex) {
            log.warn("Connection to device {} had a execution exception", dev.deviceId());
            return false;
        }
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#method_after
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        Callable<Boolean> connectionSuccess;
        if (dev.testUrl().isPresent()) {
            connectionSuccess = new Callable<Boolean>() {

                @Override
                public Boolean call() throws Exception {
                    return controller.get(dev.deviceId(), dev.testUrl().get(), JSON) != null;
                }
            };
        } else {
            connectionSuccess = new Callable<Boolean>() {

                @Override
                public Boolean call() throws Exception {
                    return controller.get(dev.deviceId(), "", JSON) != null;
                }
            };
        }
        Future<Boolean> future = executor.submit(connectionSuccess);
        try {
            Boolean result = future.get(REST_TIMEOUT_SEC, TimeUnit.SECONDS);
            return result;
        } catch (TimeoutException ex) {
            log.warn("Connection to device {} timed out", dev.deviceId());
            return false;
        } catch (InterruptedException ex) {
            log.warn("Connection to device {} interrupted", dev.deviceId());
            return false;
        } catch (ExecutionException ex) {
            log.warn("Connection to device {} had a execution exception", dev.deviceId());
            return false;
        }
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    if (mastershipService.getMasterFor(event.subject().id()) == null) {
        return true;
    }
    return (event.subject().annotations().value(AnnotationKeys.PROTOCOL).equalsIgnoreCase(SCHEME_NAME) || event.subject().id().uri().getScheme().equalsIgnoreCase(SCHEME_NAME)) && mastershipService.isLocalMaster(event.subject().id());
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    if (mastershipService.getMasterFor(event.subject().id()) == null) {
        return true;
    }
    return (SCHEME_NAME.equalsIgnoreCase(event.subject().annotations().value(AnnotationKeys.PROTOCOL)) || (SCHEME_NAME.equalsIgnoreCase(event.subject().id().uri().getScheme()))) && mastershipService.isLocalMaster(event.subject().id());
}
#end_block

#method_before
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "UseSecurityGroup");
    if (flag == null) {
        log.info("UseSecurityGroup is not configured, " + "using current value of {}", useSecurityGroup);
    } else {
        useSecurityGroup = flag;
        log.info("Configured. UseSecurityGroup is {}", useSecurityGroup ? "enabled" : "disabled");
    }
    resetSecurityGroupRules();
}
#method_after
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "useSecurityGroup");
    if (flag == null) {
        log.info("useSecurityGroup is not configured, " + "using current value of {}", useSecurityGroup);
    } else {
        useSecurityGroup = flag;
        log.info("Configured. useSecurityGroup is {}", useSecurityGroup ? "enabled" : "disabled");
    }
    resetSecurityGroupRules();
}
#end_block

#method_before
private void resetSecurityGroupRules() {
    if (useSecurityGroup) {
        // setSecurityGroupTableBypassRule(false);
        securityGroupService.securityGroups().forEach(securityGroup -> securityGroup.getRules().forEach(this::securityGroupRuleAdded));
    } else {
        // setSecurityGroupTableBypassRule(true);
        securityGroupService.securityGroups().forEach(securityGroup -> securityGroup.getRules().forEach(this::securityGroupRuleRemoved));
    }
    log.info("Reset security group info " + (useSecurityGroup ? " with " : " without") + " Security Group");
}
#method_after
private void resetSecurityGroupRules() {
    if (useSecurityGroup) {
        securityGroupService.securityGroups().forEach(securityGroup -> securityGroup.getRules().forEach(this::securityGroupRuleAdded));
    } else {
        securityGroupService.securityGroups().forEach(securityGroup -> securityGroup.getRules().forEach(this::securityGroupRuleRemoved));
    }
    log.info("Reset security group info " + (useSecurityGroup ? " with " : " without") + " Security Group");
}
#end_block

#method_before
public void setData(byte[] data) {
    this.length = (short) data.length;
    this.data = data;
}
#method_after
public void setData(byte[] data) {
    this.data = data;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    int payloadLength = options.stream().mapToInt(DHCP6Option::getLength).sum();
    // 2 bytes code and 2 bytes length
    payloadLength += options.size() * 4;
    if (RELAY_MSG_TYPES.contains(msgType)) {
        payloadLength += DHCP6_RELAY_MSG_SIZE;
    } else {
        payloadLength += DHCP6_DEFAULT_SIZE;
    }
    ByteBuffer bb = ByteBuffer.allocate(payloadLength);
    bb.put(msgType);
    if (RELAY_MSG_TYPES.contains(msgType)) {
        bb.put(hopCount);
        bb.put(linkAddress);
        bb.put(peerAddress);
    } else {
        // make transaction id to 12 bits
        byte[] tid = new byte[3];
        int tmpTid = transactionId;
        for (int c = 2; c >= 0; c--) {
            tid[c] = (byte) (tmpTid & 0xff);
            tmpTid >>= 8;
        }
        bb.put(tid);
    }
    serializeOptions(bb);
    return bb.array();
}
#method_after
@Override
public byte[] serialize() {
    int payloadLength = options.stream().mapToInt(DHCP6Option::getLength).sum();
    // 2 bytes code and 2 bytes length
    payloadLength += options.size() * (OPT_CODE_SIZE + OPT_LEN_SIZE);
    if (RELAY_MSG_TYPES.contains(msgType)) {
        payloadLength += DHCP6_RELAY_MSG_SIZE;
    } else {
        payloadLength += DHCP6_DEFAULT_SIZE;
    }
    ByteBuffer bb = ByteBuffer.allocate(payloadLength);
    if (RELAY_MSG_TYPES.contains(msgType)) {
        bb.put(msgType);
        bb.put(hopCount);
        bb.put(linkAddress);
        bb.put(peerAddress);
    } else {
        int defaultHeader = ((int) msgType) << MSG_TYPE_OFFSET | (transactionId & TRANSACTION_ID_MASK);
        bb.putInt(defaultHeader);
    }
    // serialize options
    options.forEach(option -> {
        bb.putShort(option.getCode());
        bb.putShort(option.getLength());
        bb.put(option.getData());
    });
    return bb.array();
}
#end_block

#method_before
public static Deserializer<DHCP6> deserializer() {
    return (data, offset, length) -> {
        DHCP6 dhcp6 = new DHCP6();
        final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        if (bb.remaining() < DHCP6.DHCP6_DEFAULT_SIZE) {
            return dhcp6;
        }
        dhcp6.msgType = bb.get();
        if (RELAY_MSG_TYPES.contains(dhcp6.msgType)) {
            dhcp6.hopCount = bb.get();
            dhcp6.linkAddress = new byte[IPV6_ADDR_LEN];
            dhcp6.peerAddress = new byte[IPV6_ADDR_LEN];
            bb.get(dhcp6.linkAddress);
            bb.get(dhcp6.peerAddress);
        } else {
            dhcp6.transactionId = bb.get();
            dhcp6.transactionId |= dhcp6.transactionId << 8 | bb.get();
            dhcp6.transactionId |= dhcp6.transactionId << 8 | bb.get();
        }
        dhcp6.options = Lists.newArrayList();
        while (bb.remaining() >= 2) {
            DHCP6Option option = new DHCP6Option();
            short code = bb.getShort();
            if (bb.remaining() < 2) {
                break;
            }
            short optionLen = bb.getShort();
            if (bb.remaining() < optionLen) {
                break;
            }
            byte[] optionData = new byte[optionLen];
            bb.get(optionData);
            option.setCode(code);
            option.setData(optionData);
            dhcp6.options.add(option);
        }
        return dhcp6;
    };
}
#method_after
public static Deserializer<DHCP6> deserializer() {
    return (data, offset, length) -> {
        DHCP6 dhcp6 = new DHCP6();
        checkNotNull(data);
        if (offset < 0 || length < 0 || length > data.length || offset >= data.length || offset + length > data.length) {
            throw new DeserializationException("Illegal offset or length");
        }
        final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        if (bb.remaining() < DHCP6.DHCP6_DEFAULT_SIZE) {
            throw new DeserializationException("Buffer underflow while reading DHCPv6 option");
        }
        // peek message type
        dhcp6.msgType = bb.array()[0];
        if (RELAY_MSG_TYPES.contains(dhcp6.msgType)) {
            // drop message type
            bb.get();
            dhcp6.hopCount = bb.get();
            dhcp6.linkAddress = new byte[IPV6_ADDR_LEN];
            dhcp6.peerAddress = new byte[IPV6_ADDR_LEN];
            bb.get(dhcp6.linkAddress);
            bb.get(dhcp6.peerAddress);
        } else {
            // get msg type + transaction id (1 + 3 bytes)
            int defaultHeader = bb.getInt();
            dhcp6.transactionId = defaultHeader & TRANSACTION_ID_MASK;
        }
        dhcp6.options = Lists.newArrayList();
        while (bb.remaining() >= OPT_CODE_SIZE) {
            DHCP6Option option = new DHCP6Option();
            short code = bb.getShort();
            if (bb.remaining() < OPT_LEN_SIZE) {
                throw new DeserializationException("Buffer underflow while reading DHCPv6 option");
            }
            short optionLen = bb.getShort();
            if (bb.remaining() < optionLen) {
                throw new DeserializationException("Buffer underflow while reading DHCPv6 option");
            }
            byte[] optionData = new byte[optionLen];
            bb.get(optionData);
            option.setCode(code);
            option.setLength(optionLen);
            option.setData(optionData);
            dhcp6.options.add(option);
        }
        return dhcp6;
    };
}
#end_block

#method_before
@Test
public void testDiscoverPortsAfterDeviceAdded() {
    final int portCount = 5;
    provider.executor = new SynchronousExecutor();
    prepareMocks(portCount);
    deviceService.listener.event(new DeviceEvent(DeviceEvent.Type.DEVICE_ADDED, netconfDevice));
    assertEquals("Ports should be added", portCount, providerService.ports.get(netconfDevice.id()).size());
    deviceService.listener.event(new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, netconfDevice));
    assertEquals("Ports should be removed", 0, providerService.ports.get(netconfDevice.id()).size());
}
#method_after
@Test
public void testDiscoverPortsAfterDeviceAdded() {
    provider.executor = MoreExecutors.newDirectExecutorService();
    prepareMocks(PORT_COUNT);
    deviceService.listener.event(new DeviceEvent(DeviceEvent.Type.DEVICE_ADDED, netconfDevice));
    assertEquals("Ports should be added", PORT_COUNT, providerService.ports.get(netconfDevice.id()).size());
    deviceService.listener.event(new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, netconfDevice));
    assertEquals("Ports should be removed", 0, providerService.ports.get(netconfDevice.id()).size());
}
#end_block

#method_before
@Override
public boolean createInterface(String bridgeName, OvsdbInterface ovsdbIface) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    if (getPortUuid(ovsdbIface.name(), bridgeUuid) != null) {
        log.warn("Interface {} already exists", ovsdbIface.name());
        // remove existing one and re-create?
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    // insert a new port with the interface name
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(ovsdbIface.name());
    Insert portInsert = new Insert(dbSchema.getTableSchema(PORT), PORT, port.getRow());
    portInsert.getRow().put(INTERFACES, Uuid.uuid(INTERFACE));
    operations.add(portInsert);
    // update the bridge table with the new port
    Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert(PORTS, Uuid.uuid(PORT));
    List<Condition> conditions = Lists.newArrayList(condition);
    List<Mutation> mutations = Lists.newArrayList(mutation);
    operations.add(new Mutate(dbSchema.getTableSchema(BRIDGE), conditions, mutations));
    // insert an interface
    Interface intf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    intf.setName(ovsdbIface.name());
    if (ovsdbIface.type().isPresent()) {
        intf.setType(ovsdbIface.typeToString());
    }
    if (ovsdbIface.mtu().isPresent()) {
        Set<Long> mtuSet = Sets.newConcurrentHashSet();
        mtuSet.add(ovsdbIface.mtu().get());
        intf.setMtu(mtuSet);
        intf.setMtuRequest(mtuSet);
    }
    intf.setOptions(ovsdbIface.options());
    Insert intfInsert = new Insert(dbSchema.getTableSchema(INTERFACE), INTERFACE, intf.getRow());
    operations.add(intfInsert);
    transactConfig(DATABASENAME, operations);
    log.info("Created interface {}", ovsdbIface);
    return true;
}
#method_after
@Override
public boolean createInterface(String bridgeName, OvsdbInterface ovsdbIface) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    if (getPortUuid(ovsdbIface.name(), bridgeUuid) != null) {
        log.warn("Interface {} already exists", ovsdbIface.name());
        // remove existing one and re-create?
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    // insert a new port with the interface name
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(ovsdbIface.name());
    Insert portInsert = new Insert(dbSchema.getTableSchema(PORT), PORT, port.getRow());
    portInsert.getRow().put(INTERFACES, Uuid.uuid(INTERFACE));
    operations.add(portInsert);
    // update the bridge table with the new port
    Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert(PORTS, Uuid.uuid(PORT));
    List<Condition> conditions = Lists.newArrayList(condition);
    List<Mutation> mutations = Lists.newArrayList(mutation);
    operations.add(new Mutate(dbSchema.getTableSchema(BRIDGE), conditions, mutations));
    // insert an interface
    Interface intf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    intf.setName(ovsdbIface.name());
    intf.setType(ovsdbIface.typeToString());
    if (ovsdbIface.mtu().isPresent()) {
        Set<Long> mtuSet = Sets.newConcurrentHashSet();
        mtuSet.add(ovsdbIface.mtu().get());
        intf.setMtu(mtuSet);
        intf.setMtuRequest(mtuSet);
    }
    intf.setOptions(ovsdbIface.options());
    Insert intfInsert = new Insert(dbSchema.getTableSchema(INTERFACE), INTERFACE, intf.getRow());
    operations.add(intfInsert);
    transactConfig(DATABASENAME, operations);
    log.info("Created interface {}", ovsdbIface);
    return true;
}
#end_block

#method_before
public Optional<Type> type() {
    return type;
}
#method_after
public Type type() {
    return type;
}
#end_block

#method_before
public String typeToString() {
    return type.get().name().toLowerCase();
}
#method_after
public String typeToString() {
    return type.name().toLowerCase();
}
#end_block

#method_before
public Builder type(Type type) {
    this.type = Optional.ofNullable(type);
    return this;
}
#method_after
public Builder type(Type type) {
    this.type = type;
    return this;
}
#end_block

#method_before
public static String generate(List<String> commands, CommandType type) {
    ObjectMapper om = new ObjectMapper();
    ArrayNode aryNode = om.createArrayNode();
    if (commands == null) {
        return aryNode.toString();
    }
    IntStream.range(0, commands.size()).forEach(idx -> {
        ObjectNode parm = om.createObjectNode();
        parm.put(CMD, commands.get(idx));
        parm.put(VERSION, 1);
        ObjectNode node = om.createObjectNode();
        node.put(JSONRPC, TWO_POINT_ZERO);
        switch(type) {
            case CLI_ASCII:
                node.put(METHOD, CLI_ASCII);
                break;
            case CLI:
            default:
                node.put(METHOD, CLI);
                break;
        }
        node.set(PARAMS, parm);
        node.put(ID, idx + 1);
        aryNode.add(node);
    });
    return aryNode.toString();
}
#method_after
public static String generate(List<String> commands, CommandType type) {
    ObjectMapper om = new ObjectMapper();
    ArrayNode aryNode = om.createArrayNode();
    if (commands == null) {
        return aryNode.toString();
    }
    IntStream.range(0, commands.size()).forEach(idx -> {
        ObjectNode parm = om.createObjectNode();
        parm.put(CMD, commands.get(idx));
        parm.put(VERSION, ONE);
        ObjectNode node = om.createObjectNode();
        node.put(JSONRPC, TWO_POINT_ZERO);
        switch(type) {
            case CLI_ASCII:
                node.put(METHOD, CLI_ASCII);
                break;
            case CLI:
            default:
                node.put(METHOD, CLI);
                break;
        }
        node.set(PARAMS, parm);
        node.put(ID, idx + 1);
        aryNode.add(node);
    });
    return aryNode.toString();
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    DriverHandler handler = handler();
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    ArrayList<String> cmd = new ArrayList<>();
    cmd.add(SHOW_VERSION_CMD);
    String req = NxApiRequest.generate(cmd, NxApiRequest.CommandType.CLI);
    String response = NxApiRequest.post(controller, deviceId, req);
    String mrf = UNKNOWN;
    String hwVer = UNKNOWN;
    String swVer = UNKNOWN;
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        JsonNode body = json.findValue("body");
        if (body != null) {
            mrf = body.get(MANUFACTURER).asText();
            hwVer = body.get(CHASSIS_ID).asText();
            swVer = body.get(KICKSTART_VER).asText();
        }
    } catch (IOException e) {
        log.error("Failed to to retrieve Device Information {}", e);
    }
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    Device device = deviceService.getDevice(deviceId);
    return new DefaultDeviceDescription(device.id().uri(), device.type(), mrf, hwVer, swVer, UNKNOWN, device.chassisId(), (SparseAnnotations) device.annotations());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    DriverHandler handler = handler();
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    ArrayList<String> cmd = new ArrayList<>();
    cmd.add(SHOW_VERSION_CMD);
    String req = NxApiRequest.generate(cmd, NxApiRequest.CommandType.CLI);
    String response = NxApiRequest.post(controller, deviceId, req);
    String mrf = UNKNOWN;
    String hwVer = UNKNOWN;
    String swVer = UNKNOWN;
    String serialNum = UNKNOWN;
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        JsonNode body = json.findValue("body");
        if (body != null) {
            mrf = body.get(MANUFACTURER).asText();
            hwVer = body.get(CHASSIS_ID).asText();
            swVer = body.get(KICKSTART_VER).asText();
        }
    } catch (IOException e) {
        log.error("Failed to to retrieve Device Information {}", e);
    }
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    Device device = deviceService.getDevice(deviceId);
    return new DefaultDeviceDescription(device.id().uri(), Device.Type.SWITCH, mrf, hwVer, swVer, serialNum, new ChassisId(), (SparseAnnotations) device.annotations());
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    DriverHandler handler = handler();
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    ArrayList<String> cmd = new ArrayList<>();
    cmd.add(SHOW_INTERFACES_CMD);
    String req = NxApiRequest.generate(cmd, NxApiRequest.CommandType.CLI);
    String response = NxApiRequest.post(controller, deviceId, req);
    // parse interface information from response
    List<PortDescription> ports = Lists.newArrayList();
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        JsonNode interfaces = json.findValue(ROW_INTERFACE);
        if (interfaces != null) {
            interfaces.forEach(itf -> {
                String ifName = itf.get(INTERFACE).asText();
                if (ifName.startsWith(ETH)) {
                    String ifNum = ifName.substring(ETHERNET.length()).replace('/', '0');
                    boolean state = itf.get(STATE).asText().equals(UP) ? true : false;
                    // in Mbps
                    long portSpeed = itf.get(ETH_BW).asLong() / 1000;
                    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, ifName);
                    PortDescription desc = new DefaultPortDescription(PortNumber.portNumber(ifNum), state, Port.Type.FIBER, portSpeed, annotations.build());
                    ports.add(desc);
                }
            });
        }
    } catch (IOException e) {
        log.error("Failed to to retrieve Interfaces {}", e);
    }
    return ports;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    DriverHandler handler = handler();
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    ArrayList<String> cmd = new ArrayList<>();
    cmd.add(SHOW_INTERFACES_CMD);
    String req = NxApiRequest.generate(cmd, NxApiRequest.CommandType.CLI);
    String response = NxApiRequest.post(controller, deviceId, req);
    // parse interface information from response
    List<PortDescription> ports = Lists.newArrayList();
    try {
        ObjectMapper om = new ObjectMapper();
        JsonNode json = om.readTree(response);
        JsonNode interfaces = json.findValue(ROW_INTERFACE);
        if (interfaces != null) {
            interfaces.forEach(itf -> {
                String ifName = itf.get(INTERFACE).asText();
                if (ifName.startsWith(ETH)) {
                    String ifNum = ifName.substring(ETHERNET.length()).replace(SLASH, ZERO);
                    boolean state = itf.get(STATE).asText().equals(UP);
                    // in Mbps
                    long portSpeed = itf.get(ETH_BW).asLong() / ONE_THOUSAND;
                    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, ifName);
                    PortDescription desc = new DefaultPortDescription(PortNumber.portNumber(ifNum), state, Port.Type.FIBER, portSpeed, annotations.build());
                    ports.add(desc);
                }
            });
        }
    } catch (IOException e) {
        log.error("Failed to to retrieve Interfaces {}", e);
    }
    return ports;
}
#end_block

#method_before
@Activate
public void activate() {
    Serializer serializer = Serializer.using(KryoNamespaces.API, ObjectNode.class, ArrayNode.class, JsonNodeFactory.class, LinkedHashMap.class, TextNode.class, BooleanNode.class, LongNode.class, DoubleNode.class, ShortNode.class, IntNode.class, NullNode.class);
    prefsConsistentMap = storageService.<String, ObjectNode>consistentMapBuilder().withName(ONOS_USER_PREFERENCES).withSerializer(serializer).withRelaxedReadConsistency().build();
    prefsConsistentMap.addListener(prefsListener);
    prefs = prefsConsistentMap.asJavaMap();
    tokensConsistentMap = storageService.<UiSessionToken, String>consistentMapBuilder().withName(ONOS_SESSION_TOKENS).withSerializer(serializer).withRelaxedReadConsistency().build();
    tokensConsistentMap.addListener(tokensListener);
    tokens = tokensConsistentMap.asJavaMap();
    register(core);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    Serializer serializer = Serializer.using(KryoNamespaces.API, ObjectNode.class, ArrayNode.class, JsonNodeFactory.class, LinkedHashMap.class, TextNode.class, BooleanNode.class, LongNode.class, DoubleNode.class, ShortNode.class, IntNode.class, NullNode.class, UiSessionToken.class);
    prefsConsistentMap = storageService.<String, ObjectNode>consistentMapBuilder().withName(ONOS_USER_PREFERENCES).withSerializer(serializer).withRelaxedReadConsistency().build();
    prefsConsistentMap.addListener(prefsListener);
    prefs = prefsConsistentMap.asJavaMap();
    tokensConsistentMap = storageService.<UiSessionToken, String>consistentMapBuilder().withName(ONOS_SESSION_TOKENS).withSerializer(serializer).withRelaxedReadConsistency().build();
    tokens = tokensConsistentMap.asJavaMap();
    register(core);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    tokensConsistentMap.removeListener(tokensListener);
    prefsConsistentMap.removeListener(prefsListener);
    eventHandlingExecutor.shutdown();
    UiWebSocketServlet.closeAll();
    unregister(core);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    prefsConsistentMap.removeListener(prefsListener);
    eventHandlingExecutor.shutdown();
    UiWebSocketServlet.closeAll();
    unregister(core);
    log.info("Stopped");
}
#end_block

#method_before
// =====================================================================
// UiTokenService
@Override
public UiSessionToken issueToken(String username) {
    // TODO: generate token
    String tokenString = "foo";
    UiSessionToken token = new UiSessionToken(tokenString);
    tokens.put(token, username);
    return token;
}
#method_after
// =====================================================================
// UiTokenService
@Override
public UiSessionToken issueToken(String username) {
    UiSessionToken token = new UiSessionToken(tokenGen.nextSessionId());
    tokens.put(token, username);
    log.debug("UiSessionToken issued: {}", token);
    return token;
}
#end_block

#method_before
@Override
public void revokeToken(UiSessionToken token) {
    tokens.remove(token);
}
#method_after
@Override
public void revokeToken(UiSessionToken token) {
    if (token != null) {
        tokens.remove(token);
        log.debug("UiSessionToken revoked: {}", token);
    }
}
#end_block

#method_before
@Override
public boolean isTokenValid(UiSessionToken token) {
    return tokens.containsKey(token);
}
#method_after
@Override
public boolean isTokenValid(UiSessionToken token) {
    return token != null && tokens.containsKey(token);
}
#end_block

#method_before
private ObjectNode jsonPrefs() {
    ObjectNode json = mapper.createObjectNode();
    prefs.entrySet().forEach(e -> json.set(keyName(e.getKey()), e.getValue()));
    return json;
}
#method_after
private ObjectNode jsonPrefs() {
    ObjectNode json = mapper.createObjectNode();
    prefs.forEach((key, value) -> json.set(keyName(key), value));
    return json;
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    controller.removeNodeListener(innerNodeListener);
    providerRegistry.unregister(this);
    deviceService.removeListener(deviceListener);
    providerService = null;
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    controller.removeNodeListener(innerNodeListener);
    providerRegistry.unregister(this);
    deviceService.removeListener(deviceListener);
    waitForTasksToEnd();
    providerService = null;
    log.info("Stopped");
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    DeviceId deviceId = event.subject().id();
    if (mastershipService.getMasterFor(deviceId) == null) {
        return isRelevant(deviceId);
    }
    return isRelevant(deviceId) && mastershipService.isLocalMaster(deviceId);
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    DeviceId deviceId = event.subject().id();
    return isRelevant(deviceId) && mastershipService.isLocalMaster(deviceId);
}
#end_block

#method_before
private boolean isRelevant(DeviceId deviceId) {
    String prefix = deviceId.toString().split(":")[0];
    return prefix.toLowerCase().contains(SCHEME_NAME);
}
#method_after
private boolean isRelevant(DeviceId deviceId) {
    return deviceId.uri().getScheme().equals(SCHEME_NAME);
}
#end_block

#method_before
private static void parsePhysicalInterface(List<PortDescription> portDescriptions, HierarchicalConfiguration phyIntf) {
    Builder annotations = DefaultAnnotations.builder();
    PortNumber portNumber = portNumber(phyIntf.getString(SNMP_INDEX));
    String phyPortName = phyIntf.getString(NAME);
    if (portNumber == null) {
        log.debug("Skipping physical-interface {}, no PortNumer", phyPortName);
        log.trace("  {}", phyIntf);
        return;
    }
    setIfNonNull(annotations, AnnotationKeys.PORT_NAME, phyPortName);
    setIfNonNull(annotations, AnnotationKeys.PORT_MAC, phyIntf.getString("current-physical-address"));
    setIfNonNull(annotations, AK_IF_TYPE, phyIntf.getString(IF_TYPE));
    setIfNonNull(annotations, AK_DESCRIPTION, phyIntf.getString("description"));
    boolean opUp = phyIntf.getString(AK_OPER_STATUS, "down").equals("up");
    annotations.set("oper-status", toUpDown(opUp));
    boolean admUp = phyIntf.getString(AK_ADMIN_STATUS, "down").equals("up");
    annotations.set("admin-status", toUpDown(admUp));
    long portSpeed = toMbps(phyIntf.getString(SPEED));
    portDescriptions.add(new DefaultPortDescription(portNumber, admUp & opUp, Type.COPPER, portSpeed, annotations.build()));
    // parse each logical Interface
    for (HierarchicalConfiguration logIntf : phyIntf.configurationsAt("logical-interface")) {
        if (logIntf == null) {
            continue;
        }
        PortNumber lPortNumber = safePortNumber(logIntf.getString(SNMP_INDEX));
        if (lPortNumber == null) {
            log.debug("Skipping logical-interface {} under {}, no PortNumer", logIntf.getString(NAME), phyPortName);
            log.trace("  {}", logIntf);
            continue;
        }
        Builder lannotations = DefaultAnnotations.builder();
        setIfNonNull(lannotations, AnnotationKeys.PORT_NAME, logIntf.getString(NAME));
        setIfNonNull(lannotations, AK_PHYSICAL_PORT_NAME, phyPortName);
        String afName = logIntf.getString("address-family.address-family-name");
        String address = logIntf.getString("address-family.interface-address.ifa-local");
        if (afName != null && address != null) {
            // e.g., inet : IPV4, inet6 : IPV6
            setIfNonNull(lannotations, afName, address);
        }
        // preserving former behavior
        setIfNonNull(lannotations, "ip", logIntf.getString("address-family.interface-address.ifa-local"));
        setIfNonNull(lannotations, AK_ENCAPSULATION, logIntf.getString("encapsulation"));
        // TODO confirm if this is correct.
        // Looking at sample data,
        // it seemed all logical loop-back interfaces were down
        boolean lEnabled = logIntf.getString("if-config-flags.iff-up") != null;
        portDescriptions.add(new DefaultPortDescription(lPortNumber, admUp & opUp & lEnabled, Type.COPPER, portSpeed, lannotations.build()));
    }
}
#method_after
private static void parsePhysicalInterface(List<PortDescription> portDescriptions, HierarchicalConfiguration phyIntf) {
    Builder annotations = DefaultAnnotations.builder();
    PortNumber portNumber = portNumber(phyIntf.getString(SNMP_INDEX));
    String phyPortName = phyIntf.getString(NAME);
    if (portNumber == null) {
        log.debug("Skipping physical-interface {}, no PortNumer", phyPortName);
        log.trace("  {}", phyIntf);
        return;
    }
    setIfNonNull(annotations, AnnotationKeys.PORT_NAME, phyPortName);
    setIfNonNull(annotations, AnnotationKeys.PORT_MAC, phyIntf.getString("current-physical-address"));
    setIfNonNull(annotations, AK_IF_TYPE, phyIntf.getString(IF_TYPE));
    setIfNonNull(annotations, AK_DESCRIPTION, phyIntf.getString("description"));
    boolean opUp = phyIntf.getString("oper-status", "down").equals("up");
    annotations.set(AK_OPER_STATUS, toUpDown(opUp));
    boolean admUp = phyIntf.getString("admin-status", "down").equals("up");
    annotations.set(AK_ADMIN_STATUS, toUpDown(admUp));
    long portSpeed = toMbps(phyIntf.getString(SPEED));
    portDescriptions.add(new DefaultPortDescription(portNumber, admUp & opUp, Type.COPPER, portSpeed, annotations.build()));
    // parse each logical Interface
    for (HierarchicalConfiguration logIntf : phyIntf.configurationsAt("logical-interface")) {
        if (logIntf == null) {
            continue;
        }
        PortNumber lPortNumber = safePortNumber(logIntf.getString(SNMP_INDEX));
        if (lPortNumber == null) {
            log.debug("Skipping logical-interface {} under {}, no PortNumer", logIntf.getString(NAME), phyPortName);
            log.trace("  {}", logIntf);
            continue;
        }
        Builder lannotations = DefaultAnnotations.builder();
        setIfNonNull(lannotations, AnnotationKeys.PORT_NAME, logIntf.getString(NAME));
        setIfNonNull(lannotations, AK_PHYSICAL_PORT_NAME, phyPortName);
        String afName = logIntf.getString("address-family.address-family-name");
        String address = logIntf.getString("address-family.interface-address.ifa-local");
        if (afName != null && address != null) {
            // e.g., inet : IPV4, inet6 : IPV6
            setIfNonNull(lannotations, afName, address);
        }
        // preserving former behavior
        setIfNonNull(lannotations, "ip", logIntf.getString("address-family.interface-address.ifa-local"));
        setIfNonNull(lannotations, AK_ENCAPSULATION, logIntf.getString("encapsulation"));
        // TODO confirm if this is correct.
        // Looking at sample data,
        // it seemed all logical loop-back interfaces were down
        boolean lEnabled = logIntf.getString("if-config-flags.iff-up") != null;
        portDescriptions.add(new DefaultPortDescription(lPortNumber, admUp & opUp & lEnabled, Type.COPPER, portSpeed, lannotations.build()));
    }
}
#end_block

#method_before
@Override
public <T> T post(DeviceId device, String request, InputStream payload, MediaType mediaType, Class<T> responseClass) {
    Response response = getResponse(device, request, payload, mediaType);
    if (response.hasEntity()) {
        return response.readEntity(responseClass);
    }
    log.error("Response from device {} for request {} contains no entity", device, request);
    return null;
}
#method_after
@Override
public <T> T post(DeviceId device, String request, InputStream payload, MediaType mediaType, Class<T> responseClass) {
    Response response = getResponse(device, request, payload, mediaType);
    if (response != null && response.hasEntity()) {
        return response.readEntity(responseClass);
    }
    log.error("Response from device {} for request {} contains no entity", device, request);
    return null;
}
#end_block

#method_before
private Response getResponse(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(mediaType.toString()).post(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), mediaType.toString()));
        } catch (IOException e) {
            log.error("Cannot do POST {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(mediaType.toString()).post(Entity.entity(null, mediaType.toString()));
    }
    return response;
}
#method_after
private Response getResponse(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(mediaType).post(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), mediaType));
        } catch (IOException e) {
            log.error("Cannot do POST {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(mediaType).post(Entity.entity(null, mediaType));
    }
    return response;
}
#end_block

#method_before
@Override
public int put(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(mediaType.toString()).put(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), mediaType.toString()));
        } catch (IOException e) {
            log.error("Cannot do PUT {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(mediaType.toString()).put(Entity.entity(null, mediaType.toString()));
    }
    if (response == null) {
        return Status.NO_CONTENT.getStatusCode();
    }
    return response.getStatus();
}
#method_after
@Override
public int put(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(mediaType).put(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), mediaType));
        } catch (IOException e) {
            log.error("Cannot do PUT {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(mediaType).put(Entity.entity(null, mediaType));
    }
    if (response == null) {
        return Status.NO_CONTENT.getStatusCode();
    }
    return response.getStatus();
}
#end_block

#method_before
@Override
public InputStream get(DeviceId device, String request, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response s = wt.request(mediaType.toString()).get();
    if (checkReply(s)) {
        return new ByteArrayInputStream(s.readEntity((String.class)).getBytes(StandardCharsets.UTF_8));
    }
    return null;
}
#method_after
@Override
public InputStream get(DeviceId device, String request, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response s = wt.request(mediaType).get();
    if (checkReply(s)) {
        return new ByteArrayInputStream(s.readEntity((String.class)).getBytes(StandardCharsets.UTF_8));
    }
    return null;
}
#end_block

#method_before
@Override
public int delete(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    // FIXME: do we need to delete an entry by enclosing data in DELETE
    // request?
    // wouldn't it be nice to use PUT to implement the similar concept?
    Response response = wt.request(mediaType.toString()).delete();
    return response.getStatus();
}
#method_after
@Override
public int delete(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    WebTarget wt = getWebTarget(device, request);
    // FIXME: do we need to delete an entry by enclosing data in DELETE
    // request?
    // wouldn't it be nice to use PUT to implement the similar concept?
    Response response = wt.request(mediaType).delete();
    return response.getStatus();
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    String ns = schemaId.namespace();
    checkNotNull(schemaId);
    YangSchemaNode schemaNode = null;
    if (ns == null) {
        log.error(E_NEXIST, ns);
    }
    YangSchemaNode node = getForNameSpace(ns, true);
    if (node == null) {
        // If namespace is module name.
        node = getForSchemaName(ns);
    }
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, ns);
    if (node != null) {
        try {
            schemaNode = node.getChildSchema(id).getSchemaNode();
        } catch (DataModelException e) {
            log.error("failed to get child schema", e);
        }
        if (schemaNode == null) {
            List<YangInclude> includeList = ((YangModule) node).getIncludeList();
            id.setNameSpace(node.getNameSpace());
            // Checking requested node in submodule.
            schemaNode = getSubModlueChildNode(id, includeList);
        }
        return schemaNode;
    } else {
        log.error(E_NEXIST, ns);
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    String ns = schemaId.namespace();
    if (ns == null) {
        log.error("namespace should not be null for a node");
    }
    YangSchemaNode schemaNode = null;
    YangSchemaNode node = getForNameSpace(ns, true);
    if (node == null) {
        // If namespace is module name.
        node = getForSchemaName(ns);
    }
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, ns);
    if (node != null) {
        try {
            schemaNode = node.getChildSchema(id).getSchemaNode();
        } catch (DataModelException e) {
        // if exception occurs check for submodule
        }
        if (schemaNode == null) {
            List<YangInclude> includeList = ((YangModule) node).getIncludeList();
            // Checking requested node in submodule.
            schemaNode = getSubModlueChildNode(id, includeList);
        }
        return schemaNode;
    } else {
        log.error(E_NEXIST, ns);
    }
    return null;
}
#end_block

#method_before
default ConsistentMultimap<K, V> asMultimap() {
    return asMultimap(DEFAULT_OPERTATION_TIMEOUT_MILLIS);
}
#method_after
default ConsistentMultimap<K, V> asMultimap() {
    return asMultimap(DEFAULT_OPERATION_TIMEOUT_MILLIS);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(MultimapEventListener<K1, V1> listener) {
    InternalBackingMultimapEventListener backingMapListener = listeners.remove(listener);
    if (backingMapListener != null) {
        return backingMap.removeListener(backingMapListener);
    } else {
        return CompletableFuture.completedFuture(null);
    }
}
#method_after
@Override
public CompletableFuture<Void> removeListener(MultimapEventListener<K1, V1> listener) {
    synchronized (listeners) {
        InternalBackingMultimapEventListener backingMapListener = listeners.remove(listener);
        if (backingMapListener != null) {
            return backingMap.removeListener(backingMapListener);
        } else {
            return CompletableFuture.completedFuture(null);
        }
    }
}
#end_block

#method_before
@Test
public void getMaster() {
    put(VNID1, VDID3, N2, true, true);
    assertEquals("wrong role", MASTER, sms.getRole(VNID1, N2, VDID3));
    assertEquals("wrong device", N2, sms.getMaster(VNID1, VDID3));
}
#method_after
@Test
public void getMaster() {
    put(VNID1, VDID3, N2, true, true);
    assertEquals("wrong role", MASTER, sms.getRole(VNID1, N2, VDID3));
    assertEquals("wrong node", N2, sms.getMaster(VNID1, VDID3));
}
#end_block

#method_before
private synchronized boolean addToBackup(NetworkId networkId, DeviceId deviceId, NodeId nodeId) {
    Map<DeviceId, List<NodeId>> backups = getBackups(networkId);
    boolean modified = false;
    List<NodeId> stbys = backups.getOrDefault(deviceId, new ArrayList<>());
    if (nodeId != null && !stbys.contains(nodeId)) {
        stbys.add(nodeId);
        modified = true;
    }
    backups.put(deviceId, stbys);
    return modified;
}
#method_after
private synchronized boolean addToBackup(NetworkId networkId, DeviceId deviceId, NodeId nodeId) {
    Map<DeviceId, List<NodeId>> backups = getBackups(networkId);
    boolean modified = false;
    List<NodeId> stbys = backups.getOrDefault(deviceId, new ArrayList<>());
    if (nodeId != null && !stbys.contains(nodeId)) {
        stbys.add(nodeId);
        backups.put(deviceId, stbys);
        modified = true;
    }
    return modified;
}
#end_block

#method_before
@Override
public CompletableFuture<Void> setRole(NodeId instance, DeviceId deviceId, MastershipRole role) {
    return null;
}
#method_after
@Override
public CompletableFuture<Void> setRole(NodeId nodeId, DeviceId deviceId, MastershipRole role) {
    checkNotNull(nodeId, NODE_ID_NULL);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(role, ROLE_NULL);
    CompletableFuture<MastershipEvent> eventFuture = null;
    switch(role) {
        case MASTER:
            eventFuture = store.setMaster(networkId, nodeId, deviceId);
            break;
        case STANDBY:
            eventFuture = store.setStandby(networkId, nodeId, deviceId);
            break;
        case NONE:
            eventFuture = store.relinquishRole(networkId, nodeId, deviceId);
            break;
        default:
            log.info("Unknown role; ignoring");
            return CompletableFuture.completedFuture(null);
    }
    return eventFuture.thenAccept(this::post).thenApply(v -> null);
}
#end_block

#method_before
@Override
public MastershipRole getLocalRole(DeviceId deviceId) {
    return null;
}
#method_after
@Override
public MastershipRole getLocalRole(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getRole(networkId, localNodeId, deviceId);
}
#end_block

#method_before
@Override
public CompletableFuture<MastershipRole> requestRoleFor(DeviceId deviceId) {
    return null;
}
#method_after
@Override
public CompletableFuture<MastershipRole> requestRoleFor(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    final Timer.Context timer = startTimer(requestRoleTimer);
    return store.requestRole(networkId, deviceId).whenComplete((result, error) -> stopTimer(timer));
}
#end_block

#method_before
@Override
public CompletableFuture<Void> relinquishMastership(DeviceId deviceId) {
    return null;
}
#method_after
@Override
public CompletableFuture<Void> relinquishMastership(DeviceId deviceId) {
    return store.relinquishRole(networkId, localNodeId, deviceId).thenAccept(this::post).thenApply(v -> null);
}
#end_block

#method_before
@Override
public NodeId getMasterFor(DeviceId deviceId) {
    return null;
}
#method_after
@Override
public NodeId getMasterFor(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getMaster(networkId, deviceId);
}
#end_block

#method_before
@Override
public RoleInfo getNodesFor(DeviceId deviceId) {
    return null;
}
#method_after
@Override
public RoleInfo getNodesFor(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    return store.getNodes(networkId, deviceId);
}
#end_block

#method_before
@Override
public Set<DeviceId> getDevicesOf(NodeId nodeId) {
    return null;
}
#method_after
@Override
public Set<DeviceId> getDevicesOf(NodeId nodeId) {
    checkNotNull(nodeId, NODE_ID_NULL);
    return store.getDevices(networkId, nodeId);
}
#end_block

#method_before
@Override
public MastershipTerm getMastershipTerm(DeviceId deviceId) {
    return null;
}
#method_after
@Override
public MastershipTerm getMastershipTerm(DeviceId deviceId) {
    return store.getTermFor(networkId, deviceId);
}
#end_block

#method_before
@Override
public MetricsService metricsService() {
    return null;
}
#method_after
@Override
public MetricsService metricsService() {
    // TODO: support metric service for virtual network
    log.warn("Currently, virtual network does not support metric service.");
    return null;
}
#end_block

#method_before
@Override
public void balanceRoles() {
}
#method_after
@Override
public void balanceRoles() {
    // FIXME: More advanced logic for balancing virtual network roles.
    List<ControllerNode> nodes = newArrayList(clusterService.getNodes());
    nodes.sort(Comparator.comparing(ControllerNode::id));
    // Pick a node using network Id,
    NodeId masterNode = nodes.get((int) (networkId.id() % nodes.size())).id();
    List<CompletableFuture<Void>> setRoleFutures = Lists.newLinkedList();
    for (VirtualDevice device : manager.getVirtualDevices(networkId)) {
        setRoleFutures.add(setRole(masterNode, device.id(), MastershipRole.MASTER));
    }
    CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(setRoleFutures.toArray(new CompletableFuture[setRoleFutures.size()]));
    Futures.getUnchecked(balanceRolesFuture);
}
#end_block

#method_before
@Test
public void testNonEmptyOFAgentSet() throws IOException {
    expect(mockOFAgentService.agents()).andReturn(agents).anyTimes();
    replay(mockOFAgentService);
    final WebTarget wt = target();
    assertNotNull("WebTarget is null", wt);
    assertNotNull("WebTarget request is null", wt.request());
    final String response = wt.path("service/ofagents").request().get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("ofAgents"));
    assertThat(response, containsString("\"networkId\":\"1\""));
    assertThat(response, containsString("\"networkId\":\"2\""));
    verify(mockOFAgentService);
}
#method_after
@Test
public void testNonEmptyOFAgentSet() throws IOException {
    expect(mockOFAgentService.agents()).andReturn(agents).anyTimes();
    replay(mockOFAgentService);
    final WebTarget wt = target();
    assertNotNull("WebTarget is null", wt);
    assertNotNull("WebTarget request is null", wt.request());
    final String response = wt.path("service/ofagents").request().get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("ofAgents"));
    mockOFAgentService.agents().forEach(ofAgent -> {
        String expectedJsonStringNetworkId = "\"networkId\":\"" + ofAgent.networkId().id() + "\"";
        assertThat(response, containsString(expectedJsonStringNetworkId));
        String expectedJsonStringState = "\"state\":\"" + ofAgent.state() + "\"";
        assertThat(response, containsString(expectedJsonStringState));
        ofAgent.controllers().forEach(ofController -> {
            String expectedJsonStringIP = "\"ip\":\"" + ofController.ip() + "\"";
            assertThat(response, containsString(expectedJsonStringIP));
            String expectedJsonStringPort = "\"port\":\"" + ofController.port() + "\"";
            assertThat(response, containsString(expectedJsonStringPort));
        });
    });
    verify(mockOFAgentService);
}
#end_block

#method_before
@Test
public void testOFAgentCreateBadRequest() {
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request-ofagent-create.json");
    assertNotNull("post-bad-request-ofagent-create.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-create").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_INTERNAL_ERROR));
}
#method_after
@Test
public void testOFAgentCreateBadRequest() {
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request.json");
    assertNotNull("post-bad-request.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-create").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_INTERNAL_ERROR));
}
#end_block

#method_before
@Test
public void testOFAgentUpdate() {
    expect(mockOFAgentService.agent(eq(NETWORK))).andReturn(OF_AGENT).anyTimes();
    replay(mockOFAgentService);
    mockOFAgentAdminService.updateAgent(anyObject());
    expectLastCall().anyTimes();
    replay(mockOFAgentAdminService);
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-ofagent-update.json");
    assertNotNull("post-ofagent-update.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-update").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
    assertThat(response.readEntity(String.class), containsString("OFAgent updated"));
    verify(mockOFAgentService);
    verify(mockOFAgentAdminService);
}
#method_after
@Test
public void testOFAgentUpdate() {
    expect(mockOFAgentService.agent(eq(NETWORK))).andReturn(OF_AGENT).anyTimes();
    replay(mockOFAgentService);
    mockOFAgentAdminService.updateAgent(anyObject());
    expectLastCall().anyTimes();
    replay(mockOFAgentAdminService);
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("put-ofagent-update.json");
    assertNotNull("put-ofagent-update.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-update").request(MediaType.APPLICATION_JSON_TYPE).put(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
    assertThat(response.readEntity(String.class), containsString("OFAgent updated"));
    verify(mockOFAgentService);
    verify(mockOFAgentAdminService);
}
#end_block

#method_before
@Test
public void testNonExistentOFAgentUpdate() {
    expect(mockOFAgentService.agent(anyObject())).andReturn(null).anyTimes();
    replay(mockOFAgentService);
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-non-existent-ofagent-update.json");
    assertNotNull("post-non-existent-ofagent-update.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-update").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_NOT_FOUND));
    verify(mockOFAgentService);
}
#method_after
@Test
public void testNonExistentOFAgentUpdate() {
    expect(mockOFAgentService.agent(anyObject())).andReturn(null).anyTimes();
    replay(mockOFAgentService);
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("put-non-existent-ofagent-update.json");
    assertNotNull("put-non-existent-ofagent-update.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-update").request(MediaType.APPLICATION_JSON_TYPE).put(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_NOT_FOUND));
    verify(mockOFAgentService);
}
#end_block

#method_before
@Test
public void testOFAgentUpdateBadRequest() {
    expect(mockOFAgentService.agent(anyObject())).andReturn(null).anyTimes();
    replay(mockOFAgentService);
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request-ofagent-update.json");
    assertNotNull("post-bad-request-ofagent-update.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-update").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_INTERNAL_ERROR));
    verify(mockOFAgentService);
}
#method_after
@Test
public void testOFAgentUpdateBadRequest() {
    expect(mockOFAgentService.agent(anyObject())).andReturn(null).anyTimes();
    replay(mockOFAgentService);
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("put-bad-request.json");
    assertNotNull("put-bad-request.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-update").request(MediaType.APPLICATION_JSON_TYPE).put(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_INTERNAL_ERROR));
    verify(mockOFAgentService);
}
#end_block

#method_before
@Test
public void testOFAgentStartBadRequest() {
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request-ofagent-start.json");
    assertNotNull("post-bad-request-ofagent-start.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-start").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_BAD_REQUEST));
}
#method_after
@Test
public void testOFAgentStartBadRequest() {
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request.json");
    assertNotNull("post-bad-request.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-start").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_BAD_REQUEST));
}
#end_block

#method_before
@Test
public void testOFAgentStopBadRequest() {
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request-ofagent-stop.json");
    assertNotNull("post-bad-request-ofagent-stop.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-stop").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_INTERNAL_ERROR));
}
#method_after
@Test
public void testOFAgentStopBadRequest() {
    InputStream jsonStream = OFAgentWebResourceTest.class.getResourceAsStream("post-bad-request.json");
    assertNotNull("post-bad-request.json is null", jsonStream);
    WebTarget wt = target();
    Response response = wt.path("service/ofagent-stop").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_INTERNAL_ERROR));
}
#end_block

#method_before
@POST
@Path("ofagent-update")
@Consumes(MediaType.APPLICATION_JSON)
public Response updateOFAgent(InputStream stream) throws IOException {
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent ofAgent = (new OFAgentCodec()).decode((ObjectNode) mapper().readTree(stream), this);
    if (ofAgent == null) {
        return Response.status(NOT_FOUND).entity(OFAGENT_NOT_UPDATED).build();
    } else if (get(OFAgentService.class).agent(ofAgent.networkId()) == null) {
        return Response.status(NOT_FOUND).entity(OFAGENT_NOT_UPDATED).build();
    }
    adminService.updateAgent(ofAgent);
    return Response.status(OK).entity(OFAGENT_UPDATED).build();
}
#method_after
@PUT
@Path("ofagent-update")
@Consumes(MediaType.APPLICATION_JSON)
public Response updateOFAgent(InputStream stream) throws IOException {
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent ofAgent = (new OFAgentCodec()).decode((ObjectNode) mapper().readTree(stream), this);
    if (ofAgent == null) {
        return Response.status(NOT_FOUND).entity(OFAGENT_NOT_UPDATED).build();
    } else if (get(OFAgentService.class).agent(ofAgent.networkId()) == null) {
        return Response.status(NOT_FOUND).entity(OFAGENT_NOT_UPDATED).build();
    }
    adminService.updateAgent(ofAgent);
    return Response.status(OK).entity(OFAGENT_UPDATED).build();
}
#end_block

#method_before
@Override
public ObjectNode encode(OFController ofController, CodecContext context) {
    checkNotNull(ofController, "ApplicationId cannot be null");
    return context.mapper().createObjectNode().put(IP, String.valueOf(ofController.ip())).put(PORT, String.valueOf(ofController.port()));
}
#method_after
@Override
public ObjectNode encode(OFController ofController, CodecContext context) {
    checkNotNull(ofController, "OFController cannot be null");
    return context.mapper().createObjectNode().put(IP, String.valueOf(ofController.ip())).put(PORT, String.valueOf(ofController.port()));
}
#end_block

#method_before
public OFAgent decode(ObjectNode json, CodecContext context) {
    JsonNode networkId = json.get("networkId");
    checkNotNull(networkId);
    checkNotNull(json.get("controllers"));
    checkState(json.get("controllers").isArray());
    log.warn("controllers: " + json.get("controllers").toString());
    Set<OFController> controllers = Sets.newHashSet();
    json.get("controllers").forEach(jsonController -> controllers.add((new OFControllerCodec()).decode((ObjectNode) jsonController, context)));
    return DefaultOFAgent.builder().networkId(NetworkId.networkId(networkId.asLong())).controllers(controllers).state(OFAgent.State.STOPPED).build();
}
#method_after
public OFAgent decode(ObjectNode json, CodecContext context) {
    JsonNode networkId = json.get("networkId");
    checkNotNull(networkId);
    checkNotNull(json.get("controllers"));
    checkState(json.get("controllers").isArray());
    Set<OFController> controllers = Sets.newHashSet();
    json.get("controllers").forEach(jsonController -> controllers.add((new OFControllerCodec()).decode((ObjectNode) jsonController, context)));
    return DefaultOFAgent.builder().networkId(NetworkId.networkId(networkId.asLong())).controllers(controllers).state(OFAgent.State.STOPPED).build();
}
#end_block

#method_before
private void setProperties(Analyzer analyzer) {
    analyzer.setProperty(Analyzer.BUNDLE_NAME, bundleName);
    analyzer.setProperty(Analyzer.BUNDLE_SYMBOLICNAME, bundleSymbolicName);
    analyzer.setProperty(Analyzer.BUNDLE_VERSION, bundleVersion.replace('-', '.'));
    if (bundleDescription != null) {
        analyzer.setProperty(Analyzer.BUNDLE_DESCRIPTION, bundleDescription);
    }
    if (bundleLicense != null) {
        analyzer.setProperty(Analyzer.BUNDLE_LICENSE, bundleLicense);
    }
    // TODO consider using stricter version policy
    // analyzer.setProperty("-provider-policy", "${range;[===,==+)}");
    // analyzer.setProperty("-consumer-policy", "${range;[===,==+)}");
    // There are no good defaults so make sure you set the Import-Package
    analyzer.setProperty(Analyzer.IMPORT_PACKAGE, importPackages);
    if (privatePackages != null) {
        analyzer.setProperty(Analyzer.PRIVATE_PACKAGE, privatePackages);
    }
    analyzer.setProperty(Analyzer.REMOVEHEADERS, "Private-Package,Include-Resource");
    analyzer.setProperty(Analyzer.DYNAMICIMPORT_PACKAGE, dynamicimportPackages);
    // TODO include version in export, but not in import
    analyzer.setProperty(Analyzer.EXPORT_PACKAGE, exportPackages);
    // FIXME NOTE we handle this manually below
    if (includeResources != null) {
        analyzer.setProperty(Analyzer.INCLUDE_RESOURCE, includeResources);
    }
    if (embeddedDependencies != null) {
        analyzer.setProperty(Analyzer.BUNDLE_CLASSPATH, embeddedDependencies);
        analyzer.setProperty(Analyzer.INCLUDE_RESOURCE, includeResources + "," + embeddedDependencies);
    }
    if (isWab()) {
        analyzer.setProperty(Analyzer.WAB, "src/main/webapp/");
        analyzer.setProperty("Web-ContextPath", webContext);
        analyzer.setProperty(Analyzer.IMPORT_PACKAGE, "*,org.glassfish.jersey.servlet,org.jvnet.mimepull\n");
    }
}
#method_after
private void setProperties(Analyzer analyzer) {
    analyzer.setProperty(Analyzer.BUNDLE_NAME, bundleName);
    analyzer.setProperty(Analyzer.BUNDLE_SYMBOLICNAME, bundleSymbolicName);
    analyzer.setProperty(Analyzer.BUNDLE_VERSION, bundleVersion.replace('-', '.'));
    if (bundleDescription != null) {
        analyzer.setProperty(Analyzer.BUNDLE_DESCRIPTION, bundleDescription);
    }
    if (bundleLicense != null) {
        analyzer.setProperty(Analyzer.BUNDLE_LICENSE, bundleLicense);
    }
    // TODO consider using stricter version policy
    // analyzer.setProperty("-provider-policy", "${range;[===,==+)}");
    // analyzer.setProperty("-consumer-policy", "${range;[===,==+)}");
    // There are no good defaults so make sure you set the Import-Package
    analyzer.setProperty(Analyzer.IMPORT_PACKAGE, importPackages);
    if (privatePackages != null) {
        analyzer.setProperty(Analyzer.PRIVATE_PACKAGE, privatePackages);
    }
    analyzer.setProperty(Analyzer.REMOVEHEADERS, "Private-Package,Include-Resource");
    analyzer.setProperty(Analyzer.DYNAMICIMPORT_PACKAGE, dynamicimportPackages);
    // TODO include version in export, but not in import
    analyzer.setProperty(Analyzer.EXPORT_PACKAGE, exportPackages);
    // FIXME NOTE we handle this manually below
    if (includeResources != null) {
        analyzer.setProperty(Analyzer.INCLUDE_RESOURCE, includeResources);
    }
    if (embeddedDependencies != null) {
        analyzer.setProperty(Analyzer.BUNDLE_CLASSPATH, embeddedDependencies);
        String finalIncludes = Strings.isNullOrEmpty(includeResources) ? embeddedDependencies : (includeResources + "," + embeddedDependencies);
        analyzer.setProperty(Analyzer.INCLUDE_RESOURCE, finalIncludes);
    }
    if (isWab()) {
        analyzer.setProperty(Analyzer.WAB, "src/main/webapp/");
        analyzer.setProperty("Web-ContextPath", webContext);
        analyzer.setProperty(Analyzer.IMPORT_PACKAGE, "*,org.glassfish.jersey.servlet,org.jvnet.mimepull\n");
    }
}
#end_block

#method_before
public static SparseAnnotations combine(BasicLinkConfig cfg, SparseAnnotations an) {
    DefaultAnnotations.Builder b = DefaultAnnotations.builder();
    if (cfg.metric() != DEF_METRIC) {
        b.set(AnnotationKeys.METRIC, String.valueOf(cfg.metric()));
    }
    if (!cfg.latency().equals(DEF_DURATION)) {
        // Convert the latency from Duration to Double so that it's computable in the latencyConstraint.
        b.set(AnnotationKeys.LATENCY, String.valueOf(cfg.latency().toNanos()));
    }
    if (cfg.bandwidth() != DEF_BANDWIDTH) {
        b.set(AnnotationKeys.BANDWIDTH, String.valueOf(cfg.bandwidth()));
    }
    if (cfg.isDurable() != null) {
        b.set(AnnotationKeys.DURABLE, String.valueOf(cfg.isDurable()));
    }
    return DefaultAnnotations.union(an, b.build());
}
#method_after
public static SparseAnnotations combine(BasicLinkConfig cfg, SparseAnnotations an) {
    DefaultAnnotations.Builder b = DefaultAnnotations.builder();
    if (cfg.metric() != DEF_METRIC) {
        b.set(AnnotationKeys.METRIC, String.valueOf(cfg.metric()));
    }
    if (!cfg.latency().equals(DEF_DURATION)) {
        // Convert the latency from Duration to long,
        // so that it's computable in the latencyConstraint.
        b.set(AnnotationKeys.LATENCY, String.valueOf(cfg.latency().toNanos()));
    }
    if (cfg.bandwidth() != DEF_BANDWIDTH) {
        b.set(AnnotationKeys.BANDWIDTH, String.valueOf(cfg.bandwidth()));
    }
    if (cfg.isDurable() != null) {
        b.set(AnnotationKeys.DURABLE, String.valueOf(cfg.isDurable()));
    }
    return DefaultAnnotations.union(an, b.build());
}
#end_block

#method_before
private double cost(Link link) {
    // Check only links, not EdgeLinks
    if (link.src().elementId() instanceof DeviceId && link.dst().elementId() instanceof DeviceId) {
        return getAnnotatedValue(link, LATENCY);
    } else {
        return 0;
    }
}
#method_after
private double cost(Link link) {
    // Check only links, not EdgeLinks
    if (link.type() != Link.Type.EDGE) {
        return link.annotations().value(LATENCY) != null ? getAnnotatedValue(link, LATENCY) : 0;
    } else {
        return 0;
    }
}
#end_block

#method_before
protected List<Constraint> buildConstraints() {
    final List<Constraint> constraints = new LinkedList<>();
    // Check for a bandwidth specification
    if (!isNullOrEmpty(bandwidthString)) {
        Bandwidth bandwidth;
        try {
            bandwidth = Bandwidth.bps(Long.parseLong(bandwidthString));
        // when the string can't be parsed as long, then try to parse as double
        } catch (NumberFormatException e) {
            bandwidth = Bandwidth.bps(Double.parseDouble(bandwidthString));
        }
        constraints.add(new BandwidthConstraint(bandwidth));
    }
    // Check for partial failure specification
    if (partial) {
        constraints.add(new PartialFailureConstraint());
    }
    // Check for encapsulation specification
    if (!isNullOrEmpty(encapsulationString)) {
        final EncapsulationType encapType = EncapsulationType.valueOf(encapsulationString);
        constraints.add(new EncapsulationConstraint(encapType));
    }
    // Check for hashed path selection
    if (hashedPathSelection) {
        constraints.add(new HashedPathSelectionConstraint());
    }
    // Check for domain processing
    if (domains) {
        constraints.add(DomainConstraint.domain());
    }
    if (!isNullOrEmpty(latconstraint)) {
        long lat = Long.parseLong(latconstraint);
        constraints.add(new LatencyConstraint(Duration.of(lat, ChronoUnit.NANOS)));
    }
    return constraints;
}
#method_after
protected List<Constraint> buildConstraints() {
    final List<Constraint> constraints = new LinkedList<>();
    // Check for a bandwidth specification
    if (!isNullOrEmpty(bandwidthString)) {
        Bandwidth bandwidth;
        try {
            bandwidth = Bandwidth.bps(Long.parseLong(bandwidthString));
        // when the string can't be parsed as long, then try to parse as double
        } catch (NumberFormatException e) {
            bandwidth = Bandwidth.bps(Double.parseDouble(bandwidthString));
        }
        constraints.add(new BandwidthConstraint(bandwidth));
    }
    // Check for partial failure specification
    if (partial) {
        constraints.add(new PartialFailureConstraint());
    }
    // Check for encapsulation specification
    if (!isNullOrEmpty(encapsulationString)) {
        final EncapsulationType encapType = EncapsulationType.valueOf(encapsulationString);
        constraints.add(new EncapsulationConstraint(encapType));
    }
    // Check for hashed path selection
    if (hashedPathSelection) {
        constraints.add(new HashedPathSelectionConstraint());
    }
    // Check for domain processing
    if (domains) {
        constraints.add(DomainConstraint.domain());
    }
    // Check for a latency specification
    if (!isNullOrEmpty(latConstraint)) {
        try {
            long lat = Long.parseLong(latConstraint);
            constraints.add(new LatencyConstraint(Duration.of(lat, ChronoUnit.NANOS)));
        } catch (NumberFormatException e) {
            double lat = Double.parseDouble(latConstraint);
            constraints.add(new LatencyConstraint(Duration.of((long) lat, ChronoUnit.NANOS)));
        }
    }
    return constraints;
}
#end_block

#method_before
public static IntentData assign(IntentData data, Timestamp timestamp, NodeId node) {
    IntentData assigned = new IntentData(checkNotNull(data), checkNotNull(timestamp));
    assigned.origin = checkNotNull(node);
    assigned.internalStateVersion++;
    return assigned;
}
#method_after
public static IntentData assign(IntentData data, Timestamp timestamp, NodeId node) {
    IntentData assigned = new IntentData(data, checkNotNull(timestamp));
    assigned.origin = checkNotNull(node);
    assigned.internalStateVersion++;
    return assigned;
}
#end_block

#method_before
public static IntentData copy(IntentData data) {
    return new IntentData(checkNotNull(data));
}
#method_after
public static IntentData copy(IntentData data) {
    return new IntentData(data);
}
#end_block

#method_before
public static IntentData nextState(IntentData data, IntentState nextState) {
    IntentData next = new IntentData(checkNotNull(data));
    // TODO state machine sanity check
    next.setState(checkNotNull(nextState));
    return next;
}
#method_after
public static IntentData nextState(IntentData data, IntentState nextState) {
    IntentData next = new IntentData(data);
    // TODO state machine sanity check
    next.setState(checkNotNull(nextState));
    return next;
}
#end_block

#method_before
public static IntentData compiled(IntentData data, List<Intent> installables) {
    return new IntentData(checkNotNull(data), checkNotNull(installables));
}
#method_after
public static IntentData compiled(IntentData data, List<Intent> installables) {
    return new IntentData(data, checkNotNull(installables));
}
#end_block

#method_before
private void finish(IntentInstallationContext intentInstallationContext) {
    Set<IntentOperationContext> errCtxs = intentInstallationContext.errorContexts();
    Optional<IntentData> toUninstall = intentInstallationContext.toUninstall();
    Optional<IntentData> toInstall = intentInstallationContext.toInstall();
    // Intent install success
    if (errCtxs == null || errCtxs.isEmpty()) {
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.debug("Completed installing: {}:{}", installData.key(), installData.intent().id());
            installData = new IntentData(installData, installData.installables());
            installData.setState(INSTALLED);
            intentStore.write(installData);
        } else if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData = new IntentData(uninstallData, Collections.emptyList());
            log.debug("Completed withdrawing: {}:{}", uninstallData.key(), uninstallData.intent().id());
            switch(uninstallData.request()) {
                case INSTALL_REQ:
                    // INSTALLED intent was damaged & clean up is now complete
                    uninstallData.setState(FAILED);
                    break;
                case WITHDRAW_REQ:
                default:
                    // TODO "default" case should not happen
                    uninstallData.setState(WITHDRAWN);
                    break;
            }
            // Intent has been withdrawn; we can clear the installables
            intentStore.write(uninstallData);
        }
    } else {
        // if toInstall was cause of error, then recompile (manage/increment counter, when exceeded -> CORRUPT)
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            installData.setState(CORRUPT);
            installData.incrementErrorCount();
            intentStore.write(installData);
        }
        // if toUninstall was cause of error, then CORRUPT (another job will clean this up)
        if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData.setState(CORRUPT);
            uninstallData.incrementErrorCount();
            intentStore.write(uninstallData);
        }
    }
}
#method_after
private void finish(IntentInstallationContext intentInstallationContext) {
    Set<IntentOperationContext> errCtxs = intentInstallationContext.errorContexts();
    Optional<IntentData> toUninstall = intentInstallationContext.toUninstall();
    Optional<IntentData> toInstall = intentInstallationContext.toInstall();
    // Intent install success
    if (errCtxs == null || errCtxs.isEmpty()) {
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.debug("Completed installing: {}:{}", installData.key(), installData.intent().id());
            installData = new IntentData(installData, installData.installables());
            installData.setState(INSTALLED);
            intentStore.write(installData);
        } else if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData = new IntentData(uninstallData, Collections.emptyList());
            log.debug("Completed withdrawing: {}:{}", uninstallData.key(), uninstallData.intent().id());
            switch(uninstallData.request()) {
                case INSTALL_REQ:
                    // INSTALLED intent was damaged & clean up is now complete
                    uninstallData.setState(FAILED);
                    break;
                case WITHDRAW_REQ:
                default:
                    // TODO "default" case should not happen
                    uninstallData.setState(WITHDRAWN);
                    break;
            }
            // Intent has been withdrawn; we can clear the installables
            intentStore.write(uninstallData);
        }
    } else {
        // if toInstall was cause of error, then recompile (manage/increment counter, when exceeded -> CORRUPT)
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            intentStore.write(IntentData.corrupt(installData));
        }
        // if toUninstall was cause of error, then CORRUPT (another job will clean this up)
        if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            intentStore.write(IntentData.corrupt(uninstallData));
        }
    }
}
#end_block

#method_before
@Test
public void testClear() throws Exception {
    EventuallyConsistentMapListener<String, String> listener = getListener();
    listener.event(new EventuallyConsistentMapEvent<>(MAP_NAME, EventuallyConsistentMapEvent.Type.REMOVE, KEY1, VALUE1));
    listener.event(new EventuallyConsistentMapEvent<>(MAP_NAME, EventuallyConsistentMapEvent.Type.REMOVE, KEY2, VALUE2));
    replay(listener);
    // clear() on an empty map is a no-op - no messages will be sent
    reset(clusterCommunicator);
    replay(clusterCommunicator);
    assertTrue(ecMap.isEmpty());
    ecMap.clear();
    verify(clusterCommunicator);
    // Put some items in the map
    expectPeerMessage(clusterCommunicator);
    ecMap.put(KEY1, VALUE1);
    ecMap.put(KEY2, VALUE2);
    ecMap.addListener(listener);
    expectSpecificBroadcastMessage(generateRemoveMessage(KEY1, KEY2), UPDATE_MESSAGE_SUBJECT, clusterCommunicator);
    ecMap.clear();
    verify(clusterCommunicator);
    verify(listener);
}
#method_after
@Test
public void testClear() throws Exception {
    EventuallyConsistentMapListener<String, String> listener = getListener();
    listener.event(new EventuallyConsistentMapEvent<>(MAP_NAME, EventuallyConsistentMapEvent.Type.PUT, KEY1, VALUE1));
    listener.event(new EventuallyConsistentMapEvent<>(MAP_NAME, EventuallyConsistentMapEvent.Type.PUT, KEY2, VALUE2));
    listener.event(new EventuallyConsistentMapEvent<>(MAP_NAME, EventuallyConsistentMapEvent.Type.REMOVE, KEY1, VALUE1));
    listener.event(new EventuallyConsistentMapEvent<>(MAP_NAME, EventuallyConsistentMapEvent.Type.REMOVE, KEY2, VALUE2));
    replay(listener);
    // clear() on an empty map is a no-op - no messages will be sent
    reset(clusterCommunicator);
    replay(clusterCommunicator);
    assertTrue(ecMap.isEmpty());
    ecMap.clear();
    verify(clusterCommunicator);
    // Put some items in the map
    expectPeerMessage(clusterCommunicator);
    ecMap.put(KEY1, VALUE1);
    ecMap.put(KEY2, VALUE2);
    ecMap.addListener(listener);
    expectSpecificBroadcastMessage(generateRemoveMessage(KEY1, KEY2), UPDATE_MESSAGE_SUBJECT, clusterCommunicator);
    ecMap.clear();
    verify(clusterCommunicator);
    verify(listener);
}
#end_block

#method_before
@Override
public void addListener(EventuallyConsistentMapListener<K, V> listener) {
    checkState(!destroyed, destroyedMessage);
    listeners.add(checkNotNull(listener));
}
#method_after
@Override
public void addListener(EventuallyConsistentMapListener<K, V> listener) {
    checkState(!destroyed, destroyedMessage);
    listeners.add(checkNotNull(listener));
    items.forEach((k, v) -> {
        if (v.isAlive()) {
            listener.event(new EventuallyConsistentMapEvent<K, V>(mapName, PUT, k, v.get()));
        }
    });
}
#end_block

#method_before
private String getPortServiceState(DeviceId deviceId, PortNumber portNumber) {
    if (deviceService.getDevice(deviceId).type() != Type.FIBER_SWITCH) {
        return RoadmUtil.NA;
    }
    Map<ConnectPoint, ProtectedTransportEndpointState> map = roadmService.getProtectionSwitchStates(deviceId);
    String portState = null;
    for (ProtectedTransportEndpointState state : map.values()) {
        for (TransportEndpointState element : state.pathStates()) {
            if (element.description().output().connectPoint().port().equals(portNumber)) {
                portState = element.attributes().get(OpticalAnnotations.INPUT_PORT_STATUS);
                break;
            }
        }
    }
    return RoadmUtil.defaultString(portState, RoadmUtil.UNKNOWN);
}
#method_after
private String getPortServiceState(DeviceId deviceId, PortNumber portNumber) {
    if (deviceService.getDevice(deviceId).type() != Type.FIBER_SWITCH) {
        return RoadmUtil.NA;
    }
    Map<ConnectPoint, ProtectedTransportEndpointState> map = roadmService.getProtectionSwitchStates(deviceId);
    for (ProtectedTransportEndpointState state : map.values()) {
        for (TransportEndpointState element : state.pathStates()) {
            if (element.description().output().connectPoint().port().equals(portNumber)) {
                return RoadmUtil.defaultString(element.attributes().get(OpticalAnnotations.INPUT_PORT_STATUS), RoadmUtil.UNKNOWN);
            }
        }
    }
    return RoadmUtil.UNKNOWN;
}
#end_block

#method_before
private void putProtectionSwitchPaths(DeviceId deviceId, ObjectNode node) {
    Map<ConnectPoint, ProtectedTransportEndpointState> states = roadmService.getProtectionSwitchStates(deviceId);
    ConnectPoint identifier = states.keySet().toArray(new ConnectPoint[0])[0];
    ArrayNode nodes = node.putArray(OPS_PATHS);
    nodes.add(new ObjectNode(JsonNodeFactory.instance).put(OPS_ARRAY_INDEX, ACTIVE_UNKNOWN).put(OPS_ARRAY_OPERATION, OPS_OPT_AUTO).put(OPS_ARRAY_NAME, OPS_OPT_AUTO));
    String[] operations = { OPS_OPT_FORCE, OPS_OPT_MANUAL };
    for (String opt : operations) {
        int index = 0;
        for (TransportEndpointState state : states.get(identifier).pathStates()) {
            String id = state.id().id().toUpperCase();
            nodes.add(new ObjectNode(JsonNodeFactory.instance).put(OPS_ARRAY_INDEX, index++).put(OPS_ARRAY_OPERATION, opt).put(OPS_ARRAY_NAME, String.format("%s %s", opt, id)));
        }
    }
}
#method_after
private void putProtectionSwitchPaths(DeviceId deviceId, ObjectNode node) {
    Map<ConnectPoint, ProtectedTransportEndpointState> states = roadmService.getProtectionSwitchStates(deviceId);
    ArrayNode nodes = node.putArray(OPS_PATHS);
    // Add path names for every identifier.
    int groupIndex = 0;
    for (ConnectPoint identifier : states.keySet()) {
        // No group name needed if there is only one connection point identifier.
        String groupName = states.keySet().size() == 1 ? "" : String.format(OPS_GROUP_FMT, ++groupIndex);
        // Add AUTOMATIC operation.
        nodes.add(new ObjectNode(JsonNodeFactory.instance).put(OPS_ARRAY_INDEX, ACTIVE_UNKNOWN).put(OPS_ARRAY_OPERATION, OPS_OPT_AUTO).put(OPS_ARRAY_NAME, String.format("%s%s", groupName, OPS_OPT_AUTO)));
        // Add FORCE and MANUAL operations for every path.
        for (String opt : OPS_NON_AUTO_OPTS) {
            int pathIndex = 0;
            for (TransportEndpointState state : states.get(identifier).pathStates()) {
                nodes.add(new ObjectNode(JsonNodeFactory.instance).put(OPS_ARRAY_INDEX, pathIndex++).put(OPS_ARRAY_OPERATION, opt).put(OPS_ARRAY_NAME, String.format("%s%s %s", groupName, opt, state.id().id().toUpperCase())));
            }
        }
    }
}
#end_block

#method_before
@Override
public Map<ConnectPoint, ProtectedTransportEndpointState> getProtectionSwitchStates(DeviceId deviceId) {
    checkNotNull(deviceId);
    ProtectionConfigBehaviour behaviour = getProtectionConfig(deviceId);
    if (behaviour == null) {
        return ImmutableMap.of();
    }
    Map<ConnectPoint, ProtectedTransportEndpointState> map;
    try {
        map = behaviour.getProtectionEndpointStates().get();
    } catch (InterruptedException e1) {
        log.error("Interrupted.", e1);
        return ImmutableMap.of();
    } catch (ExecutionException e1) {
        log.error("Exception caught.", e1);
        return ImmutableMap.of();
    }
    return map;
}
#method_after
@Override
public Map<ConnectPoint, ProtectedTransportEndpointState> getProtectionSwitchStates(DeviceId deviceId) {
    checkNotNull(deviceId);
    ProtectionConfigBehaviour behaviour = getProtectionConfig(deviceId);
    if (behaviour == null) {
        return ImmutableMap.of();
    }
    return getProtectionSwitchStates(behaviour);
}
#end_block

#method_before
private void delayedSetAttenuation(DeviceId deviceId, PortNumber outPort, OchSignal ochSignal, long attenuation) {
    Runnable setAtt = () -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            log.warn("Thread interrupted. Setting attenuation early.");
        }
        setAttenuation(deviceId, outPort, ochSignal, attenuation);
    };
    new Thread(setAtt).start();
}
#method_after
private void delayedSetAttenuation(DeviceId deviceId, PortNumber outPort, OchSignal ochSignal, long attenuation) {
    Runnable setAtt = () -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            log.warn("Thread interrupted. Setting attenuation early.");
            Thread.currentThread().interrupt();
        }
        setAttenuation(deviceId, outPort, ochSignal, attenuation);
    };
    new Thread(setAtt).start();
}
#end_block

#method_before
@Override
public Map<ConnectPoint, ProtectedTransportEndpointState> getProtectionSwitchStates(DeviceId deviceId) {
    checkNotNull(deviceId);
    ProtectionConfigBehaviour behaviour = getProtectionConfig(deviceId);
    if (behaviour == null) {
        return ImmutableMap.of();
    }
    Map<ConnectPoint, ProtectedTransportEndpointState> map;
    try {
        map = behaviour.getProtectionEndpointStates().get();
    } catch (InterruptedException e1) {
        log.error("Interrupted.", e1);
        return ImmutableMap.of();
    } catch (ExecutionException e1) {
        log.error("Exception caught.", e1);
        return ImmutableMap.of();
    }
    return map;
}
#method_after
private Map<ConnectPoint, ProtectedTransportEndpointState> getProtectionSwitchStates(ProtectionConfigBehaviour behaviour) {
    Map<ConnectPoint, ProtectedTransportEndpointState> map;
    try {
        map = behaviour.getProtectionEndpointStates().get();
    } catch (InterruptedException e1) {
        log.error("Interrupted.", e1);
        Thread.currentThread().interrupt();
        return ImmutableMap.of();
    } catch (ExecutionException e1) {
        log.error("Exception caught.", e1);
        return ImmutableMap.of();
    }
    return map;
}
#end_block

#method_before
@Override
public int hashCode() {
    return values().hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(values());
}
#end_block

#method_before
@Override
public Set<DeviceId> getPhysicalDevices(NetworkId networkId, DeviceId deviceId) {
    checkNotNull(networkId, "Network ID cannot be null");
    checkNotNull(deviceId, "Virtual device ID cannot be null");
    return store.getPhysicalDevices(networkId, deviceId);
}
#method_after
@Override
public Set<DeviceId> getPhysicalDevices(NetworkId networkId, DeviceId deviceId) {
    checkNotNull(networkId, "Network ID cannot be null");
    checkNotNull(deviceId, "Virtual device ID cannot be null");
    Set<VirtualPort> virtualPortSet = getVirtualPorts(networkId, deviceId);
    Set<DeviceId> physicalDeviceSet = new HashSet<>();
    virtualPortSet.forEach(virtualPort -> {
        if (virtualPort.realizedBy() != null) {
            physicalDeviceSet.add(virtualPort.realizedBy().deviceId());
        }
    });
    return ImmutableSet.copyOf(physicalDeviceSet);
}
#end_block

#method_before
private boolean switchDevice(PortNumber port) {
    deleteFlow();
    addFlow(port);
    return true;
}
#method_after
private boolean switchDevice(PortNumber port) {
    // TODO
    // If the flow operations do not go through, the controller would be in an inconsistent state.
    // Using listener can be a hack to imitate async API, to workaround the issue.
    // But can probably get tricky to do it correctly, ensuring not leaving dangling listener, etc.
    deleteFlow();
    addFlow(port);
    return true;
}
#end_block

#method_before
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        NiciraResubmit resubmit = (NiciraResubmit) extensionTreatment;
        return factory.actions().niciraResubmit((int) resubmit.inPort().toLong(), resubmit.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        NiciraResubmitTable resubmitTable = (NiciraResubmitTable) extensionTreatment;
        return factory.actions().niciraResubmitTable((int) resubmitTable.inPort().toLong(), resubmitTable.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        NiciraSetNshSpi niciraNshSpi = (NiciraSetNshSpi) extensionTreatment;
        return factory.actions().setField(factory.oxms().nsp(U32.of(niciraNshSpi.nshSpi().servicePathId())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        NiciraSetNshSi niciraNshSi = (NiciraSetNshSi) extensionTreatment;
        return factory.actions().setField(factory.oxms().nsi(U8.of(niciraNshSi.nshSi().serviceIndex())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC1(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC2(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC3(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC4(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_MDTYPE.type())) {
        NiciraNshMdType niciraNshMdType = (NiciraNshMdType) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshMdtype(U8.of(niciraNshMdType.nshMdType())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_NP.type())) {
        NiciraNshNp niciraNshNp = (NiciraNshNp) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshNp(U8.of(niciraNshNp.nshNp())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_SRC.type())) {
        NiciraEncapEthSrc niciraEncapEthSrc = (NiciraEncapEthSrc) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthSrc(MacAddress.of(niciraEncapEthSrc.encapEthSrc().toBytes())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_DST.type())) {
        NiciraEncapEthDst niciraEncapEthDst = (NiciraEncapEthDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthDst(MacAddress.of(niciraEncapEthDst.encapEthDst().toBytes())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_TYPE.type())) {
        NiciraEncapEthType niciraEncapEthType = (NiciraEncapEthType) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthType(U16.of(niciraEncapEthType.encapEthType())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_PUSH_NSH.type())) {
        return factory.actions().niciraPushNsh();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_POP_NSH.type())) {
        return factory.actions().niciraPopNsh();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_TUN_GPE_NP.type())) {
        NiciraTunGpeNp niciraTunGpeNp = (NiciraTunGpeNp) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunGpeNp(U8.of(niciraTunGpeNp.tunGpeNp())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C1_TO_C1.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_C2.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C3_TO_C3.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C4_TO_C4.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_IPV4_DST_TO_TUN_IPV4_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_ID_TO_TUN_ID.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_TUN_ID.type())) {
        MoveExtensionTreatment mov = (MoveExtensionTreatment) extensionTreatment;
        OFActionNiciraMove.Builder action = factory.actions().buildNiciraMove();
        action.setDstOfs(mov.dstOffset());
        action.setSrcOfs(mov.srcOffset());
        action.setNBits(mov.nBits());
        action.setSrc(mov.src());
        action.setDst(mov.dst());
        return action.build();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_CT.type())) {
        NiciraCt niciraCt = (NiciraCt) extensionTreatment;
        OFActionNiciraCt.Builder action = factory.actions().buildNiciraCt();
        action.setFlags(niciraCt.NiciraCtFlags());
        action.setZoneSrc(niciraCt.NiciraCtZoneSrc());
        action.setZone(niciraCt.NiciraCtZone());
        action.setRecircTable(niciraCt.NiciraCtRecircTable());
        action.setAlg(niciraCt.NiciraCtAlg());
        return action.build();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NAT.type())) {
        NiciraNat niciraNat = (NiciraNat) extensionTreatment;
        OFActionNiciraNat.Builder action = factory.actions().buildNiciraNat();
        action.setFlags(niciraNat.NiciraNatFlags());
        int presetFlags = niciraNat.NiciraNatPresentFlags();
        action.setRangePresent(presetFlags);
        List<IPv4Address> ipv4RangeList = Lists.newArrayList();
        List<IPv6Address> ipv6RangeList = Lists.newArrayList();
        List<U16> portRangeList = Lists.newArrayList();
        List<U8> padList = Lists.newArrayList();
        if ((presetFlags & NAT_RANGE_IPV4_MIN) != 0) {
            ipv4RangeList.add(IPv4Address.of(niciraNat.NiciraNatIpAddressMin().getIp4Address().toString()));
        }
        if ((presetFlags & NAT_RANGE_IPV4_MAX) != 0) {
            ipv4RangeList.add(IPv4Address.of(niciraNat.NiciraNatIpAddressMax().getIp4Address().toString()));
        }
        if ((presetFlags & NAT_RANGE_IPV6_MIN) != 0) {
            ipv6RangeList.add(IPv6Address.of(niciraNat.NiciraNatIpAddressMin().getIp6Address().toString()));
        }
        if ((presetFlags & NAT_RANGE_IPV6_MAX) != 0) {
            ipv6RangeList.add(IPv6Address.of(niciraNat.NiciraNatIpAddressMax().getIp6Address().toString()));
        }
        if ((presetFlags & NAT_RANGE_PROTO_MIN) != 0) {
            portRangeList.add(U16.of(niciraNat.NiciraNatPortMin()));
        }
        if ((presetFlags & NAT_RANGE_PROTO_MAX) != 0) {
            portRangeList.add(U16.of(niciraNat.NiciraNatPortMax()));
        }
        for (; (ipv6RangeList.size() * 16 + ipv4RangeList.size() * 4 + portRangeList.size() * 2 + padList.size()) % 8 != 0; ) {
            padList.add(U8.ofRaw((byte) 0));
        }
        action.setIpv4Range(ipv4RangeList);
        action.setIpv6Range(ipv6RangeList);
        action.setPortRange(portRangeList);
        action.setPad(padList);
        // nat action must be nested in ct action
        OFActionNiciraCt.Builder ctAction = factory.actions().buildNiciraCt();
        List<OFAction> actions = Lists.newArrayList();
        actions.add(action.build());
        int ctFlags = CT_COMMIT;
        if ((niciraNat.NiciraNatFlags() | presetFlags) == 0) {
            ctFlags = 0;
        }
        ctAction.setFlags(ctFlags);
        ctAction.setRecircTable((short) 0xff);
        ctAction.setNatAction(actions);
        return ctAction.build();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_CT_CLEAR.type())) {
        return factory.actions().niciraCtClear();
    }
    return null;
}
#method_after
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        NiciraResubmit resubmit = (NiciraResubmit) extensionTreatment;
        return factory.actions().niciraResubmit((int) resubmit.inPort().toLong(), resubmit.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        NiciraResubmitTable resubmitTable = (NiciraResubmitTable) extensionTreatment;
        return factory.actions().niciraResubmitTable((int) resubmitTable.inPort().toLong(), resubmitTable.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        NiciraSetNshSpi niciraNshSpi = (NiciraSetNshSpi) extensionTreatment;
        return factory.actions().setField(factory.oxms().nsp(U32.of(niciraNshSpi.nshSpi().servicePathId())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        NiciraSetNshSi niciraNshSi = (NiciraSetNshSi) extensionTreatment;
        return factory.actions().setField(factory.oxms().nsi(U8.of(niciraNshSi.nshSi().serviceIndex())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC1(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC2(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC3(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC4(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_MDTYPE.type())) {
        NiciraNshMdType niciraNshMdType = (NiciraNshMdType) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshMdtype(U8.of(niciraNshMdType.nshMdType())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_NP.type())) {
        NiciraNshNp niciraNshNp = (NiciraNshNp) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshNp(U8.of(niciraNshNp.nshNp())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_SRC.type())) {
        NiciraEncapEthSrc niciraEncapEthSrc = (NiciraEncapEthSrc) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthSrc(MacAddress.of(niciraEncapEthSrc.encapEthSrc().toBytes())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_DST.type())) {
        NiciraEncapEthDst niciraEncapEthDst = (NiciraEncapEthDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthDst(MacAddress.of(niciraEncapEthDst.encapEthDst().toBytes())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_TYPE.type())) {
        NiciraEncapEthType niciraEncapEthType = (NiciraEncapEthType) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthType(U16.of(niciraEncapEthType.encapEthType())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_PUSH_NSH.type())) {
        return factory.actions().niciraPushNsh();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_POP_NSH.type())) {
        return factory.actions().niciraPopNsh();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_TUN_GPE_NP.type())) {
        NiciraTunGpeNp niciraTunGpeNp = (NiciraTunGpeNp) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunGpeNp(U8.of(niciraTunGpeNp.tunGpeNp())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C1_TO_C1.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_C2.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C3_TO_C3.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C4_TO_C4.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_IPV4_DST_TO_TUN_IPV4_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_ID_TO_TUN_ID.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_TUN_ID.type())) {
        MoveExtensionTreatment mov = (MoveExtensionTreatment) extensionTreatment;
        OFActionNiciraMove.Builder action = factory.actions().buildNiciraMove();
        action.setDstOfs(mov.dstOffset());
        action.setSrcOfs(mov.srcOffset());
        action.setNBits(mov.nBits());
        action.setSrc(mov.src());
        action.setDst(mov.dst());
        return action.build();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_CT.type())) {
        NiciraCt niciraCt = (NiciraCt) extensionTreatment;
        OFActionNiciraCt.Builder ctAction = factory.actions().buildNiciraCt();
        ctAction.setFlags(niciraCt.niciraCtFlags());
        ctAction.setZoneSrc(niciraCt.niciraCtZoneSrc());
        ctAction.setZone(niciraCt.niciraCtZone());
        ctAction.setRecircTable(niciraCt.niciraCtRecircTable());
        ctAction.setAlg(niciraCt.niciraCtAlg());
        for (ExtensionTreatment nestedTreatment : niciraCt.niciraCtNestActions()) {
            if (nestedTreatment instanceof NiciraNat) {
                NiciraNat niciraNat = (NiciraNat) nestedTreatment;
                OFActionNiciraNat.Builder action = factory.actions().buildNiciraNat();
                action.setFlags(niciraNat.niciraNatFlags());
                int presetFlags = niciraNat.niciraNatPresentFlags();
                action.setRangePresent(presetFlags);
                List<IPv4Address> ipv4RangeList = Lists.newArrayList();
                List<IPv6Address> ipv6RangeList = Lists.newArrayList();
                List<U16> portRangeList = Lists.newArrayList();
                List<U8> padList = Lists.newArrayList();
                if ((presetFlags & NAT_RANGE_IPV4_MIN) != 0) {
                    ipv4RangeList.add(IPv4Address.of(niciraNat.niciraNatIpAddressMin().getIp4Address().toString()));
                }
                if ((presetFlags & NAT_RANGE_IPV4_MAX) != 0) {
                    ipv4RangeList.add(IPv4Address.of(niciraNat.niciraNatIpAddressMax().getIp4Address().toString()));
                }
                if ((presetFlags & NAT_RANGE_IPV6_MIN) != 0) {
                    ipv6RangeList.add(IPv6Address.of(niciraNat.niciraNatIpAddressMin().getIp6Address().toString()));
                }
                if ((presetFlags & NAT_RANGE_IPV6_MAX) != 0) {
                    ipv6RangeList.add(IPv6Address.of(niciraNat.niciraNatIpAddressMax().getIp6Address().toString()));
                }
                if ((presetFlags & NAT_RANGE_PROTO_MIN) != 0) {
                    portRangeList.add(U16.of(niciraNat.niciraNatPortMin()));
                }
                if ((presetFlags & NAT_RANGE_PROTO_MAX) != 0) {
                    portRangeList.add(U16.of(niciraNat.niciraNatPortMax()));
                }
                for (; (ipv6RangeList.size() * 16 + ipv4RangeList.size() * 4 + portRangeList.size() * 2 + padList.size()) % 8 != 0; ) {
                    padList.add(U8.ofRaw((byte) 0));
                }
                action.setIpv4Range(ipv4RangeList);
                action.setIpv6Range(ipv6RangeList);
                action.setPortRange(portRangeList);
                action.setPad(padList);
                // nat action must be nested in ct action
                List<OFAction> actions = Lists.newArrayList();
                actions.add(action.build());
                ctAction.setActions(actions);
            }
        }
        return ctAction.build();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_CT_CLEAR.type())) {
        return factory.actions().niciraCtClear();
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case TUNNEL_IPV4_DST:
                OFOxmTunnelIpv4Dst tunnelIpv4Dst = (OFOxmTunnelIpv4Dst) oxm;
                return new NiciraSetTunnelDst(Ip4Address.valueOf(tunnelIpv4Dst.getValue().getInt()));
            case NSP:
                OFOxmNsp nsp = (OFOxmNsp) oxm;
                return new NiciraSetNshSpi(NshServicePathId.of((nsp.getValue().getRaw())));
            case NSI:
                OFOxmNsi nsi = (OFOxmNsi) oxm;
                return new NiciraSetNshSi(NshServiceIndex.of((nsi.getValue().getRaw())));
            case NSH_C1:
                OFOxmNshC1 nshC1 = (OFOxmNshC1) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC1.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type());
            case NSH_C2:
                OFOxmNshC2 nshC2 = (OFOxmNshC2) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC2.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type());
            case NSH_C3:
                OFOxmNshC3 nshC3 = (OFOxmNshC3) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC3.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type());
            case NSH_C4:
                OFOxmNshC4 nshC4 = (OFOxmNshC4) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC4.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type());
            case NSH_MDTYPE:
                OFOxmNshMdtype nshMdType = (OFOxmNshMdtype) oxm;
                return new NiciraNshMdType((nshMdType.getValue().getRaw()));
            case NSH_NP:
                OFOxmNshNp nshNp = (OFOxmNshNp) oxm;
                return new NiciraNshNp((nshNp.getValue().getRaw()));
            case ENCAP_ETH_SRC:
                OFOxmEncapEthSrc encapEthSrc = (OFOxmEncapEthSrc) oxm;
                return new NiciraEncapEthSrc(org.onlab.packet.MacAddress.valueOf((encapEthSrc.getValue().getBytes())));
            case ENCAP_ETH_DST:
                OFOxmEncapEthDst encapEthDst = (OFOxmEncapEthDst) oxm;
                return new NiciraEncapEthDst(org.onlab.packet.MacAddress.valueOf((encapEthDst.getValue().getBytes())));
            case ENCAP_ETH_TYPE:
                OFOxmEncapEthType encapEthType = (OFOxmEncapEthType) oxm;
                return new NiciraEncapEthType((encapEthType.getValue().getRaw()));
            case TUN_GPE_NP:
                OFOxmTunGpeNp tunGpeNp = (OFOxmTunGpeNp) oxm;
                return new NiciraTunGpeNp((tunGpeNp.getValue().getRaw()));
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    }
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_NICIRA) {
            OFActionNicira nicira = (OFActionNicira) experimenter;
            switch(nicira.getSubtype()) {
                case SUB_TYPE_MOVE:
                    OFActionNiciraMove moveAction = (OFActionNiciraMove) nicira;
                    switch(Long.valueOf(moveAction.getSrc()).intValue()) {
                        case SRC_ARP_SHA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
                        case SRC_ETH:
                            return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
                        case SRC_IP:
                            return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
                        case SRC_ARP_SPA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
                        case NSH_C1:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC1ToC1();
                        case NSH_C2:
                            if (Long.valueOf(moveAction.getDst()).intValue() == TUN_ID) {
                                return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToTunId();
                            }
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToC2();
                        case NSH_C3:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC3ToC3();
                        case NSH_C4:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC4ToC4();
                        case TUN_IPV4_DST:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunDstToTunDst();
                        case TUN_ID:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunIdToTunId();
                        default:
                            throw new UnsupportedOperationException("Driver does not support move from " + moveAction.getSrc() + " to " + moveAction.getDst() + "of length " + moveAction.getNBits());
                    }
                case SUB_TYPE_RESUBMIT:
                    OFActionNiciraResubmit resubmitAction = (OFActionNiciraResubmit) nicira;
                    return new NiciraResubmit(PortNumber.portNumber(resubmitAction.getInPort()));
                case SUB_TYPE_PUSH_NSH:
                    return new NiciraPushNsh();
                case SUB_TYPE_POP_NSH:
                    return new NiciraPopNsh();
                case SUB_TYPE_RESUBMIT_TABLE:
                    OFActionNiciraResubmitTable resubmitTable = (OFActionNiciraResubmitTable) nicira;
                    return new NiciraResubmitTable(PortNumber.portNumber(resubmitTable.getInPort()), resubmitTable.getTable());
                case SUB_TYPE_CT:
                    OFActionNiciraCt ctAction = (OFActionNiciraCt) nicira;
                    return new NiciraCt(ctAction.getFlags(), ctAction.getZoneSrc(), ctAction.getZone(), ctAction.getRecircTable(), ctAction.getAlg());
                case SUB_TYPE_NAT:
                    OFActionNiciraNat natAction = (OFActionNiciraNat) nicira;
                    if ((natAction.getRangePresent() & (NAT_RANGE_IPV4_MIN | NAT_RANGE_IPV4_MAX)) != 0) {
                        return new NiciraNat(natAction.getFlags(), natAction.getRangePresent(), natAction.getPortRange().get(0).getValue(), natAction.getPortRange().get(1).getValue(), IpAddress.valueOf(natAction.getIpv4Range().get(0).toString()), IpAddress.valueOf(natAction.getIpv4Range().get(1).toString()));
                    } else if ((natAction.getRangePresent() & (NAT_RANGE_IPV6_MIN | NAT_RANGE_IPV6_MAX)) != 0) {
                        return new NiciraNat(natAction.getFlags(), natAction.getRangePresent(), natAction.getPortRange().get(0).getValue(), natAction.getPortRange().get(1).getValue(), IpAddress.valueOf(natAction.getIpv6Range().get(0).toString()), IpAddress.valueOf(natAction.getIpv6Range().get(1).toString()));
                    } else {
                        return new NiciraNat(natAction.getFlags(), natAction.getRangePresent(), natAction.getPortRange().get(0).getValue(), natAction.getPortRange().get(1).getValue(), IpAddress.valueOf(""), IpAddress.valueOf(""));
                    }
                case SUB_TYPE_CT_CLEAR:
                    return new NiciraCtClear();
                default:
                    throw new UnsupportedOperationException("Driver does not support extension subtype " + nicira.getSubtype());
            }
        }
    }
    return null;
}
#method_after
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case TUNNEL_IPV4_DST:
                OFOxmTunnelIpv4Dst tunnelIpv4Dst = (OFOxmTunnelIpv4Dst) oxm;
                return new NiciraSetTunnelDst(Ip4Address.valueOf(tunnelIpv4Dst.getValue().getInt()));
            case NSP:
                OFOxmNsp nsp = (OFOxmNsp) oxm;
                return new NiciraSetNshSpi(NshServicePathId.of((nsp.getValue().getRaw())));
            case NSI:
                OFOxmNsi nsi = (OFOxmNsi) oxm;
                return new NiciraSetNshSi(NshServiceIndex.of((nsi.getValue().getRaw())));
            case NSH_C1:
                OFOxmNshC1 nshC1 = (OFOxmNshC1) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC1.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type());
            case NSH_C2:
                OFOxmNshC2 nshC2 = (OFOxmNshC2) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC2.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type());
            case NSH_C3:
                OFOxmNshC3 nshC3 = (OFOxmNshC3) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC3.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type());
            case NSH_C4:
                OFOxmNshC4 nshC4 = (OFOxmNshC4) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC4.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type());
            case NSH_MDTYPE:
                OFOxmNshMdtype nshMdType = (OFOxmNshMdtype) oxm;
                return new NiciraNshMdType((nshMdType.getValue().getRaw()));
            case NSH_NP:
                OFOxmNshNp nshNp = (OFOxmNshNp) oxm;
                return new NiciraNshNp((nshNp.getValue().getRaw()));
            case ENCAP_ETH_SRC:
                OFOxmEncapEthSrc encapEthSrc = (OFOxmEncapEthSrc) oxm;
                return new NiciraEncapEthSrc(org.onlab.packet.MacAddress.valueOf((encapEthSrc.getValue().getBytes())));
            case ENCAP_ETH_DST:
                OFOxmEncapEthDst encapEthDst = (OFOxmEncapEthDst) oxm;
                return new NiciraEncapEthDst(org.onlab.packet.MacAddress.valueOf((encapEthDst.getValue().getBytes())));
            case ENCAP_ETH_TYPE:
                OFOxmEncapEthType encapEthType = (OFOxmEncapEthType) oxm;
                return new NiciraEncapEthType((encapEthType.getValue().getRaw()));
            case TUN_GPE_NP:
                OFOxmTunGpeNp tunGpeNp = (OFOxmTunGpeNp) oxm;
                return new NiciraTunGpeNp((tunGpeNp.getValue().getRaw()));
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    }
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_NICIRA) {
            OFActionNicira nicira = (OFActionNicira) experimenter;
            switch(nicira.getSubtype()) {
                case SUB_TYPE_MOVE:
                    OFActionNiciraMove moveAction = (OFActionNiciraMove) nicira;
                    switch(Long.valueOf(moveAction.getSrc()).intValue()) {
                        case SRC_ARP_SHA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
                        case SRC_ETH:
                            return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
                        case SRC_IP:
                            return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
                        case SRC_ARP_SPA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
                        case NSH_C1:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC1ToC1();
                        case NSH_C2:
                            if (Long.valueOf(moveAction.getDst()).intValue() == TUN_ID) {
                                return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToTunId();
                            }
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToC2();
                        case NSH_C3:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC3ToC3();
                        case NSH_C4:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC4ToC4();
                        case TUN_IPV4_DST:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunDstToTunDst();
                        case TUN_ID:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunIdToTunId();
                        default:
                            throw new UnsupportedOperationException("Driver does not support move from " + moveAction.getSrc() + " to " + moveAction.getDst() + "of length " + moveAction.getNBits());
                    }
                case SUB_TYPE_RESUBMIT:
                    OFActionNiciraResubmit resubmitAction = (OFActionNiciraResubmit) nicira;
                    return new NiciraResubmit(PortNumber.portNumber(resubmitAction.getInPort()));
                case SUB_TYPE_PUSH_NSH:
                    return new NiciraPushNsh();
                case SUB_TYPE_POP_NSH:
                    return new NiciraPopNsh();
                case SUB_TYPE_RESUBMIT_TABLE:
                    OFActionNiciraResubmitTable resubmitTable = (OFActionNiciraResubmitTable) nicira;
                    return new NiciraResubmitTable(PortNumber.portNumber(resubmitTable.getInPort()), resubmitTable.getTable());
                case SUB_TYPE_CT:
                    OFActionNiciraCt ctAction = (OFActionNiciraCt) nicira;
                    List<OFAction> actions = ctAction.getActions();
                    for (OFAction act : actions) {
                        OFActionExperimenter ctExperimenter = (OFActionExperimenter) act;
                        if (Long.valueOf(ctExperimenter.getExperimenter()).intValue() == TYPE_NICIRA) {
                            OFActionNicira actionNicira = (OFActionNicira) ctExperimenter;
                            switch(actionNicira.getSubtype()) {
                                case SUB_TYPE_NAT:
                                    OFActionNiciraNat natAction = (OFActionNiciraNat) actionNicira;
                                    int portMin = 0;
                                    int portMax = 0;
                                    IpAddress ipAddressMin = IpAddress.valueOf(0);
                                    IpAddress ipAddressMax = IpAddress.valueOf(0);
                                    // FIXME: we need to get ipv6 and port from list<ipv4> temporarily,
                                    // becase loxi don't know how to arrange these data to corresonding field.
                                    IPv4Address[] arrays = (IPv4Address[]) natAction.getIpv4Range().toArray(new IPv4Address[0]);
                                    int index = 0;
                                    if ((natAction.getRangePresent() & NAT_RANGE_IPV4_MIN) != 0) {
                                        ipAddressMin = IpAddress.valueOf(arrays[index++].toString());
                                    }
                                    if ((natAction.getRangePresent() & NAT_RANGE_IPV4_MAX) != 0) {
                                        ipAddressMax = IpAddress.valueOf(arrays[index++].toString());
                                    }
                                    if ((natAction.getRangePresent() & NAT_RANGE_IPV6_MIN) != 0) {
                                        byte[] bytes = Bytes.concat(arrays[index++].getBytes(), arrays[index++].getBytes(), arrays[index++].getBytes(), arrays[index++].getBytes());
                                        ipAddressMin = IpAddress.valueOf(IpAddress.Version.INET6, bytes);
                                    }
                                    if ((natAction.getRangePresent() & NAT_RANGE_IPV6_MAX) != 0) {
                                        byte[] bytes = Bytes.concat(arrays[index++].getBytes(), arrays[index++].getBytes(), arrays[index++].getBytes(), arrays[index++].getBytes());
                                        ipAddressMax = IpAddress.valueOf(IpAddress.Version.INET6, bytes);
                                    }
                                    if ((natAction.getRangePresent() & NAT_RANGE_PROTO_MIN) != 0) {
                                        portMin = arrays[index].getInt() >> 16 & 0x0000ffff;
                                    }
                                    if ((natAction.getRangePresent() & NAT_RANGE_PROTO_MAX) != 0) {
                                        portMax = arrays[index].getInt() & 0x0000ffff;
                                    }
                                    List<ExtensionTreatment> treatments = new ArrayList<>();
                                    NiciraNat natTreatment = new NiciraNat(natAction.getFlags(), natAction.getRangePresent(), portMin, portMax, ipAddressMin, ipAddressMax);
                                    treatments.add(natTreatment);
                                    return new NiciraCt(ctAction.getFlags(), ctAction.getZoneSrc(), ctAction.getZone(), ctAction.getRecircTable(), ctAction.getAlg(), treatments);
                                default:
                                    throw new UnsupportedOperationException("Driver does not support nested" + " in ct action extension subtype " + actionNicira.getSubtype());
                            }
                        }
                    }
                    return new NiciraCt(ctAction.getFlags(), ctAction.getZoneSrc(), ctAction.getZone(), ctAction.getRecircTable(), ctAction.getAlg(), new ArrayList<>());
                case SUB_TYPE_CT_CLEAR:
                    return new NiciraCtClear();
                default:
                    throw new UnsupportedOperationException("Driver does not support extension subtype " + nicira.getSubtype());
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void deserialize(byte[] data) {
}
#method_after
@Override
public void deserialize(byte[] data) {
    Map<String, Object> values = appKryo.deserialize(data);
    flags = (int) values.get("flags");
    zoneSrc = (long) values.get("zoneSrc");
    zone = (int) values.get("zone");
    recircTable = (short) values.get("recircTable");
    alg = (int) values.get("alg");
    nestedActions = (List) values.get("nestedActions");
}
#end_block

#method_before
@Override
public byte[] serialize() {
    return appKryo.serialize(0);
}
#method_after
@Override
public byte[] serialize() {
    Map<String, Object> values = Maps.newHashMap();
    values.put("flags", flags);
    values.put("zoneSrc", zoneSrc);
    values.put("zone", zone);
    values.put("recircTable", recircTable);
    values.put("alg", alg);
    values.put("nestedActions", nestedActions);
    return appKryo.serialize(values);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(type(), flags, zone, zoneSrc, alg, recircTable);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), flags, zone, zoneSrc, alg, recircTable, nestedActions);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof NiciraCt) {
        NiciraCt that = (NiciraCt) obj;
        return Objects.equals(flags, that.flags) && Objects.equals(zone, that.zone) && Objects.equals(zoneSrc, that.zoneSrc) && Objects.equals(alg, that.alg) && Objects.equals(recircTable, that.recircTable) && Objects.equals(this.type(), that.type());
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof NiciraCt) {
        NiciraCt that = (NiciraCt) obj;
        return Objects.equals(flags, that.flags) && Objects.equals(zone, that.zone) && Objects.equals(zoneSrc, that.zoneSrc) && Objects.equals(alg, that.alg) && Objects.equals(recircTable, that.recircTable) && Objects.equals(nestedActions, that.nestedActions) && Objects.equals(this.type(), that.type());
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("flags", flags).add("zoneSrc", zoneSrc).add("zone", zone).add("recircTable", recircTable).add("alg", alg).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("flags", flags).add("zoneSrc", zoneSrc).add("zone", zone).add("recircTable", recircTable).add("alg", alg).add("nestedActions", nestedActions).toString();
}
#end_block

#method_before
@Override
public void deserialize(byte[] data) {
}
#method_after
@Override
public void deserialize(byte[] data) {
    Map<String, Object> values = appKryo.deserialize(data);
    flags = (int) values.get("flags");
    presentFlags = (int) values.get("presentFlags");
    portMin = (int) values.get("portMin");
    portMax = (int) values.get("portMax");
    ipAddressMin = (IpAddress) values.get("ipAddressMin");
    ipAddressMax = (IpAddress) values.get("ipAddressMax");
}
#end_block

#method_before
@Override
public byte[] serialize() {
    return appKryo.serialize(0);
}
#method_after
@Override
public byte[] serialize() {
    Map<String, Object> values = Maps.newHashMap();
    values.put("flags", flags);
    values.put("presentFlags", presentFlags);
    values.put("portMin", portMin);
    values.put("portMax", portMax);
    values.put("ipAddressMin", ipAddressMin);
    values.put("ipAddressMax", ipAddressMax);
    return appKryo.serialize(values);
}
#end_block

#method_before
@Override
public void event(OpenstackRouterEvent event) {
    switch(event.type()) {
        case OPENSTACK_FLOATING_IP_ASSOCIATED:
        case OPENSTACK_FLOATING_IP_DISASSOCIATED:
            eventExecutor.execute(() -> {
                NetFloatingIP fip = event.floatingIp();
                log.debug("Floating IP {} is updated", fip.getFloatingIpAddress());
                floatingIpUpdated(fip, event.portId());
            });
            break;
        case OPENSTACK_FLOATING_IP_CREATED:
            log.debug("Floating IP {} is created", event.floatingIp().getFloatingIpAddress());
            break;
        case OPENSTACK_FLOATING_IP_UPDATED:
            log.debug("Floating IP {} is updated", event.floatingIp().getFloatingIpAddress());
            break;
        case OPENSTACK_FLOATING_IP_REMOVED:
            log.debug("Floating IP {} is removed", event.floatingIp().getFloatingIpAddress());
            break;
        case OPENSTACK_ROUTER_CREATED:
        case OPENSTACK_ROUTER_UPDATED:
        case OPENSTACK_ROUTER_REMOVED:
        case OPENSTACK_ROUTER_INTERFACE_ADDED:
        case OPENSTACK_ROUTER_INTERFACE_UPDATED:
        case OPENSTACK_ROUTER_INTERFACE_REMOVED:
        default:
            // do nothing for the other events
            break;
    }
}
#method_after
@Override
public void event(OpenstackRouterEvent event) {
    switch(event.type()) {
        case OPENSTACK_FLOATING_IP_ASSOCIATED:
            eventExecutor.execute(() -> {
                NetFloatingIP fip = event.floatingIp();
                Port osPort = osNetworkService.port(event.portId());
                if (osPort == null) {
                    final String error = String.format(ERR_FLOW + "port(%s) not found", fip.getFloatingIpAddress(), fip.getPortId());
                    throw new IllegalStateException(error);
                }
                setFloatingIpRules(fip, osPort, true);
                log.info("Associated floating IP {}:{}", fip.getFloatingIpAddress(), fip.getFixedIpAddress());
            });
            break;
        case OPENSTACK_FLOATING_IP_DISASSOCIATED:
            eventExecutor.execute(() -> {
                NetFloatingIP fip = event.floatingIp();
                Port osPort = osNetworkService.port(event.portId());
                if (osPort == null) {
                    final String error = String.format(ERR_FLOW + "port(%s) not found", fip.getFloatingIpAddress(), event.portId());
                    throw new IllegalStateException(error);
                }
                setFloatingIpRules(fip, osPort, false);
                log.info("Disassociated floating IP {}:{}", fip.getFloatingIpAddress(), fip.getFixedIpAddress());
            });
            break;
        case OPENSTACK_FLOATING_IP_REMOVED:
            eventExecutor.execute(() -> {
                NetFloatingIP fip = event.floatingIp();
                if (Strings.isNullOrEmpty(fip.getPortId())) {
                    return;
                }
                Port osPort = osNetworkService.port(fip.getPortId());
                if (osPort == null) {
                    // disassociation step, it can reach here
                    return;
                }
                setFloatingIpRules(fip, osPort, false);
                log.info("Disassociated floating IP {}:{}", fip.getFloatingIpAddress(), fip.getFixedIpAddress());
            });
            break;
        case OPENSTACK_FLOATING_IP_CREATED:
        case OPENSTACK_FLOATING_IP_UPDATED:
        case OPENSTACK_ROUTER_CREATED:
        case OPENSTACK_ROUTER_UPDATED:
        case OPENSTACK_ROUTER_REMOVED:
        case OPENSTACK_ROUTER_INTERFACE_ADDED:
        case OPENSTACK_ROUTER_INTERFACE_UPDATED:
        case OPENSTACK_ROUTER_INTERFACE_REMOVED:
        default:
            // do nothing for the other events
            break;
    }
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
            eventExecutor.execute(() -> {
                log.info("GATEWAY node {} detected", osNode.hostname());
                osRouterService.floatingIps().stream().filter(fip -> !Strings.isNullOrEmpty(fip.getPortId())).forEach(fip -> {
                    floatingIpUpdated(fip, fip.getPortId());
                });
            });
            break;
        case INIT:
        case DEVICE_CREATED:
        case INCOMPLETE:
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    switch(event.type()) {
        case COMPLETE:
            eventExecutor.execute(() -> {
                for (NetFloatingIP fip : osRouterService.floatingIps()) {
                    if (Strings.isNullOrEmpty(fip.getPortId())) {
                        continue;
                    }
                    Port osPort = osNetworkService.port(fip.getPortId());
                    if (osPort == null) {
                        log.warn("Failed to set floating IP {}", fip.getId());
                        continue;
                    }
                    setFloatingIpRules(fip, osPort, true);
                }
            });
            break;
        case INIT:
        case DEVICE_CREATED:
        case INCOMPLETE:
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void addOrUpdateNode(OpenstackNode node) {
    nodeStore.put(node.hostname(), OpenstackNode.getUpdatedNode(node, nodeState(node)));
}
#method_after
@Override
public void addOrUpdateNode(OpenstackNode node) {
    nodeStore.computeIf(node.hostname(), v -> v == null || (!v.equals(node) || v.state() != COMPLETE), (k, v) -> getUpdatedNode(node, nodeState(node)));
}
#end_block

#method_before
private void setNodeState(OpenstackNode node, NodeState newState) {
    if (node.state() != newState) {
        log.debug("Changed {} state: {}", node.hostname(), newState);
        nodeStore.put(node.hostname(), OpenstackNode.getUpdatedNode(node, newState));
    }
}
#method_after
private void setNodeState(OpenstackNode node, NodeState newState) {
    nodeStore.put(node.hostname(), getUpdatedNode(node, newState));
}
#end_block

#method_before
private boolean isIfaceCreated(DeviceId deviceId, String ifaceName) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null || !device.is(BridgeConfig.class)) {
        return false;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    return bridgeConfig.getPorts().stream().filter(port -> port.annotations().value(PORT_NAME).equals(ifaceName)).findAny().isPresent();
}
#method_after
private boolean isIfaceCreated(DeviceId deviceId, String ifaceName) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null || !device.is(BridgeConfig.class)) {
        return false;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    return bridgeConfig.getPorts().stream().anyMatch(port -> port.annotations().value(PORT_NAME).equals(ifaceName));
}
#end_block

#method_before
private boolean isBridgeCreated(DeviceId deviceId, String bridgeName) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null || !device.is(BridgeConfig.class)) {
        return false;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    return bridgeConfig.getBridges().stream().filter(bridge -> bridge.name().equals(bridgeName)).findAny().isPresent();
}
#method_after
private boolean isBridgeCreated(DeviceId deviceId, String bridgeName) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null || !device.is(BridgeConfig.class)) {
        return false;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    return bridgeConfig.getBridges().stream().anyMatch(bridge -> bridge.name().equals(bridgeName));
}
#end_block

#method_before
private Set<String> systemIfaces(OpenstackNode node) {
    Set<String> ifaces = Sets.newHashSet();
    node.dataIp().ifPresent(ip -> ifaces.add(DEFAULT_TUNNEL));
    node.vlanPort().ifPresent(p -> ifaces.add(p));
    if (node.type().equals(NodeType.GATEWAY)) {
        ifaces.add(PATCH_INTG_BRIDGE);
        ifaces.add(PATCH_ROUT_BRIDGE);
        ifaces.add(node.uplink().get());
    }
    return ifaces;
}
#method_after
private Set<String> systemIfaces(OpenstackNode node) {
    Set<String> ifaces = Sets.newHashSet();
    node.dataIp().ifPresent(ip -> ifaces.add(DEFAULT_TUNNEL));
    node.vlanPort().ifPresent(ifaces::add);
    if (node.type().equals(NodeType.GATEWAY)) {
        ifaces.add(PATCH_INTG_BRIDGE);
        ifaces.add(PATCH_ROUT_BRIDGE);
        ifaces.add(node.uplink().get());
    }
    return ifaces;
}
#end_block

#method_before
private void readConfiguration() {
    OpenstackNodeConfig config = configRegistry.getConfig(appId, CONFIG_CLASS);
    if (config == null) {
        log.debug("No configuration found");
        return;
    }
    Map<String, OpenstackNode> prevNodeMap = new HashMap(nodeStore.asJavaMap());
    config.openstackNodes().forEach(node -> {
        prevNodeMap.remove(node.hostname());
        addOrUpdateNode(node);
    });
    prevNodeMap.values().forEach(this::deleteNode);
}
#method_after
private void readConfiguration() {
    OpenstackNodeConfig config = configRegistry.getConfig(appId, CONFIG_CLASS);
    if (config == null) {
        log.debug("No configuration found");
        return;
    }
    Map<String, OpenstackNode> prevNodeMap = Maps.newHashMap(nodeStore.asJavaMap());
    config.openstackNodes().forEach(node -> {
        prevNodeMap.remove(node.hostname());
        addOrUpdateNode(node);
    });
    prevNodeMap.values().forEach(this::deleteNode);
}
#end_block

#method_before
private List<GroupBucket> generateBucketsForSelectGroup(OpenstackNode computeNode, List<OpenstackNode> gatewayNodeList, NetworkMode networkMode) {
    List<GroupBucket> bucketList = Lists.newArrayList();
    if (networkMode.equals(NetworkMode.VXLAN)) {
        gatewayNodeList.stream().filter(node -> node.dataIp().isPresent()).forEach(node -> {
            TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().extension(buildNiciraExtenstion(computeNode.intBridge(), node.dataIp().get().getIp4Address()), computeNode.intBridge()).setOutput(getTunnelPort(computeNode.intBridge())).build();
            bucketList.add(createSelectGroupBucket(tBuilder));
        });
        return bucketList;
    } else {
        gatewayNodeList.stream().filter(node -> node.vlanPort().isPresent()).forEach(node -> {
            TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().setEthDst(MacAddress.valueOf(vlanPortMac(node))).setOutput(vlanPortNum(computeNode)).build();
            bucketList.add(createSelectGroupBucket(tBuilder));
        });
        return bucketList;
    }
}
#method_after
private List<GroupBucket> generateBucketsForSelectGroup(OpenstackNode computeNode, List<OpenstackNode> gatewayNodeList, NetworkMode networkMode) {
    List<GroupBucket> bucketList = Lists.newArrayList();
    switch(networkMode) {
        case VXLAN:
            gatewayNodeList.stream().filter(node -> node.dataIp().isPresent()).forEach(node -> {
                TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().extension(buildNiciraExtenstion(computeNode.intBridge(), node.dataIp().get().getIp4Address()), computeNode.intBridge()).setOutput(getTunnelPort(computeNode.intBridge())).build();
                bucketList.add(createSelectGroupBucket(tBuilder));
            });
            return bucketList;
        case VLAN:
            gatewayNodeList.stream().filter(node -> node.vlanPort().isPresent()).forEach(node -> {
                TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().setEthDst(MacAddress.valueOf(vlanPortMac(node))).setOutput(vlanPortNum(computeNode)).build();
                bucketList.add(createSelectGroupBucket(tBuilder));
            });
            return bucketList;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkMode.toString());
            throw new IllegalStateException(error);
    }
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> osNode.dataIp().isPresent()).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge(), NetworkMode.VXLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> osNode.vlanPort().isPresent()).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge(), NetworkMode.VLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            break;
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setGatewayIcmpRule(gatewayIp, gwDeviceId, install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> osNode.dataIp().isPresent()).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge(), NetworkMode.VXLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> osNode.vlanPort().isPresent()).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge(), NetworkMode.VLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setGatewayIcmpRule(gatewayIp, gwDeviceId, install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            break;
        default:
            break;
    }
}
#method_after
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
        case INCOMPLETE:
            eventExecutor.execute(() -> {
                log.info("COMPLETE node {} detected", osNode.hostname());
                reconfigureRouters();
            });
            break;
        case INIT:
        case DEVICE_CREATED:
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
        case INCOMPLETE:
            eventExecutor.execute(() -> {
                log.info("Reconfigure routers for {}", osNode.hostname());
                reconfigureRouters();
            });
            break;
        case INIT:
        case DEVICE_CREATED:
        default:
            break;
    }
}
#end_block

#method_before
private void initializeUnusedPortNumSet() {
    for (int i = TP_PORT_MINIMUM_NUM; i < TP_PORT_MAXIMUM_NUM; i++) {
        if (!allocatedPortNumMap.containsKey(Integer.valueOf(i))) {
            unUsedPortNumSet.add(Integer.valueOf(i));
        }
    }
    clearPortNumMap();
}
#method_after
private void initializeUnusedPortNumSet() {
    for (int i = TP_PORT_MINIMUM_NUM; i < TP_PORT_MAXIMUM_NUM; i++) {
        if (!allocatedPortNumMap.containsKey(i)) {
            unUsedPortNumSet.add(i);
        }
    }
    clearPortNumMap();
}
#end_block

#method_before
private void processSnatPacket(PacketContext context, Ethernet eth) {
    IPv4 iPacket = (IPv4) eth.getPayload();
    InboundPacket packetIn = context.inPacket();
    int patPort = getPortNum();
    InstancePort srcInstPort = instancePortService.instancePort(eth.getSourceMAC());
    if (srcInstPort == null) {
        log.trace(ERR_PACKETIN + "source host(MAC:{}) does not exist", eth.getSourceMAC());
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(iPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(srcInstPort, srcIp);
    IpAddress externalGatewayIp = getExternalIp(srcSubnet);
    if (externalGatewayIp == null) {
        return;
    }
    if (patPort == 0) {
        log.error("There's no unused port for external ip {}... Drop this packet", getExternalIp(srcSubnet));
        return;
    }
    populateSnatFlowRules(context.inPacket(), srcInstPort, TpPort.tpPort(patPort), externalGatewayIp);
    packetOut((Ethernet) eth.clone(), packetIn.receivedFrom().deviceId(), patPort, externalGatewayIp);
}
#method_after
private void processSnatPacket(PacketContext context, Ethernet eth) {
    IPv4 iPacket = (IPv4) eth.getPayload();
    InboundPacket packetIn = context.inPacket();
    int patPort = getPortNum();
    InstancePort srcInstPort = instancePortService.instancePort(eth.getSourceMAC());
    if (srcInstPort == null) {
        log.error(ERR_PACKETIN + "source host(MAC:{}) does not exist", eth.getSourceMAC());
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(iPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(srcInstPort, srcIp);
    IpAddress externalGatewayIp = getExternalIp(srcSubnet);
    if (externalGatewayIp == null) {
        return;
    }
    populateSnatFlowRules(context.inPacket(), srcInstPort, TpPort.tpPort(patPort), externalGatewayIp);
    packetOut((Ethernet) eth.clone(), packetIn.receivedFrom().deviceId(), patPort, externalGatewayIp);
}
#end_block

#method_before
private int getPortNum() {
    if (unUsedPortNumSet.isEmpty()) {
        clearPortNumMap();
    }
    int portNum = findUnusedPortNum();
    if (portNum != 0) {
        unUsedPortNumSet.remove(Integer.valueOf(portNum));
        allocatedPortNumMap.put(Integer.valueOf(portNum), Long.valueOf(System.currentTimeMillis()));
    }
    return portNum;
}
#method_after
private int getPortNum() {
    if (unUsedPortNumSet.isEmpty()) {
        clearPortNumMap();
    }
    int portNum = findUnusedPortNum();
    if (portNum != 0) {
        unUsedPortNumSet.remove(portNum);
        allocatedPortNumMap.put(portNum, System.currentTimeMillis());
    }
    return portNum;
}
#end_block

#method_before
private int findUnusedPortNum() {
    return unUsedPortNumSet.stream().findAny().orElse(Integer.valueOf(0)).intValue();
}
#method_after
private int findUnusedPortNum() {
    return unUsedPortNumSet.stream().findAny().orElse(0);
}
#end_block

#method_before
private void clearPortNumMap() {
    allocatedPortNumMap.entrySet().forEach(e -> {
        if (System.currentTimeMillis() - e.getValue().value().longValue() > TIME_OUT_SNAT_PORT_MS) {
            allocatedPortNumMap.remove(e.getKey());
            unUsedPortNumSet.add(e.getKey());
        }
    });
}
#method_after
private void clearPortNumMap() {
    allocatedPortNumMap.entrySet().forEach(e -> {
        if (System.currentTimeMillis() - e.getValue().value() > TIME_OUT_SNAT_PORT_MS) {
            allocatedPortNumMap.remove(e.getKey());
            unUsedPortNumSet.add(e.getKey());
        }
    });
}
#end_block

#method_before
@Override
protected void execute() {
    if (!isNullOrEmpty(meterstr)) {
        meterId = MeterId.meterId(Long.parseLong(meterstr));
    }
    MeterService service = get(MeterService.class);
    Collection<Meter> meters = service.getAllMeters();
    if (uri != null) {
        DeviceId deviceId = DeviceId.deviceId(uri);
        Collection<Meter> devMeters = Collections2.filter(meters, m -> m.deviceId().equals(deviceId));
        if (meterId == null) {
            printMeters(devMeters);
        } else {
            for (Meter meter : devMeters) {
                if (meter.id().equals(meterId)) {
                    print(meter.toString());
                    return;
                }
            }
            print("Meter %s not found for device %s", meterId, deviceId);
        }
    } else {
        printMeters(meters);
    }
}
#method_after
@Override
protected void execute() {
    if (!isNullOrEmpty(meterstr)) {
        meterId = MeterId.meterId(Long.parseLong(meterstr));
    }
    MeterService service = get(MeterService.class);
    if (meterId != null && uri != null) {
        Meter m = service.getMeter(DeviceId.deviceId(uri), meterId);
        if (m != null) {
            print("%s", m);
        } else {
            error("Meter %s not found for device %s", meterId, uri);
        }
    } else {
        Collection<Meter> meters = service.getAllMeters();
        if (uri == null) {
            printMeters(meters);
        } else {
            printMeters(Collections2.filter(meters, m -> m.deviceId().equals(DeviceId.deviceId(uri))));
        }
    }
}
#end_block

#method_before
@Activate
public void activate() {
    local = clusterService.getLocalNode().id();
    meters = storageService.<MeterKey, MeterData>consistentMapBuilder().withName(METERSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), MeterKey.class, MeterData.class, DefaultMeter.class, DefaultBand.class, Band.Type.class, MeterState.class, Meter.Unit.class, MeterFailReason.class)).build();
    meters.addListener(mapListener);
    meterFeatures = storageService.<MeterFeaturesKey, MeterFeatures>consistentMapBuilder().withName(METERFEATURESSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), MeterFeaturesKey.class, MeterFeatures.class, DefaultMeterFeatures.class, Band.Type.class, Meter.Unit.class, MeterFailReason.class)).build();
    availableMeterIds = storageService.<DeviceId, Set<MeterId>>consistentMapBuilder().withName(AVAILABLEMETERIDSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), DeviceId.class, MeterId.class, Set.class, HashSet.class)).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    local = clusterService.getLocalNode().id();
    meters = storageService.<MeterKey, MeterData>consistentMapBuilder().withName(METERSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), MeterKey.class, MeterData.class, DefaultMeter.class, DefaultBand.class, Band.Type.class, MeterState.class, Meter.Unit.class, MeterFailReason.class)).build();
    meters.addListener(mapListener);
    meterFeatures = storageService.<MeterFeaturesKey, MeterFeatures>consistentMapBuilder().withName(METERFEATURESSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), MeterFeaturesKey.class, MeterFeatures.class, DefaultMeterFeatures.class, Band.Type.class, Meter.Unit.class, MeterFailReason.class)).build();
    availableMeterIds = storageService.<DeviceId, BitSet>consistentMapBuilder().withName(AVAILABLEMETERIDSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), DeviceId.class, BitSet.class)).build();
    log.info("Started");
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> storeMeter(Meter meter) {
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    setMeterIdUnavailable(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        meters.put(key, data);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> storeMeter(Meter meter) {
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    updateMeterIdAvailability(meter.deviceId(), meter.id(), false);
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        meters.put(key, data);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> deleteMeter(Meter meter) {
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    // that it has been removed from the dataplane.
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.success());
        }
        setMeterIdAvailable(meter.deviceId(), meter.id());
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> deleteMeter(Meter meter) {
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    // that it has been removed from the dataplane.
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.success());
        }
        updateMeterIdAvailability(meter.deviceId(), meter.id(), true);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    store.unsetDelegate(delegate);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    store.unsetDelegate(delegate);
    eventDispatcher.removeSink(MeterEvent.class);
    log.info("Stopped");
}
#end_block

#method_before
private MeterId allocateMeterId(DeviceId deviceId) {
    MeterId meterid = null;
    if ((meterid = store.getAvailableMeterId(deviceId)) != null) {
        return meterid;
    }
    long maxMeters = store.getMaxMeters(MeterFeaturesKey.key(deviceId));
    if (maxMeters == 0L) {
        // MeterFeatures couldn't be retrieved, trying with queryMeters
        maxMeters = queryMeters(deviceId);
    }
    if (maxMeters == 0L) {
        throw new IllegalStateException("Meters not supported by device " + deviceId);
    }
    final long mmeters = maxMeters;
    long id = meterIdCounters.compute(deviceId, (k, v) -> {
        if (v == null) {
            return allocateCounter(k);
        }
        if (v.get() >= mmeters) {
            throw new IllegalStateException("Maximum number of meters " + meterIdCounters.get(deviceId).get() + " reached for device " + deviceId);
        }
        return v;
    }).incrementAndGet();
    return MeterId.meterId(id);
}
#method_after
private MeterId allocateMeterId(DeviceId deviceId) {
    // We first query the store for any previously removed meterId that could
    // be reused. Receiving a value (not null) already means that meters
    // are available for the device.
    MeterId meterid = store.firstReusableMeterId(deviceId);
    if (meterid != null) {
        return meterid;
    }
    // If there was no reusable MeterId we have to generate a new value
    // with an upper limit in maxMeters.
    long maxMeters = store.getMaxMeters(MeterFeaturesKey.key(deviceId));
    if (maxMeters == 0L) {
        // MeterFeatures couldn't be retrieved, trying with queryMeters.
        // queryMeters is implemented in FullMetersAvailable behaviour.
        maxMeters = queryMeters(deviceId);
    }
    if (maxMeters == 0L) {
        throw new IllegalStateException("Meters not supported by device " + deviceId);
    }
    final long mmeters = maxMeters;
    long id = meterIdCounters.compute(deviceId, (k, v) -> {
        if (v == null) {
            return allocateCounter(k);
        }
        if (v.get() >= mmeters) {
            throw new IllegalStateException("Maximum number of meters " + meterIdCounters.get(deviceId).get() + " reached for device " + deviceId);
        }
        return v;
    }).incrementAndGet();
    return MeterId.meterId(id);
}
#end_block

#method_before
@Override
public void pushMeterMetrics(DeviceId deviceId, Collection<Meter> meterEntries) {
    // FIXME: FOLLOWING CODE CANNOT BE TESTED UNTIL SOMETHING THAT
    // FIXME: IMPLEMENTS METERS EXISTS
    Map<Pair<DeviceId, MeterId>, Meter> storedMeterMap = store.getAllMeters().stream().collect(Collectors.toMap(m -> Pair.of(m.deviceId(), m.id()), Function.identity()));
    meterEntries.stream().filter(m -> storedMeterMap.remove(Pair.of(m.deviceId(), m.id())) != null).forEach(m -> store.updateMeterState(m));
    storedMeterMap.values().forEach(m -> {
        if (m.state() == MeterState.PENDING_ADD) {
            provider().performMeterOperation(m.deviceId(), new MeterOperation(m, MeterOperation.Type.MODIFY));
        } else if (m.state() == MeterState.PENDING_REMOVE) {
            store.deleteMeterNow(m);
        }
    });
}
#method_after
@Override
public void pushMeterMetrics(DeviceId deviceId, Collection<Meter> meterEntries) {
    // FIXME: FOLLOWING CODE CANNOT BE TESTED UNTIL SOMETHING THAT
    // FIXME: IMPLEMENTS METERS EXISTS
    Map<Pair<DeviceId, MeterId>, Meter> storedMeterMap = store.getAllMeters().stream().collect(Collectors.toMap(m -> Pair.of(m.deviceId(), m.id()), Function.identity()));
    Map<MeterId, Meter> meterEntriesMap = meterEntries.stream().collect(Collectors.toMap(Meter::id, Meter -> Meter));
    storedMeterMap.keySet().stream().filter(m -> m.getLeft().equals(deviceId)).forEach(m -> {
        if (!meterEntriesMap.containsKey(m.getRight())) {
            // The meter is missing in the device. Reinstall!
            Meter meter = storedMeterMap.get(Pair.of(deviceId, m.getRight()));
            provider().performMeterOperation(deviceId, new MeterOperation(meter, MeterOperation.Type.ADD));
        }
    });
    meterEntries.stream().filter(m -> storedMeterMap.remove(Pair.of(m.deviceId(), m.id())) != null).forEach(m -> store.updateMeterState(m));
    storedMeterMap.values().forEach(m -> {
        if (m.state() == MeterState.PENDING_ADD) {
            provider().performMeterOperation(m.deviceId(), new MeterOperation(m, MeterOperation.Type.MODIFY));
        } else if (m.state() == MeterState.PENDING_REMOVE) {
            store.deleteMeterNow(m);
        }
    });
}
#end_block

#method_before
@Override
public void run() {
    log.info("RETRY Hash buckets for linkup: {}", link);
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(link.dst().deviceId()))).collect(Collectors.toSet());
    log.debug("retry-link: nsNextObjStore contents for device {}: {}", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            addToHashedNextObjective(link.src().port(), dstMac, ns, nextId, true);
        }
    }
}
#method_after
@Override
public void run() {
    log.info("RETRY Hash buckets for linkup: {}", link);
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter(nsStoreEntry -> nsStoreEntry.deviceId().equals(deviceId)).map(nsStoreEntry -> nsStoreEntry.neighborSet()).filter(ns -> ns.getDeviceIds().contains(link.dst().deviceId())).collect(Collectors.toSet());
    log.debug("retry-link: nsNextObjStore contents for device {}: {}", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null) {
            addToHashedNextObjective(link.src().port(), dstMac, ns, nextId, true);
        }
    }
}
#end_block

#method_before
@Override
public void enterOrderedByStatement(OrderedByStatementContext ctx) {
    ListenerUtil.handleUnsupportedYangConstruct(YangConstructType.ORDERED_BY_DATA, ctx, UtilConstants.CURRENTLY_UNSUPPORTED, getFileName());
}
#method_after
@Override
public void enterOrderedByStatement(OrderedByStatementContext ctx) {
    handleUnsupportedYangConstruct(YangConstructType.ORDERED_BY_DATA, ctx, CURRENTLY_UNSUPPORTED, getFileName(), ctx.orderedBy().getText());
}
#end_block

#method_before
@Override
public void enterAnyxmlStatement(AnyxmlStatementContext ctx) {
    increaseUnsupportedYangConstructDepth();
    ListenerUtil.handleUnsupportedYangConstruct(YangConstructType.ANYXML_DATA, ctx, UtilConstants.UNSUPPORTED_YANG_CONSTRUCT, getFileName());
}
#method_after
@Override
public void enterAnyxmlStatement(AnyxmlStatementContext ctx) {
    increaseUnsupportedYangConstructDepth();
    handleUnsupportedYangConstruct(YangConstructType.ANYXML_DATA, ctx, UNSUPPORTED_YANG_CONSTRUCT, getFileName(), ctx.identifier().getText());
}
#end_block

#method_before
@Override
public void enterRefineStatement(RefineStatementContext ctx) {
    increaseUnsupportedYangConstructDepth();
    ListenerUtil.handleUnsupportedYangConstruct(YangConstructType.REFINE_DATA, ctx, UtilConstants.UNSUPPORTED_YANG_CONSTRUCT, getFileName());
}
#method_after
@Override
public void enterRefineStatement(RefineStatementContext ctx) {
    increaseUnsupportedYangConstructDepth();
    handleUnsupportedYangConstruct(REFINE_DATA, ctx, UNSUPPORTED_YANG_CONSTRUCT, getFileName(), ctx.refine().getText());
}
#end_block

#method_before
@Override
public void enterUnknownStatement(UnknownStatementContext ctx) {
// do nothing
}
#method_after
@Override
public void enterUnknownStatement(UnknownStatementContext ctx) {
    increaseUnsupportedYangConstructDepth();
    handleUnsupportedYangConstruct(UNKNOWN_STATEMENT, ctx, CURRENTLY_UNSUPPORTED, getFileName(), ctx.unknown().getText());
}
#end_block

#method_before
@Override
public void exitUnknownStatement(UnknownStatementContext ctx) {
// do nothing
}
#method_after
@Override
public void exitUnknownStatement(UnknownStatementContext ctx) {
    decreaseUnsupportedYangConstructDepth();
}
#end_block

#method_before
public static File formatFile(File dataFile) throws IOException {
    // take default Eclipse formatting options
    Map options = DefaultCodeFormatterConstants.getEclipseDefaultSettings();
    // initialize the compiler settings to be able to format 1.5 code
    options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_8);
    options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_8);
    options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_8);
    options.put(DefaultCodeFormatterConstants.FORMATTER_TAB_CHAR, "space");
    // change the option to wrap each enum constant on a new line
    options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_ENUM_CONSTANTS, DefaultCodeFormatterConstants.createAlignmentValue(true, DefaultCodeFormatterConstants.WRAP_ONE_PER_LINE, DefaultCodeFormatterConstants.INDENT_ON_COLUMN));
    // instantiate the default code formatter with the given options
    final CodeFormatter codeFormatter = ToolFactory.createCodeFormatter(options);
    String source = null;
    try {
        source = FileUtils.readFileToString(dataFile, StandardCharsets.UTF_8);
    } catch (IOException e) {
        e.printStackTrace();
    }
    final TextEdit edit = codeFormatter.format(// format a compilation unit
    CodeFormatter.K_COMPILATION_UNIT, // source to format
    source, // starting position
    0, // length
    source.length(), // initial indentation
    0, // line separator
    System.getProperty("line.separator"));
    IDocument document = new Document(source);
    try {
        edit.apply(document);
    } catch (MalformedTreeException e) {
        e.printStackTrace();
    } catch (BadLocationException e) {
        e.printStackTrace();
    } catch (NullPointerException e) {
        e.printStackTrace();
    }
    FileWriter writer = new FileWriter(dataFile);
    writer.write(document.get());
    writer.close();
    return dataFile;
}
#method_after
public static File formatFile(File dataFile) throws IOException {
    // take default Eclipse formatting options.
    Map options = getEclipseDefaultSettings();
    // initialize the compiler settings to be able to format 1.8 code.
    options.put(COMPILER_COMPLIANCE, VERSION_1_8);
    options.put(COMPILER_CODEGEN_TARGET_PLATFORM, VERSION_1_8);
    options.put(COMPILER_SOURCE, VERSION_1_8);
    options.put(FORMATTER_TAB_CHAR, SPACE);
    // change the option to wrap each enum constant on a new line.
    options.put(FORMATTER_ALIGNMENT_FOR_ENUM_CONSTANTS, createAlignmentValue(true, WRAP_ONE_PER_LINE, INDENT_ON_COLUMN));
    // instantiate the default code formatter with the given options.
    final CodeFormatter codeFormatter = createCodeFormatter(options);
    String source = FileUtils.readFileToString(dataFile, UTF_8);
    final TextEdit edit = codeFormatter.format(// format a compilation unit
    CodeFormatter.K_COMPILATION_UNIT, // source to format
    source, // starting position
    0, // length
    source.length(), // initial indentation
    0, // line separator
    System.getProperty("line.separator"));
    IDocument document = new Document(source);
    try {
        edit.apply(document);
    } catch (MalformedTreeException e) {
        log.info(" failed to format the file {} due to malformed tree.", dataFile.getName());
    } catch (BadLocationException e) {
        log.info(" failed to format the file {} due to bad location.", dataFile.getName());
    } catch (NullPointerException e) {
        log.info(" failed to format the file {} due to incomplete file ", dataFile.getName());
    }
    FileWriter writer = new FileWriter(dataFile);
    writer.write(document.get());
    writer.close();
    return dataFile;
}
#end_block

#method_before
public static String netconfGetConfig(DriverHandler handler, String filter) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    String reply;
    try {
        reply = session.getConfig(TargetConfig.RUNNING, filter);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#method_after
public static String netconfGetConfig(DriverHandler handler, String filter) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    String reply;
    try {
        reply = session.getConfig(DatastoreId.RUNNING, filter);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#end_block

#method_before
public static boolean netconfEditConfig(DriverHandler handler, String mode, String cfg) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    boolean reply = false;
    try {
        reply = session.editConfig(TargetConfig.RUNNING, mode, cfg);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to edit configuration.", e));
    }
    return reply;
}
#method_after
public static boolean netconfEditConfig(DriverHandler handler, String mode, String cfg) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    boolean reply = false;
    try {
        reply = session.editConfig(DatastoreId.RUNNING, mode, cfg);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to edit configuration.", e));
    }
    return reply;
}
#end_block

#method_before
public static List<HierarchicalConfiguration> configsAt(String content, String key) {
    List<HierarchicalConfiguration> info;
    try {
        HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(content);
        info = cfg.configurationsAt(key);
    } catch (Exception e) {
        // Accept null for information polling
        return null;
    }
    return info;
}
#method_after
public static List<HierarchicalConfiguration> configsAt(String content, String key) {
    List<HierarchicalConfiguration> info;
    try {
        HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(content);
        info = cfg.configurationsAt(key);
    } catch (Exception e) {
        // Accept empty for information polling
        return ImmutableList.of();
    }
    return info;
}
#end_block

#method_before
@Override
public CompletableFuture<Void> switchToForce(ConnectPoint identifier, int index) {
    return getProtectionEndpointConfig(identifier).thenApply(m -> m.paths().get(index)).thenApply(m -> switchPort(formatOperation(m.output().connectPoint().port(), KEY_OPT_FORCE))).thenApply(m -> null);
}
#method_after
@Override
public CompletableFuture<Void> switchToForce(ConnectPoint identifier, int index) {
    return getProtectionEndpointConfig(identifier).thenApply(m -> m.paths().get(index)).thenApply(m -> switchDevice(formatOperation(m.output().connectPoint().port(), KEY_OPT_FORCE))).thenApply(m -> null);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> switchToManual(ConnectPoint identifier, int index) {
    return getProtectionEndpointConfig(identifier).thenApply(m -> m.paths().get(index)).thenApply(m -> switchPort(formatOperation(m.output().connectPoint().port(), KEY_OPT_MANUAL))).thenApply(m -> null);
}
#method_after
@Override
public CompletableFuture<Void> switchToManual(ConnectPoint identifier, int index) {
    return getProtectionEndpointConfig(identifier).thenApply(m -> m.paths().get(index)).thenApply(m -> switchDevice(formatOperation(m.output().connectPoint().port(), KEY_OPT_MANUAL))).thenApply(m -> null);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> switchToAutomatic(ConnectPoint identifier) {
    switchPort(KEY_OPT_AUTO);
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> switchToAutomatic(ConnectPoint identifier) {
    switchDevice(KEY_OPT_AUTO);
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
private PortNumber acquireActivePort() {
    String filter = new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_STATE)).append(xmlEmpty(KEY_OPSSTATE)).append(xmlClose(KEY_STATE)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
    String reply = netconfGet(handler(), filter);
    return reply.contains(KEY_NAME_PRIMARY) ? PORT_PRIMARY : PORT_SECONDARY;
}
#method_after
private PortNumber acquireActivePort() {
    String filter = new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_STATE)).append(xmlEmpty(KEY_OPSSTATE)).append(xmlClose(KEY_STATE)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
    String reply = netconfGet(handler(), filter);
    log.debug("Service state replying, {}", reply);
    return reply.contains(KEY_NAME_PRIMARY) ? PORT_PRIMARY : PORT_SECONDARY;
}
#end_block

#method_before
@Deprecated
default String getConfig(TargetConfig netconfTargetConfig, String configurationFilterSchema) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), configurationFilterSchema);
}
#method_after
default String getConfig(DatastoreId netconfTargetConfig) throws NetconfException {
    // deprecation of the other 2 variants.
    return getConfig(netconfTargetConfig.id());
}
#end_block

#method_before
@Deprecated
default String getConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig));
}
#method_after
@Deprecated
default String getConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    return getConfig(TargetConfig.toDatastoreId(netconfTargetConfig));
}
#end_block

#method_before
@Deprecated
default String getConfig(String netconfTargetConfig) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig));
}
#method_after
@Deprecated
default String getConfig(String netconfTargetConfig) throws NetconfException {
    return getConfig(TargetConfig.toDatastoreId(netconfTargetConfig));
}
#end_block

#method_before
@Deprecated
default String getConfig(String netconfTargetConfig, String configurationFilterSchema) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), configurationFilterSchema);
}
#method_after
@Deprecated
default String getConfig(String netconfTargetConfig, String configurationFilterSchema) throws NetconfException {
    return getConfig(TargetConfig.toDatastoreId(netconfTargetConfig), configurationFilterSchema);
}
#end_block

#method_before
@Deprecated
default String getConfig(TargetConfig netconfTargetConfig, String configurationFilterSchema) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), configurationFilterSchema);
}
#method_after
@Deprecated
default String getConfig(TargetConfig netconfTargetConfig, String configurationFilterSchema) throws NetconfException {
    return getConfig(TargetConfig.toDatastoreId(netconfTargetConfig), configurationFilterSchema);
}
#end_block

#method_before
@Deprecated
default boolean editConfig(String netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    return editConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), mode, newConfiguration);
}
#method_after
@Deprecated
default boolean editConfig(String netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    return editConfig(TargetConfig.toDatastoreId(netconfTargetConfig), mode, newConfiguration);
}
#end_block

#method_before
@Deprecated
default boolean editConfig(TargetConfig netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    return editConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), mode, newConfiguration);
}
#method_after
@Deprecated
default boolean editConfig(TargetConfig netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    return editConfig(TargetConfig.toDatastoreId(netconfTargetConfig), mode, newConfiguration);
}
#end_block

#method_before
@Deprecated
default boolean copyConfig(TargetConfig netconfTargetConfig, String newConfiguration) throws NetconfException {
    return copyConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), newConfiguration);
}
#method_after
default boolean copyConfig(DatastoreId destination, DatastoreId source) throws NetconfException {
    // deprecation of the other 2 variants.
    return copyConfig(destination.id(), source.id());
}
#end_block

#method_before
@Deprecated
default boolean copyConfig(TargetConfig netconfTargetConfig, String newConfiguration) throws NetconfException {
    return copyConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig), newConfiguration);
}
#method_after
@Deprecated
default boolean copyConfig(TargetConfig netconfTargetConfig, String newConfiguration) throws NetconfException {
    return copyConfig(TargetConfig.toDatastoreId(netconfTargetConfig), newConfiguration);
}
#end_block

#method_before
@Deprecated
default boolean deleteConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    return deleteConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig));
}
#method_after
default boolean deleteConfig(DatastoreId netconfTargetConfig) throws NetconfException {
    // deprecation of the other 2 variants.
    return deleteConfig(netconfTargetConfig.id());
}
#end_block

#method_before
@Deprecated
default boolean deleteConfig(String netconfTargetConfig) throws NetconfException {
    return deleteConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig));
}
#method_after
@Deprecated
default boolean deleteConfig(String netconfTargetConfig) throws NetconfException {
    return deleteConfig(TargetConfig.toDatastoreId(netconfTargetConfig));
}
#end_block

#method_before
@Deprecated
default boolean deleteConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    return deleteConfig(TargetConfig.toTargetConfiguration(netconfTargetConfig));
}
#method_after
@Deprecated
default boolean deleteConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    return deleteConfig(TargetConfig.toDatastoreId(netconfTargetConfig));
}
#end_block

#method_before
private void sendHello() throws NetconfException {
    serverHelloResponseOld = sendRequest(createHelloString());
    Matcher capabilityMatcher = CAPABILITY_REGEX_PATTERN.matcher(serverHelloResponseOld);
    while (capabilityMatcher.find()) {
        deviceCapabilities.add(capabilityMatcher.group(1));
    }
    sessionID = String.valueOf(-1);
    Matcher sessionIDMatcher = SESSION_ID_REGEX_PATTERN.matcher(serverHelloResponseOld);
    if (sessionIDMatcher.find()) {
        sessionID = sessionIDMatcher.group(1);
    } else {
        throw new NetconfException("Missing SessionID in server hello " + "reponse.");
    }
}
#method_after
private void sendHello() throws NetconfException {
    serverHelloResponseOld = sendRequest(createHelloString(), true);
    Matcher capabilityMatcher = CAPABILITY_REGEX_PATTERN.matcher(serverHelloResponseOld);
    while (capabilityMatcher.find()) {
        deviceCapabilities.add(capabilityMatcher.group(1));
    }
    sessionID = String.valueOf(-1);
    Matcher sessionIDMatcher = SESSION_ID_REGEX_PATTERN.matcher(serverHelloResponseOld);
    if (sessionIDMatcher.find()) {
        sessionID = sessionIDMatcher.group(1);
    } else {
        throw new NetconfException("Missing SessionID in server hello " + "reponse.");
    }
}
#end_block

#method_before
@Override
public void checkAndReestablish() throws NetconfException {
    if (sshSession.getState() != Channel.STATE_OPEN) {
        try {
            log.debug("Trying to reopen the Sesion with {}", deviceInfo.getDeviceId());
            startSshSession();
        } catch (IOException | IllegalStateException e) {
            log.debug("Trying to reopen the Connection with {}", deviceInfo.getDeviceId());
            try {
                connectionActive = false;
                replies.clear();
                messageIdInteger.set(0);
                startConnection();
                if (subscriptionConnected) {
                    log.debug("Restarting subscription with {}", deviceInfo.getDeviceId());
                    subscriptionConnected = false;
                    startSubscription(notificationFilterSchema);
                }
            } catch (IOException e2) {
                log.error("No connection {} for device {}", netconfConnection, e.getMessage());
                throw new NetconfException("Cannot re-open the connection with device" + deviceInfo, e);
            }
        }
    }
}
#method_after
@Override
public void checkAndReestablish() throws NetconfException {
    if (sshSession.getState() != Channel.STATE_OPEN) {
        try {
            log.debug("Trying to reopen the Sesion with {}", deviceInfo.getDeviceId());
            startSshSession();
        } catch (IOException | IllegalStateException e) {
            log.debug("Trying to reopen the Connection with {}", deviceInfo.getDeviceId());
            try {
                connectionActive = false;
                replies.clear();
                startConnection();
                if (subscriptionConnected) {
                    log.debug("Restarting subscription with {}", deviceInfo.getDeviceId());
                    subscriptionConnected = false;
                    startSubscription(notificationFilterSchema);
                }
            } catch (IOException e2) {
                log.error("No connection {} for device {}", netconfConnection, e.getMessage());
                throw new NetconfException("Cannot re-open the connection with device" + deviceInfo, e);
            }
        }
    }
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndReestablish();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request) throws NetconfException {
    return sendRequest(request, false);
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndReestablish();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
@Override
public String getConfig(TargetConfiguration netconfTargetConfig, String configurationSchema) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc ");
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append("xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<get-config>\n");
    rpc.append("<source>\n");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</source>");
    if (configurationSchema != null) {
        rpc.append("<filter type=\"subtree\">\n");
        rpc.append(configurationSchema).append("\n");
        rpc.append("</filter>\n");
    }
    rpc.append("</get-config>\n");
    rpc.append("</rpc>\n");
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    return checkReply(reply) ? reply : "ERROR " + reply;
}
#method_after
@Override
public String getConfig(DatastoreId netconfTargetConfig) throws NetconfException {
    return getConfig(netconfTargetConfig, null);
}
#end_block

#method_before
@Override
public boolean editConfig(TargetConfiguration netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#method_after
@Override
public boolean editConfig(DatastoreId netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#end_block

#method_before
@Override
public boolean copyConfig(TargetConfiguration netconfTargetConfig, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<config>")) {
        newConfiguration = "<config>" + newConfiguration + "</config>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append(newConfiguration);
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean copyConfig(DatastoreId destination, DatastoreId source) throws NetconfException {
    return bareCopyConfig(destination.asXml(), source.asXml());
}
#end_block

#method_before
@Override
public boolean deleteConfig(TargetConfiguration netconfTargetConfig) throws NetconfException {
    if (netconfTargetConfig.equals(TargetConfiguration.RUNNING)) {
        log.warn("Target configuration for delete operation can't be \"running\"", netconfTargetConfig);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean deleteConfig(DatastoreId netconfTargetConfig) throws NetconfException {
    if (netconfTargetConfig.equals(DatastoreId.RUNNING)) {
        log.warn("Target configuration for delete operation can't be \"running\"", netconfTargetConfig);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#end_block

#method_before
@Override
public boolean lock() throws NetconfException {
    return lock("running");
}
#method_after
@Override
public boolean lock(DatastoreId configType) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<lock>");
    rpc.append("<target>");
    rpc.append("<");
    rpc.append(configType.id());
    rpc.append("/>");
    rpc.append("</target>");
    rpc.append("</lock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    String lockReply = sendRequest(rpc.toString());
    return checkReply(lockReply);
}
#end_block

#method_before
@Override
public boolean unlock() throws NetconfException {
    return unlock("running");
}
#method_after
@Override
public boolean unlock(DatastoreId configType) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<unlock>");
    rpc.append("<target>");
    rpc.append("<");
    rpc.append(configType.id());
    rpc.append("/>");
    rpc.append("</target>");
    rpc.append("</unlock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    String unlockReply = sendRequest(rpc.toString());
    return checkReply(unlockReply);
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    List<NamedFactory<UserAuth>> userAuthFactories = new ArrayList<>();
    userAuthFactories.add(new UserAuthPassword.Factory());
    sshServerNetconf.setUserAuthFactories(userAuthFactories);
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    sshServerNetconf.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(TEST_SERFILE));
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    assertThat(session1.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
    session2 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
    assertThat(session2.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    SimpleGeneratorHostKeyProvider provider = new SimpleGeneratorHostKeyProvider();
    provider.setFile(new File(TEST_SERFILE));
    sshServerNetconf.setKeyPairProvider(provider);
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    assertThat(session1.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
    session2 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
    assertThat(session2.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
}
#end_block

#method_before
@Test
public void testEditConfigRequest() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(TargetConfiguration.RUNNING, null, SAMPLE_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#method_after
@Test
public void testEditConfigRequest() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(DatastoreId.RUNNING, null, SAMPLE_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#end_block

#method_before
@Test
public void testDeleteConfigRequestWithRunningTargetConfiguration() {
    log.info("Starting delete-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertFalse("NETCONF delete-config command failed", session1.deleteConfig(TargetConfiguration.RUNNING));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF delete-config test failed: " + e.getMessage());
    }
    log.info("Finishing delete-config async");
}
#method_after
@Test
public void testDeleteConfigRequestWithRunningTargetConfiguration() {
    log.info("Starting delete-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertFalse("NETCONF delete-config command failed", session1.deleteConfig(DatastoreId.RUNNING));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF delete-config test failed: " + e.getMessage());
    }
    log.info("Finishing delete-config async");
}
#end_block

#method_before
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF copy-config command failed", session1.copyConfig(TargetConfiguration.RUNNING, "candidate"));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#method_after
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF copy-config command failed", session1.copyConfig(DatastoreId.RUNNING, DatastoreId.CANDIDATE));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF copy-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#end_block

#method_before
@Test
public void testValueOfString() throws Exception {
    assertArrayEquals(BYTE_ONLAB, MacAddress.valueOf(STR_ONLAB).toBytes());
}
#method_after
@Test
public void testValueOfString() throws Exception {
    assertArrayEquals(MAC_ONOS_BYTE, MacAddress.valueOf(MAC_ONOS_STR).toBytes());
}
#end_block

#method_before
@Test
public void testValueOfByte() throws Exception {
    assertArrayEquals(BYTE_ONLAB, MacAddress.valueOf(BYTE_ONLAB).toBytes());
}
#method_after
@Test
public void testValueOfByte() throws Exception {
    assertArrayEquals(MAC_ONOS_BYTE, MacAddress.valueOf(MAC_ONOS_BYTE).toBytes());
}
#end_block

#method_before
@Test
public void testValueOfLong() throws Exception {
    assertArrayEquals(BYTE_ONLAB, MacAddress.valueOf(LONG_ONLAB).toBytes());
}
#method_after
@Test
public void testValueOfLong() throws Exception {
    assertArrayEquals(MAC_ONOS_BYTE, MacAddress.valueOf(MAC_ONOS_LONG).toBytes());
}
#end_block

#method_before
@Test
public void testToBytes() throws Exception {
    assertArrayEquals(BYTE_ONLAB, MAC_ONLAB.toBytes());
}
#method_after
@Test
public void testToBytes() throws Exception {
    assertArrayEquals(MAC_ONOS_BYTE, MAC_ONOS.toBytes());
}
#end_block

#method_before
@Test
public void testToLong() throws Exception {
    assertEquals(LONG_ONLAB, MAC_ONLAB.toLong());
}
#method_after
@Test
public void testToLong() throws Exception {
    assertEquals(MAC_ONOS_LONG, MAC_ONOS.toLong());
}
#end_block

#method_before
@Test
public void testIsBroadcast() throws Exception {
    assertFalse(MAC_NORMAL.isBroadcast());
    assertTrue(MAC_BCAST.isBroadcast());
    assertFalse(MAC_MCAST.isBroadcast());
    assertFalse(MAC_MCAST_2.isBroadcast());
    assertFalse(MAC_LLDP.isBroadcast());
    assertFalse(MAC_LLDP_2.isBroadcast());
    assertFalse(MAC_LLDP_3.isBroadcast());
    assertFalse(MAC_ONLAB.isBroadcast());
}
#method_after
@Test
public void testIsBroadcast() throws Exception {
    assertFalse(MAC_NORMAL.isBroadcast());
    assertTrue(MAC_BCAST.isBroadcast());
    assertFalse(MAC_MCAST.isBroadcast());
    assertFalse(MAC_MCAST_2.isBroadcast());
    assertFalse(MAC_LLDP.isBroadcast());
    assertFalse(MAC_LLDP_2.isBroadcast());
    assertFalse(MAC_LLDP_3.isBroadcast());
    assertFalse(MAC_ONOS.isBroadcast());
}
#end_block

#method_before
@Test
public void testIsMulticast() throws Exception {
    // Note: LLDP MACs are also a multicast MACs
    assertFalse(MAC_NORMAL.isMulticast());
    assertFalse(MAC_BCAST.isMulticast());
    assertTrue(MAC_MCAST.isMulticast());
    assertTrue(MAC_MCAST_2.isMulticast());
    assertTrue(MAC_LLDP.isMulticast());
    assertTrue(MAC_LLDP_2.isMulticast());
    assertTrue(MAC_LLDP_3.isMulticast());
    assertFalse(MAC_ONLAB.isMulticast());
}
#method_after
@Test
public void testIsMulticast() throws Exception {
    // Note: LLDP MACs are also a multicast MACs
    assertFalse(MAC_NORMAL.isMulticast());
    assertFalse(MAC_BCAST.isMulticast());
    assertTrue(MAC_MCAST.isMulticast());
    assertTrue(MAC_MCAST_2.isMulticast());
    assertTrue(MAC_LLDP.isMulticast());
    assertTrue(MAC_LLDP_2.isMulticast());
    assertTrue(MAC_LLDP_3.isMulticast());
    assertFalse(MAC_ONOS.isMulticast());
}
#end_block

#method_before
@Test
@Deprecated
public void testIsLinkLocal() throws Exception {
    assertFalse(MAC_NORMAL.isLinkLocal());
    assertFalse(MAC_BCAST.isLinkLocal());
    assertFalse(MAC_MCAST.isLinkLocal());
    assertFalse(MAC_MCAST_2.isLinkLocal());
    assertTrue(MAC_LLDP.isLinkLocal());
    assertTrue(MAC_LLDP_2.isLinkLocal());
    assertTrue(MAC_LLDP_3.isLinkLocal());
    assertFalse(MAC_ONLAB.isLinkLocal());
}
#method_after
@Test
@Deprecated
public void testIsLinkLocal() throws Exception {
    assertFalse(MAC_NORMAL.isLinkLocal());
    assertFalse(MAC_BCAST.isLinkLocal());
    assertFalse(MAC_MCAST.isLinkLocal());
    assertFalse(MAC_MCAST_2.isLinkLocal());
    assertTrue(MAC_LLDP.isLinkLocal());
    assertTrue(MAC_LLDP_2.isLinkLocal());
    assertTrue(MAC_LLDP_3.isLinkLocal());
    assertFalse(MAC_ONOS.isLinkLocal());
}
#end_block

#method_before
@Test
public void testIsLldp() throws Exception {
    assertFalse(MAC_NORMAL.isLldp());
    assertFalse(MAC_BCAST.isLldp());
    assertFalse(MAC_MCAST.isLldp());
    assertFalse(MAC_MCAST_2.isLldp());
    assertTrue(MAC_LLDP.isLldp());
    assertTrue(MAC_LLDP_2.isLldp());
    assertTrue(MAC_LLDP_3.isLldp());
    assertFalse(MAC_ONLAB.isLldp());
}
#method_after
@Test
public void testIsLldp() throws Exception {
    assertFalse(MAC_NORMAL.isLldp());
    assertFalse(MAC_BCAST.isLldp());
    assertFalse(MAC_MCAST.isLldp());
    assertFalse(MAC_MCAST_2.isLldp());
    assertTrue(MAC_LLDP.isLldp());
    assertTrue(MAC_LLDP_2.isLldp());
    assertTrue(MAC_LLDP_3.isLldp());
    assertFalse(MAC_ONOS.isLldp());
}
#end_block

#method_before
@Test
public void testOui() throws Exception {
    assertArrayEquals(MAC_ONLAB.oui(), OUI_ONLAB);
}
#method_after
@Test
public void testOui() throws Exception {
    assertArrayEquals(MAC_ONOS.oui(), OUI_ONOS);
}
#end_block

#method_before
@Test
public void testEquals() throws Exception {
    assertTrue(MAC_ONLAB.equals(MAC_ONLAB));
    assertFalse(MAC_ONLAB.equals(STR_ONLAB));
    assertTrue(MAC_ONLAB.equals(MAC_ONLAB_EQUAL));
    assertFalse(MAC_ONLAB.equals(MAC_NORMAL));
    assertFalse(MAC_ONLAB.equals(MAC_BCAST));
    assertFalse(MAC_ONLAB.equals(MAC_MCAST));
    assertFalse(MAC_ONLAB.equals(MAC_MCAST_2));
    assertFalse(MAC_ONLAB.equals(MAC_LLDP));
    assertFalse(MAC_ONLAB.equals(MAC_LLDP_2));
    assertFalse(MAC_ONLAB.equals(MAC_LLDP_3));
}
#method_after
@Test
public void testEquals() throws Exception {
    assertTrue(MAC_ONOS.equals(MAC_ONOS));
    assertFalse(MAC_ONOS.equals(MAC_ONOS_STR));
    assertTrue(MAC_ONOS.equals(MAC_ONOS_EQUAL));
    assertFalse(MAC_ONOS.equals(MAC_NORMAL));
    assertFalse(MAC_ONOS.equals(MAC_BCAST));
    assertFalse(MAC_ONOS.equals(MAC_MCAST));
    assertFalse(MAC_ONOS.equals(MAC_MCAST_2));
    assertFalse(MAC_ONOS.equals(MAC_LLDP));
    assertFalse(MAC_ONOS.equals(MAC_LLDP_2));
    assertFalse(MAC_ONOS.equals(MAC_LLDP_3));
}
#end_block

#method_before
@Test
public void testHashCode() throws Exception {
    assertEquals(Long.hashCode(LONG_ONLAB), MAC_ONLAB.hashCode());
}
#method_after
@Test
public void testHashCode() throws Exception {
    assertEquals(Long.hashCode(MAC_ONOS_LONG), MAC_ONOS.hashCode());
}
#end_block

#method_before
@Test
public void testToString() throws Exception {
    assertEquals(STR_ONLAB, MAC_ONLAB.toString());
}
#method_after
@Test
public void testToString() throws Exception {
    assertEquals(MAC_ONOS_STR, MAC_ONOS.toString());
}
#end_block

#method_before
@Test
public void testToStringNoColon() throws Exception {
    assertEquals(STR_ONLAB_NO_COLON, MAC_ONLAB.toStringNoColon());
}
#method_after
@Test
public void testToStringNoColon() throws Exception {
    assertEquals(MAC_ONOS_STR_NO_COLON, MAC_ONOS.toStringNoColon());
}
#end_block

#method_before
public boolean isLldp() {
    return LLDP[0] == address[0] && LLDP[1] == address[1] && LLDP[2] == address[2] && LLDP[3] == address[3] && LLDP[4] == address[4] && (LLDP[5] == address[5] || LLDP[6] == address[5] || LLDP[7] == address[5]);
}
#method_after
public boolean isLldp() {
    return LLDP.contains(this);
}
#end_block

#method_before
private List<PortDescription> buildPortDescriptions(PcepDpid dpid, Port port, PortType portType) {
    List<PortDescription> portList;
    if (portMap.containsKey(dpid.value())) {
        portList = portMap.get(dpid.value());
    } else {
        portList = new ArrayList<>();
    }
    if (port != null && portType != null) {
        portList.add(buildPortDescription(port, portType));
    }
    portMap.put(dpid.value(), portList);
    return portList;
}
#method_after
private List<PortDescription> buildPortDescriptions(PcepDpid dpid, Port port) {
    List<PortDescription> portList;
    if (portMap.containsKey(dpid.value())) {
        portList = portMap.get(dpid.value());
    } else {
        portList = new ArrayList<>();
    }
    if (port != null) {
        SparseAnnotations annotations = DefaultAnnotations.builder().putAll(port.annotations()).build();
        portList.add(new DefaultPortDescription(port.number(), port.isEnabled(), port.type(), port.portSpeed(), annotations));
    }
    portMap.put(dpid.value(), portList);
    return portList;
}
#end_block

#method_before
private LinkDescription buildLinkDescription(PcepLink pceLink) {
    LinkDescription ld;
    checkNotNull(pceLink);
    DeviceId srcDeviceID = deviceId(uri(pceLink.linkSrcDeviceID()));
    DeviceId dstDeviceID = deviceId(uri(pceLink.linkDstDeviceId()));
    deviceProviderService.updatePorts(srcDeviceID, buildPortDescriptions(pceLink.linkSrcDeviceID(), pceLink.linkSrcPort(), pceLink.portType()));
    deviceProviderService.updatePorts(dstDeviceID, buildPortDescriptions(pceLink.linkDstDeviceId(), pceLink.linkDstPort(), pceLink.portType()));
    ConnectPoint src = new ConnectPoint(srcDeviceID, pceLink.linkSrcPort().number());
    ConnectPoint dst = new ConnectPoint(dstDeviceID, pceLink.linkDstPort().number());
    DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set("subType", String.valueOf(pceLink.linkSubType())).set("workState", pceLink.linkState()).set("distance", String.valueOf(pceLink.linkDistance())).set("capType", pceLink.linkCapacityType().toLowerCase()).set("avail_" + pceLink.linkCapacityType().toLowerCase(), String.valueOf(pceLink.linkAvailValue())).set("max_" + pceLink.linkCapacityType().toLowerCase(), String.valueOf(pceLink.linkMaxValue())).build();
    // construct the link
    ld = new DefaultLinkDescription(src, dst, Type.OPTICAL, extendedAttributes);
    return ld;
}
#method_after
private LinkDescription buildLinkDescription(PcepLink pceLink) {
    LinkDescription ld;
    checkNotNull(pceLink);
    DeviceId srcDeviceID = deviceId(uri(pceLink.linkSrcDeviceID()));
    DeviceId dstDeviceID = deviceId(uri(pceLink.linkDstDeviceId()));
    deviceProviderService.updatePorts(srcDeviceID, buildPortDescriptions(pceLink.linkSrcDeviceID(), pceLink.linkSrcPort()));
    deviceProviderService.updatePorts(dstDeviceID, buildPortDescriptions(pceLink.linkDstDeviceId(), pceLink.linkDstPort()));
    ConnectPoint src = new ConnectPoint(srcDeviceID, pceLink.linkSrcPort().number());
    ConnectPoint dst = new ConnectPoint(dstDeviceID, pceLink.linkDstPort().number());
    DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set("subType", String.valueOf(pceLink.linkSubType())).set("workState", pceLink.linkState()).set("distance", String.valueOf(pceLink.linkDistance())).set("capType", pceLink.linkCapacityType().toLowerCase()).set("avail_" + pceLink.linkCapacityType().toLowerCase(), String.valueOf(pceLink.linkAvailValue())).set("max_" + pceLink.linkCapacityType().toLowerCase(), String.valueOf(pceLink.linkMaxValue())).build();
    // construct the link
    ld = new DefaultLinkDescription(src, dst, Type.OPTICAL, extendedAttributes);
    return ld;
}
#end_block

#method_before
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    if (this.isDomainProcessingEnabled(intent)) {
        intentList.addAll(this.getDomainIntents(intent, domainService));
    }
    List<Objective> objectives = new ArrayList<>();
    List<DeviceId> devices = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        // add only objectives that are not inside of a domain
        if (LOCAL.equals(domainService.getDomain(deviceId))) {
            List<Objective> deviceObjectives = createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels);
            deviceObjectives.forEach(objective -> {
                objectives.add(objective);
                devices.add(deviceId);
            });
        }
    }
    // if any objectives have been created
    if (!objectives.isEmpty()) {
        intentList.add(new FlowObjectiveIntent(appId, intent.key(), devices, objectives, intent.resources(), intent.resourceGroup()));
    }
    return intentList.build();
}
#method_after
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();
    if (this.isDomainProcessingEnabled(intent)) {
        intentList.addAll(this.getDomainIntents(intent, domainService));
    }
    List<Objective> objectives = new ArrayList<>();
    List<DeviceId> devices = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        // add only objectives that are not inside of a domain
        if (LOCAL.equals(domainService.getDomain(deviceId))) {
            List<Objective> deviceObjectives = createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels);
            deviceObjectives.forEach(objective -> {
                objectives.add(objective);
                devices.add(deviceId);
            });
        }
    }
    // if any objectives have been created
    if (!objectives.isEmpty()) {
        intentList.add(new FlowObjectiveIntent(appId, intent.key(), devices, objectives, intent.resources(), intent.resourceGroup()));
    }
    return intentList.build();
}
#end_block

#method_before
protected List<Constraint> buildConstraints() {
    final List<Constraint> constraints = new LinkedList<>();
    // Check for a bandwidth specification
    if (!isNullOrEmpty(bandwidthString)) {
        Bandwidth bandwidth;
        try {
            bandwidth = Bandwidth.bps(Long.parseLong(bandwidthString));
        // when the string can't be parsed as long, then try to parse as double
        } catch (NumberFormatException e) {
            bandwidth = Bandwidth.bps(Double.parseDouble(bandwidthString));
        }
        constraints.add(new BandwidthConstraint(bandwidth));
    }
    // Check for partial failure specification
    if (partial) {
        constraints.add(new PartialFailureConstraint());
    }
    // Check for encapsulation specification
    if (!isNullOrEmpty(encapsulationString)) {
        final EncapsulationType encapType = EncapsulationType.valueOf(encapsulationString);
        constraints.add(new EncapsulationConstraint(encapType));
    }
    // Check for hashed path selection
    if (hashedPathSelection) {
        constraints.add(new HashedPathSelectionConstraint());
    }
    // Check for domain processing
    if (domains) {
        constraints.add(new DomainConstraint());
    }
    return constraints;
}
#method_after
protected List<Constraint> buildConstraints() {
    final List<Constraint> constraints = new LinkedList<>();
    // Check for a bandwidth specification
    if (!isNullOrEmpty(bandwidthString)) {
        Bandwidth bandwidth;
        try {
            bandwidth = Bandwidth.bps(Long.parseLong(bandwidthString));
        // when the string can't be parsed as long, then try to parse as double
        } catch (NumberFormatException e) {
            bandwidth = Bandwidth.bps(Double.parseDouble(bandwidthString));
        }
        constraints.add(new BandwidthConstraint(bandwidth));
    }
    // Check for partial failure specification
    if (partial) {
        constraints.add(new PartialFailureConstraint());
    }
    // Check for encapsulation specification
    if (!isNullOrEmpty(encapsulationString)) {
        final EncapsulationType encapType = EncapsulationType.valueOf(encapsulationString);
        constraints.add(new EncapsulationConstraint(encapType));
    }
    // Check for hashed path selection
    if (hashedPathSelection) {
        constraints.add(new HashedPathSelectionConstraint());
    }
    // Check for domain processing
    if (domains) {
        constraints.add(DomainConstraint.domain());
    }
    return constraints;
}
#end_block

#method_before
protected boolean isDomainProcessingEnabled(LinkCollectionIntent intent) {
    return intent.constraints().stream().anyMatch(constraint -> constraint instanceof DomainConstraint);
}
#method_after
protected boolean isDomainProcessingEnabled(LinkCollectionIntent intent) {
    return intent.constraints().contains(DomainConstraint.domain());
}
#end_block

#method_before
protected List<Intent> getDomainIntents(LinkCollectionIntent intent, DomainService domainService) {
    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();
    // TODO: support multi point to multi point
    if (intent.filteredIngressPoints().size() == 1 && intent.filteredEgressPoints().size() == 1) {
        ImmutableList.Builder<Link> domainLinks = ImmutableList.builder();
        // get the initial ingress connection point
        FilteredConnectPoint ingress = intent.filteredIngressPoints().iterator().next();
        FilteredConnectPoint egress;
        // the current domain (or LOCAL)
        DomainId currentDomain = domainService.getDomain(ingress.connectPoint().deviceId());
        DeviceId currentDevice = ingress.connectPoint().deviceId();
        // if we entered a domain store the domain ingress
        FilteredConnectPoint domainIngress = LOCAL.equals(currentDomain) ? null : ingress;
        // this is necessary because a set is not sorted by default
        for (int i = 0; i < intent.links().size(); i++) {
            // find the next link
            List<Link> nextLinks = getLinksWithSource(intent.links(), currentDevice);
            // no matching link exists
            if (nextLinks.isEmpty()) {
                throw new IntentCompilationException("No matching link starting at " + ingress.connectPoint().deviceId());
            }
            Link nextLink = nextLinks.get(0);
            ingress = new FilteredConnectPoint(nextLink.src());
            // get the egress and the domain
            egress = new FilteredConnectPoint(nextLink.dst());
            DomainId dstDomain = domainService.getDomain(egress.connectPoint().deviceId());
            if (!LOCAL.equals(currentDomain)) {
                if (currentDomain.equals(dstDomain)) {
                    // we are staying in the same domain, store the traversed link
                    domainLinks.add(nextLink);
                    log.debug("{} belongs to the same domain.", egress.connectPoint().deviceId());
                } else {
                    // we are leaving the current domain -> add the domain intent
                    DomainPointToPointIntent domainIntent = DomainPointToPointIntent.builder().appId(intent.appId()).filteredIngressPoint(domainIngress).filteredEgressPoint(ingress).links(domainLinks.build()).build();
                    // add to intent list
                    intentList.add(domainIntent);
                    // update current domain (might be LOCAL)
                    currentDomain = dstDomain;
                    // update the domain ingress
                    domainIngress = LOCAL.equals(currentDomain) ? null : egress;
                    // TODO: might end up with an unused builder
                    // reset domain links
                    domainLinks = ImmutableList.builder();
                }
            } else {
                if (!LOCAL.equals(dstDomain)) {
                    // entering a new domain
                    currentDomain = dstDomain;
                    domainIngress = egress;
                }
            }
            currentDevice = egress.connectPoint().deviceId();
        }
        // get the egress point
        egress = intent.filteredEgressPoints().iterator().next();
        // still inside a domain?
        if (!LOCAL.equals(currentDomain) && currentDomain.equals(domainService.getDomain(egress.connectPoint().deviceId()))) {
            // add intent
            DomainPointToPointIntent domainIntent = DomainPointToPointIntent.builder().appId(intent.appId()).filteredIngressPoint(domainIngress).filteredEgressPoint(egress).links(domainLinks.build()).build();
            intentList.add(domainIntent);
        }
    }
    return intentList.build();
}
#method_after
protected List<Intent> getDomainIntents(LinkCollectionIntent intent, DomainService domainService) {
    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();
    // TODO: support multi point to multi point
    if (intent.filteredIngressPoints().size() != 1 || intent.filteredEgressPoints().size() != 1) {
        log.warn("Multiple ingress or egress ports not supported!");
        return intentList.build();
    }
    ImmutableList.Builder<Link> domainLinks = ImmutableList.builder();
    // get the initial ingress connection point
    FilteredConnectPoint ingress = intent.filteredIngressPoints().iterator().next();
    FilteredConnectPoint egress;
    DeviceId currentDevice = ingress.connectPoint().deviceId();
    // the current domain (or LOCAL)
    DomainId currentDomain = domainService.getDomain(currentDevice);
    // if we entered a domain store the domain ingress
    FilteredConnectPoint domainIngress = LOCAL.equals(currentDomain) ? null : ingress;
    // this is necessary because a set is not sorted by default
    for (int i = 0; i < intent.links().size(); i++) {
        // find the next link
        List<Link> nextLinks = getEgressLinks(intent.links(), currentDevice);
        // no matching link exists
        if (nextLinks.isEmpty()) {
            throw new IntentCompilationException("No matching link starting at " + ingress.connectPoint().deviceId());
        }
        // get the first link
        Link nextLink = nextLinks.get(0);
        ingress = new FilteredConnectPoint(nextLink.src());
        egress = new FilteredConnectPoint(nextLink.dst());
        // query the domain for the domain of the link's destination
        DomainId dstDomain = domainService.getDomain(egress.connectPoint().deviceId());
        if (!currentDomain.equals(dstDomain)) {
            // we are leaving the current domain or LOCAL
            log.debug("Domain transition from {} to {}.", currentDomain, dstDomain);
            if (!LOCAL.equals(currentDomain)) {
                // add the domain intent to the intent list
                intentList.add(createDomainP2PIntent(intent, domainIngress, ingress, domainLinks.build()));
                // TODO: might end up with an unused builder
                // reset domain links builder
                domainLinks = ImmutableList.builder();
            }
            // update current domain (might be LOCAL)
            currentDomain = dstDomain;
            // update the domain's ingress
            domainIngress = LOCAL.equals(currentDomain) ? null : egress;
        } else {
            if (!LOCAL.equals(currentDomain)) {
                // we are staying in the same domain, store the traversed link
                domainLinks.add(nextLink);
                log.debug("{} belongs to the same domain.", egress.connectPoint().deviceId());
            }
        }
        currentDevice = egress.connectPoint().deviceId();
    }
    // get the egress point
    egress = intent.filteredEgressPoints().iterator().next();
    // still inside a domain?
    if (!LOCAL.equals(currentDomain) && currentDomain.equals(domainService.getDomain(egress.connectPoint().deviceId()))) {
        // add intent
        intentList.add(createDomainP2PIntent(intent, domainIngress, egress, domainLinks.build()));
    }
    return intentList.build();
}
#end_block

#method_before
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    if (this.isDomainProcessingEnabled(intent)) {
        intentList.addAll(this.getDomainIntents(intent, domainService));
    }
    List<FlowRule> rules = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        // add only flows that are not inside of a domain
        if (LOCAL.equals(domainService.getDomain(deviceId))) {
            rules.addAll(createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels));
        }
    }
    // if any rules have been created
    if (!rules.isEmpty()) {
        intentList.add(new FlowRuleIntent(appId, intent.key(), rules, intent.resources()));
    }
    return intentList.build();
}
#method_after
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    ImmutableList.Builder<Intent> intentList = ImmutableList.builder();
    if (this.isDomainProcessingEnabled(intent)) {
        intentList.addAll(this.getDomainIntents(intent, domainService));
    }
    List<FlowRule> rules = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        // add only flows that are not inside of a domain
        if (LOCAL.equals(domainService.getDomain(deviceId))) {
            rules.addAll(createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels));
        }
    }
    // if any rules have been created
    if (!rules.isEmpty()) {
        intentList.add(new FlowRuleIntent(appId, intent.key(), rules, intent.resources()));
    }
    return intentList.build();
}
#end_block

#method_before
private void sendHandshakeHelloMessage() throws IOException {
    // The OF protocol requires us to start things off by sending the highest
    // version of the protocol supported.
    // bitmap represents OF1.0 (ofp_version=0x01) and OF1.3 (ofp_version=0x04)
    // see Sec. 7.5.1 of the OF1.3.4 spec
    U32 bitmap = U32.ofRaw((0b1 << OFVersion.OF_10.getWireVersion()) | (0b1 << OFVersion.OF_13.getWireVersion()) | (0b1 << OFVersion.OF_14.getWireVersion()));
    OFVersion version = Optional.ofNullable(ofVersion).orElse(OFVersion.OF_13);
    OFHelloElem hem = OFFactories.getFactory(version).buildHelloElemVersionbitmap().setBitmaps(Collections.singletonList(bitmap)).build();
    OFMessage.Builder mb = OFFactories.getFactory(version).buildHello().setXid(this.handshakeTransactionIds--).setElements(Collections.singletonList(hem));
    log.info("Sending {} Hello to {}", version, channel.getRemoteAddress());
    channel.write(Collections.singletonList(mb.build()));
}
#method_after
private void sendHandshakeHelloMessage() throws IOException {
    // The OF protocol requires us to start things off by sending the highest
    // version of the protocol supported.
    // bitmap represents OF1.0, OF1.3, and OF1.4
    // see Sec. 7.5.1 of the OF1.3.4 spec
    U32 bitmap = U32.ofRaw((0b1 << OFVersion.OF_10.getWireVersion()) | (0b1 << OFVersion.OF_13.getWireVersion()) | (0b1 << OFVersion.OF_14.getWireVersion()));
    OFVersion version = Optional.ofNullable(ofVersion).orElse(OFVersion.OF_13);
    OFHelloElem hem = OFFactories.getFactory(version).buildHelloElemVersionbitmap().setBitmaps(Collections.singletonList(bitmap)).build();
    OFMessage.Builder mb = OFFactories.getFactory(version).buildHello().setXid(this.handshakeTransactionIds--).setElements(Collections.singletonList(hem));
    log.info("Sending {} Hello to {}", version, channel.getRemoteAddress());
    channel.write(Collections.singletonList(mb.build()));
}
#end_block

#method_before
@Activate
public void activate() {
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    linkService.addListener(linkListener);
    domainStore.setDelegate(delegate);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    deviceService.removeListener(deviceListener);
    hostService.removeListener(hostListener);
    linkService.removeListener(linkListener);
    domainStore.unsetDelegate(delegate);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    log.info("Stopped");
}
#end_block

#method_before
@Override
public Set<DomainId> getDomainIds() {
    return domainStore.getDomainIds();
}
#method_after
@Override
public Set<DomainId> getDomainIds() {
    Set<DomainId> domIds = new HashSet<>();
    deviceService.getAvailableDevices().forEach(dev -> domIds.add(getAnnotatedDomainId(dev)));
    return domIds;
}
#end_block

#method_before
@Override
public Set<DeviceId> getDeviceIds(DomainId domainId) {
    return domainStore.getDeviceIds(domainId);
}
#method_after
@Override
public Set<DeviceId> getDeviceIds(DomainId domainId) {
    Set<DeviceId> domainIds = new HashSet<>();
    deviceService.getAvailableDevices().forEach(dev -> {
        if (getAnnotatedDomainId(dev).equals(domainId)) {
            domainIds.add(dev.id());
        }
    });
    return domainIds;
}
#end_block

#method_before
@Override
public DomainId getDomain(DeviceId deviceId) {
    checkNotNull(deviceId);
    return domainStore.getDomain(deviceId);
}
#method_after
@Override
public DomainId getDomain(DeviceId deviceId) {
    checkNotNull(deviceId);
    return checkNotNull(getAnnotatedDomainId(deviceService.getDevice(deviceId)));
}
#end_block

#method_before
@Activate
public void activate() {
    configService.registerProperties(getClass());
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService, domainIntentService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch", log));
    workerExecutor = newFixedThreadPool(numThreads, groupedThreads("onos/intent", "worker-%d", log));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    configService.registerProperties(getClass());
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService, networkConfigService, domainIntentService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch", log));
    workerExecutor = newFixedThreadPool(numThreads, groupedThreads("onos/intent", "worker-%d", log));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.unbindIdGenerator(idGenerator);
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    intentInstaller.init(null, null, null, null, null);
    if (skipReleaseResourcesOnWithdrawal) {
        store.unsetDelegate(testOnlyDelegate);
    } else {
        store.unsetDelegate(delegate);
    }
    configService.unregisterProperties(getClass(), false);
    trackerService.unsetDelegate(topoDelegate);
    eventDispatcher.removeSink(IntentEvent.class);
    batchExecutor.shutdown();
    workerExecutor.shutdown();
    Intent.unbindIdGenerator(idGenerator);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    intentInstaller.init(null, null, null, null, null, null);
    if (skipReleaseResourcesOnWithdrawal) {
        store.unsetDelegate(testOnlyDelegate);
    } else {
        store.unsetDelegate(delegate);
    }
    configService.unregisterProperties(getClass(), false);
    trackerService.unsetDelegate(topoDelegate);
    eventDispatcher.removeSink(IntentEvent.class);
    batchExecutor.shutdown();
    workerExecutor.shutdown();
    Intent.unbindIdGenerator(idGenerator);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void notify(IntentEvent event) {
    post(event);
    switch(event.type()) {
        case WITHDRAWN:
            // release resources allocated to withdrawn intent
            if (!resourceService.release(event.subject().id())) {
                log.error("Failed to release resources allocated to {}", event.subject().id());
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void notify(IntentEvent event) {
    post(event);
    switch(event.type()) {
        case WITHDRAWN:
            if (!skipReleaseResourcesOnWithdrawal) {
                releaseResources(event.subject());
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void execute(Collection<IntentData> operations) {
    log.debug("Execute {} operation(s).", operations.size());
    log.trace("Execute operations: {}", operations);
    // batchExecutor is single-threaded, so only one batch is in flight at a time
    CompletableFuture.runAsync(() -> {
        // process intent until the phase reaches one of the final phases
        List<CompletableFuture<IntentData>> futures = operations.stream().map(x -> CompletableFuture.completedFuture(x).thenApply(IntentManager.this::createInitialPhase).thenApplyAsync(IntentProcessPhase::process, workerExecutor).thenApply(FinalIntentProcessPhase::data).exceptionally(e -> {
            // FIXME
            log.warn("Future failed: {}", e);
            return null;
        })).collect(Collectors.toList());
        // write multiple data to store in order
        store.batchWrite(Tools.allOf(futures).join().stream().filter(Objects::nonNull).collect(Collectors.toList()));
    }, batchExecutor).exceptionally(e -> {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        return null;
    }).thenRun(accumulator::ready);
}
#method_after
@Override
public void execute(Collection<IntentData> operations) {
    log.debug("Execute {} operation(s).", operations.size());
    log.trace("Execute operations: {}", operations);
    // batchExecutor is single-threaded, so only one batch is in flight at a time
    CompletableFuture.runAsync(() -> {
        // process intent until the phase reaches one of the final phases
        List<CompletableFuture<IntentData>> futures = operations.stream().map(x -> CompletableFuture.completedFuture(x).thenApply(IntentManager.this::createInitialPhase).thenApplyAsync(IntentProcessPhase::process, workerExecutor).thenApply(FinalIntentProcessPhase::data).exceptionally(e -> {
            // When the future fails, we update the Intent to simulate the failure of
            // the installation/withdrawal phase and we save in the current map. In
            // the next round the CleanUp Thread will pick this Intent again.
            log.warn("Future failed", e);
            log.warn("Intent {} - state {} - request {}", x.key(), x.state(), x.request());
            switch(x.state()) {
                case INSTALL_REQ:
                case INSTALLING:
                case WITHDRAW_REQ:
                case WITHDRAWING:
                    x.setState(FAILED);
                    IntentData current = store.getIntentData(x.key());
                    return new IntentData(x, current.installables());
                default:
                    return null;
            }
        })).collect(Collectors.toList());
        // write multiple data to store in order
        store.batchWrite(Tools.allOf(futures).join().stream().filter(Objects::nonNull).collect(Collectors.toList()));
    }, batchExecutor).exceptionally(e -> {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        return null;
    }).thenRun(accumulator::ready);
}
#end_block

#method_before
private IntentProcessPhase createInitialPhase(IntentData data) {
    IntentData current = store.getIntentData(data.key());
    return newInitialPhase(processor, data, current);
}
#method_after
private IntentProcessPhase createInitialPhase(IntentData data) {
    IntentData pending = store.getPendingData(data.key());
    if (pending == null || pending.version().isNewerThan(data.version())) {
        /*
                If the pending map is null, then this intent was compiled by a
                previous batch iteration, so we can skip it.
                If the pending map has a newer request, it will get compiled as
                part of the next batch, so we can skip it.
             */
        return Skipped.getPhase();
    }
    IntentData current = store.getIntentData(data.key());
    return newInitialPhase(processor, data, current);
}
#end_block

#method_before
void init(IntentStore intentStore, ObjectiveTrackerService trackerService, FlowRuleService flowRuleService, FlowObjectiveService flowObjectiveService, DomainIntentService domainIntentService) {
    this.store = intentStore;
    this.trackerService = trackerService;
    // TODO Various services should be plugged to the intent installer instead of being hardcoded
    this.flowRuleService = flowRuleService;
    this.flowObjectiveService = flowObjectiveService;
    this.domainIntentService = domainIntentService;
}
#method_after
void init(IntentStore intentStore, ObjectiveTrackerService trackerService, FlowRuleService flowRuleService, FlowObjectiveService flowObjectiveService, NetworkConfigService networkConfigService, DomainIntentService domainIntentService) {
    this.store = intentStore;
    this.trackerService = trackerService;
    // TODO Various services should be plugged to the intent installer instead of being hardcoded
    this.flowRuleService = flowRuleService;
    this.flowObjectiveService = flowObjectiveService;
    this.networkConfigService = networkConfigService;
    this.domainIntentService = domainIntentService;
}
#end_block

#method_before
// FIXME: Refactor to accept both FlowObjectiveIntent and FlowRuleIntents
// FIXME: Intent Manager should have never become dependent on a specific intent type(s).
// This will be addressed in intent domains work; not now.
void apply(Optional<IntentData> toUninstall, Optional<IntentData> toInstall) {
    // Hook for handling success at intent installation level
    Consumer<IntentInstallationContext> successConsumer = (ctx) -> {
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.debug("Completed installing: {}", installData.key());
            installData.setState(INSTALLED);
            store.write(installData);
        } else if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            log.debug("Completed withdrawing: {}", uninstallData.key());
            switch(uninstallData.request()) {
                case INSTALL_REQ:
                    uninstallData.setState(FAILED);
                    break;
                case WITHDRAW_REQ:
                default:
                    // TODO "default" case should not happen
                    uninstallData.setState(WITHDRAWN);
                    break;
            }
            // Intent has been withdrawn; we can clear the installables
            store.write(new IntentData(uninstallData, Collections.emptyList()));
        }
    };
    // Hook for handling errors at intent installation level
    Consumer<IntentInstallationContext> errorConsumer = (ctx) -> {
        // if toInstall was cause of error, then recompile (manage/increment counter, when exceeded -> CORRUPT)
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            installData.setState(CORRUPT);
            installData.incrementErrorCount();
            store.write(installData);
        }
        // if toUninstall was cause of error, then CORRUPT (another job will clean this up)
        if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData.setState(CORRUPT);
            uninstallData.incrementErrorCount();
            store.write(uninstallData);
        }
    };
    // Hooks at operation level
    Consumer<OperationContext> successOperationConsumer = (ctx) -> {
        ctx.intentContext.finishContext(ctx);
    };
    Consumer<OperationContext> errorOperationConsumer = (ctx) -> {
        if (ctx.toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.warn("Failed installation operation for: {} {} due to {}", installData.key(), installData.intent(), ctx.error());
        }
        if (ctx.toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            log.warn("Failed withdrawal operatin for: {} {} due to {}", uninstallData.key(), uninstallData.intent(), ctx.error());
        }
        ctx.intentContext.handleError(ctx);
    };
    // Create a context for tracking the backing operations for applying
    // the intents to the environment.
    IntentInstallationContext intentContext = new IntentInstallationContext(successConsumer, errorConsumer);
    Set<OperationContext> contexts = createContext(intentContext, toUninstall, toInstall);
    intentContext.pendingContexts = contexts;
    contexts.forEach(ctx -> {
        ctx.prepare(toUninstall, toInstall, successOperationConsumer, errorOperationConsumer);
        ctx.apply();
    });
}
#method_after
// FIXME: Intent Manager should have never become dependent on a specific intent type(s).
// This will be addressed in intent domains work; not now.
void apply(Optional<IntentData> toUninstall, Optional<IntentData> toInstall) {
    // Hook for handling success at intent installation level.
    Consumer<IntentInstallationContext> successConsumer = (ctx) -> {
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.debug("Completed installing: {}", installData.key());
            installData.setState(INSTALLED);
            store.write(installData);
        } else if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            log.debug("Completed withdrawing: {}", uninstallData.key());
            switch(uninstallData.request()) {
                case INSTALL_REQ:
                    uninstallData.setState(FAILED);
                    break;
                case WITHDRAW_REQ:
                default:
                    // TODO "default" case should not happen
                    uninstallData.setState(WITHDRAWN);
                    break;
            }
            // Intent has been withdrawn; we can clear the installables
            store.write(new IntentData(uninstallData, Collections.emptyList()));
        }
    };
    // Hook for handling errors at intent installation level
    Consumer<IntentInstallationContext> errorConsumer = (ctx) -> {
        // if toInstall was cause of error, then recompile (manage/increment counter, when exceeded -> CORRUPT)
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            installData.setState(CORRUPT);
            installData.incrementErrorCount();
            store.write(installData);
        }
        // if toUninstall was cause of error, then CORRUPT (another job will clean this up)
        if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData.setState(CORRUPT);
            uninstallData.incrementErrorCount();
            store.write(uninstallData);
        }
    };
    // Hooks at operation level
    Consumer<OperationContext> successOperationConsumer = (ctx) -> {
        ctx.intentContext.finishContext(ctx);
    };
    Consumer<OperationContext> errorOperationConsumer = (ctx) -> {
        if (ctx.toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.warn("Failed installation operation for: {} {} due to {}", installData.key(), installData.intent(), ctx.error());
        }
        if (ctx.toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            log.warn("Failed withdrawal operation for: {} {} due to {}", uninstallData.key(), uninstallData.intent(), ctx.error());
        }
        ctx.intentContext.handleError(ctx);
    };
    // Create a context for tracking the backing operations for applying
    // the intents to the environment.
    IntentInstallationContext intentContext = new IntentInstallationContext(successConsumer, errorConsumer);
    Set<OperationContext> contexts = createContext(intentContext, toUninstall, toInstall);
    intentContext.pendingContexts = contexts;
    contexts.forEach(ctx -> {
        ctx.prepare(toUninstall, toInstall, successOperationConsumer, errorOperationConsumer);
        ctx.apply();
    });
}
#end_block

#method_before
// --- Utilities to support FlowRule vs. FlowObjective vs. DomainIntent behavior ----
// Creates the context appropriate for tracking operations of the
private Set<OperationContext> createContext(IntentInstallationContext intentContext, Optional<IntentData> toUninstall, Optional<IntentData> toInstall) {
    Set<OperationContext> contexts = Sets.newConcurrentHashSet();
    if (isInstallable(toUninstall, toInstall, FlowRuleIntent.class)) {
        contexts.add(new FlowRuleOperationContext(intentContext));
    }
    if (isInstallable(toUninstall, toInstall, FlowObjectiveIntent.class)) {
        contexts.add(new FlowObjectiveOperationContext(intentContext));
    }
    if (isInstallable(toUninstall, toInstall, DomainIntent.class)) {
        contexts.add(new DomainIntentOperationContext(intentContext));
    }
    // the installable intents should be empty.
    return contexts.isEmpty() ? ImmutableSet.of(new ErrorContext(intentContext)) : contexts;
}
#method_after
// --- Utilities to support FlowRule vs. FlowObjective vs. DomainIntent behavior ----
// Creates the set of contexts appropriate for tracking operations of the
private Set<OperationContext> createContext(IntentInstallationContext intentContext, Optional<IntentData> toUninstall, Optional<IntentData> toInstall) {
    Set<OperationContext> contexts = Sets.newConcurrentHashSet();
    if (isInstallable(toUninstall, toInstall, FlowRuleIntent.class)) {
        contexts.add(new FlowRuleOperationContext(intentContext));
    }
    if (isInstallable(toUninstall, toInstall, FlowObjectiveIntent.class)) {
        contexts.add(new FlowObjectiveOperationContext(intentContext));
    }
    if (isInstallable(toUninstall, toInstall, ProtectionEndpointIntent.class)) {
        contexts.add(new ProtectionConfigOperationContext(intentContext));
    }
    if (isInstallable(toUninstall, toInstall, DomainIntent.class)) {
        contexts.add(new DomainIntentOperationContext(intentContext));
    }
    if (contexts.isEmpty()) {
        log.warn("{} did not contain installable Intents", intentContext);
        return ImmutableSet.of(new ErrorContext(intentContext));
    }
    return contexts;
}
#end_block

#method_before
private boolean isInstallable(Optional<IntentData> toUninstall, Optional<IntentData> toInstall, Class<? extends Intent> intentClass) {
    boolean notBothNull = false;
    if (toInstall.isPresent()) {
        notBothNull = true;
        if (!toInstall.get().installables().stream().anyMatch(i -> intentClass.isAssignableFrom(i.getClass()))) {
            return false;
        }
    }
    if (toUninstall.isPresent()) {
        notBothNull = true;
        if (!toUninstall.get().installables().stream().anyMatch(i -> intentClass.isAssignableFrom(i.getClass()))) {
            return false;
        }
    }
    return notBothNull;
}
#method_after
private boolean isInstallable(Optional<IntentData> toUninstall, Optional<IntentData> toInstall, Class<? extends Intent> intentClass) {
    return Stream.concat(toInstall.map(IntentData::installables).map(Collection::stream).orElse(Stream.empty()), toUninstall.map(IntentData::installables).map(Collection::stream).orElse(Stream.empty())).anyMatch(i -> intentClass.isAssignableFrom(i.getClass()));
}
#end_block

#method_before
private void prepareIntentData(Optional<IntentData> uninstallData, Optional<IntentData> installData) {
    if (!installData.isPresent() && !uninstallData.isPresent()) {
        return;
    } else if (!installData.isPresent()) {
        prepareIntentData(uninstallData, Direction.REMOVE);
    } else if (!uninstallData.isPresent()) {
        prepareIntentData(installData, Direction.ADD);
    } else {
        IntentData uninstall = uninstallData.get();
        IntentData install = installData.get();
        List<Intent> uninstallIntents = Lists.newArrayList(uninstall.installables());
        List<Intent> installIntents = Lists.newArrayList(install.installables());
        checkState(uninstallIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
        checkState(installIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
        // TODO: Filter FlowObjective intents
        // Filter out same intents and intents with same flow rules
        Iterator<Intent> iterator = installIntents.iterator();
        while (iterator.hasNext()) {
            Intent installIntent = iterator.next();
            uninstallIntents.stream().filter(uIntent -> {
                if (uIntent.equals(installIntent)) {
                    return true;
                } else if (uIntent instanceof FlowRuleIntent && installIntent instanceof FlowRuleIntent) {
                    // (direction can be implied from intent state)
                    return ((FlowRuleIntent) uIntent).flowRules().containsAll(((FlowRuleIntent) installIntent).flowRules());
                } else {
                    return false;
                }
            }).findFirst().ifPresent(common -> {
                uninstallIntents.remove(common);
                if (INSTALLED.equals(uninstall.state())) {
                    // only remove the install intent if the existing
                    // intent (i.e. the uninstall one) is already
                    // installed or installing
                    iterator.remove();
                }
            });
        }
        final IntentData newUninstall = new IntentData(uninstall, uninstallIntents);
        final IntentData newInstall = new IntentData(install, installIntents);
        trackerService.removeTrackedResources(newUninstall.key(), newUninstall.intent().resources());
        uninstallIntents.forEach(installable -> trackerService.removeTrackedResources(newUninstall.intent().key(), installable.resources()));
        trackerService.addTrackedResources(newInstall.key(), newInstall.intent().resources());
        installIntents.forEach(installable -> trackerService.addTrackedResources(newInstall.key(), installable.resources()));
        prepareIntents(uninstallIntents, Direction.REMOVE);
        prepareIntents(installIntents, Direction.ADD);
    }
}
#method_after
private void prepareIntentData(Optional<IntentData> uninstallData, Optional<IntentData> installData) {
    if (!installData.isPresent() && !uninstallData.isPresent()) {
        return;
    } else if (!installData.isPresent()) {
        prepareIntentData(uninstallData, Direction.REMOVE);
    } else if (!uninstallData.isPresent()) {
        prepareIntentData(installData, Direction.ADD);
    } else {
        IntentData uninstall = uninstallData.get();
        IntentData install = installData.get();
        List<Intent> uninstallIntents = Lists.newArrayList(uninstall.installables());
        List<Intent> installIntents = Lists.newArrayList(install.installables());
        checkState(uninstallIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", uninstallIntents);
        checkState(installIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", installIntents);
        // TODO: Filter FlowObjective intents
        // Filter out same intents and intents with same flow rules
        Iterator<Intent> iterator = installIntents.iterator();
        while (iterator.hasNext()) {
            Intent installIntent = iterator.next();
            uninstallIntents.stream().filter(uIntent -> {
                if (uIntent.equals(installIntent)) {
                    return true;
                } else if (uIntent instanceof FlowRuleIntent && installIntent instanceof FlowRuleIntent) {
                    // (direction can be implied from intent state)
                    return !flowRuleIntentChanged(((FlowRuleIntent) uIntent), ((FlowRuleIntent) installIntent));
                } else {
                    return false;
                }
            }).findFirst().ifPresent(common -> {
                uninstallIntents.remove(common);
                if (INSTALLED.equals(uninstall.state())) {
                    // only remove the install intent if the existing
                    // intent (i.e. the uninstall one) is already
                    // installed or installing
                    iterator.remove();
                }
            });
        }
        final IntentData newUninstall = new IntentData(uninstall, uninstallIntents);
        final IntentData newInstall = new IntentData(install, installIntents);
        trackerService.removeTrackedResources(newUninstall.key(), newUninstall.intent().resources());
        uninstallIntents.forEach(installable -> trackerService.removeTrackedResources(newUninstall.intent().key(), installable.resources()));
        trackerService.addTrackedResources(newInstall.key(), newInstall.intent().resources());
        installIntents.forEach(installable -> trackerService.addTrackedResources(newInstall.key(), installable.resources()));
        prepareIntents(uninstallIntents, Direction.REMOVE);
        prepareIntents(installIntents, Direction.ADD);
    }
}
#end_block

#method_before
private void prepareIntentData(Optional<IntentData> intentData, Direction direction) {
    if (!intentData.isPresent()) {
        return;
    }
    IntentData data = intentData.get();
    List<Intent> intentsToApply = data.installables();
    checkState(intentsToApply.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
    if (direction == Direction.ADD) {
        trackerService.addTrackedResources(data.key(), data.intent().resources());
        intentsToApply.forEach(installable -> trackerService.addTrackedResources(data.key(), installable.resources()));
    } else {
        trackerService.removeTrackedResources(data.key(), data.intent().resources());
        intentsToApply.forEach(installable -> trackerService.removeTrackedResources(data.intent().key(), installable.resources()));
    }
    prepareIntents(intentsToApply, direction);
}
#method_after
private void prepareIntentData(Optional<IntentData> intentData, Direction direction) {
    if (!intentData.isPresent()) {
        return;
    }
    IntentData data = intentData.get();
    List<Intent> intentsToApply = data.installables();
    checkState(intentsToApply.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", intentsToApply);
    if (direction == Direction.ADD) {
        trackerService.addTrackedResources(data.key(), data.intent().resources());
        intentsToApply.forEach(installable -> trackerService.addTrackedResources(data.key(), installable.resources()));
    } else {
        trackerService.removeTrackedResources(data.key(), data.intent().resources());
        intentsToApply.forEach(installable -> trackerService.removeTrackedResources(data.intent().key(), installable.resources()));
    }
    prepareIntents(intentsToApply, direction);
}
#end_block

#method_before
private boolean isSupported(Intent intent) {
    return intent instanceof FlowRuleIntent || intent instanceof FlowObjectiveIntent || intent instanceof DomainIntent;
}
#method_after
private boolean isSupported(Intent intent) {
    return intent instanceof FlowRuleIntent || intent instanceof FlowObjectiveIntent || intent instanceof ProtectionEndpointIntent || intent instanceof DomainIntent;
}
#end_block

#method_before
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    intentsToApply.stream().filter(x -> x instanceof FlowObjectiveIntent).flatMap(x -> buildObjectiveContexts((FlowObjectiveIntent) x, direction).stream()).forEach(contexts::add);
}
#method_after
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    intentsToApply.stream().filter(intent -> intent instanceof FlowObjectiveIntent).map(intent -> buildObjectiveContexts((FlowObjectiveIntent) intent, direction)).flatMap(Collection::stream).forEach(contexts::add);
    // Two stage for different direction context
    // We will apply REMOVE context first, and apply ADD context.
    contexts.forEach(context -> {
        switch(direction) {
            case REMOVE:
                pendingContexts.add(context);
                break;
            case ADD:
                nextPendingContexts.add(context);
                break;
            default:
                break;
        }
    });
}
#end_block

#method_before
private List<FlowObjectiveInstallationContext> buildObjectiveContexts(FlowObjectiveIntent intent, Direction direction) {
    int size = intent.objectives().size();
    List<FlowObjectiveInstallationContext> contexts = new ArrayList<>(size);
    for (int i = 0; i < size; i++) {
        DeviceId deviceId = intent.devices().get(i);
        Objective.Builder builder = intent.objectives().get(i).copy();
        FlowObjectiveInstallationContext context = new FlowObjectiveInstallationContext();
        final Objective objective;
        switch(direction) {
            case ADD:
                objective = builder.add(context);
                break;
            case REMOVE:
                objective = builder.remove(context);
                break;
            default:
                throw new UnsupportedOperationException("Unsupported direction " + direction);
        }
        context.setObjective(objective, deviceId);
        contexts.add(context);
    }
    return contexts;
}
#method_after
private Set<? extends ObjectiveContext> buildObjectiveContexts(FlowObjectiveIntent intent, Direction direction) {
    Set<FlowObjectiveInstallationContext> contexts = Sets.newHashSet();
    int size = intent.objectives().size();
    List<Objective> objectives = intent.objectives();
    List<DeviceId> deviceIds = intent.devices();
    if (direction == Direction.ADD) {
        for (int i = 0; i < size; i++) {
            Objective objective = objectives.get(i);
            DeviceId deviceId = deviceIds.get(i);
            FlowObjectiveInstallationContext ctx = buildObjectiveContext(objective, deviceId, direction);
            contexts.add(ctx);
        }
        return contexts;
    } else {
        // basic idea is to chain objective contexts
        for (int i = 0; i < size; i++) {
            Objective objective = intent.objectives().get(i);
            DeviceId deviceId = intent.devices().get(i);
            if (objective instanceof FilteringObjective) {
                // don't need to care ordering of filtering objective
                FlowObjectiveInstallationContext ctx = buildObjectiveContext(objective, deviceId, direction);
                contexts.add(ctx);
            } else if (objective instanceof NextObjective) {
            // need to removed after forwarding objective
            // nothing to do here
            } else if (objective instanceof ForwardingObjective) {
                // forwarding objective, also find next objective if
                // exist
                FlowObjectiveInstallationContext fwdCtx = buildObjectiveContext(objective, deviceId, direction);
                ForwardingObjective fwd = (ForwardingObjective) objective;
                NextObjective nxt = null;
                Integer nextId = fwd.nextId();
                if (nextId != null) {
                    for (int j = 0; j < size; j++) {
                        if (objectives.get(j).id() == nextId) {
                            nxt = (NextObjective) objectives.get(j);
                            break;
                        }
                    }
                    // if a next objective exists in the Intent
                    if (nxt != null) {
                        FlowObjectiveInstallationContext nxtCtx = buildObjectiveContext(nxt, deviceId, direction);
                        fwdCtx.nextContext(nxtCtx);
                    }
                }
                contexts.add(fwdCtx);
            } else {
                // possible here?
                log.warn(UNSUPPORT_OBJ, objective);
            }
        }
    }
    return contexts;
}
#end_block

#method_before
@Override
void apply() {
    contexts.forEach(objectiveContext -> {
        pendingContexts.add(objectiveContext);
        flowObjectiveService.apply(objectiveContext.deviceId, objectiveContext.objective);
    });
}
#method_after
@Override
void apply() {
    // pending contexts
    if (pendingContexts.isEmpty()) {
        pendingContexts.addAll(nextPendingContexts);
        nextPendingContexts.clear();
    }
    final Set<ObjectiveContext> contextsToApply = Sets.newHashSet(pendingContexts);
    contextsToApply.forEach(ctx -> {
        FlowObjectiveInstallationContext foiCtx = (FlowObjectiveInstallationContext) ctx;
        flowObjectiveService.apply(foiCtx.deviceId, foiCtx.objective);
    });
}
#end_block

#method_before
void setObjective(Objective objective, DeviceId deviceId) {
    this.objective = objective;
    this.deviceId = deviceId;
}
#method_after
void setObjective(Objective objective, DeviceId deviceId) {
    // init function
    this.objective = objective;
    this.deviceId = deviceId;
    this.error = null;
    this.retry = new AtomicInteger(0);
    this.nextContext = null;
}
#end_block

#method_before
@Override
public void onSuccess(Objective objective) {
    finish();
}
#method_after
@Override
public void onSuccess(Objective objective) {
    finished(null);
}
#end_block

#method_before
@Override
public void onError(Objective objective, ObjectiveError error) {
    this.error = error;
    errorContexts.add(this);
    finish();
}
#method_after
@Override
public void onError(Objective objective, ObjectiveError error) {
    finished(error);
}
#end_block

#method_before
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    // TODO examine the possibility of parallelization of intents application on domains
    builder.newStage();
    List<DomainIntent> intents = intentsToApply.stream().filter(x -> x instanceof DomainIntent).map(x -> (DomainIntent) x).collect(Collectors.toList());
    for (DomainIntent intent : intents) {
        if (direction == Direction.ADD) {
            builder.add(intent);
        } else {
            builder.remove(intent);
        }
    }
}
#method_after
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    List<DomainIntent> intents = intentsToApply.stream().filter(x -> x instanceof DomainIntent).map(x -> (DomainIntent) x).collect(Collectors.toList());
    for (DomainIntent intent : intents) {
        if (direction == Direction.ADD) {
            builder.add(intent);
        } else {
            builder.remove(intent);
        }
    }
}
#end_block

#method_before
@Activate
public void activate() {
    cfgService.registerProperties(getClass());
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(DefaultGroup.class, DefaultGroupBucket.class, DefaultGroupDescription.class, DefaultGroupKey.class, GroupDescription.Type.class, Group.GroupState.class, GroupBuckets.class, GroupStoreMessage.class, GroupStoreMessage.Type.class, UpdateType.class, GroupStoreMessageSubjects.class, MultiValuedTimestamp.class, GroupStoreKeyMapKey.class, GroupStoreIdMapKey.class, GroupStoreMapKey.class);
    clusterMsgSerializer = kryoBuilder.build("GroupStore");
    Serializer serializer = Serializer.using(clusterMsgSerializer);
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/group", "message-handlers", log));
    clusterCommunicator.addSubscriber(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, clusterMsgSerializer::deserialize, this::process, messageHandlingExecutor);
    log.debug("Creating Consistent map onos-group-store-keymap");
    groupStoreEntriesByKey = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-group-store-keymap").withSerializer(serializer).build();
    groupStoreEntriesByKey.addListener(mapListener);
    log.debug("Current size of groupstorekeymap:{}", groupStoreEntriesByKey.size());
    log.debug("Creating Consistent map pendinggroupkeymap");
    auditPendingReqQueue = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-pending-group-keymap").withSerializer(serializer).build();
    log.debug("Current size of pendinggroupkeymap:{}", auditPendingReqQueue.size());
    groupTopic = getOrCreateGroupTopic(serializer);
    groupTopic.subscribe(this::processGroupMessage);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    cfgService.registerProperties(getClass());
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(DefaultGroup.class, DefaultGroupBucket.class, DefaultGroupDescription.class, DefaultGroupKey.class, GroupDescription.Type.class, Group.GroupState.class, GroupBuckets.class, GroupStoreMessage.class, GroupStoreMessage.Type.class, UpdateType.class, GroupStoreMessageSubjects.class, MultiValuedTimestamp.class, GroupStoreKeyMapKey.class, GroupStoreIdMapKey.class, GroupStoreMapKey.class);
    clusterMsgSerializer = kryoBuilder.build("GroupStore");
    Serializer serializer = Serializer.using(clusterMsgSerializer);
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/group", "message-handlers", log));
    clusterCommunicator.addSubscriber(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, clusterMsgSerializer::deserialize, this::process, messageHandlingExecutor);
    log.debug("Creating Consistent map onos-group-store-keymap");
    groupStoreEntriesByKey = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-group-store-keymap").withSerializer(serializer).build();
    groupStoreEntriesByKey.addListener(mapListener);
    log.debug("Current size of groupstorekeymap:{}", groupStoreEntriesByKey.size());
    log.debug("Creating GroupStoreId Map From GroupStoreKey Map");
    matchGroupEntries();
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/group", "store", log));
    statusChangeListener = status -> {
        if (status == Status.ACTIVE) {
            executor.execute(this::matchGroupEntries);
        }
    };
    groupStoreEntriesByKey.addStatusChangeListener(statusChangeListener);
    log.debug("Creating Consistent map pendinggroupkeymap");
    auditPendingReqQueue = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-pending-group-keymap").withSerializer(serializer).build();
    log.debug("Current size of pendinggroupkeymap:{}", auditPendingReqQueue.size());
    groupTopic = getOrCreateGroupTopic(serializer);
    groupTopic.subscribe(this::processGroupMessage);
    log.info("Started");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context != null ? context.getProperties() : new Properties();
    try {
        String s = get(properties, "garbageCollect");
        garbageCollect = isNullOrEmpty(s) ? GARBAGE_COLLECT : Boolean.parseBoolean(s.trim());
        s = get(properties, "gcThresh");
        gcThresh = isNullOrEmpty(s) ? GC_THRESH : Integer.parseInt(s.trim());
        s = get(properties, "allowExtraneousGroups");
        allowExtraneousGroups = isNullOrEmpty(s) ? ALLOW_EXTRANEOUS_GROUP : Boolean.parseBoolean(s.trim());
    } catch (Exception e) {
        gcThresh = GC_THRESH;
        garbageCollect = GARBAGE_COLLECT;
        allowExtraneousGroups = ALLOW_EXTRANEOUS_GROUP;
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context != null ? context.getProperties() : new Properties();
    try {
        String s = get(properties, "garbageCollect");
        garbageCollect = isNullOrEmpty(s) ? GARBAGE_COLLECT : Boolean.parseBoolean(s.trim());
        s = get(properties, "gcThresh");
        gcThresh = isNullOrEmpty(s) ? GC_THRESH : Integer.parseInt(s.trim());
        s = get(properties, "allowExtraneousGroups");
        allowExtraneousGroups = isNullOrEmpty(s) ? ALLOW_EXTRANEOUS_GROUPS : Boolean.parseBoolean(s.trim());
    } catch (Exception e) {
        gcThresh = GC_THRESH;
        garbageCollect = GARBAGE_COLLECT;
        allowExtraneousGroups = ALLOW_EXTRANEOUS_GROUPS;
    }
}
#end_block

#method_before
private int getFreeGroupIdValue(DeviceId deviceId) {
    int freeId = groupIdGen.incrementAndGet();
    while (true) {
        Group existing = getGroup(deviceId, new DefaultGroupId(freeId));
        if (existing == null) {
            existing = (extraneousGroupEntriesById.get(deviceId) != null) ? extraneousGroupEntriesById.get(deviceId).get(new DefaultGroupId(freeId)) : null;
        }
        if (existing != null) {
            freeId = groupIdGen.incrementAndGet();
        } else {
            break;
        }
    }
    log.debug("getFreeGroupIdValue: Next Free ID is {}", freeId);
    return freeId;
}
#method_after
private int getFreeGroupIdValue(DeviceId deviceId) {
    int freeId = groupIdGen.incrementAndGet();
    while (true) {
        Group existing = getGroup(deviceId, new GroupId(freeId));
        if (existing == null) {
            existing = (extraneousGroupEntriesById.get(deviceId) != null) ? extraneousGroupEntriesById.get(deviceId).get(new GroupId(freeId)) : null;
        }
        if (existing != null) {
            freeId = groupIdGen.incrementAndGet();
        } else {
            break;
        }
    }
    log.debug("getFreeGroupIdValue: Next Free ID is {}", freeId);
    return freeId;
}
#end_block

#method_before
private Group getMatchingExtraneousGroupbyId(DeviceId deviceId, Integer groupId) {
    ConcurrentMap<GroupId, Group> extraneousMap = extraneousGroupEntriesById.get(deviceId);
    if (extraneousMap == null) {
        return null;
    }
    return extraneousMap.get(new DefaultGroupId(groupId));
}
#method_after
private Group getMatchingExtraneousGroupbyId(DeviceId deviceId, Integer groupId) {
    ConcurrentMap<GroupId, Group> extraneousMap = extraneousGroupEntriesById.get(deviceId);
    if (extraneousMap == null) {
        return null;
    }
    return extraneousMap.get(new GroupId(groupId));
}
#end_block

#method_before
private void storeGroupDescriptionInternal(GroupDescription groupDesc) {
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        return;
    }
    if (deviceAuditStatus.get(groupDesc.deviceId()) == null) {
        // Device group audit has not completed yet
        // Add this group description to pending group key table
        // Create a group entry object with Dummy Group ID
        log.debug("storeGroupDescriptionInternal: Device {} AUDIT pending...Queuing Group ADD request", groupDesc.deviceId());
        StoredGroupEntry group = new DefaultGroup(dummyGroupId, groupDesc);
        group.setState(GroupState.WAITING_AUDIT_COMPLETE);
        Map<GroupStoreKeyMapKey, StoredGroupEntry> pendingKeyTable = getPendingGroupKeyTable();
        pendingKeyTable.put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
        return;
    }
    Group matchingExtraneousGroup = null;
    if (groupDesc.givenGroupId() != null) {
        // Check if there is a extraneous group existing with the same Id
        matchingExtraneousGroup = getMatchingExtraneousGroupbyId(groupDesc.deviceId(), groupDesc.givenGroupId());
        if (matchingExtraneousGroup != null) {
            log.debug("storeGroupDescriptionInternal: Matching extraneous group " + "found in Device {} for group id 0x{}", groupDesc.deviceId(), Integer.toHexString(groupDesc.givenGroupId()));
            // Check if the group buckets matches with user provided buckets
            if (matchingExtraneousGroup.buckets().equals(groupDesc.buckets())) {
                // Group is already existing with the same buckets and Id
                // Create a group entry object
                log.debug("storeGroupDescriptionInternal: Buckets also matching " + "in Device {} for group id 0x{}", groupDesc.deviceId(), Integer.toHexString(groupDesc.givenGroupId()));
                StoredGroupEntry group = new DefaultGroup(matchingExtraneousGroup.id(), groupDesc);
                // Insert the newly created group entry into key and id maps
                getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
                // Ensure it also inserted into group id based table to
                // avoid any chances of duplication in group id generation
                getGroupIdTable(groupDesc.deviceId()).put(matchingExtraneousGroup.id(), group);
                addOrUpdateGroupEntry(matchingExtraneousGroup);
                removeExtraneousGroupEntry(matchingExtraneousGroup);
                return;
            } else {
                // Group buckets are not matching. Update group
                // with user provided buckets.
                log.debug("storeGroupDescriptionInternal: Buckets are not " + "matching in Device {} for group id 0x{}", groupDesc.deviceId(), Integer.toHexString(groupDesc.givenGroupId()));
                StoredGroupEntry modifiedGroup = new DefaultGroup(matchingExtraneousGroup.id(), groupDesc);
                modifiedGroup.setState(GroupState.PENDING_UPDATE);
                getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), modifiedGroup);
                // Ensure it also inserted into group id based table to
                // avoid any chances of duplication in group id generation
                getGroupIdTable(groupDesc.deviceId()).put(matchingExtraneousGroup.id(), modifiedGroup);
                removeExtraneousGroupEntry(matchingExtraneousGroup);
                log.debug("storeGroupDescriptionInternal: Triggering Group " + "UPDATE request for {} in device {}", matchingExtraneousGroup.id(), groupDesc.deviceId());
                notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_REQUESTED, modifiedGroup));
                return;
            }
        }
    } else {
        // Check if there is an extraneous group with user provided buckets
        matchingExtraneousGroup = getMatchingExtraneousGroupbyBuckets(groupDesc.deviceId(), groupDesc.buckets());
        if (matchingExtraneousGroup != null) {
            // Group is already existing with the same buckets.
            // So reuse this group.
            log.debug("storeGroupDescriptionInternal: Matching extraneous group found in Device {}", groupDesc.deviceId());
            // Create a group entry object
            StoredGroupEntry group = new DefaultGroup(matchingExtraneousGroup.id(), groupDesc);
            // Insert the newly created group entry into key and id maps
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
            // Ensure it also inserted into group id based table to
            // avoid any chances of duplication in group id generation
            getGroupIdTable(groupDesc.deviceId()).put(matchingExtraneousGroup.id(), group);
            addOrUpdateGroupEntry(matchingExtraneousGroup);
            removeExtraneousGroupEntry(matchingExtraneousGroup);
            return;
        } else {
            // TODO: Check if there are any empty groups that can be used here
            log.debug("storeGroupDescriptionInternal: No matching extraneous groups found in Device {}", groupDesc.deviceId());
        }
    }
    GroupId id = null;
    if (groupDesc.givenGroupId() == null) {
        // Get a new group identifier
        id = new DefaultGroupId(getFreeGroupIdValue(groupDesc.deviceId()));
    } else {
        // we need to use the identifier passed in by caller, but check if
        // already used
        Group existing = getGroup(groupDesc.deviceId(), new DefaultGroupId(groupDesc.givenGroupId()));
        if (existing != null) {
            log.warn("Group already exists with the same id: 0x{} in dev:{} " + "but with different key: {} (request gkey: {})", Integer.toHexString(groupDesc.givenGroupId()), groupDesc.deviceId(), existing.appCookie(), groupDesc.appCookie());
            return;
        }
        id = new DefaultGroupId(groupDesc.givenGroupId());
    }
    // Create a group entry object
    StoredGroupEntry group = new DefaultGroup(id, groupDesc);
    // Insert the newly created group entry into key and id maps
    getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
    // Ensure it also inserted into group id based table to
    // avoid any chances of duplication in group id generation
    getGroupIdTable(groupDesc.deviceId()).put(id, group);
    log.debug("storeGroupDescriptionInternal: Processing Group ADD request for Id {} in device {}", id, groupDesc.deviceId());
    notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
}
#method_after
private void storeGroupDescriptionInternal(GroupDescription groupDesc) {
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        return;
    }
    if (deviceAuditStatus.get(groupDesc.deviceId()) == null) {
        // Device group audit has not completed yet
        // Add this group description to pending group key table
        // Create a group entry object with Dummy Group ID
        log.debug("storeGroupDescriptionInternal: Device {} AUDIT pending...Queuing Group ADD request", groupDesc.deviceId());
        StoredGroupEntry group = new DefaultGroup(dummyGroupId, groupDesc);
        group.setState(GroupState.WAITING_AUDIT_COMPLETE);
        Map<GroupStoreKeyMapKey, StoredGroupEntry> pendingKeyTable = getPendingGroupKeyTable();
        pendingKeyTable.put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
        return;
    }
    Group matchingExtraneousGroup = null;
    if (groupDesc.givenGroupId() != null) {
        // Check if there is a extraneous group existing with the same Id
        matchingExtraneousGroup = getMatchingExtraneousGroupbyId(groupDesc.deviceId(), groupDesc.givenGroupId());
        if (matchingExtraneousGroup != null) {
            log.debug("storeGroupDescriptionInternal: Matching extraneous group " + "found in Device {} for group id 0x{}", groupDesc.deviceId(), Integer.toHexString(groupDesc.givenGroupId()));
            // Check if the group buckets matches with user provided buckets
            if (matchingExtraneousGroup.buckets().equals(groupDesc.buckets())) {
                // Group is already existing with the same buckets and Id
                // Create a group entry object
                log.debug("storeGroupDescriptionInternal: Buckets also matching " + "in Device {} for group id 0x{}", groupDesc.deviceId(), Integer.toHexString(groupDesc.givenGroupId()));
                StoredGroupEntry group = new DefaultGroup(matchingExtraneousGroup.id(), groupDesc);
                // Insert the newly created group entry into key and id maps
                getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
                // Ensure it also inserted into group id based table to
                // avoid any chances of duplication in group id generation
                getGroupIdTable(groupDesc.deviceId()).put(matchingExtraneousGroup.id(), group);
                addOrUpdateGroupEntry(matchingExtraneousGroup);
                removeExtraneousGroupEntry(matchingExtraneousGroup);
                return;
            } else {
                // Group buckets are not matching. Update group
                // with user provided buckets.
                log.debug("storeGroupDescriptionInternal: Buckets are not " + "matching in Device {} for group id 0x{}", groupDesc.deviceId(), Integer.toHexString(groupDesc.givenGroupId()));
                StoredGroupEntry modifiedGroup = new DefaultGroup(matchingExtraneousGroup.id(), groupDesc);
                modifiedGroup.setState(GroupState.PENDING_UPDATE);
                getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), modifiedGroup);
                // Ensure it also inserted into group id based table to
                // avoid any chances of duplication in group id generation
                getGroupIdTable(groupDesc.deviceId()).put(matchingExtraneousGroup.id(), modifiedGroup);
                removeExtraneousGroupEntry(matchingExtraneousGroup);
                log.debug("storeGroupDescriptionInternal: Triggering Group " + "UPDATE request for {} in device {}", matchingExtraneousGroup.id(), groupDesc.deviceId());
                notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_REQUESTED, modifiedGroup));
                return;
            }
        }
    } else {
        // Check if there is an extraneous group with user provided buckets
        matchingExtraneousGroup = getMatchingExtraneousGroupbyBuckets(groupDesc.deviceId(), groupDesc.buckets());
        if (matchingExtraneousGroup != null) {
            // Group is already existing with the same buckets.
            // So reuse this group.
            log.debug("storeGroupDescriptionInternal: Matching extraneous group found in Device {}", groupDesc.deviceId());
            // Create a group entry object
            StoredGroupEntry group = new DefaultGroup(matchingExtraneousGroup.id(), groupDesc);
            // Insert the newly created group entry into key and id maps
            getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
            // Ensure it also inserted into group id based table to
            // avoid any chances of duplication in group id generation
            getGroupIdTable(groupDesc.deviceId()).put(matchingExtraneousGroup.id(), group);
            addOrUpdateGroupEntry(matchingExtraneousGroup);
            removeExtraneousGroupEntry(matchingExtraneousGroup);
            return;
        } else {
            // TODO: Check if there are any empty groups that can be used here
            log.debug("storeGroupDescriptionInternal: No matching extraneous groups found in Device {}", groupDesc.deviceId());
        }
    }
    GroupId id = null;
    if (groupDesc.givenGroupId() == null) {
        // Get a new group identifier
        id = new GroupId(getFreeGroupIdValue(groupDesc.deviceId()));
    } else {
        // we need to use the identifier passed in by caller, but check if
        // already used
        Group existing = getGroup(groupDesc.deviceId(), new GroupId(groupDesc.givenGroupId()));
        if (existing != null) {
            log.warn("Group already exists with the same id: 0x{} in dev:{} " + "but with different key: {} (request gkey: {})", Integer.toHexString(groupDesc.givenGroupId()), groupDesc.deviceId(), existing.appCookie(), groupDesc.appCookie());
            return;
        }
        id = new GroupId(groupDesc.givenGroupId());
    }
    // Create a group entry object
    StoredGroupEntry group = new DefaultGroup(id, groupDesc);
    // Insert the newly created group entry into key and id maps
    getGroupStoreKeyMap().put(new GroupStoreKeyMapKey(groupDesc.deviceId(), groupDesc.appCookie()), group);
    // Ensure it also inserted into group id based table to
    // avoid any chances of duplication in group id generation
    getGroupIdTable(groupDesc.deviceId()).put(id, group);
    log.debug("storeGroupDescriptionInternal: Processing Group ADD request for Id {} in device {}", id, groupDesc.deviceId());
    notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
}
#end_block

#method_before
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    List<GroupBucket> oldBuckets = oldGroup.buckets().buckets();
    List<GroupBucket> updatedBucketList = new ArrayList<>();
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        List<GroupBucket> newBuckets = buckets.buckets();
        // Add old buckets that will not be updated and check if any will be updated.
        for (GroupBucket oldBucket : oldBuckets) {
            int newBucketIndex = newBuckets.indexOf(oldBucket);
            if (newBucketIndex != -1) {
                GroupBucket newBucket = newBuckets.get(newBucketIndex);
                if (!newBucket.hasSameParameters(oldBucket)) {
                    // Bucket will be updated
                    groupDescUpdated = true;
                }
            } else {
                // Old bucket will remain the same - add it.
                updatedBucketList.add(oldBucket);
            }
        }
        // Add all new buckets
        updatedBucketList.addAll(newBuckets);
        if (!oldBuckets.containsAll(newBuckets)) {
            groupDescUpdated = true;
        }
    } else if (type == UpdateType.REMOVE) {
        List<GroupBucket> bucketsToRemove = buckets.buckets();
        // Check which old buckets should remain
        for (GroupBucket oldBucket : oldBuckets) {
            if (!bucketsToRemove.contains(oldBucket)) {
                updatedBucketList.add(oldBucket);
            } else {
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return updatedBucketList;
    } else {
        return null;
    }
}
#method_after
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    if (type == UpdateType.SET) {
        return buckets.buckets();
    }
    List<GroupBucket> oldBuckets = oldGroup.buckets().buckets();
    List<GroupBucket> updatedBucketList = new ArrayList<>();
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        List<GroupBucket> newBuckets = buckets.buckets();
        // Add old buckets that will not be updated and check if any will be updated.
        for (GroupBucket oldBucket : oldBuckets) {
            int newBucketIndex = newBuckets.indexOf(oldBucket);
            if (newBucketIndex != -1) {
                GroupBucket newBucket = newBuckets.get(newBucketIndex);
                if (!newBucket.hasSameParameters(oldBucket)) {
                    // Bucket will be updated
                    groupDescUpdated = true;
                }
            } else {
                // Old bucket will remain the same - add it.
                updatedBucketList.add(oldBucket);
            }
        }
        // Add all new buckets
        updatedBucketList.addAll(newBuckets);
        if (!oldBuckets.containsAll(newBuckets)) {
            groupDescUpdated = true;
        }
    } else if (type == UpdateType.REMOVE) {
        List<GroupBucket> bucketsToRemove = buckets.buckets();
        // Check which old buckets should remain
        for (GroupBucket oldBucket : oldBuckets) {
            if (!bucketsToRemove.contains(oldBucket)) {
                updatedBucketList.add(oldBucket);
            } else {
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return updatedBucketList;
    } else {
        return null;
    }
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        mapName = DEFAULT_MAP_NAME;
        readPercentage = DEFAULT_READ_PERCENTAGE;
        totalOperationsPerTransaction = DEFAULT_TOTAL_OPERATIONS;
        withContention = DEFAULT_WITH_CONTENTION;
        withRetries = DEFAULT_WITH_RETRIES;
        reportIntervalSeconds = DEFAULT_REPORT_INTERVAL_SECONDS;
        return;
    }
    Dictionary properties = context.getProperties();
    String newMapName = mapName;
    double newReadPercentage = readPercentage;
    int newTotalOperationsPerTransaction = totalOperationsPerTransaction;
    boolean newWithContention = withContention;
    boolean newWithRetries = withRetries;
    int newReportIntervalSeconds = reportIntervalSeconds;
    try {
        String s;
        s = get(properties, "mapName");
        if (!isNullOrEmpty(s)) {
            newMapName = s;
        }
        s = get(properties, "readPercentage");
        if (!isNullOrEmpty(s)) {
            newReadPercentage = Double.parseDouble(s);
        }
        s = get(properties, "totalOperationsPerTransaction");
        if (!isNullOrEmpty(s)) {
            newTotalOperationsPerTransaction = Integer.parseInt(s);
        }
        s = get(properties, "withContention");
        if (!isNullOrEmpty(s)) {
            newWithContention = Boolean.parseBoolean(s);
        }
        s = get(properties, "withRetries");
        if (!isNullOrEmpty(s)) {
            newWithRetries = Boolean.parseBoolean(s);
        }
        s = get(properties, "reportIntervalSeconds");
        if (!isNullOrEmpty(s)) {
            newReportIntervalSeconds = Integer.parseInt(s);
        }
    } catch (NumberFormatException | ClassCastException e) {
        return;
    }
    boolean modified = newMapName != mapName || newReadPercentage != readPercentage || newTotalOperationsPerTransaction != totalOperationsPerTransaction || newWithContention != withContention || newWithRetries != withRetries || newReportIntervalSeconds != reportIntervalSeconds;
    // If no configuration options have changed, skip restarting the test.
    if (!modified) {
        return;
    }
    mapName = newMapName;
    readPercentage = newReadPercentage;
    totalOperationsPerTransaction = newTotalOperationsPerTransaction;
    withContention = newWithContention;
    withRetries = newWithRetries;
    reportIntervalSeconds = newReportIntervalSeconds;
    // Restart the test.
    stopTest();
    testRunner = Executors.newSingleThreadExecutor(groupedThreads("app/transaction-perf-test-runner", ""));
    reporter = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/net-perf-test", "reporter"));
    startTest();
    reporter.scheduleWithFixedDelay(this::reportPerformance, reportIntervalSeconds, reportIntervalSeconds, TimeUnit.SECONDS);
    logConfig("Restarted");
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        mapName = DEFAULT_MAP_NAME;
        readPercentage = DEFAULT_READ_PERCENTAGE;
        totalOperationsPerTransaction = DEFAULT_TOTAL_OPERATIONS;
        withContention = DEFAULT_WITH_CONTENTION;
        withRetries = DEFAULT_WITH_RETRIES;
        reportIntervalSeconds = DEFAULT_REPORT_INTERVAL_SECONDS;
        return;
    }
    Dictionary properties = context.getProperties();
    String newMapName = mapName;
    double newReadPercentage = readPercentage;
    int newTotalOperationsPerTransaction = totalOperationsPerTransaction;
    boolean newWithContention = withContention;
    boolean newWithRetries = withRetries;
    int newReportIntervalSeconds = reportIntervalSeconds;
    try {
        String s;
        s = get(properties, "mapName");
        if (!isNullOrEmpty(s)) {
            newMapName = s;
        }
        s = get(properties, "readPercentage");
        if (!isNullOrEmpty(s)) {
            newReadPercentage = Double.parseDouble(s);
        }
        s = get(properties, "totalOperationsPerTransaction");
        if (!isNullOrEmpty(s)) {
            newTotalOperationsPerTransaction = Integer.parseInt(s);
        }
        s = get(properties, "withContention");
        if (!isNullOrEmpty(s)) {
            newWithContention = Boolean.parseBoolean(s);
        }
        s = get(properties, "withRetries");
        if (!isNullOrEmpty(s)) {
            newWithRetries = Boolean.parseBoolean(s);
        }
        s = get(properties, "reportIntervalSeconds");
        if (!isNullOrEmpty(s)) {
            newReportIntervalSeconds = Integer.parseInt(s);
        }
    } catch (NumberFormatException | ClassCastException e) {
        return;
    }
    boolean modified = newMapName != mapName || newReadPercentage != readPercentage || newTotalOperationsPerTransaction != totalOperationsPerTransaction || newWithContention != withContention || newWithRetries != withRetries || newReportIntervalSeconds != reportIntervalSeconds;
    // If no configuration options have changed, skip restarting the test.
    if (!modified) {
        return;
    }
    mapName = newMapName;
    readPercentage = newReadPercentage;
    totalOperationsPerTransaction = newTotalOperationsPerTransaction;
    withContention = newWithContention;
    withRetries = newWithRetries;
    reportIntervalSeconds = newReportIntervalSeconds;
    // Restart the test.
    stopTest();
    testRunner = Executors.newSingleThreadExecutor(groupedThreads("app/transaction-perf-test-runner", ""));
    reporter = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/transaction-perf-test", "reporter"));
    startTest();
    reporter.scheduleWithFixedDelay(this::reportPerformance, reportIntervalSeconds, reportIntervalSeconds, TimeUnit.SECONDS);
    logConfig("Restarted");
}
#end_block

#method_before
@Activate
protected void activate() {
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    componentConfigService.registerProperties(getClass());
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    providers.clear();
    driverByKey.clear();
    classes.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    componentConfigService.unregisterProperties(getClass(), false);
    providers.clear();
    driverByKey.clear();
    classes.clear();
    log.info("Stopped");
}
#end_block

#method_before
// Checks for the minimum required drivers and when available, activate
private void checkRequiredDrivers() {
// FIXME: implement this
}
#method_after
// Checks for the minimum required drivers and when available, activate
private synchronized void checkRequiredDrivers() {
    Set<String> driverSet = registeredDrivers();
    boolean isReady = driverSet.containsAll(requiredDriverSet);
    if (isReady && !isStarted) {
        log.info("Starting driver subsystem");
        componenService.activate(null, DRIVER_COMPONENT);
        isStarted = true;
    } else if (!isReady && isStarted) {
        log.info("Stopping driver subsystem");
        componenService.deactivate(null, DRIVER_COMPONENT);
        isStarted = false;
    }
}
#end_block

#method_before
// Returns the input power range as a string, N/A if the port is not an
private String getPowerRange(DeviceId deviceId, PortNumber portNumber) {
    Range<Long> range = roadmService.inputPortPowerRange(deviceId, portNumber);
    if (range == null) {
        range = roadmService.targetPortPowerRange(deviceId, portNumber);
    }
    return RoadmUtil.objectToString(range, RoadmUtil.NA);
}
#method_after
// Returns the power range as a string, N/A if the power range not exists.
// The power range would be input power range or target power range determined by port property.
// If the port is RX direction then acquire the input power range from driver.
private String getPowerRange(DeviceId deviceId, PortNumber portNumber) {
    Range<Long> range = roadmService.inputPortPowerRange(deviceId, portNumber);
    if (range == null) {
        range = roadmService.targetPortPowerRange(deviceId, portNumber);
    }
    return RoadmUtil.objectToString(range, RoadmUtil.NA);
}
#end_block

#method_before
@Override
public void triggerProbe(DeviceId deviceId) {
    // TODO: This will be implemented later.
    log.info("Triggering probe on device {}", deviceId);
}
#method_after
@Override
public void triggerProbe(DeviceId deviceId) {
    // TODO: This will be implemented later.
    log.debug("Should be triggering probe on device {}", deviceId);
}
#end_block

#method_before
@Test
public void testNonBlockingThread() throws Exception {
    CompletableFuture<String> future = new CompletableFuture<>();
    Executor executor = SharedExecutors.getPoolThreadExecutor();
    BlockingAwareFuture<String> blockingFuture = (BlockingAwareFuture<String>) Tools.orderedFuture(future, new OrderedExecutor(executor), executor);
    CountDownLatch latch = new CountDownLatch(1);
    blockingFuture.thenRun(() -> latch.countDown());
    executor.execute(() -> future.complete("foo"));
    latch.await(5, TimeUnit.SECONDS);
    assertEquals(0, latch.getCount());
    assertEquals("foo", blockingFuture.join());
}
#method_after
@Test
public void testNonBlockingThread() throws Exception {
    CompletableFuture<String> future = new CompletableFuture<>();
    Executor executor = SharedExecutors.getPoolThreadExecutor();
    BlockingAwareFuture<String> blockingFuture = (BlockingAwareFuture<String>) Tools.orderedFuture(future, new OrderedExecutor(executor), executor);
    CountDownLatch latch = new CountDownLatch(1);
    blockingFuture.thenRun(() -> latch.countDown());
    executor.execute(() -> future.complete("foo"));
    latch.await(5, TimeUnit.SECONDS);
    assertEquals(0, latch.getCount());
    assertEquals("foo", blockingFuture.join());
    assertFalse(blockingFuture.isBlocked());
}
#end_block

#method_before
@Test
public void testBlockingThread() throws Exception {
    CompletableFuture<String> future = new CompletableFuture<>();
    Executor executor = SharedExecutors.getPoolThreadExecutor();
    BlockingAwareFuture<String> blockingFuture = (BlockingAwareFuture<String>) Tools.orderedFuture(future, new OrderedExecutor(executor), executor);
    CountDownLatch latch = new CountDownLatch(2);
    CompletableFuture<String> wrappedFuture = blockingFuture.thenApply(v -> {
        assertEquals("foo", v);
        latch.countDown();
        return v;
    });
    wrappedFuture.thenRun(() -> latch.countDown());
    executor.execute(() -> wrappedFuture.join());
    Thread.sleep(100);
    assertTrue(blockingFuture.isBlocked());
    future.complete("foo");
    latch.await(5, TimeUnit.SECONDS);
    assertEquals(0, latch.getCount());
    assertEquals("foo", blockingFuture.join());
    assertEquals("foo", wrappedFuture.join());
}
#method_after
@Test
public void testBlockingThread() throws Exception {
    CompletableFuture<String> future = new CompletableFuture<>();
    Executor executor = SharedExecutors.getPoolThreadExecutor();
    BlockingAwareFuture<String> blockingFuture = (BlockingAwareFuture<String>) Tools.orderedFuture(future, new OrderedExecutor(executor), executor);
    CountDownLatch latch = new CountDownLatch(2);
    CompletableFuture<String> wrappedFuture = blockingFuture.thenApply(v -> {
        assertEquals("foo", v);
        latch.countDown();
        return v;
    });
    wrappedFuture.thenRun(() -> latch.countDown());
    executor.execute(() -> wrappedFuture.join());
    Thread.sleep(100);
    assertTrue(blockingFuture.isBlocked());
    future.complete("foo");
    latch.await(5, TimeUnit.SECONDS);
    assertEquals(0, latch.getCount());
    assertEquals("foo", blockingFuture.join());
    assertEquals("foo", wrappedFuture.join());
    assertFalse(blockingFuture.isBlocked());
}
#end_block

#method_before
@Override
public T get() throws InterruptedException, ExecutionException {
    blocked.set(true);
    return super.get();
}
#method_after
@Override
public T get() throws InterruptedException, ExecutionException {
    blocked.set(true);
    try {
        return super.get();
    } finally {
        blocked.set(false);
    }
}
#end_block

#method_before
@Override
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    blocked.set(true);
    return super.get(timeout, unit);
}
#method_after
@Override
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    blocked.set(true);
    try {
        return super.get(timeout, unit);
    } finally {
        blocked.set(false);
    }
}
#end_block

#method_before
@Override
public T join() {
    blocked.set(true);
    return super.join();
}
#method_after
@Override
public synchronized T join() {
    blocked.set(true);
    try {
        return super.join();
    } finally {
        blocked.set(false);
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.trace("{} MAC filtering rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.debug("filtering objective missing VLAN, cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            VlanId vlanId;
            if (requireVlanExtensions()) {
                ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
                vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            } else {
                VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) flowRule.selector().getCriterion(Criterion.Type.VLAN_VID);
                vlanId = vlanIdCriterion.vlanId();
            }
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.trace("{} VLAN filtering rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.trace("{} VLAN assignment rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                vidCriterion = (VlanIdCriterion) criterion;
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filt, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.trace("{} MAC filtering rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.debug("filtering objective missing VLAN, cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            VlanId vlanId;
            if (requireVlanExtensions()) {
                ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
                vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            } else {
                VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) flowRule.selector().getCriterion(Criterion.Type.VLAN_VID);
                vlanId = vlanIdCriterion.vlanId();
            }
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.trace("{} VLAN filtering rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.trace("{} VLAN assignment rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4 || ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        log.warn("Routing table is currently unsupported in dev:{}", deviceId);
        return Collections.emptySet();
    }
    return super.processEthTypeSpecific(fwd);
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    // XXX remove when support is added to Qumran based OF-DPA
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4 || ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        log.warn("Routing table is currently unsupported in dev:{}", deviceId);
        return ImmutableSet.of();
    }
    return super.processEthTypeSpecific(fwd);
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective:{} must include ethType", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        log.warn("ACL table for IPv6 is currently unsupported in dev:{}", deviceId);
        return Collections.emptySet();
    }
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        for (Criterion c : fwd.selector().criteria()) {
            if (c instanceof IPCriterion) {
                if (((IPCriterion) c).type() == Criterion.Type.IPV4_DST) {
                    log.warn("ACL table for Dst IPv4 is currently " + "unsupported in dev:{}", deviceId);
                    return Collections.emptySet();
                }
            }
        }
    }
    return super.processVersatile(fwd);
}
#method_after
@Override
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective:{} must include ethType", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return ImmutableSet.of();
    }
    // XXX remove when support is added to Qumran based OF-DPA
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        log.warn("ACL table for IPv6 is currently unsupported in dev:{}", deviceId);
        return ImmutableSet.of();
    }
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        for (Criterion c : fwd.selector().criteria()) {
            if (c instanceof IPCriterion) {
                if (((IPCriterion) c).type() == Criterion.Type.IPV4_DST) {
                    log.warn("ACL table for Dst IPv4 is currently " + "unsupported in dev:{}", deviceId);
                    return ImmutableSet.of();
                }
            }
        }
    }
    return super.processVersatile(fwd);
}
#end_block

#method_before
private Set<FlowRule> devirtualize(NetworkId networkId, FlowRule flowRule) {
    Set<FlowRule> outRules = new HashSet<>();
    Set<ConnectPoint> ingressPoints = extractIngressPoints(networkId, flowRule.deviceId(), flowRule.selector());
    ConnectPoint egressPoint = extractEgressPoints(networkId, flowRule.deviceId(), flowRule.treatment());
    if (egressPoint == null) {
        return outRules;
    }
    TrafficSelector.Builder commonSelectorBuilder = DefaultTrafficSelector.builder();
    flowRule.selector().criteria().stream().filter(c -> c.type() != Criterion.Type.IN_PORT).forEach(c -> commonSelectorBuilder.add(c));
    TrafficSelector commonSelector = commonSelectorBuilder.build();
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    flowRule.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    for (ConnectPoint ingressPoint : ingressPoints) {
        if (egressPoint.port() == PortNumber.FLOOD) {
            Set<ConnectPoint> outPoints = vnService.getVirtualPorts(networkId, flowRule.deviceId()).stream().map(VirtualPort::realizedBy).filter(p -> p != ingressPoint).collect(Collectors.toSet());
            for (ConnectPoint outPoint : outPoints) {
                outRules.addAll(generateRules(networkId, ingressPoint, outPoint, commonSelector, commonTreatment, flowRule));
            }
        } else {
            outRules.addAll(generateRules(networkId, ingressPoint, egressPoint, commonSelector, commonTreatment, flowRule));
        }
    }
    return outRules;
}
#method_after
private Set<FlowRule> devirtualize(NetworkId networkId, FlowRule flowRule) {
    Set<FlowRule> outRules = new HashSet<>();
    Set<ConnectPoint> ingressPoints = extractIngressPoints(networkId, flowRule.deviceId(), flowRule.selector());
    ConnectPoint egressPoint = extractEgressPoints(networkId, flowRule.deviceId(), flowRule.treatment());
    if (egressPoint == null) {
        return outRules;
    }
    TrafficSelector.Builder commonSelectorBuilder = DefaultTrafficSelector.builder();
    flowRule.selector().criteria().stream().filter(c -> c.type() != Criterion.Type.IN_PORT).forEach(c -> commonSelectorBuilder.add(c));
    TrafficSelector commonSelector = commonSelectorBuilder.build();
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    flowRule.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    for (ConnectPoint ingressPoint : ingressPoints) {
        if (egressPoint.port() == PortNumber.FLOOD) {
            Set<ConnectPoint> outPoints = vnService.getVirtualPorts(networkId, flowRule.deviceId()).stream().map(VirtualPort::realizedBy).filter(p -> !p.equals(ingressPoint)).collect(Collectors.toSet());
            for (ConnectPoint outPoint : outPoints) {
                outRules.addAll(generateRules(networkId, ingressPoint, outPoint, commonSelector, commonTreatment, flowRule));
            }
        } else {
            outRules.addAll(generateRules(networkId, ingressPoint, egressPoint, commonSelector, commonTreatment, flowRule));
        }
    }
    return outRules;
}
#end_block

#method_before
private Set<FlowRule> generateRules(NetworkId networkId, ConnectPoint ingressPoint, ConnectPoint egressPoint, TrafficSelector commonSelector, TrafficTreatment commonTreatment, FlowRule flowRule) {
    Set<FlowRule> outRules = new HashSet<>();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId()) || egressPoint.port().isLogical()) {
        // Traffic is handled inside a single physical switch
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchInPort(ingressPoint.port());
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment);
        // Isolate traffic from different virtual networks with VLAN
        VirtualPort virtualIngressPort = vnService.getVirtualPorts(networkId, flowRule.deviceId()).stream().filter(p -> p.realizedBy().equals(ingressPoint)).findFirst().get();
        VirtualPort virtualEgressPort = vnService.getVirtualPorts(networkId, flowRule.deviceId()).stream().filter(p -> p.realizedBy().equals(egressPoint)).findFirst().get();
        if (virtualIngressPort.isLinkTo()) {
            selectorBuilder.matchVlanId(VlanId.vlanId(networkId.id().shortValue()));
        } else {
            treatmentBuilder.pushVlan().setVlanId(VlanId.vlanId(networkId.id().shortValue()));
        }
        // Set up a tunnel on the physical path for virtual link mapping
        if (virtualEgressPort.isLinkFrom()) {
            outRules.addAll(generateRulesOnPath(networkId, virtualEgressPort, commonSelector, commonTreatment, flowRule));
        } else {
            treatmentBuilder.popVlan();
        }
        treatmentBuilder.setOutput(egressPoint.port());
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(ingressPoint.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
        if (flowRule.isPermanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(flowRule.timeout());
        }
        FlowRule rule = ruleBuilder.build();
        frm.addIngressRule(flowRule, rule, networkId);
        outRules.add(rule);
    } else {
        // Traffic is handled by multiple physical switches
        // A tunnel is needed.
        Path internalPath = internalRoutingAlgorithm.findPath(ingressPoint, egressPoint);
        checkNotNull(internalPath, "No path between " + ingressPoint.toString() + " " + egressPoint.toString());
        ConnectPoint inCp = ingressPoint;
        ConnectPoint outCp = internalPath.links().get(0).src();
        // ingress point of tunnel
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(commonSelector);
        selectorBuilder.matchInPort(ingressPoint.port());
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment);
        // TODO: add the logic to check host location
        treatmentBuilder.pushVlan().setVlanId(VlanId.vlanId(networkId.id().shortValue()));
        treatmentBuilder.setOutput(outCp.port());
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(ingressPoint.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
        if (flowRule.isPermanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(flowRule.timeout());
        }
        FlowRule rule = ruleBuilder.build();
        frm.addIngressRule(flowRule, rule, networkId);
        outRules.add(rule);
        // routing inside tunnel
        inCp = internalPath.links().get(0).dst();
        if (internalPath.links().size() > 1) {
            for (Link l : internalPath.links().subList(1, internalPath.links().size() - 1)) {
                outCp = l.src();
                selectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchVlanId(VlanId.vlanId(networkId.id().shortValue())).matchInPort(inCp.port());
                treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment).setOutput(outCp.port());
                ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(inCp.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
                if (flowRule.isPermanent()) {
                    ruleBuilder.makePermanent();
                } else {
                    ruleBuilder.makeTemporary(flowRule.timeout());
                }
                outRules.add(ruleBuilder.build());
                inCp = l.dst();
            }
        }
        // egress point of tunnel
        selectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchVlanId(VlanId.vlanId(networkId.id().shortValue())).matchInPort(inCp.port());
        treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment).popVlan().setOutput(egressPoint.port());
        ruleBuilder = DefaultFlowRule.builder().fromApp(appId).forDevice(egressPoint.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
        if (flowRule.isPermanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(flowRule.timeout());
        }
        outRules.add(ruleBuilder.build());
    }
    return outRules;
}
#method_after
private Set<FlowRule> generateRules(NetworkId networkId, ConnectPoint ingressPoint, ConnectPoint egressPoint, TrafficSelector commonSelector, TrafficTreatment commonTreatment, FlowRule flowRule) {
    Set<FlowRule> outRules = new HashSet<>();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId()) || egressPoint.port().isLogical()) {
        // Traffic is handled inside a single physical switch
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchInPort(ingressPoint.port());
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment);
        VirtualPort virtualIngressPort = vnService.getVirtualPorts(networkId, flowRule.deviceId()).stream().filter(p -> p.realizedBy().equals(ingressPoint)).findFirst().get();
        VirtualPort virtualEgressPort = vnService.getVirtualPorts(networkId, flowRule.deviceId()).stream().filter(p -> p.realizedBy().equals(egressPoint)).findFirst().get();
        ConnectPoint ingressCp = new ConnectPoint(virtualIngressPort.element().id(), virtualIngressPort.number());
        ConnectPoint egressCp = new ConnectPoint(virtualEgressPort.element().id(), virtualEgressPort.number());
        Optional<VirtualLink> optionalIngressLink = vnService.getVirtualLinks(networkId).stream().filter(l -> l.dst().equals(ingressCp)).findFirst();
        Optional<VirtualLink> optionalEgressLink = vnService.getVirtualLinks(networkId).stream().filter(l -> l.src().equals(egressCp)).findFirst();
        // Isolate traffic from different virtual networks with VLAN
        if (!optionalIngressLink.isPresent() && !optionalEgressLink.isPresent()) {
            treatmentBuilder.setOutput(egressPoint.port());
        } else if (optionalIngressLink.isPresent() && !optionalEgressLink.isPresent()) {
            selectorBuilder.matchVlanId(VlanId.vlanId(networkId.id().shortValue()));
            treatmentBuilder.popVlan();
            treatmentBuilder.setOutput(egressPoint.port());
        } else if (!optionalIngressLink.isPresent() && optionalEgressLink.isPresent()) {
            outRules.addAll(generateRulesOnPath(networkId, optionalEgressLink.get(), commonSelector, commonTreatment, flowRule));
            treatmentBuilder.pushVlan().setVlanId(VlanId.vlanId(networkId.id().shortValue()));
            treatmentBuilder.setOutput(egressPoint.port());
        } else if (optionalIngressLink.isPresent() && optionalEgressLink.isPresent()) {
            outRules.addAll(generateRulesOnPath(networkId, optionalEgressLink.get(), commonSelector, commonTreatment, flowRule));
            selectorBuilder.matchVlanId(VlanId.vlanId(networkId.id().shortValue()));
            treatmentBuilder.setOutput(egressPoint.port());
        }
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(ingressPoint.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
        if (flowRule.isPermanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(flowRule.timeout());
        }
        FlowRule rule = ruleBuilder.build();
        frm.addIngressRule(flowRule, rule, networkId);
        outRules.add(rule);
    } else {
        // Traffic is handled by multiple physical switches
        // A tunnel is needed.
        Path internalPath = internalRoutingAlgorithm.findPath(ingressPoint, egressPoint);
        checkNotNull(internalPath, "No path between " + ingressPoint.toString() + " " + egressPoint.toString());
        ConnectPoint outCp = internalPath.links().get(0).src();
        // ingress point of tunnel
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(commonSelector);
        selectorBuilder.matchInPort(ingressPoint.port());
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment);
        // TODO: add the logic to check host location
        treatmentBuilder.pushVlan().setVlanId(VlanId.vlanId(networkId.id().shortValue()));
        treatmentBuilder.setOutput(outCp.port());
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(ingressPoint.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
        if (flowRule.isPermanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(flowRule.timeout());
        }
        FlowRule rule = ruleBuilder.build();
        frm.addIngressRule(flowRule, rule, networkId);
        outRules.add(rule);
        // routing inside tunnel
        ConnectPoint inCp = internalPath.links().get(0).dst();
        if (internalPath.links().size() > 1) {
            for (Link l : internalPath.links().subList(1, internalPath.links().size())) {
                outCp = l.src();
                selectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchVlanId(VlanId.vlanId(networkId.id().shortValue())).matchInPort(inCp.port());
                treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment).setOutput(outCp.port());
                ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(inCp.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
                if (flowRule.isPermanent()) {
                    ruleBuilder.makePermanent();
                } else {
                    ruleBuilder.makeTemporary(flowRule.timeout());
                }
                outRules.add(ruleBuilder.build());
                inCp = l.dst();
            }
        }
        // egress point of tunnel
        selectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchVlanId(VlanId.vlanId(networkId.id().shortValue())).matchInPort(inCp.port());
        treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment).popVlan().setOutput(egressPoint.port());
        ruleBuilder = DefaultFlowRule.builder().fromApp(appId).forDevice(egressPoint.deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatmentBuilder.build()).withPriority(flowRule.priority());
        if (flowRule.isPermanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(flowRule.timeout());
        }
        outRules.add(ruleBuilder.build());
    }
    return outRules;
}
#end_block

#method_before
private Set<FlowRule> generateRulesOnPath(NetworkId networkId, VirtualPort srcVirtualPort, TrafficSelector commonSelector, TrafficTreatment commonTreatment, FlowRule flowRule) {
    Set<FlowRule> outRules = new HashSet<>();
    VirtualLink virtualLink = vnService.getVirtualLinks(networkId).stream().filter(l -> l.src().deviceId().equals(srcVirtualPort.element().id()) && l.src().port().equals(srcVirtualPort.number())).findFirst().get();
    VirtualPort dstVirtualPort = vnService.getVirtualPorts(networkId, virtualLink.dst().deviceId()).stream().filter(p -> p.number().equals(virtualLink.dst().port())).findFirst().get();
    ConnectPoint srcCp = srcVirtualPort.realizedBy();
    ConnectPoint dstCp = dstVirtualPort.realizedBy();
    Path internalPath = internalRoutingAlgorithm.findPath(srcCp, dstCp);
    List<Link> links = internalPath.links();
    if (internalPath != null && links.size() > 1) {
        for (int i = 0; i < links.size() - 1; i++) {
            ConnectPoint inCp = links.get(i).dst();
            ConnectPoint outCp = links.get(i + 1).src();
            TrafficSelector.Builder linkSelectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchVlanId(VlanId.vlanId(networkId.id().shortValue())).matchInPort(inCp.port());
            TrafficTreatment.Builder linkTreatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment).setOutput(outCp.port());
            FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(inCp.deviceId()).withSelector(linkSelectorBuilder.build()).withTreatment(linkTreatmentBuilder.build()).withPriority(flowRule.priority());
            if (flowRule.isPermanent()) {
                ruleBuilder.makePermanent();
            } else {
                ruleBuilder.makeTemporary(flowRule.timeout());
            }
            outRules.add(ruleBuilder.build());
        }
    }
    return outRules;
}
#method_after
private Set<FlowRule> generateRulesOnPath(NetworkId networkId, VirtualLink virtualLink, TrafficSelector commonSelector, TrafficTreatment commonTreatment, FlowRule flowRule) {
    VirtualPort srcVirtualPort = vnService.getVirtualPorts(networkId, virtualLink.src().deviceId()).stream().filter(p -> p.number().equals(virtualLink.src().port())).findFirst().get();
    VirtualPort dstVirtualPort = vnService.getVirtualPorts(networkId, virtualLink.dst().deviceId()).stream().filter(p -> p.number().equals(virtualLink.dst().port())).findFirst().get();
    Set<FlowRule> outRules = new HashSet<>();
    ConnectPoint srcCp = srcVirtualPort.realizedBy();
    ConnectPoint dstCp = dstVirtualPort.realizedBy();
    Path internalPath = internalRoutingAlgorithm.findPath(srcCp, dstCp);
    List<Link> links = internalPath.links();
    if (internalPath != null && links.size() > 1) {
        for (int i = 0; i < links.size() - 1; i++) {
            ConnectPoint inCp = links.get(i).dst();
            ConnectPoint outCp = links.get(i + 1).src();
            TrafficSelector.Builder linkSelectorBuilder = DefaultTrafficSelector.builder(commonSelector).matchVlanId(VlanId.vlanId(networkId.id().shortValue())).matchInPort(inCp.port());
            TrafficTreatment.Builder linkTreatmentBuilder = DefaultTrafficTreatment.builder(commonTreatment).setOutput(outCp.port());
            FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(vnService.getVirtualNetworkApplicationId(networkId)).forDevice(inCp.deviceId()).withSelector(linkSelectorBuilder.build()).withTreatment(linkTreatmentBuilder.build()).withPriority(flowRule.priority());
            if (flowRule.isPermanent()) {
                ruleBuilder.makePermanent();
            } else {
                ruleBuilder.makeTemporary(flowRule.timeout());
            }
            outRules.add(ruleBuilder.build());
        }
    }
    return outRules;
}
#end_block

#method_before
private void addOrUpdateFlowEntry(NetworkId networkId, DeviceId deviceId, FlowEntry flowEntry) {
    Set<FlowEntry> set = flowEntryTable.get(networkId, deviceId);
    if (set == null) {
        set = Sets.newConcurrentHashSet();
        flowEntryTable.put(networkId, deviceId, set);
    }
    // Replace old entry with new one
    set.stream().filter(fe -> fe.exactMatch(flowEntry)).forEach(set::remove);
    set.add(flowEntry);
    // Remove old entry from missing flow
    Set<FlowRule> missingRules = getMissingRules(networkId, deviceId);
    if (missingRules != null && !missingRules.isEmpty()) {
        missingRules.stream().filter(fr -> fr.exactMatch(flowEntry)).forEach(fr -> removeMissingFlowRule(networkId, deviceId, fr));
    }
}
#method_after
private void addOrUpdateFlowEntry(NetworkId networkId, DeviceId deviceId, FlowEntry flowEntry) {
    Set<FlowEntry> set = flowEntryTable.get(networkId, deviceId);
    if (set == null) {
        set = Sets.newConcurrentHashSet();
        flowEntryTable.put(networkId, deviceId, set);
    }
    // Replace old entry with new one
    set.stream().filter(fe -> fe.exactMatch(flowEntry)).forEach(set::remove);
    set.add(flowEntry);
}
#end_block

#method_before
@Override
public void removeTenantId(TenantId tenantId) {
    tenantIdSet.remove(tenantId);
}
#method_after
@Override
public void removeTenantId(TenantId tenantId) {
    // Remove all the virtual networks of this tenant
    Set<VirtualNetwork> networkIdSet = getNetworks(tenantId);
    if (networkIdSet != null) {
        networkIdSet.forEach(virtualNetwork -> removeNetwork(virtualNetwork.id()));
    }
    tenantIdSet.remove(tenantId);
}
#end_block

#method_before
@Override
public void removeNetwork(NetworkId networkId) {
    // Make sure that the virtual network exists before attempting to remove it.
    if (networkExists(networkId)) {
        // TODO update both maps in one transaction.
        VirtualNetwork virtualNetwork = networkIdVirtualNetworkMap.remove(networkId);
        if (virtualNetwork == null) {
            return;
        }
        TenantId tenantId = virtualNetwork.tenantId();
        Set<NetworkId> networkIdSet = new HashSet<>();
        tenantIdNetworkIdSetMap.get(tenantId).forEach(networkId1 -> {
            if (networkId1.id().equals(networkId.id())) {
                networkIdSet.add(networkId1);
            }
        });
        tenantIdNetworkIdSetMap.compute(virtualNetwork.tenantId(), (id, existingNetworkIds) -> {
            if (existingNetworkIds == null || existingNetworkIds.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingNetworkIds, networkIdSet));
            }
        });
    }
}
#method_after
@Override
public void removeNetwork(NetworkId networkId) {
    // Make sure that the virtual network exists before attempting to remove it.
    if (networkExists(networkId)) {
        // Remove all the devices of this network
        Set<VirtualDevice> deviceSet = getDevices(networkId);
        if (deviceSet != null) {
            deviceSet.forEach(virtualDevice -> removeDevice(networkId, virtualDevice.id()));
        }
        // TODO update both maps in one transaction.
        VirtualNetwork virtualNetwork = networkIdVirtualNetworkMap.remove(networkId);
        if (virtualNetwork == null) {
            return;
        }
        TenantId tenantId = virtualNetwork.tenantId();
        Set<NetworkId> networkIdSet = new HashSet<>();
        tenantIdNetworkIdSetMap.get(tenantId).forEach(networkId1 -> {
            if (networkId1.id().equals(networkId.id())) {
                networkIdSet.add(networkId1);
            }
        });
        tenantIdNetworkIdSetMap.compute(virtualNetwork.tenantId(), (id, existingNetworkIds) -> {
            if (existingNetworkIds == null || existingNetworkIds.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingNetworkIds, networkIdSet));
            }
        });
    }
}
#end_block

#method_before
@Override
public void removeDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    // TODO update both maps in one transaction.
    Set<DeviceId> deviceIdSet = new HashSet<>();
    networkIdDeviceIdSetMap.get(networkId).forEach(deviceId1 -> {
        if (deviceId1.equals(deviceId)) {
            deviceIdSet.add(deviceId1);
        }
    });
    if (deviceIdSet != null) {
        networkIdDeviceIdSetMap.compute(networkId, (id, existingDeviceIds) -> {
            if (existingDeviceIds == null || existingDeviceIds.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingDeviceIds, deviceIdSet));
            }
        });
        deviceIdVirtualDeviceMap.remove(deviceId);
    }
// TODO remove virtual links and ports when removing the virtual device
}
#method_after
@Override
public void removeDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    // Remove all the virtual ports of the this device
    Set<VirtualPort> virtualPorts = getPorts(networkId, deviceId);
    if (virtualPorts != null) {
        virtualPorts.forEach(virtualPort -> removePort(networkId, deviceId, virtualPort.number()));
    }
    // TODO update both maps in one transaction.
    Set<DeviceId> deviceIdSet = new HashSet<>();
    networkIdDeviceIdSetMap.get(networkId).forEach(deviceId1 -> {
        if (deviceId1.equals(deviceId)) {
            deviceIdSet.add(deviceId1);
        }
    });
    if (deviceIdSet != null) {
        networkIdDeviceIdSetMap.compute(networkId, (id, existingDeviceIds) -> {
            if (existingDeviceIds == null || existingDeviceIds.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingDeviceIds, deviceIdSet));
            }
        });
        deviceIdVirtualDeviceMap.remove(deviceId);
    }
}
#end_block

#method_before
@Override
public VirtualHost addHost(NetworkId networkId, HostId hostId, MacAddress mac, VlanId vlan, HostLocation location, Set<IpAddress> ips) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<HostId> hostIdSet = networkIdHostIdSetMap.get(networkId);
    if (hostIdSet == null) {
        hostIdSet = new HashSet<>();
    }
    VirtualHost virtualhost = new DefaultVirtualHost(networkId, hostId, mac, vlan, location, ips);
    // TODO update both maps in one transaction.
    hostIdVirtualHostMap.put(hostId, virtualhost);
    hostIdSet.add(hostId);
    networkIdHostIdSetMap.put(networkId, hostIdSet);
    return virtualhost;
}
#method_after
@Override
public VirtualHost addHost(NetworkId networkId, HostId hostId, MacAddress mac, VlanId vlan, HostLocation location, Set<IpAddress> ips) {
    checkState(networkExists(networkId), "The network has not been added.");
    checkState(virtualPortExists(networkId, location.deviceId(), location.port()), "The virtual port has not been created.");
    Set<HostId> hostIdSet = networkIdHostIdSetMap.get(networkId);
    if (hostIdSet == null) {
        hostIdSet = new HashSet<>();
    }
    VirtualHost virtualhost = new DefaultVirtualHost(networkId, hostId, mac, vlan, location, ips);
    // TODO update both maps in one transaction.
    hostIdVirtualHostMap.put(hostId, virtualhost);
    hostIdSet.add(hostId);
    networkIdHostIdSetMap.put(networkId, hostIdSet);
    return virtualhost;
}
#end_block

#method_before
@Override
public VirtualLink addLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst, Link.State state, TunnelId realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(networkId);
    if (virtualLinkSet == null) {
        virtualLinkSet = new HashSet<>();
    }
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    Optional<VirtualPort> vSrcPortOptional = virtualPortSet.stream().filter(p -> p.element().id().equals(src.deviceId()) && p.number().equals(src.port()) && !p.isLinkFrom()).findFirst();
    checkState(vSrcPortOptional.isPresent(), "The requested virtual source port can not be used.");
    Optional<VirtualPort> vDstPortOptional = virtualPortSet.stream().filter(p -> p.element().id().equals(dst.deviceId()) && p.number().equals(dst.port()) && !p.isLinkTo()).findFirst();
    checkState(vDstPortOptional.isPresent(), "The requested virtual destination port can not be used.");
    VirtualPort vSrcPort = vSrcPortOptional.get();
    VirtualPort vDstPort = vDstPortOptional.get();
    vSrcPort.setIsLinkFrom(true);
    vDstPort.setIsLinkTo(true);
    VirtualLink virtualLink = DefaultVirtualLink.builder().networkId(networkId).src(src).dst(dst).state(state).tunnelId(realizedBy).build();
    virtualLinkSet.add(virtualLink);
    networkIdVirtualLinkSetMap.put(networkId, virtualLinkSet);
    return virtualLink;
}
#method_after
@Override
public VirtualLink addLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst, Link.State state, TunnelId realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    checkState(virtualPortExists(networkId, src.deviceId(), src.port()), "The source virtual port has not been added.");
    checkState(virtualPortExists(networkId, dst.deviceId(), dst.port()), "The destination virtual port has not been added.");
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(networkId);
    if (virtualLinkSet == null) {
        virtualLinkSet = new HashSet<>();
    }
    // validate that the link does not already exist in this network
    checkState(getLink(networkId, src, dst) == null, "The virtual link already exists");
    checkState(getLink(networkId, src, null) == null, "The source connection point has been used by another link");
    checkState(getLink(networkId, null, dst) == null, "The destination connection point has been used by another link");
    VirtualLink virtualLink = DefaultVirtualLink.builder().networkId(networkId).src(src).dst(dst).state(state).tunnelId(realizedBy).build();
    virtualLinkSet.add(virtualLink);
    networkIdVirtualLinkSetMap.put(networkId, virtualLinkSet);
    return virtualLink;
}
#end_block

#method_before
@Override
public void updateLink(VirtualLink virtualLink, TunnelId tunnelId, Link.State state) {
    checkState(networkExists(virtualLink.networkId()), "The network has not been added.");
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(virtualLink.networkId());
    if (virtualLinkSet == null) {
        virtualLinkSet = new HashSet<>();
        networkIdVirtualLinkSetMap.put(virtualLink.networkId(), virtualLinkSet);
        log.warn("The updated virtual link {} has not been added", virtualLink);
        return;
    }
    if (!virtualLinkSet.remove(virtualLink)) {
        log.warn("The updated virtual link {} has not been added", virtualLink);
        return;
    }
    VirtualLink newVirtualLink = DefaultVirtualLink.builder().networkId(virtualLink.networkId()).src(virtualLink.src()).dst(virtualLink.dst()).tunnelId(tunnelId).state(state).build();
    virtualLinkSet.add(newVirtualLink);
    networkIdVirtualLinkSetMap.put(newVirtualLink.networkId(), virtualLinkSet);
}
#method_after
@Override
public void updateLink(VirtualLink virtualLink, TunnelId tunnelId, Link.State state) {
    checkState(networkExists(virtualLink.networkId()), "The network has not been added.");
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(virtualLink.networkId());
    if (virtualLinkSet == null) {
        virtualLinkSet = new HashSet<>();
        networkIdVirtualLinkSetMap.put(virtualLink.networkId(), virtualLinkSet);
        log.warn("The updated virtual link {} has not been added", virtualLink);
        return;
    }
    if (!virtualLinkSet.remove(virtualLink)) {
        log.warn("The updated virtual link {} does not exist", virtualLink);
        return;
    }
    VirtualLink newVirtualLink = DefaultVirtualLink.builder().networkId(virtualLink.networkId()).src(virtualLink.src()).dst(virtualLink.dst()).tunnelId(tunnelId).state(state).build();
    virtualLinkSet.add(newVirtualLink);
    networkIdVirtualLinkSetMap.put(newVirtualLink.networkId(), virtualLinkSet);
}
#end_block

#method_before
@Override
public VirtualLink removeLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    checkState(networkExists(networkId), "The network has not been added.");
    final VirtualLink virtualLink = getLink(networkId, src, dst);
    if (virtualLink == null) {
        return null;
    }
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    Optional<VirtualPort> vSrcPortOptional = virtualPortSet.stream().filter(p -> p.element().id().equals(src.deviceId()) && p.number().equals(src.port()) && p.isLinkFrom()).findFirst();
    if (!vSrcPortOptional.isPresent()) {
        log.warn("The removed virtual link between {} and {} has not been added", src, dst);
        return null;
    }
    Optional<VirtualPort> vDstPortOptional = virtualPortSet.stream().filter(p -> p.element().id().equals(dst.deviceId()) && p.number().equals(dst.port()) && p.isLinkTo()).findFirst();
    if (!vDstPortOptional.isPresent()) {
        log.warn("The removed virtual link between {} and {} has not been added", src, dst);
        return null;
    }
    Set<VirtualLink> virtualLinkSet = new HashSet<>();
    virtualLinkSet.add(virtualLink);
    if (virtualLinkSet != null) {
        networkIdVirtualLinkSetMap.compute(networkId, (id, existingVirtualLinks) -> {
            if (existingVirtualLinks == null || existingVirtualLinks.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingVirtualLinks, virtualLinkSet));
            }
        });
    }
    VirtualPort vSrcPort = vSrcPortOptional.get();
    VirtualPort vDstPort = vDstPortOptional.get();
    vSrcPort.setIsLinkFrom(false);
    vDstPort.setIsLinkTo(false);
    return virtualLink;
}
#method_after
@Override
public VirtualLink removeLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    checkState(networkExists(networkId), "The network has not been added.");
    final VirtualLink virtualLink = getLink(networkId, src, dst);
    if (virtualLink == null) {
        log.warn("The removed virtual link between {} and {} does not exist", src, dst);
        return null;
    }
    Set<VirtualLink> virtualLinkSet = new HashSet<>();
    virtualLinkSet.add(virtualLink);
    if (virtualLinkSet != null) {
        networkIdVirtualLinkSetMap.compute(networkId, (id, existingVirtualLinks) -> {
            if (existingVirtualLinks == null || existingVirtualLinks.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingVirtualLinks, virtualLinkSet));
            }
        });
    }
    return virtualLink;
}
#end_block

#method_before
@Override
public VirtualPort addPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet == null) {
        virtualPortSet = new HashSet<>();
    }
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    boolean exist = virtualPortSet.stream().anyMatch(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber));
    checkState(!exist, "The requested Port Number is already in use");
    VirtualPort virtualPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(virtualPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_ADDED, networkId, device, virtualPort));
    return virtualPort;
}
#method_after
@Override
public VirtualPort addPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet == null) {
        virtualPortSet = new HashSet<>();
    }
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    checkState(!virtualPortExists(networkId, deviceId, portNumber), "The requested Port Number has been added.");
    VirtualPort virtualPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(virtualPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_ADDED, networkId, device, virtualPort));
    return virtualPort;
}
#end_block

#method_before
@Override
public void bindPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    VirtualPort vPort = virtualPortSet.stream().filter(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber)).findFirst().get();
    checkNotNull(vPort, "The virtual port has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    virtualPortSet.remove(vPort);
    vPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(vPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_UPDATED, networkId, device, vPort));
}
#method_after
@Override
public void bindPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    Optional<VirtualPort> virtualPortOptional = virtualPortSet.stream().filter(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber)).findFirst();
    checkState(virtualPortOptional.isPresent(), "The virtual port has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    VirtualPort vPort = virtualPortOptional.get();
    virtualPortSet.remove(vPort);
    vPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(vPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_UPDATED, networkId, device, vPort));
}
#end_block

#method_before
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    Set<VirtualPort> virtualPortSet = new HashSet<>();
    networkIdVirtualPortSetMap.get(networkId).forEach(port -> {
        if (port.element().id().equals(deviceId) && port.number().equals(portNumber)) {
            virtualPortSet.add(port);
        }
    });
    if (!virtualPortSet.isEmpty()) {
        AtomicBoolean portRemoved = new AtomicBoolean(false);
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return new HashSet<>();
            } else {
                portRemoved.set(true);
                return new HashSet<>(Sets.difference(existingVirtualPorts, virtualPortSet));
            }
        });
        if (portRemoved.get()) {
            virtualPortSet.forEach(virtualPort -> notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_REMOVED, networkId, device, virtualPort)));
        }
    }
}
#method_after
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    if (networkIdVirtualPortSetMap.get(networkId) == null) {
        log.warn("No port has been created for NetworkId: {}", networkId);
        return;
    }
    Set<VirtualPort> virtualPortSet = new HashSet<>();
    networkIdVirtualPortSetMap.get(networkId).forEach(port -> {
        if (port.element().id().equals(deviceId) && port.number().equals(portNumber)) {
            virtualPortSet.add(port);
        }
    });
    if (!virtualPortSet.isEmpty()) {
        AtomicBoolean portRemoved = new AtomicBoolean(false);
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return new HashSet<>();
            } else {
                portRemoved.set(true);
                return new HashSet<>(Sets.difference(existingVirtualPorts, virtualPortSet));
            }
        });
        if (portRemoved.get()) {
            virtualPortSet.forEach(virtualPort -> notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_REMOVED, networkId, device, virtualPort)));
            // Remove all the virtual links connected to this virtual port
            Set<VirtualLink> existingVirtualLinks = networkIdVirtualLinkSetMap.get(networkId);
            if (existingVirtualLinks != null && !existingVirtualLinks.isEmpty()) {
                Set<VirtualLink> virtualLinkSet = new HashSet<>();
                ConnectPoint cp = new ConnectPoint(deviceId, portNumber);
                existingVirtualLinks.forEach(virtualLink -> {
                    if (virtualLink.src().equals(cp) || virtualLink.dst().equals(cp)) {
                        virtualLinkSet.add(virtualLink);
                    }
                });
                virtualLinkSet.forEach(virtualLink -> removeLink(networkId, virtualLink.src(), virtualLink.dst()));
            }
            // Remove all the hosts connected to this virtual port
            Set<HostId> hostIdSet = new HashSet<>();
            hostIdVirtualHostMap.forEach((hostId, virtualHost) -> {
                if (virtualHost.location().deviceId().equals(deviceId) && virtualHost.location().port().equals(portNumber)) {
                    hostIdSet.add(hostId);
                }
            });
            hostIdSet.forEach(hostId -> removeHost(networkId, hostId));
        }
    }
}
#end_block

#method_before
@Override
public VirtualLink getLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(networkId);
    if (virtualLinkSet == null) {
        return null;
    }
    VirtualLink virtualLink = null;
    for (VirtualLink link : virtualLinkSet) {
        if (link.src().equals(src) && link.dst().equals(dst)) {
            virtualLink = link;
            break;
        }
    }
    return virtualLink;
}
#method_after
@Override
public VirtualLink getLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(networkId);
    if (virtualLinkSet == null) {
        return null;
    }
    VirtualLink virtualLink = null;
    for (VirtualLink link : virtualLinkSet) {
        if (src == null && link.dst().equals(dst)) {
            virtualLink = link;
            break;
        } else if (dst == null && link.src().equals(src)) {
            virtualLink = link;
            break;
        } else if (link.src().equals(src) && link.dst().equals(dst)) {
            virtualLink = link;
            break;
        }
    }
    return virtualLink;
}
#end_block

#method_before
@Test
public void removeVirtualizeFlowRule() {
    TrafficSelector ts = DefaultTrafficSelector.builder().build();
    TrafficTreatment tr = DefaultTrafficTreatment.builder().setOutput(PORT_NUM2).build();
    FlowRule r1 = DefaultFlowRule.builder().forDevice(VDID1).withSelector(ts).withTreatment(tr).withPriority(10).fromApp(vAppId).makeTemporary(TIMEOUT).build();
    virtualProvider.removeFlowRule(VNET_ID, r1);
    assertEquals("0 rules should exist", 0, virtualProvider.flowRuleService.getFlowRuleCount());
}
#method_after
@Test
public void removeVirtualizeFlowRule() {
    TrafficSelector ts = DefaultTrafficSelector.builder().build();
    TrafficTreatment tr = DefaultTrafficTreatment.builder().setOutput(PORT_NUM2).build();
    FlowRule r1 = DefaultFlowRule.builder().forDevice(VDID).withSelector(ts).withTreatment(tr).withPriority(10).fromApp(vAppId).makeTemporary(TIMEOUT).build();
    virtualProvider.removeFlowRule(VNET_ID, r1);
    assertEquals("0 rules should exist", 0, virtualProvider.flowRuleService.getFlowRuleCount());
}
#end_block

#method_before
@Override
public Set<VirtualDevice> getVirtualDevices(NetworkId networkId) {
    return ImmutableSet.of(VDEV1);
}
#method_after
@Override
public Set<VirtualDevice> getVirtualDevices(NetworkId networkId) {
    return ImmutableSet.of(VDEV);
}
#end_block

#method_before
@Override
public Set<VirtualLink> getVirtualLinks(NetworkId networkId) {
    return null;
}
#method_after
@Override
public Set<VirtualLink> getVirtualLinks(NetworkId networkId) {
    return new HashSet<>();
}
#end_block

#method_before
@Override
public Set<VirtualPort> getVirtualPorts(NetworkId networkId, DeviceId deviceId) {
    return ImmutableSet.of(VPORT11, VPORT12);
}
#method_after
@Override
public Set<VirtualPort> getVirtualPorts(NetworkId networkId, DeviceId deviceId) {
    return ImmutableSet.of(VPORT1, VPORT2);
}
#end_block

#method_before
public static void updateJavaInfo(YangNode node, YangPluginConfig config) {
    if (node instanceof YangModule) {
        // handle module
        YangModule module = (YangModule) node;
        String modulePkg = getRootPackage(module.getVersion(), module.getModuleNamespace(), module.getRevision(), null);
        updatePackageInfo((JavaCodeGeneratorInfo) node, config, modulePkg);
    } else if (node instanceof YangSubModule) {
        // handle submodule
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        String subModulePkg = getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), null);
        updatePackageInfo((JavaCodeGeneratorInfo) node, config, subModulePkg);
    } else {
        // handle other nodes and also handle grouping
        if (node.getReferredSchema() != null) {
            // in case of grouping in normal case we generate java file
            // info for node even before cloning so when we clone the
            // actual java file info will be cloned but in this case we
            // will clone first so in the cloned node , we have to update
            // the actual java file info for correct operations. because
            // code will be generated only for actual node.
            YangNode n = (YangNode) getRefSchema((JavaCodeGeneratorInfo) node);
            if (n != null) {
                updatePackageInfo((JavaCodeGeneratorInfo) n, config);
                ((JavaCodeGeneratorInfo) node).setJavaFileInfo(((JavaCodeGeneratorInfo) n).getJavaFileInfo());
            }
        } else {
            updatePackageInfo((JavaCodeGeneratorInfo) node, config);
        }
    }
    if (node instanceof YangLeavesHolder) {
        YangLeavesHolder holder = (YangLeavesHolder) node;
        for (YangLeaf leaf : holder.getListOfLeaf()) {
            updateLeavesJavaQualifiedInfo((JavaLeafInfoContainer) leaf);
        }
        for (YangLeafList leaf : holder.getListOfLeafList()) {
            updateLeavesJavaQualifiedInfo((JavaLeafInfoContainer) leaf);
        }
    }
}
#method_after
static void updateJavaInfo(YangNode node, YangPluginConfig config) {
    if (node instanceof YangModule) {
        // handle module
        YangModule module = (YangModule) node;
        String modulePkg = getRootPackage(module.getVersion(), module.getModuleNamespace(), module.getRevision(), null);
        updatePackageInfo((JavaCodeGeneratorInfo) node, config, modulePkg);
    } else if (node instanceof YangSubModule) {
        // handle submodule
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        String subModulePkg = getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), null);
        updatePackageInfo((JavaCodeGeneratorInfo) node, config, subModulePkg);
    } else {
        // handle other nodes and also handle grouping
        if (node.getReferredSchema() != null) {
            // in case of grouping in normal case we generate java file
            // info for node even before cloning so when we clone the
            // actual java file info will be cloned but in this case we
            // will clone first so in the cloned node , we have to update
            // the actual java file info for correct operations. because
            // code will be generated only for actual node.
            YangNode n = (YangNode) getRefSchema((JavaCodeGeneratorInfo) node);
            if (n != null) {
                updatePackageInfo((JavaCodeGeneratorInfo) n, config);
                ((JavaCodeGeneratorInfo) node).setJavaFileInfo(((JavaCodeGeneratorInfo) n).getJavaFileInfo());
            }
        } else {
            updatePackageInfo((JavaCodeGeneratorInfo) node, config);
        }
    }
    if (node instanceof YangLeavesHolder) {
        YangLeavesHolder holder = (YangLeavesHolder) node;
        for (YangLeaf leaf : holder.getListOfLeaf()) {
            updateLeavesJavaQualifiedInfo((JavaLeafInfoContainer) leaf);
        }
        for (YangLeafList leaf : holder.getListOfLeafList()) {
            updateLeavesJavaQualifiedInfo((JavaLeafInfoContainer) leaf);
        }
    }
}
#end_block

#method_before
public static Set<YangNode> addLinkerAndJavaInfo(Set<YangNode> nodes) {
    YangLinker yangLinker = new YangLinkerManager();
    // Do the linking.
    yangLinker.resolveDependencies(nodes);
    // add the java info.
    for (YangNode node : nodes) {
        if (!((YangDeviationHolder) node).isModuleForDeviation()) {
            updateTranslator(node);
        }
    }
    return nodes;
}
#method_after
public static Set<YangNode> addLinkerAndJavaInfo(Set<YangNode> nodes) {
    YangLinker yangLinker = new YangLinkerManager();
    // Do the linking.
    yangLinker.resolveDependencies(nodes);
    // add the java info.
    for (YangNode node : nodes) {
        if (!((YangDeviationHolder) node).isModuleForDeviation()) {
            try {
                translate(node, new YangPluginConfig(), false);
            } catch (IOException e) {
                log.error("failed to target link node {},", node.getName());
            }
        }
    }
    return nodes;
}
#end_block

#method_before
@Override
public CompletableFuture<OFMessage> writeResponse(Dpid dpid, OFMessage msg) {
    write(dpid, msg);
    if (!responses.containsKey(dpid)) {
        responses.put(dpid, new ConcurrentHashMap());
    }
    ConcurrentMap<Long, CompletableFuture<OFMessage>> xids = responses.get(dpid);
    CompletableFuture<OFMessage> future = new CompletableFuture();
    xids.put(msg.getXid(), future);
    return future;
}
#method_after
@Override
public CompletableFuture<OFMessage> writeResponse(Dpid dpid, OFMessage msg) {
    write(dpid, msg);
    ConcurrentMap<Long, CompletableFuture<OFMessage>> xids = responses.computeIfAbsent(dpid, k -> new ConcurrentHashMap());
    CompletableFuture<OFMessage> future = new CompletableFuture();
    xids.put(msg.getXid(), future);
    return future;
}
#end_block

#method_before
public double asKHz() {
    return frequency / KHZ;
}
#method_after
public double asKHz() {
    return (double) frequency / KHZ;
}
#end_block

#method_before
private String getConnectionsFilter() {
    return new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlShort(KEY_CONNS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
}
#method_after
private String getConnectionsFilter() {
    return new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlEmpty(KEY_CONNS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
}
#end_block

#method_before
private Collection<FlowEntry> parseConnections() {
    log.debug("Fetch connections...");
    String reply = netconfGetConfig(handler(), getConnectionsFilter());
    HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(reply);
    List<HierarchicalConfiguration> subtrees = cfg.configurationsAt(KEY_DATA_CONNS);
    Collection<FlowEntry> list = new ArrayList<>();
    for (HierarchicalConfiguration connection : subtrees) {
        FlowRule rule = parseConnection(connection);
        if (rule != null) {
            list.add(new DefaultFlowEntry(rule, FlowEntry.FlowEntryState.ADDED));
        }
    }
    return list;
}
#method_after
private Collection<FlowEntry> parseConnections() {
    log.debug("Fetch connections...");
    String reply = netconfGetConfig(handler(), getConnectionsFilter());
    HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(reply);
    List<HierarchicalConfiguration> subtrees = cfg.configurationsAt(KEY_DATA_CONNS);
    Collection<FlowEntry> list = new ArrayList<>();
    for (HierarchicalConfiguration connection : subtrees) {
        list.add(new DefaultFlowEntry(parseConnection(connection), FlowEntry.FlowEntryState.ADDED));
    }
    return list;
}
#end_block

#method_before
private FlowRule parseConnection(HierarchicalConfiguration cfg) {
    OplinkConnection connection = new OplinkConnection(this, PortNumber.portNumber(cfg.getString(KEY_SRC_PORTID)), PortNumber.portNumber(cfg.getString(KEY_DST_PORTID)), cfg.getInt(KEY_SRC_CHID));
    return connection.getFlowRule();
}
#method_after
private FlowRule parseConnection(HierarchicalConfiguration cfg) {
    return OplinkOpticalUtility.toFlowRule(this, PortNumber.portNumber(cfg.getString(KEY_SRC_PORTID)), PortNumber.portNumber(cfg.getString(KEY_DST_PORTID)), cfg.getInt(KEY_SRC_CHID));
}
#end_block

#method_before
private boolean applyConnection(FlowRule rule) {
    log.debug("Applying connection {}", rule);
    OplinkConnection connection = new OplinkConnection(rule);
    // Build xml
    String connID = connection.getChannel().toString();
    String cfg = new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_CONNS)).append(xml(KEY_CONNID, connID)).append(xmlHead(KEY_SRC)).append(xml(KEY_PORTID, connection.getInPort().name())).append(xml(KEY_CHID, connID)).append(xmlEnd(KEY_SRC)).append(xmlHead(KEY_DST)).append(xml(KEY_PORTID, connection.getOutPort().name())).append(xmlEnd(KEY_DST)).append(xml(KEY_CHATT, connection.getAttenuation().toString())).append(xmlEnd(KEY_CONNS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
    return netconfEditConfig(handler(), CFG_MODE_MERGE, cfg);
}
#method_after
private boolean applyConnection(FlowRule rule) {
    log.debug("Applying connection {}", rule);
    OplinkCrossConnect crossConnect = OplinkOpticalUtility.fromFlowRule(this, rule);
    // Build xml
    String connID = Integer.toString(crossConnect.getChannel());
    String cfg = new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_CONNS)).append(xml(KEY_CONNID, connID)).append(xmlOpen(KEY_SRC)).append(xml(KEY_PORTID, crossConnect.getInPort().name())).append(xml(KEY_CHID, connID)).append(xmlClose(KEY_SRC)).append(xmlOpen(KEY_DST)).append(xml(KEY_PORTID, crossConnect.getOutPort().name())).append(xmlClose(KEY_DST)).append(xml(KEY_CHATT, Integer.toString(crossConnect.getAttenuation()))).append(xmlClose(KEY_CONNS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
    return netconfEditConfig(handler(), CFG_MODE_MERGE, cfg);
}
#end_block

#method_before
private boolean removeConnection(FlowRule rule) {
    log.debug("Removing connection {}", rule);
    OplinkConnection connection = new OplinkConnection(rule);
    // Build xml
    String connID = connection.getChannel().toString();
    String cfg = new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_CONNS)).append(xml(KEY_CONNID, connID)).append(xmlHead(KEY_SRC)).append(xml(KEY_PORTID, connection.getInPort().name())).append(xml(KEY_CHID, connID)).append(xmlEnd(KEY_SRC)).append(xmlEnd(KEY_CONNS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
    return netconfEditConfig(handler(), CFG_MODE_REMOVE, cfg);
}
#method_after
private boolean removeConnection(FlowRule rule) {
    log.debug("Removing connection {}", rule);
    OplinkCrossConnect crossConnect = OplinkOpticalUtility.fromFlowRule(this, rule);
    // Build xml
    String connID = Integer.toString(crossConnect.getChannel());
    String cfg = new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_CONNS)).append(xml(KEY_CONNID, connID)).append(xmlOpen(KEY_SRC)).append(xml(KEY_PORTID, crossConnect.getInPort().name())).append(xml(KEY_CHID, connID)).append(xmlClose(KEY_SRC)).append(xmlClose(KEY_CONNS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
    return netconfEditConfig(handler(), CFG_MODE_REMOVE, cfg);
}
#end_block

#method_before
private String getPortPowerFilter(PortNumber port, String selection) {
    return new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlHead(KEY_PORT)).append(xmlShort(selection)).append(xmlEnd(KEY_PORT)).append(xmlEnd(KEY_PORTS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
}
#method_after
private String getPortPowerFilter(PortNumber port, String selection) {
    return new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlOpen(KEY_PORT)).append(xmlEmpty(selection)).append(xmlClose(KEY_PORT)).append(xmlClose(KEY_PORTS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
}
#end_block

#method_before
private String getChannelPowerFilter(PortNumber port, OchSignal channel) {
    return new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlHead(KEY_PORT)).append(xmlHead(KEY_OCMSTATS)).append(xml(KEY_CHNUM, Integer.toString(channel.spacingMultiplier()))).append(xmlShort(KEY_CHSTATS)).append(xmlEnd(KEY_OCMSTATS)).append(xmlEnd(KEY_PORT)).append(xmlEnd(KEY_PORTS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
}
#method_after
private String getChannelPowerFilter(PortNumber port, OchSignal channel) {
    return new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlOpen(KEY_PORT)).append(xmlOpen(KEY_OCMSTATS)).append(xml(KEY_CHNUM, Integer.toString(channel.spacingMultiplier()))).append(xmlEmpty(KEY_CHSTATS)).append(xmlClose(KEY_OCMSTATS)).append(xmlClose(KEY_PORT)).append(xmlClose(KEY_PORTS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
}
#end_block

#method_before
private String getChannelAttenuationFilter(PortNumber port, OchSignal channel) {
    return new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_CONNS)).append(xml(KEY_CONNID, Integer.toString(channel.spacingMultiplier()))).append(xmlShort(KEY_CHATT)).append(xmlEnd(KEY_CONNS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
}
#method_after
private String getChannelAttenuationFilter(PortNumber port, OchSignal channel) {
    return new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_CONNS)).append(xml(KEY_CONNID, Integer.toString(channel.spacingMultiplier()))).append(xmlEmpty(KEY_CHATT)).append(xmlClose(KEY_CONNS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
}
#end_block

#method_before
private String getPowerRangeFilter(PortNumber port, String direction) {
    return new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlHead(KEY_PORT)).append(xml(KEY_PORTDIRECT, direction)).append(xmlShort(KEY_PORTPROPERTY)).append(xmlEnd(KEY_PORT)).append(xmlEnd(KEY_PORTS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
}
#method_after
private String getPowerRangeFilter(PortNumber port, String direction) {
    return new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlOpen(KEY_PORT)).append(xml(KEY_PORTDIRECT, direction)).append(xmlEmpty(KEY_PORTPROPERTY)).append(xmlClose(KEY_PORT)).append(xmlClose(KEY_PORTS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
}
#end_block

#method_before
private Long acquirePortPower(PortNumber port, String selection) {
    String reply = netconfGetConfig(handler(), getPortPowerFilter(port, selection));
    HierarchicalConfiguration info = configAt(reply, KEY_PORTS_PORT);
    if (info == null) {
        return null;
    }
    return (long) (info.getDouble(selection) * TIME_POWER);
}
#method_after
private Long acquirePortPower(PortNumber port, String selection) {
    String reply = netconfGetConfig(handler(), getPortPowerFilter(port, selection));
    HierarchicalConfiguration info = configAt(reply, KEY_PORTS_PORT);
    if (info == null) {
        return null;
    }
    return (long) (info.getDouble(selection) * POWER_MULTIPLIER);
}
#end_block

#method_before
private Long acquireChannelAttenuation(PortNumber port, OchSignal channel) {
    log.debug("Get port{} channel{} attenuation...", port, channel.channelSpacing());
    String reply = netconfGetConfig(handler(), getChannelAttenuationFilter(port, channel));
    HierarchicalConfiguration info = configAt(reply, KEY_CONNS);
    if (info == null) {
        return null;
    }
    return (long) (info.getDouble(KEY_CHATT) * TIME_POWER);
}
#method_after
private Long acquireChannelAttenuation(PortNumber port, OchSignal channel) {
    log.debug("Get port{} channel{} attenuation...", port, channel.channelSpacing());
    String reply = netconfGetConfig(handler(), getChannelAttenuationFilter(port, channel));
    HierarchicalConfiguration info = configAt(reply, KEY_CONNS);
    if (info == null) {
        return null;
    }
    return (long) (info.getDouble(KEY_CHATT) * POWER_MULTIPLIER);
}
#end_block

#method_before
private Long acquireChannelPower(PortNumber port, OchSignal channel) {
    log.debug("Get port{} channel{} power...", port, channel.channelSpacing());
    String reply = netconfGetConfig(handler(), getChannelPowerFilter(port, channel));
    HierarchicalConfiguration info = configAt(reply, KEY_DATA_CONNS);
    if (info == null) {
        return null;
    }
    return (long) (info.getDouble(KEY_CHPWR) * TIME_POWER);
}
#method_after
private Long acquireChannelPower(PortNumber port, OchSignal channel) {
    log.debug("Get port{} channel{} power...", port, channel.channelSpacing());
    String reply = netconfGetConfig(handler(), getChannelPowerFilter(port, channel));
    HierarchicalConfiguration info = configAt(reply, KEY_DATA_CONNS);
    if (info == null) {
        return null;
    }
    return (long) (info.getDouble(KEY_CHPWR) * POWER_MULTIPLIER);
}
#end_block

#method_before
private boolean setPortTargetPower(PortNumber port, long power) {
    log.debug("Set port{} target power...", port);
    String cfg = new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlHead(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlHead(KEY_PORT)).append(xml(KEY_PORTTARPWR, Long.toString(power))).append(xmlEnd(KEY_PORT)).append(xmlEnd(KEY_PORTS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
    return netconfEditConfig(handler(), CFG_MODE_MERGE, cfg);
}
#method_after
private boolean setPortTargetPower(PortNumber port, long power) {
    log.debug("Set port{} target power...", port);
    String cfg = new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlOpen(KEY_PORTS)).append(xml(KEY_PORTID, Long.toString(port.toLong()))).append(xmlOpen(KEY_PORT)).append(xml(KEY_PORTTARPWR, Long.toString(power))).append(xmlClose(KEY_PORT)).append(xmlClose(KEY_PORTS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
    return netconfEditConfig(handler(), CFG_MODE_MERGE, cfg);
}
#end_block

#method_before
private boolean setChannelTargetPower(PortNumber port, OchSignal channel, long power) {
    log.debug("Set port{} channel{} attenuation.", port, channel.channelSpacing());
    FlowRuleService service = handler().get(FlowRuleService.class);
    Iterable<FlowEntry> entries = service.getFlowEntries(data().deviceId());
    for (FlowEntry entry : entries) {
        Set<Criterion> criterions = entry.selector().criteria();
        PortNumber ip = criterions.stream().filter(c -> c instanceof PortCriterion).map(c -> ((PortCriterion) c).port()).findAny().orElse(null);
        OchSignal ch = criterions.stream().filter(c -> c instanceof OchSignalCriterion).map(c -> ((OchSignalCriterion) c).lambda()).findAny().orElse(null);
        PortNumber op = entry.treatment().immediate().stream().filter(c -> c instanceof Instructions.OutputInstruction).map(c -> ((Instructions.OutputInstruction) c).port()).findAny().orElse(null);
        if ((port.equals(ip) || port.equals(op)) && channel.equals(ch)) {
            log.debug("Flow is found, modify flow with attenuation.");
            TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(op).extension(new OplinkAttenuation((int) power), data().deviceId()).build();
            service.applyFlowRules(DefaultFlowRule.builder().forDevice(data().deviceId()).makePermanent().withSelector(entry.selector()).withTreatment(treatment).withPriority(entry.priority()).withCookie(entry.id().value()).build());
            return true;
        }
    }
    return false;
}
#method_after
private boolean setChannelTargetPower(PortNumber port, OchSignal channel, long power) {
    log.debug("Set port{} channel{} attenuation.", port, channel.channelSpacing());
    FlowRuleService service = handler().get(FlowRuleService.class);
    Iterable<FlowEntry> entries = service.getFlowEntries(data().deviceId());
    for (FlowEntry entry : entries) {
        OplinkCrossConnect crossConnect = OplinkOpticalUtility.fromFlowRule(this, entry);
        // The channel port might be input port or output port.
        if ((port.equals(crossConnect.getInPort()) || port.equals(crossConnect.getOutPort())) && channel.spacingMultiplier() == crossConnect.getChannel()) {
            log.debug("Flow is found, modify the flow with attenuation.");
            // Modify attenuation in treatment
            TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(crossConnect.getOutPort()).extension(new OplinkAttenuation((int) power), data().deviceId()).build();
            // Apply the new flow rule
            service.applyFlowRules(DefaultFlowRule.builder().forDevice(data().deviceId()).makePermanent().withSelector(entry.selector()).withTreatment(treatment).withPriority(entry.priority()).withCookie(entry.id().value()).build());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private Range<Long> getPowerRange(PortNumber port, String directionKey, String minKey, String maxKey) {
    String reply = netconfGetConfig(handler(), getPowerRangeFilter(port, directionKey));
    HierarchicalConfiguration info = configAt(reply, KEY_PORTS_PORT_PROPERTY);
    if (info == null) {
        return null;
    }
    long minPower = (long) (info.getDouble(minKey) * TIME_POWER);
    long maxPower = (long) (info.getDouble(maxKey) * TIME_POWER);
    return Range.closed(minPower, maxPower);
}
#method_after
private Range<Long> getPowerRange(PortNumber port, String directionKey, String minKey, String maxKey) {
    String reply = netconfGetConfig(handler(), getPowerRangeFilter(port, directionKey));
    HierarchicalConfiguration info = configAt(reply, KEY_PORTS_PORT_PROPERTY);
    if (info == null) {
        return null;
    }
    long minPower = (long) (info.getDouble(minKey) * POWER_MULTIPLIER);
    long maxPower = (long) (info.getDouble(maxKey) * POWER_MULTIPLIER);
    return Range.closed(minPower, maxPower);
}
#end_block

#method_before
private String getPortsFilter() {
    return new StringBuilder(xmlHead(KEY_OPENOPTICALDEV_XMLNS)).append(xmlShort(KEY_PORTS)).append(xmlEnd(KEY_OPENOPTICALDEV)).toString();
}
#method_after
private String getPortsFilter() {
    return new StringBuilder(xmlOpen(KEY_OPENOPTICALDEV_XMLNS)).append(xmlEmpty(KEY_PORTS)).append(xmlClose(KEY_OPENOPTICALDEV)).toString();
}
#end_block

#method_before
private PortDescription parsePort(HierarchicalConfiguration cfg) {
    PortNumber portNumber = PortNumber.portNumber(cfg.getLong(KEY_PORTID));
    HierarchicalConfiguration portInfo = cfg.configurationAt(KEY_PORT);
    DefaultAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, portInfo.getString(KEY_PORTNAME)).set(PORT_DIRECTION, portInfo.getString(KEY_PORTDIRECT)).build();
    return omsPortDescription(portNumber, true, START_CENTER_FREQ, END_CENTER_FREQ, CHANNEL_SPACING.frequency(), annotations);
}
#method_after
private PortDescription parsePort(HierarchicalConfiguration cfg) {
    PortNumber portNumber = PortNumber.portNumber(cfg.getLong(KEY_PORTID));
    HierarchicalConfiguration portInfo = cfg.configurationAt(KEY_PORT);
    DefaultAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, portInfo.getString(KEY_PORTNAME)).set(PORT_DIRECTION, portInfo.getString(KEY_PORTDIRECT)).build();
    return omsPortDescription(portNumber, true, START_CENTER_FREQ, STOP_CENTER_FREQ, CHANNEL_SPACING.frequency(), annotations);
}
#end_block

#method_before
public static String netconfGetConfig(DriverHandler handler, String filter) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler.data().deviceId()).getSession();
    String reply;
    try {
        reply = session.getConfig(CFG_TAR_RUNNING, filter);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#method_after
public static String netconfGetConfig(DriverHandler handler, String filter) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    String reply;
    try {
        reply = session.getConfig(CFG_TAR_RUNNING, filter);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#end_block

#method_before
public static boolean netconfEditConfig(DriverHandler handler, String mode, String cfg) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler.data().deviceId()).getSession();
    boolean reply = false;
    try {
        reply = session.editConfig(CFG_TAR_RUNNING, mode, cfg);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to edit configuration.", e));
    }
    return reply;
}
#method_after
public static boolean netconfEditConfig(DriverHandler handler, String mode, String cfg) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    boolean reply = false;
    try {
        reply = session.editConfig(CFG_TAR_RUNNING, mode, cfg);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to edit configuration.", e));
    }
    return reply;
}
#end_block

#method_before
private void prepareIntentData(Optional<IntentData> uninstallData, Optional<IntentData> installData) {
    if (!installData.isPresent() && !uninstallData.isPresent()) {
        return;
    } else if (!installData.isPresent()) {
        prepareIntentData(uninstallData, Direction.REMOVE);
    } else if (!uninstallData.isPresent()) {
        prepareIntentData(installData, Direction.ADD);
    } else {
        IntentData uninstall = uninstallData.get();
        IntentData install = installData.get();
        List<Intent> uninstallIntents = Lists.newArrayList(uninstall.installables());
        List<Intent> installIntents = Lists.newArrayList(install.installables());
        checkState(uninstallIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", uninstallIntents);
        checkState(installIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", installIntents);
        // TODO: Filter FlowObjective intents
        // Filter out same intents and intents with same flow rules
        Iterator<Intent> iterator = installIntents.iterator();
        while (iterator.hasNext()) {
            Intent installIntent = iterator.next();
            uninstallIntents.stream().filter(uIntent -> {
                if (uIntent.equals(installIntent)) {
                    return true;
                } else if (uIntent instanceof FlowRuleIntent && installIntent instanceof FlowRuleIntent) {
                    // (direction can be implied from intent state)
                    return containsAllFlowRules(((FlowRuleIntent) uIntent).flowRules(), ((FlowRuleIntent) installIntent).flowRules());
                } else {
                    return false;
                }
            }).findFirst().ifPresent(common -> {
                uninstallIntents.remove(common);
                if (INSTALLED.equals(uninstall.state())) {
                    // only remove the install intent if the existing
                    // intent (i.e. the uninstall one) is already
                    // installed or installing
                    iterator.remove();
                }
            });
        }
        final IntentData newUninstall = new IntentData(uninstall, uninstallIntents);
        final IntentData newInstall = new IntentData(install, installIntents);
        trackerService.removeTrackedResources(newUninstall.key(), newUninstall.intent().resources());
        uninstallIntents.forEach(installable -> trackerService.removeTrackedResources(newUninstall.intent().key(), installable.resources()));
        trackerService.addTrackedResources(newInstall.key(), newInstall.intent().resources());
        installIntents.forEach(installable -> trackerService.addTrackedResources(newInstall.key(), installable.resources()));
        prepareIntents(uninstallIntents, Direction.REMOVE);
        prepareIntents(installIntents, Direction.ADD);
    }
}
#method_after
private void prepareIntentData(Optional<IntentData> uninstallData, Optional<IntentData> installData) {
    if (!installData.isPresent() && !uninstallData.isPresent()) {
        return;
    } else if (!installData.isPresent()) {
        prepareIntentData(uninstallData, Direction.REMOVE);
    } else if (!uninstallData.isPresent()) {
        prepareIntentData(installData, Direction.ADD);
    } else {
        IntentData uninstall = uninstallData.get();
        IntentData install = installData.get();
        List<Intent> uninstallIntents = Lists.newArrayList(uninstall.installables());
        List<Intent> installIntents = Lists.newArrayList(install.installables());
        checkState(uninstallIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", uninstallIntents);
        checkState(installIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected: %s", installIntents);
        // TODO: Filter FlowObjective intents
        // Filter out same intents and intents with same flow rules
        Iterator<Intent> iterator = installIntents.iterator();
        while (iterator.hasNext()) {
            Intent installIntent = iterator.next();
            uninstallIntents.stream().filter(uIntent -> {
                if (uIntent.equals(installIntent)) {
                    return true;
                } else if (uIntent instanceof FlowRuleIntent && installIntent instanceof FlowRuleIntent) {
                    // (direction can be implied from intent state)
                    return !flowRuleIntentChanged(((FlowRuleIntent) uIntent), ((FlowRuleIntent) installIntent));
                } else {
                    return false;
                }
            }).findFirst().ifPresent(common -> {
                uninstallIntents.remove(common);
                if (INSTALLED.equals(uninstall.state())) {
                    // only remove the install intent if the existing
                    // intent (i.e. the uninstall one) is already
                    // installed or installing
                    iterator.remove();
                }
            });
        }
        final IntentData newUninstall = new IntentData(uninstall, uninstallIntents);
        final IntentData newInstall = new IntentData(install, installIntents);
        trackerService.removeTrackedResources(newUninstall.key(), newUninstall.intent().resources());
        uninstallIntents.forEach(installable -> trackerService.removeTrackedResources(newUninstall.intent().key(), installable.resources()));
        trackerService.addTrackedResources(newInstall.key(), newInstall.intent().resources());
        installIntents.forEach(installable -> trackerService.addTrackedResources(newInstall.key(), installable.resources()));
        prepareIntents(uninstallIntents, Direction.REMOVE);
        prepareIntents(installIntents, Direction.ADD);
    }
}
#end_block

#method_before
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    intentsToApply.stream().filter(x -> x instanceof FlowObjectiveIntent).flatMap(x -> buildObjectiveContexts((FlowObjectiveIntent) x, direction).stream()).forEach(contexts::add);
}
#method_after
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    intentsToApply.stream().filter(intent -> intent instanceof FlowObjectiveIntent).map(intent -> buildObjectiveContexts((FlowObjectiveIntent) intent, direction)).flatMap(Collection::stream).forEach(contexts::add);
    // Two stage for different direction context
    // We will apply REMOVE context first, and apply ADD context.
    contexts.forEach(context -> {
        switch(direction) {
            case REMOVE:
                pendingContexts.add(context);
                break;
            case ADD:
                nextPendingContexts.add(context);
                break;
            default:
                break;
        }
    });
}
#end_block

#method_before
private List<FlowObjectiveInstallationContext> buildObjectiveContexts(FlowObjectiveIntent intent, Direction direction) {
    int size = intent.objectives().size();
    List<FlowObjectiveInstallationContext> contexts = new ArrayList<>(size);
    for (int i = 0; i < size; i++) {
        DeviceId deviceId = intent.devices().get(i);
        Objective.Builder builder = intent.objectives().get(i).copy();
        FlowObjectiveInstallationContext context = new FlowObjectiveInstallationContext();
        final Objective objective;
        switch(direction) {
            case ADD:
                objective = builder.add(context);
                break;
            case REMOVE:
                objective = builder.remove(context);
                break;
            default:
                throw new UnsupportedOperationException("Unsupported direction " + direction);
        }
        context.setObjective(objective, deviceId);
        contexts.add(context);
    }
    return contexts;
}
#method_after
private Set<? extends ObjectiveContext> buildObjectiveContexts(FlowObjectiveIntent intent, Direction direction) {
    Set<FlowObjectiveInstallationContext> contexts = Sets.newHashSet();
    int size = intent.objectives().size();
    List<Objective> objectives = intent.objectives();
    List<DeviceId> deviceIds = intent.devices();
    if (direction == Direction.ADD) {
        for (int i = 0; i < size; i++) {
            Objective objective = objectives.get(i);
            DeviceId deviceId = deviceIds.get(i);
            FlowObjectiveInstallationContext ctx = buildObjectiveContext(objective, deviceId, direction);
            contexts.add(ctx);
        }
        return contexts;
    } else {
        // basic idea is to chain objective contexts
        for (int i = 0; i < size; i++) {
            Objective objective = intent.objectives().get(i);
            DeviceId deviceId = intent.devices().get(i);
            if (objective instanceof FilteringObjective) {
                // don't need to care ordering of filtering objective
                FlowObjectiveInstallationContext ctx = buildObjectiveContext(objective, deviceId, direction);
                contexts.add(ctx);
            } else if (objective instanceof NextObjective) {
            // need to removed after forwarding objective
            // nothing to do here
            } else if (objective instanceof ForwardingObjective) {
                // forwarding objective, also find next objective if
                // exist
                FlowObjectiveInstallationContext fwdCtx = buildObjectiveContext(objective, deviceId, direction);
                ForwardingObjective fwd = (ForwardingObjective) objective;
                NextObjective nxt = null;
                Integer nextId = fwd.nextId();
                if (nextId != null) {
                    for (int j = 0; j < size; j++) {
                        if (objectives.get(j).id() == nextId) {
                            nxt = (NextObjective) objectives.get(j);
                            break;
                        }
                    }
                    // if a next objective exists in the Intent
                    if (nxt != null) {
                        FlowObjectiveInstallationContext nxtCtx = buildObjectiveContext(nxt, deviceId, direction);
                        fwdCtx.nextContext(nxtCtx);
                    }
                }
                contexts.add(fwdCtx);
            } else {
                // possible here?
                log.warn(UNSUPPORT_OBJ, objective);
            }
        }
    }
    return contexts;
}
#end_block

#method_before
@Override
void apply() {
    pendingContexts.addAll(contexts);
    contexts.forEach(objectiveContext -> flowObjectiveService.apply(objectiveContext.deviceId, objectiveContext.objective));
}
#method_after
@Override
void apply() {
    // pending contexts
    if (pendingContexts.isEmpty()) {
        pendingContexts.addAll(nextPendingContexts);
        nextPendingContexts.clear();
    }
    final Set<ObjectiveContext> contextsToApply = Sets.newHashSet(pendingContexts);
    contextsToApply.forEach(ctx -> {
        FlowObjectiveInstallationContext foiCtx = (FlowObjectiveInstallationContext) ctx;
        flowObjectiveService.apply(foiCtx.deviceId, foiCtx.objective);
    });
}
#end_block

#method_before
void setObjective(Objective objective, DeviceId deviceId) {
    this.objective = objective;
    this.deviceId = deviceId;
}
#method_after
void setObjective(Objective objective, DeviceId deviceId) {
    // init function
    this.objective = objective;
    this.deviceId = deviceId;
    this.error = null;
    this.retry = new AtomicInteger(0);
    this.nextContext = null;
}
#end_block

#method_before
@Override
public void onSuccess(Objective objective) {
    finish();
}
#method_after
@Override
public void onSuccess(Objective objective) {
    finished(null);
}
#end_block

#method_before
@Override
public void onError(Objective objective, ObjectiveError error) {
    this.error = error;
    errorContexts.add(this);
    finish();
}
#method_after
@Override
public void onError(Objective objective, ObjectiveError error) {
    finished(error);
}
#end_block

#method_before
@Override
protected void initNextGroupsMap() {
    nextGroupsMap = storageService.<NetworkId, ConcurrentMap<Integer, byte[]>>consistentMapBuilder().withName("onos-networkId-flowobjective-groups").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(NetworkId.class).build("DistributedVirtualFlowObjectiveStore"))).build();
}
#method_after
@Override
protected void initNextGroupsMap() {
    nextGroupsMap = storageService.<NetworkId, ConcurrentMap<Integer, byte[]>>consistentMapBuilder().withName(VNET_FLOW_OBJ_GROUP_MAP_NAME).withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(NetworkId.class).build(VNET_FLOW_OBJ_GROUP_MAP_FRIENDLYNAME))).build();
}
#end_block

#method_before
private void setupDistFlowObjectiveStore() throws TestUtils.TestUtilsException {
    distStore = new DistributedVirtualFlowObjectiveStore();
    TestUtils.setField(distStore, "storageService", storageService);
    distStore.activate();
    // super.setUp() will cause Distributed store to be used.
    flowObjectiveStore = distStore;
}
#method_after
private void setupDistFlowObjectiveStore() throws TestUtils.TestUtilsException {
    distStore = new DistributedVirtualFlowObjectiveStore();
    TestUtils.setField(distStore, STORE_FIELDNAME_STORAGESERVICE, storageService);
    distStore.activate();
    // super.setUp() will cause Distributed store to be used.
    flowObjectiveStore = distStore;
}
#end_block

#method_before
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    List<FlowRule> rules = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        rules.addAll(createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels));
    }
    return Collections.singletonList(new FlowRuleIntent(appId, intent.key(), rules, intent.resources(), PathIntent.ProtectionType.PRIMARY, intent.resourceGroup()));
}
#method_after
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    List<FlowRule> rules = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        rules.addAll(createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels));
    }
    return Collections.singletonList(new FlowRuleIntent(appId, intent.key(), rules, intent.resources()));
}
#end_block

#method_before
@Override
protected List<FlowRule> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> labels) {
    List<FlowRule> rules = new ArrayList<>(inPorts.size());
    /*
         * Looking for the encapsulation constraint
         */
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    inPorts.forEach(inport -> {
        ForwardingInstructions instructions = this.createForwardingInstruction(encapConstraint, intent, inport, outPorts, deviceId, labels);
        TrafficTreatment trafficTreatment = instructions.treatment();
        if (optimize) {
            trafficTreatment = compactActions(instructions.treatment());
        }
        if ((!encapConstraint.isPresent() || encapConstraint.get().encapType() == EncapsulationType.NONE) && !optimize) {
            trafficTreatment = fixTags(trafficTreatment, instructions.selector());
        }
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(instructions.selector()).withTreatment(trafficTreatment).withPriority(intent.priority()).fromApp(appId).makePermanent().build();
        rules.add(rule);
    });
    return rules;
}
#method_after
@Override
protected List<FlowRule> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> labels) {
    List<FlowRule> rules = new ArrayList<>(inPorts.size());
    /*
         * Looking for the encapsulation constraint
         */
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    inPorts.forEach(inport -> {
        ForwardingInstructions instructions = this.createForwardingInstruction(encapConstraint, intent, inport, outPorts, deviceId, labels);
        if (optimizeInstructions) {
            TrafficTreatment compactedTreatment = compactActions(instructions.treatment());
            instructions = new ForwardingInstructions(compactedTreatment, instructions.selector());
        }
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(instructions.selector()).withTreatment(instructions.treatment()).withPriority(intent.priority()).fromApp(appId).makePermanent().build();
        rules.add(rule);
    });
    return rules;
}
#end_block

#method_before
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    intentsToApply.stream().filter(x -> x instanceof FlowObjectiveIntent).flatMap(x -> buildObjectiveContext((FlowObjectiveIntent) x, direction).stream()).forEach(contexts::add);
}
#method_after
@Override
public void prepareIntents(List<Intent> intentsToApply, Direction direction) {
    intentsToApply.stream().filter(intent -> intent instanceof FlowObjectiveIntent).forEach(intent -> {
        buildObjectiveContexts((FlowObjectiveIntent) intent, direction);
    });
    pendingContexts.forEach(((deviceId, objectiveContexts) -> {
        objectiveContexts.forEach(contexts::add);
    }));
}
#end_block

#method_before
@Override
void apply() {
    pendingContexts.addAll(contexts);
    contexts.forEach(objectiveContext -> flowObjectiveService.apply(objectiveContext.deviceId, objectiveContext.objective));
}
#method_after
@Override
void apply() {
    // Installation for device can be parallel
    pendingContexts.forEach(((deviceId, objectiveContexts) -> {
        FlowObjectiveInstallationContext objectiveContext = (FlowObjectiveInstallationContext) objectiveContexts.poll();
        flowObjectiveService.apply(objectiveContext.deviceId, objectiveContext.objective);
    }));
}
#end_block

#method_before
private void finish() {
    synchronized (pendingContexts) {
        pendingContexts.remove(this);
        if (pendingContexts.isEmpty()) {
            if (errorContexts.isEmpty()) {
                successConsumer.accept(FlowObjectiveOperationContext.this);
            } else {
                errorConsumer.accept(FlowObjectiveOperationContext.this);
            }
        }
    }
}
#method_after
private void finish() {
    synchronized (pendingContexts) {
        if (pendingContexts.isEmpty()) {
            if (errorContexts.isEmpty()) {
                successConsumer.accept(FlowObjectiveOperationContext.this);
            } else {
                errorConsumer.accept(FlowObjectiveOperationContext.this);
            }
        } else {
            DeviceId deviceId = this.deviceId;
            Queue<ObjectiveContext> contexts = pendingContexts.get(deviceId);
            FlowObjectiveInstallationContext context = (FlowObjectiveInstallationContext) contexts.poll();
            flowObjectiveService.apply(context.deviceId, context.objective);
            // completed.
            if (contexts.isEmpty()) {
                pendingContexts.remove(deviceId);
            }
        }
    }
}
#end_block

#method_before
@Override
public void handleIncomingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = getDeviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REQUEST:
            log.warn("LISP mapping query feature will be added when " + "provider service supports it.");
            break;
        case LISP_MAP_REGISTER:
            LispMapRegister register = (LispMapRegister) msg;
            processMappings(deviceId, register.getMapRecords(), MAP_DATABASE);
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleIncomingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        log.warn("provider service has not been initialized");
        return;
    }
    DeviceId deviceId = getDeviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REQUEST:
            log.warn("LISP mapping query feature will be added when " + "provider service supports it.");
            break;
        case LISP_MAP_REGISTER:
            LispMapRegister register = (LispMapRegister) msg;
            processMappings(deviceId, register.getMapRecords(), MAP_DATABASE);
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
@Override
public void handleOutgoingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = getDeviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REPLY:
            LispMapReply reply = (LispMapReply) msg;
            processMappings(deviceId, reply.getMapRecords(), MAP_CACHE);
            break;
        case LISP_MAP_NOTIFY:
            LispMapNotify notify = (LispMapNotify) msg;
            processMappings(deviceId, notify.getMapRecords(), MAP_DATABASE);
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleOutgoingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        log.warn("provider service has not been initialized");
        return;
    }
    DeviceId deviceId = getDeviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REPLY:
            LispMapReply reply = (LispMapReply) msg;
            processMappings(deviceId, reply.getMapRecords(), MAP_CACHE);
            break;
        case LISP_MAP_NOTIFY:
            LispMapNotify notify = (LispMapNotify) msg;
            processMappings(deviceId, notify.getMapRecords(), MAP_DATABASE);
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    Device device = event.subject();
    return POSTIVE_DEVICE_EVENT.contains(event.type()) && device.is(FlowRuleProgrammable.class);
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    Device device = event.subject();
    return POSITIVE_DEVICE_EVENT.contains(event.type()) && device.is(FlowRuleProgrammable.class);
}
#end_block

#method_before
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        int connectTimeout = NetconfControllerImpl.netconfConnectTimeout;
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device" + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#method_after
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        int connectTimeout = NetconfControllerImpl.netconfConnectTimeout;
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device " + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKeyFile() != null && deviceInfo.getKeyFile().canRead()) {
                log.debug("Authenticating with key file to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKeyFile(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#end_block

#method_before
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl());
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session.", e);
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#method_after
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl(), replies);
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session {} ", e.getMessage());
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#end_block

#method_before
@Beta
private void startSubscriptionConnection(String filterSchema) throws NetconfException {
    if (!serverCapabilities.contains(INTERLEAVE_CAPABILITY_STRING)) {
        throw new NetconfException("Device" + deviceInfo + "does not support interleave");
    }
    String reply = sendRequest(createSubscriptionString(filterSchema));
    if (!checkReply(reply)) {
        throw new NetconfException("Subscription not successful with device " + deviceInfo + " with reply " + reply);
    }
    subscriptionConnected = true;
}
#method_after
@Beta
private void startSubscriptionConnection(String filterSchema) throws NetconfException {
    if (!deviceCapabilities.contains(INTERLEAVE_CAPABILITY_STRING)) {
        throw new NetconfException("Device" + deviceInfo + "does not support interleave");
    }
    String reply = sendRequest(createSubscriptionString(filterSchema));
    if (!checkReply(reply)) {
        throw new NetconfException("Subscription not successful with device " + deviceInfo + " with reply " + reply);
    }
    subscriptionConnected = true;
}
#end_block

#method_before
@Beta
@Override
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#method_after
@Beta
@Override
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        notificationFilterSchema = filterSchema;
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#end_block

#method_before
private void sendHello() throws NetconfException {
    serverHelloResponseOld = sendRequest(createHelloString());
    Matcher capabilityMatcher = Pattern.compile(CAPABILITY_REGEX_PATTERN).matcher(serverHelloResponseOld);
    while (capabilityMatcher.find()) {
        serverCapabilities.add(capabilityMatcher.group(1));
    }
    sessionID = String.valueOf(-1);
    Matcher sessionIDMatcher = Pattern.compile(SESSION_ID_REGEX_PATTERN).matcher(serverHelloResponseOld);
    if (sessionIDMatcher.find()) {
        sessionID = sessionIDMatcher.group(1);
    }
}
#method_after
private void sendHello() throws NetconfException {
    serverHelloResponseOld = sendRequest(createHelloString());
    Matcher capabilityMatcher = CAPABILITY_REGEX_PATTERN.matcher(serverHelloResponseOld);
    while (capabilityMatcher.find()) {
        deviceCapabilities.add(capabilityMatcher.group(1));
    }
    sessionID = String.valueOf(-1);
    Matcher sessionIDMatcher = SESSION_ID_REGEX_PATTERN.matcher(serverHelloResponseOld);
    if (sessionIDMatcher.find()) {
        sessionID = sessionIDMatcher.group(1);
    } else {
        throw new NetconfException("Missing SessionID in server hello " + "reponse.");
    }
}
#end_block

#method_before
@Override
public CompletableFuture<String> request(String request) {
    CompletableFuture<String> ftrep = streamHandler.sendMessage(request);
    replies.put(messageIdInteger.get(), ftrep);
    return ftrep;
}
#method_after
@Override
@Deprecated
public CompletableFuture<String> request(String request) {
    return streamHandler.sendMessage(request);
}
#end_block

#method_before
@Override
public CompletableFuture<String> request(String request) {
    CompletableFuture<String> ftrep = streamHandler.sendMessage(request);
    replies.put(messageIdInteger.get(), ftrep);
    return ftrep;
}
#method_after
private CompletableFuture<String> request(String request, int messageId) {
    return streamHandler.sendMessage(request, messageId);
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndRestablishSession();
    request = formatRequestMessageId(request);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request);
    messageIdInteger.incrementAndGet();
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request) throws NetconfException {
    checkAndReestablish();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
private String formatRequestMessageId(String request) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provieds his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageIdInteger.get() + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageIdInteger.get() + "\"" + ">");
    }
    return request;
}
#method_after
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    return request;
}
#end_block

#method_before
@Override
public String getConfig(String targetConfiguration, String configurationSchema) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc ");
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append("xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<get-config>\n");
    rpc.append("<source>\n");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</source>");
    if (configurationSchema != null) {
        rpc.append("<filter type=\"subtree\">\n");
        rpc.append(configurationSchema).append("\n");
        rpc.append("</filter>\n");
    }
    rpc.append("</get-config>\n");
    rpc.append("</rpc>\n");
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    return checkReply(reply) ? reply : "ERROR " + reply;
}
#method_after
@Override
public String getConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    return getConfig(netconfTargetConfig, null);
}
#end_block

#method_before
@Override
public String getConfig(String targetConfiguration) throws NetconfException {
    return getConfig(targetConfiguration, null);
}
#method_after
@Override
public String getConfig(String netconfTargetConfig) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfig(netconfTargetConfig));
}
#end_block

#method_before
@Override
public String getConfig(String targetConfiguration, String configurationSchema) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc ");
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append("xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<get-config>\n");
    rpc.append("<source>\n");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</source>");
    if (configurationSchema != null) {
        rpc.append("<filter type=\"subtree\">\n");
        rpc.append(configurationSchema).append("\n");
        rpc.append("</filter>\n");
    }
    rpc.append("</get-config>\n");
    rpc.append("</rpc>\n");
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    return checkReply(reply) ? reply : "ERROR " + reply;
}
#method_after
@Override
public String getConfig(String netconfTargetConfig, String configurationFilterSchema) throws NetconfException {
    return getConfig(TargetConfig.toTargetConfig(netconfTargetConfig), configurationFilterSchema);
}
#end_block

#method_before
@Override
public boolean editConfig(String targetConfiguration, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#method_after
@Override
public boolean editConfig(String netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    return editConfig(TargetConfig.toTargetConfig(netconfTargetConfig), mode, newConfiguration);
}
#end_block

#method_before
@Override
public boolean editConfig(String targetConfiguration, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#method_after
@Override
public boolean editConfig(TargetConfig netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#end_block

#method_before
@Override
public boolean copyConfig(String targetConfiguration, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<config>")) {
        newConfiguration = "<config>" + newConfiguration + "</config>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append(newConfiguration);
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean copyConfig(String netconfTargetConfig, String newConfiguration) throws NetconfException {
    return copyConfig(TargetConfig.toTargetConfig(netconfTargetConfig), newConfiguration);
}
#end_block

#method_before
@Override
public boolean copyConfig(String targetConfiguration, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<config>")) {
        newConfiguration = "<config>" + newConfiguration + "</config>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append(newConfiguration);
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean copyConfig(TargetConfig netconfTargetConfig, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<config>")) {
        newConfiguration = "<config>" + newConfiguration + "</config>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append(newConfiguration);
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#end_block

#method_before
@Override
public boolean deleteConfig(String targetConfiguration) throws NetconfException {
    if (targetConfiguration.equals("running")) {
        log.warn("Target configuration for delete operation can't be \"running\"", targetConfiguration);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean deleteConfig(String netconfTargetConfig) throws NetconfException {
    return deleteConfig(TargetConfig.toTargetConfig(netconfTargetConfig));
}
#end_block

#method_before
@Override
public boolean deleteConfig(String targetConfiguration) throws NetconfException {
    if (targetConfiguration.equals("running")) {
        log.warn("Target configuration for delete operation can't be \"running\"", targetConfiguration);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean deleteConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    if (netconfTargetConfig.equals(TargetConfig.RUNNING)) {
        log.warn("Target configuration for delete operation can't be \"running\"", netconfTargetConfig);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#end_block

#method_before
public HashSet<String> getDeviceCapabilitiesSet() {
    return serverCapabilities;
}
#method_after
@Override
public Set<String> getDeviceCapabilitiesSet() {
    return Collections.unmodifiableSet(deviceCapabilities);
}
#end_block

#method_before
@Deprecated
public String getServerCapabilities() {
    return serverHelloResponseOld;
}
#method_after
@Deprecated
@Override
public String getServerCapabilities() {
    return serverHelloResponseOld;
}
#end_block

#method_before
public void setOnosCapabilities(List<String> capabilities) {
    onosCapabilities = capabilities;
}
#method_after
@Override
public void setOnosCapabilities(Iterable<String> capabilities) {
    onosCapabilities = capabilities;
}
#end_block

#method_before
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    if (completedReply != null) {
        completedReply.complete(event.getMessagePayload());
    }
}
#method_after
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    log.debug("messageID {}, waiting replies messageIDs {}", messageId, replies.keySet());
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    if (completedReply != null) {
        completedReply.complete(event.getMessagePayload());
    }
}
#end_block

#method_before
// =======================================================================
private Highlights protectedIntentHighlights() {
    Highlights highlights = new Highlights();
    TrafficLinkMap linkMap = new TrafficLinkMap();
    if (selectedIntent != null) {
        List<Intent> installables = servicesBundle.intentService().getInstallableIntents(selectedIntent.key());
        if (installables != null) {
            ProtectionEndpointIntent ep1 = installables.stream().filter(ProtectionEndpointIntent.class::isInstance).map(ProtectionEndpointIntent.class::cast).findFirst().orElse(null);
            ProtectionEndpointIntent ep2 = installables.stream().filter(ii -> !ii.equals(ep1)).filter(ProtectionEndpointIntent.class::isInstance).map(ProtectionEndpointIntent.class::cast).findFirst().orElse(null);
            if (ep1 == null || ep2 == null) {
                log.warn("Selected Intent {} didn't have 2 protection endpoints", selectedIntent.key());
                stopMonitoring();
                return highlights;
            }
            Set<Link> primary = new LinkedHashSet<>();
            Set<Link> backup = new LinkedHashSet<>();
            Map<Boolean, List<FlowRuleIntent>> transits = installables.stream().filter(FlowRuleIntent.class::isInstance).map(FlowRuleIntent.class::cast).collect(Collectors.groupingBy(this::isPrimary));
            // walk primary
            ConnectPoint primHead = ep1.description().paths().get(0).output().connectPoint();
            ConnectPoint primTail = ep2.description().paths().get(0).output().connectPoint();
            List<FlowRuleIntent> primTransit = transits.getOrDefault(true, ImmutableList.of());
            populateLinks(primary, primHead, primTail, primTransit);
            // walk backup
            ConnectPoint backHead = ep1.description().paths().get(1).output().connectPoint();
            ConnectPoint backTail = ep2.description().paths().get(1).output().connectPoint();
            List<FlowRuleIntent> backTransit = transits.getOrDefault(false, ImmutableList.of());
            populateLinks(backup, backHead, backTail, backTransit);
            servicesBundle.intentService().getIntents().forEach(intent -> {
                // We are adding all optical intents?!
                if (intent instanceof OpticalConnectivityIntent) {
                    OpticalConnectivityIntent ocIntent = (OpticalConnectivityIntent) intent;
                    Collection<Intent> ocInstallables = servicesBundle.intentService().getInstallableIntents(ocIntent.key());
                    if (intent.id().fingerprint() == 0x1) {
                        if (!usingBackup(primary)) {
                            primary.addAll(servicesBundle.linkService().getDeviceIngressLinks(ocIntent.getSrc().deviceId()).stream().filter(i -> servicesBundle.deviceService().getDevice(i.src().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                            primary.addAll(servicesBundle.linkService().getDeviceEgressLinks(ocIntent.getDst().deviceId()).stream().filter(e -> servicesBundle.deviceService().getDevice(e.dst().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                            ocInstallables.forEach(i -> {
                                if (i instanceof FlowRuleIntent) {
                                    FlowRuleIntent fr = (FlowRuleIntent) i;
                                    primary.addAll(linkResources(fr));
                                }
                            });
                        }
                    } else {
                        backup.addAll(servicesBundle.linkService().getDeviceIngressLinks(ocIntent.getSrc().deviceId()).stream().filter(i -> servicesBundle.deviceService().getDevice(i.src().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                        backup.addAll(servicesBundle.linkService().getDeviceEgressLinks(ocIntent.getDst().deviceId()).stream().filter(e -> servicesBundle.deviceService().getDevice(e.dst().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                        ocInstallables.forEach(i -> {
                            if (i instanceof FlowRuleIntent) {
                                FlowRuleIntent fr = (FlowRuleIntent) i;
                                backup.addAll(linkResources(fr));
                            }
                        });
                    }
                }
            });
            boolean isOptical = selectedIntent instanceof OpticalConnectivityIntent;
            // Flavor is swapped so green is primary path.
            if (usingBackup(primary)) {
                // the backup becomes in use so we have a dotted line
                processLinks(linkMap, backup, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, PROTECTED_MOD_BACKUP_SET);
            } else {
                processLinks(linkMap, primary, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, PROTECTED_MOD_PRIMARY_SET);
                processLinks(linkMap, backup, Flavor.SECONDARY_HIGHLIGHT, isOptical, false, PROTECTED_MOD_BACKUP_SET);
            }
            updateHighlights(highlights, primary);
            updateHighlights(highlights, backup);
            colorLinks(highlights, linkMap);
            highlights.subdueAllElse(Highlights.Amount.MINIMALLY);
        } else {
            log.debug("Selected Intent has no installables intents");
        }
    } else {
        log.debug("Selected Intent is null");
    }
    return highlights;
}
#method_after
// =======================================================================
private Highlights protectedIntentHighlights() {
    Highlights highlights = new Highlights();
    TrafficLinkMap linkMap = new TrafficLinkMap();
    IntentService intentService = servicesBundle.intentService();
    if (selectedIntent != null) {
        List<Intent> installables = intentService.getInstallableIntents(selectedIntent.key());
        if (installables != null) {
            ProtectionEndpointIntent ep1 = installables.stream().filter(ProtectionEndpointIntent.class::isInstance).map(ProtectionEndpointIntent.class::cast).findFirst().orElse(null);
            ProtectionEndpointIntent ep2 = installables.stream().filter(ii -> !ii.equals(ep1)).filter(ProtectionEndpointIntent.class::isInstance).map(ProtectionEndpointIntent.class::cast).findFirst().orElse(null);
            if (ep1 == null || ep2 == null) {
                log.warn("Selected Intent {} didn't have 2 protection endpoints", selectedIntent.key());
                stopMonitoring();
                return highlights;
            }
            Set<Link> primary = new LinkedHashSet<>();
            Set<Link> backup = new LinkedHashSet<>();
            Map<Boolean, List<FlowRuleIntent>> transits = installables.stream().filter(FlowRuleIntent.class::isInstance).map(FlowRuleIntent.class::cast).collect(Collectors.groupingBy(this::isPrimary));
            // walk primary
            ConnectPoint primHead = ep1.description().paths().get(0).output().connectPoint();
            ConnectPoint primTail = ep2.description().paths().get(0).output().connectPoint();
            List<FlowRuleIntent> primTransit = transits.getOrDefault(true, ImmutableList.of());
            populateLinks(primary, primHead, primTail, primTransit);
            // walk backup
            ConnectPoint backHead = ep1.description().paths().get(1).output().connectPoint();
            ConnectPoint backTail = ep2.description().paths().get(1).output().connectPoint();
            List<FlowRuleIntent> backTransit = transits.getOrDefault(false, ImmutableList.of());
            populateLinks(backup, backHead, backTail, backTransit);
            // Add packet to optical links
            if (!usingBackup(primary)) {
                primary.addAll(protectedIntentMultiLayer(primHead, primTail));
            }
            backup.addAll(protectedIntentMultiLayer(backHead, backTail));
            boolean isOptical = selectedIntent instanceof OpticalConnectivityIntent;
            // Flavor is swapped so green is primary path.
            if (usingBackup(primary)) {
                // the backup becomes in use so we have a dotted line
                processLinks(linkMap, backup, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, PROTECTED_MOD_BACKUP_SET);
            } else {
                processLinks(linkMap, primary, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, PROTECTED_MOD_PRIMARY_SET);
                processLinks(linkMap, backup, Flavor.SECONDARY_HIGHLIGHT, isOptical, false, PROTECTED_MOD_BACKUP_SET);
            }
            updateHighlights(highlights, primary);
            updateHighlights(highlights, backup);
            colorLinks(highlights, linkMap);
            highlights.subdueAllElse(Highlights.Amount.MINIMALLY);
        } else {
            log.debug("Selected Intent has no installable intents");
        }
    } else {
        log.debug("Selected Intent is null");
    }
    return highlights;
}
#end_block

#method_before
private void createTrafficLinks(Highlights highlights, TrafficLinkMap linkMap, Set<Intent> intents, Flavor flavor, boolean showTraffic) {
    for (Intent intent : intents) {
        Collection<Link> l = new ArrayList<>();
        List<Intent> installables = servicesBundle.intentService().getInstallableIntents(intent.key());
        Iterable<Link> links = null;
        if (installables != null) {
            for (Intent installable : installables) {
                if (installable instanceof PathIntent) {
                    links = ((PathIntent) installable).path().links();
                } else if (installable instanceof FlowRuleIntent) {
                    l.addAll(linkResources(installable));
                    // can we add circuit intent here also? possibly recreate the packet-to-optical links
                    if (intent instanceof OpticalConnectivityIntent) {
                        OpticalConnectivityIntent ocIntent = (OpticalConnectivityIntent) intent;
                        l.addAll(servicesBundle.linkService().getDeviceIngressLinks(ocIntent.getSrc().deviceId()).stream().filter(i -> servicesBundle.deviceService().getDevice(i.src().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                        l.addAll(servicesBundle.linkService().getDeviceEgressLinks(ocIntent.getDst().deviceId()).stream().filter(e -> servicesBundle.deviceService().getDevice(e.dst().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                    }
                    links = l;
                // links = linkResources(installable);
                // links = addEdgeLinksIfNeeded(intent, linkResources(installable));
                } else if (installable instanceof FlowObjectiveIntent) {
                    links = addEdgeLinksIfNeeded(intent, linkResources(installable));
                } else if (installable instanceof LinkCollectionIntent) {
                    links = ((LinkCollectionIntent) installable).links();
                } else if (installable instanceof OpticalPathIntent) {
                    links = ((OpticalPathIntent) installable).path().links();
                }
                boolean isOptical = intent instanceof OpticalConnectivityIntent;
                processLinks(linkMap, links, flavor, isOptical, showTraffic);
                updateHighlights(highlights, links);
            }
        }
    }
}
#method_after
private void createTrafficLinks(Highlights highlights, TrafficLinkMap linkMap, Set<Intent> intents, Flavor flavor, boolean showTraffic) {
    for (Intent intent : intents) {
        List<Intent> installables = servicesBundle.intentService().getInstallableIntents(intent.key());
        Iterable<Link> links = null;
        if (installables != null) {
            for (Intent installable : installables) {
                if (installable instanceof PathIntent) {
                    links = ((PathIntent) installable).path().links();
                } else if (installable instanceof FlowRuleIntent) {
                    Collection<Link> l = new ArrayList<>();
                    l.addAll(linkResources(installable));
                    // Add cross connect links
                    if (intent instanceof OpticalConnectivityIntent) {
                        OpticalConnectivityIntent ocIntent = (OpticalConnectivityIntent) intent;
                        LinkService linkService = servicesBundle.linkService();
                        DeviceService deviceService = servicesBundle.deviceService();
                        l.addAll(linkService.getDeviceIngressLinks(ocIntent.getSrc().deviceId()).stream().filter(i -> deviceService.getDevice(i.src().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                        l.addAll(linkService.getDeviceEgressLinks(ocIntent.getDst().deviceId()).stream().filter(e -> deviceService.getDevice(e.dst().deviceId()).type() == Device.Type.SWITCH).collect(Collectors.toList()));
                    }
                    links = l;
                } else if (installable instanceof FlowObjectiveIntent) {
                    links = addEdgeLinksIfNeeded(intent, linkResources(installable));
                } else if (installable instanceof LinkCollectionIntent) {
                    links = ((LinkCollectionIntent) installable).links();
                } else if (installable instanceof OpticalPathIntent) {
                    links = ((OpticalPathIntent) installable).path().links();
                }
                boolean isOptical = intent instanceof OpticalConnectivityIntent;
                processLinks(linkMap, links, flavor, isOptical, showTraffic);
                updateHighlights(highlights, links);
            }
        }
    }
}
#end_block

#method_before
@Override
public OpticalConnectivityId setupConnectivity(ConnectPoint ingress, ConnectPoint egress, Bandwidth bandwidth, Duration latency) {
    checkNotNull(ingress);
    checkNotNull(egress);
    log.info("setupConnectivity({}, {}, {}, {})", ingress, egress, bandwidth, latency);
    bandwidth = (bandwidth == null) ? NO_BW_REQUIREMENT : bandwidth;
    Set<Path> paths = pathService.getPaths(ingress.deviceId(), egress.deviceId(), new BandwidthLinkWeight(bandwidth));
    if (paths.isEmpty()) {
        log.warn("Unable to find multi-layer path.");
        return null;
    }
    // Search path with available cross connect points
    for (Path path : paths) {
        OpticalConnectivityId id = setupPath(path, bandwidth, latency);
        if (id != null) {
            log.info("Assigned OpticalConnectivityId: {}", id);
            return id;
        }
    }
    log.error("setupConnectivity({}, {}, {}, {}) failed.", ingress, egress, bandwidth, latency);
    return null;
}
#method_after
@Override
public OpticalConnectivityId setupConnectivity(ConnectPoint ingress, ConnectPoint egress, Bandwidth bandwidth, Duration latency) {
    checkNotNull(ingress);
    checkNotNull(egress);
    log.info("setupConnectivity({}, {}, {}, {})", ingress, egress, bandwidth, latency);
    bandwidth = (bandwidth == null) ? NO_BW_REQUIREMENT : bandwidth;
    Set<Path> paths = pathService.getPaths(ingress.deviceId(), egress.deviceId(), new BandwidthLinkWeight(bandwidth));
    if (paths.isEmpty()) {
        log.warn("Unable to find multi-layer path.");
        return null;
    }
    // Search path with available cross connect points
    for (Path path : paths) {
        // Path service calculates from node to node, we're only interested in port to port
        if (!path.src().equals(ingress) || !path.dst().equals(egress)) {
            continue;
        }
        OpticalConnectivityId id = setupPath(path, bandwidth, latency);
        if (id != null) {
            log.info("Assigned OpticalConnectivityId: {}", id);
            return id;
        }
    }
    log.error("setupConnectivity({}, {}, {}, {}) failed.", ingress, egress, bandwidth, latency);
    return null;
}
#end_block

#method_before
private boolean linkDiscoveryEnabled(ConnectPoint cp) {
    // only expect OF device to have link discovery.
    return cp.deviceId().uri().getScheme().equals("of");
}
#method_after
private boolean linkDiscoveryEnabled(ConnectPoint cp) {
    // only expect OF device to have link discovery.
    return "of".equals(cp.deviceId().uri().getScheme());
}
#end_block

#method_before
@Override
public double weight(TopologyEdge edge) {
    Link l = edge.link();
    // Avoid inactive links
    if (l.state() == Link.State.INACTIVE) {
        log.trace("{} is not active", l);
        return -1.0;
    }
    // Avoid cross connect links with used ports
    if (isCrossConnectLink(l) && usedCrossConnectLinkSet.contains(l)) {
        log.trace("Cross connect {} in use", l);
        return -1.0;
    }
    // Check availability of bandwidth
    if (bandwidth != null && !NO_BW_REQUIREMENT.equals(bandwidth)) {
        if (hasEnoughBandwidth(l.src()) && hasEnoughBandwidth(l.dst())) {
            return 1.0;
        } else {
            log.trace("Not enough bandwidth on {}", l);
            return -1.0;
        }
    } else {
        // TODO needs to differentiate optical and packet?
        if (l.type() == Link.Type.OPTICAL) {
            // Transport links
            return 1.0;
        } else {
            // Packet links
            return -1.0;
        }
    }
}
#method_after
@Override
public double weight(TopologyEdge edge) {
    Link l = edge.link();
    // Avoid inactive links
    if (l.state() == Link.State.INACTIVE) {
        log.trace("{} is not active", l);
        return -1.0;
    }
    // Avoid cross connect links with used ports
    if (isCrossConnectLink(l) && usedCrossConnectLinkSet.contains(l)) {
        log.trace("Cross connect {} in use", l);
        return -1.0;
    }
    // Check availability of bandwidth
    if (bandwidth != null && !NO_BW_REQUIREMENT.equals(bandwidth)) {
        if (hasEnoughBandwidth(l.src()) && hasEnoughBandwidth(l.dst())) {
            return 1.0;
        } else {
            log.trace("Not enough bandwidth on {}", l);
            return -1.0;
        }
    } else {
        // Use everything except our own indirect links
        if (l.type() == Link.Type.INDIRECT) {
            return -1.0;
        } else {
            return 1.0;
        }
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    active = true;
    componentConfigService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    appId = coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.addListener(cfgListener);
    controller.addDeviceListener(innerNodeListener);
    deviceService.addListener(deviceListener);
    executor.execute(NetconfDeviceProvider.this::connectDevices);
    modified(context);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    active = true;
    componentConfigService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    appId = coreService.registerApplication(APP_NAME);
    factories.forEach(cfgService::registerConfigFactory);
    cfgService.addListener(cfgListener);
    controller.addDeviceListener(innerNodeListener);
    deviceService.addListener(deviceListener);
    translateConfig();
    executor.execute(NetconfDeviceProvider.this::connectDevices);
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    componentConfigService.unregisterProperties(getClass(), false);
    deviceService.removeListener(deviceListener);
    active = false;
    controller.getNetconfDevices().forEach(id -> {
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(id.toString()));
        controller.disconnectDevice(id, true);
    });
    controller.removeDeviceListener(innerNodeListener);
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    scheduledTask.cancel(true);
    executor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    componentConfigService.unregisterProperties(getClass(), false);
    deviceService.removeListener(deviceListener);
    active = false;
    controller.getNetconfDevices().forEach(id -> {
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(id.toString()));
        controller.disconnectDevice(id, true);
    });
    controller.removeDeviceListener(innerNodeListener);
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    providerService = null;
    factories.forEach(cfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    executor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
private void connectDevices() {
    Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, NetconfDeviceConfig.class);
    deviceSubjects.forEach(deviceId -> {
        NetconfDeviceConfig config = cfgService.getConfig(deviceId, NetconfDeviceConfig.class);
        DeviceDescription deviceDescription = createDeviceRepresentation(deviceId, config);
        log.info("Connecting NETCONF device {}, on {}:{} with username {}", deviceId, config.ip(), config.port(), config.username());
        storeDeviceKey(config, deviceId);
        if (deviceService.getDevice(deviceId) == null) {
            providerService.deviceConnected(deviceId, deviceDescription);
        }
        try {
            checkAndUpdateDevice(deviceId, deviceDescription);
        } catch (Exception e) {
            log.error("Unhandled exception checking {}", deviceId, e);
        }
    });
}
#method_after
private void connectDevices() {
    Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, NetconfDeviceConfig.class);
    deviceSubjects.forEach(deviceId -> {
        NetconfDeviceConfig config = cfgService.getConfig(deviceId, NetconfDeviceConfig.class);
        DeviceDescription deviceDescription = createDeviceRepresentation(deviceId, config);
        log.debug("Connecting NETCONF device {}, on {}:{} with username {}", deviceId, config.ip(), config.port(), config.username());
        storeDeviceKey(config.sshKey(), config.username(), config.password(), deviceId);
        if (deviceService.getDevice(deviceId) == null) {
            providerService.deviceConnected(deviceId, deviceDescription);
        }
        try {
            checkAndUpdateDevice(deviceId, deviceDescription);
        } catch (Exception e) {
            log.error("Unhandled exception checking {}", deviceId, e);
        }
    });
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.warn("Device {} has not been added to store, " + "since it's not reachable", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    } else if (updatedDeviceDescription == null) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
                    }
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {} " + "using DefaultDeviceDescription", deviceId);
                providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        } else if (isReachable && deviceService.isAvailable(deviceId)) {
            updatePortStatistics(device);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.warn("Device {} has not been added to store, " + "since it's not reachable", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    } else if (updatedDeviceDescription == null) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
                    }
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {} " + "using DefaultDeviceDescription", deviceId);
                providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        } else if (isReachable && deviceService.isAvailable(deviceId) && mastershipService.isLocalMaster(deviceId)) {
            updatePortStatistics(device);
        }
    }
}
#end_block

#method_before
private void updatePortStatistics(Device device) {
    if (device.is(PortStatisticsDiscovery.class)) {
        PortStatisticsDiscovery d = device.as(PortStatisticsDiscovery.class);
        providerService.updatePortStatistics(device.id(), d.discoverPortStatistics());
    } else {
        log.warn("No port statistics getter behaviour for device {}", device.id());
    }
}
#method_after
private void updatePortStatistics(Device device) {
    if (device.is(PortStatisticsDiscovery.class)) {
        PortStatisticsDiscovery d = device.as(PortStatisticsDiscovery.class);
        Collection<PortStatistics> portStatistics = d.discoverPortStatistics();
        if (portStatistics != null) {
            providerService.updatePortStatistics(device.id(), portStatistics);
        }
    } else {
        log.warn("No port statistics getter behaviour for device {}", device.id());
    }
}
#end_block

#method_before
private void checkAndUpdateDevices() {
    Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, NetconfDeviceConfig.class);
    deviceSubjects.forEach(deviceId -> {
        NetconfDeviceConfig config = cfgService.getConfig(deviceId, NetconfDeviceConfig.class);
        DeviceDescription deviceDescription = createDeviceRepresentation(deviceId, config);
        storeDeviceKey(config, deviceId);
        checkAndUpdateDevice(deviceId, deviceDescription);
    });
}
#method_after
private void checkAndUpdateDevices() {
    Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, NetconfDeviceConfig.class);
    deviceSubjects.forEach(deviceId -> {
        NetconfDeviceConfig config = cfgService.getConfig(deviceId, NetconfDeviceConfig.class);
        DeviceDescription deviceDescription = createDeviceRepresentation(deviceId, config);
        storeDeviceKey(config.sshKey(), config.username(), config.password(), deviceId);
        checkAndUpdateDevice(deviceId, deviceDescription);
    });
}
#end_block

#method_before
private void storeDeviceKey(NetconfDeviceConfig config, DeviceId deviceId) {
    if (config.sshKey().equals("")) {
        deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingUsernamePassword(DeviceKeyId.deviceKeyId(deviceId.toString()), null, config.username(), config.password()));
    } else {
        deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingSshKey(DeviceKeyId.deviceKeyId(deviceId.toString()), null, config.username(), config.password(), config.sshKey()));
    }
}
#method_after
private void storeDeviceKey(String sshKey, String username, String password, DeviceId deviceId) {
    if (sshKey.equals("")) {
        deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingUsernamePassword(DeviceKeyId.deviceKeyId(deviceId.toString()), null, username, password));
    } else {
        deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingSshKey(DeviceKeyId.deviceKeyId(deviceId.toString()), null, username, password, sshKey));
    }
}
#end_block

#method_before
private void initiateConnection(DeviceId deviceId, MastershipRole newRole) {
    try {
        if (isReachable(deviceId)) {
            controller.connectDevice(deviceId);
            providerService.receivedRoleReply(deviceId, newRole, MastershipRole.MASTER);
        }
    } catch (Exception e) {
        if (deviceService.getDevice(deviceId) != null) {
            providerService.deviceDisconnected(deviceId);
        }
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
        throw new RuntimeException(new NetconfException("Can't connect to NETCONF " + "device on " + deviceId + ":" + deviceId, e));
    }
}
#method_after
private void initiateConnection(DeviceId deviceId, MastershipRole newRole) {
    try {
        if (isReachable(deviceId)) {
            controller.connectDevice(deviceId);
            providerService.receivedRoleReply(deviceId, newRole, MastershipRole.MASTER);
        }
    } catch (Exception e) {
        if (deviceService.getDevice(deviceId) != null) {
            providerService.deviceDisconnected(deviceId);
        }
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
        throw new RuntimeException(new NetconfException("Can't connect to NETCONF device " + deviceId, e));
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    executor.execute(NetconfDeviceProvider.this::connectDevices);
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass().equals(NetconfDeviceConfig.class)) {
        executor.execute(NetconfDeviceProvider.this::connectDevices);
    } else {
        log.warn("Injecting device via this Json is deprecated, " + "please put configuration under devices/ as shown in the wiki");
        translateConfig();
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    return event.configClass().equals(NetconfDeviceConfig.class) && (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED);
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    return (event.configClass().equals(NetconfDeviceConfig.class) || event.configClass().equals(NetconfProviderConfig.class)) && (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED);
}
#end_block

#method_before
@Before
public void setUp() throws IOException {
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(appId).anyTimes();
    replay(coreService);
    provider.coreService = coreService;
    provider.providerRegistry = deviceRegistry;
    provider.mastershipService = mastershipService;
    provider.deviceService = deviceService;
    provider.cfgService = cfgService;
    provider.controller = controller;
    provider.deviceKeyAdminService = deviceKeyAdminService;
    provider.componentConfigService = new ComponentConfigAdapter();
    AbstractProjectableModel.setDriverService(null, new DriverServiceAdapter());
    provider.activate(null);
    DeviceId subject = DeviceId.deviceId(NETCONF_DEVICE_ID_STRING);
    String key = "netconf";
    ObjectMapper mapper = new ObjectMapper();
    JsonNode jsonNode = mapper.readTree(jsonStream);
    ConfigApplyDelegate delegate = new MockDelegate();
    netconfDeviceConfig.init(subject, key, jsonNode, mapper, delegate);
    JsonNode jsonNodesshKey = mapper.readTree(jsonStreamSshKey);
    netconfDeviceConfigSshKey.init(subject, key, jsonNodesshKey, mapper, delegate);
}
#method_after
@Before
public void setUp() throws IOException {
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(appId).anyTimes();
    replay(coreService);
    provider.coreService = coreService;
    provider.providerRegistry = deviceRegistry;
    provider.mastershipService = mastershipService;
    provider.deviceService = deviceService;
    provider.cfgService = cfgService;
    provider.controller = controller;
    provider.deviceKeyAdminService = deviceKeyAdminService;
    provider.componentConfigService = new ComponentConfigAdapter();
    AbstractProjectableModel.setDriverService(null, new DriverServiceAdapter());
    provider.activate(null);
    devices.clear();
    available = false;
    firstRequest = true;
    DeviceId subject = DeviceId.deviceId(NETCONF_DEVICE_ID_STRING);
    DeviceId subjectIpv6 = DeviceId.deviceId(NETCONF_DEVICE_ID_STRING_IPv6);
    String key = "netconf";
    ObjectMapper mapper = new ObjectMapper();
    JsonNode jsonNode = mapper.readTree(jsonStream);
    ConfigApplyDelegate delegate = new MockDelegate();
    netconfDeviceConfig.init(subject, key, jsonNode, mapper, delegate);
    JsonNode jsonNodesshKey = mapper.readTree(jsonStreamSshKey);
    netconfDeviceConfigSshKey.init(subject, key, jsonNodesshKey, mapper, delegate);
    JsonNode jsonNodeEmpty = mapper.createObjectNode();
    netconfDeviceConfigEmptyIpv4.init(subject, key, jsonNodeEmpty, mapper, delegate);
    netconfDeviceConfigEmptyIpv6.init(subjectIpv6, key, jsonNodeEmpty, mapper, delegate);
}
#end_block

#method_before
@Test
public void activate() throws Exception {
    assertTrue("Provider should be registered", deviceRegistry.getProviders().contains(provider.id()));
    assertEquals("Incorrect device service", deviceService, provider.deviceService);
    assertEquals("Incorrect provider service", providerService, provider.providerService);
    assertEquals("Device listener should be added", 1, deviceListeners.size());
    assertFalse("Thread to connect device should be running", provider.executor.isShutdown() || provider.executor.isTerminated());
    assertFalse("Scheduled task to update device should be running", provider.scheduledTask.isCancelled());
}
#method_after
@Test
public void activate() throws Exception {
    assertTrue("Provider should be registered", deviceRegistry.getProviders().contains(provider.id()));
    assertEquals("Incorrect device service", deviceService, provider.deviceService);
    assertEquals("Incorrect provider service", providerService, provider.providerService);
    assertTrue("Incorrect config factories", cfgFactories.containsAll(provider.factories));
    assertEquals("Device listener should be added", 1, deviceListeners.size());
    assertFalse("Thread to connect device should be running", provider.executor.isShutdown() || provider.executor.isTerminated());
    assertFalse("Scheduled task to update device should be running", provider.scheduledTask.isCancelled());
}
#end_block

#method_before
@Test
public void deactivate() throws Exception {
    provider.deactivate();
    assertEquals("Device listener should be removed", 0, deviceListeners.size());
    assertFalse("Provider should not be registered", deviceRegistry.getProviders().contains(provider));
    assertTrue("Thread to connect device should be shutdown", provider.executor.isShutdown());
    assertTrue("Scheduled task to update device should be shutdown", provider.scheduledTask.isCancelled());
    assertNull("Provider service should be null", provider.providerService);
    assertEquals("Controller listener should be removed", 0, netconfDeviceListeners.size());
}
#method_after
@Test
public void deactivate() throws Exception {
    provider.deactivate();
    assertEquals("Device listener should be removed", 0, deviceListeners.size());
    assertFalse("Provider should not be registered", deviceRegistry.getProviders().contains(provider));
    assertTrue("Thread to connect device should be shutdown", provider.executor.isShutdown());
    assertTrue("Scheduled task to update device should be shutdown", provider.scheduledTask.isCancelled());
    assertNull("Provider service should be null", provider.providerService);
    assertTrue("Network config factories not removed", cfgFactories.isEmpty());
    assertEquals("Controller listener should be removed", 0, netconfDeviceListeners.size());
}
#end_block

#method_before
@Override
public void registerConfigFactory(ConfigFactory configFactory) {
    cfgFactory = configFactory;
}
#method_after
@Override
public void registerConfigFactory(ConfigFactory configFactory) {
    cfgFactories.add(configFactory);
}
#end_block

#method_before
@Override
public void unregisterConfigFactory(ConfigFactory configFactory) {
    cfgFactory = null;
}
#method_after
@Override
public void unregisterConfigFactory(ConfigFactory configFactory) {
    cfgFactories.remove(configFactory);
}
#end_block

#method_before
@Override
public <S, C extends Config<S>> C getConfig(S subject, Class<C> configClass) {
    if (configClass.equals(NetconfDeviceConfig.class)) {
        return (C) netconfDeviceConfig;
    } else {
        return (C) new BasicDeviceConfig();
    }
}
#method_after
@Override
public <S, C extends Config<S>> C getConfig(S subject, Class<C> configClass) {
    if (available) {
        if (configClass.equals(NetconfProviderConfig.class)) {
            return (C) netconfProviderConfig;
        }
        DeviceId did = (DeviceId) subject;
        if (configClass.equals(NetconfDeviceConfig.class) && did.equals(DeviceId.deviceId(NETCONF_DEVICE_ID_STRING))) {
            return (C) netconfDeviceConfig;
        } else if (configClass.equals(NetconfDeviceConfig.class) && did.equals(DeviceId.deviceId(NETCONF_DEVICE_ID_STRING_OLD))) {
            if (firstRequest) {
                firstRequest = false;
                return null;
            }
            return (C) cfg;
        } else {
            return (C) new BasicDeviceConfig();
        }
    }
    return null;
}
#end_block

#method_before
public IpAddress ip() {
    String ip = get(IP, "");
    return ip.isEmpty() ? null : IpAddress.valueOf(ip);
}
#method_after
public IpAddress ip() {
    return IpAddress.valueOf(get(IP, checkNotNull(extractIpPort()).getKey()));
}
#end_block

#method_before
public int port() {
    return get(PORT, DEFAULT_TCP_PORT);
}
#method_after
public int port() {
    return get(PORT, checkNotNull(extractIpPort()).getValue());
}
#end_block

#method_before
@Override
public GroupId groupId() {
    return new DefaultGroupId(3);
}
#method_after
@Override
public GroupId groupId() {
    return new GroupId(3);
}
#end_block

#method_before
@Override
public GroupId groupId() {
    return new DefaultGroupId(3);
}
#method_after
@Override
public GroupId groupId() {
    return new GroupId(3);
}
#end_block

#method_before
@Override
public boolean matchesSafely(JsonObject jsonIntent) {
    // check id
    final String jsonId = jsonIntent.get("id").asString();
    if (!jsonId.equals(intent.id().toString())) {
        reason = "id " + intent.id().toString();
        return false;
    }
    // check application id
    final String jsonAppId = jsonIntent.get("appId").asString();
    final String appId = intent.appId().name();
    if (!jsonAppId.equals(appId)) {
        reason = "appId was " + jsonAppId;
        return false;
    }
    // check intent type
    final String jsonType = jsonIntent.get("type").asString();
    if (!jsonType.equals("MockIntent")) {
        reason = "type MockIntent";
        return false;
    }
    // check state field
    final String jsonState = jsonIntent.get("state").asString();
    if (!jsonState.equals("INSTALLED")) {
        reason = "state INSTALLED";
        return false;
    }
    // check resources array
    final JsonArray jsonResources = jsonIntent.get("resources").asArray();
    if (intent.resources() != null) {
        if (intent.resources().size() != jsonResources.size()) {
            reason = "resources array size of " + Integer.toString(intent.resources().size());
            return false;
        }
        for (final NetworkResource resource : intent.resources()) {
            boolean resourceFound = false;
            final String resourceString = resource.toString();
            for (int resourceIndex = 0; resourceIndex < jsonResources.size(); resourceIndex++) {
                final JsonValue value = jsonResources.get(resourceIndex);
                if (value.asString().equals(resourceString)) {
                    resourceFound = true;
                }
            }
            if (!resourceFound) {
                reason = "resource " + resourceString;
                return false;
            }
        }
    } else if (jsonResources.size() != 0) {
        reason = "resources array empty";
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matchesSafely(JsonObject jsonIntent) {
    // check id
    final String jsonId = jsonIntent.get("id").asString();
    if (!jsonId.equals(intent.id().toString())) {
        reason = "id " + intent.id().toString();
        return false;
    }
    // check application id
    final String jsonAppId = jsonIntent.get("appId").asString();
    final String appId = intent.appId().name();
    if (!jsonAppId.equals(appId)) {
        reason = "appId was " + jsonAppId;
        return false;
    }
    // check intent type
    final String jsonType = jsonIntent.get("type").asString();
    if (!"MockIntent".equals(jsonType)) {
        reason = "type MockIntent";
        return false;
    }
    // check state field
    final String jsonState = jsonIntent.get("state").asString();
    if (!"INSTALLED".equals(jsonState)) {
        reason = "state INSTALLED";
        return false;
    }
    // check resources array
    final JsonArray jsonResources = jsonIntent.get("resources").asArray();
    if (intent.resources() != null) {
        if (intent.resources().size() != jsonResources.size()) {
            reason = "resources array size of " + Integer.toString(intent.resources().size());
            return false;
        }
        for (final NetworkResource resource : intent.resources()) {
            boolean resourceFound = false;
            final String resourceString = resource.toString();
            for (int resourceIndex = 0; resourceIndex < jsonResources.size(); resourceIndex++) {
                final JsonValue value = jsonResources.get(resourceIndex);
                if (value.asString().equals(resourceString)) {
                    resourceFound = true;
                }
            }
            if (!resourceFound) {
                reason = "resource " + resourceString;
                return false;
            }
        }
    } else if (jsonResources.size() != 0) {
        reason = "resources array empty";
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public ObjectNode encode(Device device, CodecContext context) {
    checkNotNull(device, "Device cannot be null");
    DeviceService service = context.getService(DeviceService.class);
    DriverService driveService = context.getService(DriverService.class);
    ObjectNode result = context.mapper().createObjectNode().put(ID, device.id().toString()).put(TYPE, device.type().name()).put("available", service.isAvailable(device.id())).put("role", service.getRole(device.id()).toString()).put(MFR, device.manufacturer()).put(HW, device.hwVersion()).put(SW, device.swVersion()).put(SERIAL, device.serialNumber()).put("driver", driveService.getDriver(device.id()).name()).put(CHASSIS_ID, device.chassisId().toString());
    return annotate(result, device, context);
}
#method_after
@Override
public ObjectNode encode(Device device, CodecContext context) {
    checkNotNull(device, "Device cannot be null");
    DeviceService service = context.getService(DeviceService.class);
    DriverService driveService = context.getService(DriverService.class);
    ObjectNode result = context.mapper().createObjectNode().put(ID, device.id().toString()).put(TYPE, device.type().name()).put(AVAILABLE, service.isAvailable(device.id())).put(ROLE, service.getRole(device.id()).toString()).put(MFR, device.manufacturer()).put(HW, device.hwVersion()).put(SW, device.swVersion()).put(SERIAL, device.serialNumber()).put(DRIVER, driveService.getDriver(device.id()).name()).put(CHASSIS_ID, device.chassisId().toString());
    return annotate(result, device, context);
}
#end_block

#method_before
@Test
public void testDeleteConfigRequestWithRunningTargetConfiguration() {
    log.info("Starting delete-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertFalse("NETCONF delete-config command failed", session1.deleteConfig(TargetConfig.RUNNING.toString()));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF delete-config test failed: " + e.getMessage());
    }
    log.info("Finishing delete-config async");
}
#method_after
@Test
public void testDeleteConfigRequestWithRunningTargetConfiguration() {
    log.info("Starting delete-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertFalse("NETCONF delete-config command failed", session1.deleteConfig(TargetConfig.RUNNING));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF delete-config test failed: " + e.getMessage());
    }
    log.info("Finishing delete-config async");
}
#end_block

#method_before
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF copy-config command failed", session1.copyConfig(TargetConfig.RUNNING.toString(), "candidate"));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF copy-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#method_after
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF copy-config command failed", session1.copyConfig(TargetConfig.RUNNING.toString(), "candidate"));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#end_block

#method_before
@Beta
@Override
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#method_after
@Beta
@Override
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        notificationFilterSchema = filterSchema;
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndRestablishSession();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request) throws NetconfException {
    checkAndReestablish();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
@Override
public void enterXmlElement(Element element, XmlNodeType nodeType, Element rootElement) {
    if (element.equals(rootElement)) {
        return;
    }
    YdtContextOperationType opType = null;
    for (Iterator iter = element.attributeIterator(); iter.hasNext(); ) {
        Attribute attr = (Attribute) iter.next();
        if (attr.getName().equals(OPERATION)) {
            opType = YdtContextOperationType.valueOf(attr.getValue().toUpperCase());
        }
    }
    String nameSpace = null;
    if (element.getNamespace() != null) {
        nameSpace = element.getNamespace().getURI();
    }
    /*
         * When new module has to be added, and if curnode has reference of
         * previous module, then we need to traverse back to parent(logical root
         * node).
         */
    if (ydtExtBuilder.getRootNode() == ydtExtBuilder.getCurNode().getParent() && prevNodeNamespace != null && !prevNodeNamespace.equals(nameSpace)) {
        ydtExtBuilder.traverseToParent();
    }
    if (nodeType == OBJECT_NODE) {
        if (ydtExtBuilder != null) {
            if (ydtExtBuilder.getCurNode() == ydtExtBuilder.getRootNode()) {
                ydtExtBuilder.addChild(null, nameSpace, opType);
            }
            ydtExtBuilder.addChild(element.getName(), nameSpace, opType);
        }
    } else if (nodeType == TEXT_NODE) {
        if (ydtExtBuilder != null) {
            if (ydtExtBuilder.getCurNode() == ydtExtBuilder.getRootNode()) {
                ydtExtBuilder.addChild(null, nameSpace, opType);
            }
            ydtExtBuilder.addLeaf(element.getName(), nameSpace, element.getText());
        }
    }
    if (nameSpace != null) {
        prevNodeNamespace = nameSpace;
    }
}
#method_after
@Override
public void enterXmlElement(Element element, XmlNodeType nodeType, Element rootElement) {
    if (element.equals(rootElement)) {
        return;
    }
    YdtContextOperationType opType = null;
    for (Iterator iter = element.attributeIterator(); iter.hasNext(); ) {
        Attribute attr = (Attribute) iter.next();
        if (attr.getName().equals(OPERATION)) {
            opType = YdtContextOperationType.valueOf(attr.getValue().toUpperCase());
        }
    }
    String nameSpace = null;
    if (element.getNamespace() != null) {
        nameSpace = element.getNamespace().getURI();
    }
    /*
         * When new module has to be added, and if curnode has reference of
         * previous module, then we need to traverse back to parent(logical
         * root node).
         */
    if (ydtExtBuilder.getRootNode() == ydtExtBuilder.getCurNode().getParent() && prevNodeNamespace != null && !prevNodeNamespace.equals(nameSpace)) {
        ydtExtBuilder.traverseToParent();
    }
    if (nodeType == OBJECT_NODE && (element.content() == null || element.content().isEmpty())) {
        if (ydtExtBuilder != null) {
            if (ydtExtBuilder.getCurNode() == ydtExtBuilder.getRootNode()) {
                ydtExtBuilder.addChild(null, nameSpace, opType);
            }
            ydtExtBuilder.addNode(element.getName(), nameSpace);
        }
    } else if (nodeType == OBJECT_NODE) {
        if (ydtExtBuilder != null) {
            if (ydtExtBuilder.getCurNode() == ydtExtBuilder.getRootNode()) {
                ydtExtBuilder.addChild(null, nameSpace, opType);
            }
            ydtExtBuilder.addChild(element.getName(), nameSpace, opType);
        }
    } else if (nodeType == TEXT_NODE) {
        if (ydtExtBuilder != null) {
            if (ydtExtBuilder.getCurNode() == ydtExtBuilder.getRootNode()) {
                ydtExtBuilder.addChild(null, nameSpace, opType);
            }
            ydtExtBuilder.addLeaf(element.getName(), nameSpace, element.getText());
        }
    }
    if (nameSpace != null) {
        prevNodeNamespace = nameSpace;
    }
}
#end_block

#method_before
// /**
// * Unit test case in which verifying object for xml string with config as root name and
// * operation type.
// */
// @Test
// public void proceessCodecDecodeFunctionForOperTypeTest() {
// String path = "src/test/resources/ychTestResourceFiles/configrootnameOperationType.xml";
// testYangSchemaNodeProvider.processSchemaRegistry(null);
// DefaultYangSchemaRegistry schemaRegistry =
// testYangSchemaNodeProvider.getDefaultYangSchemaRegistry();
// 
// YangCodecRegistry.initializeDefaultCodec();
// DefaultYangCodecHandler defaultYangCodecHandler =
// new DefaultYangCodecHandler(schemaRegistry);
// 
// StringBuilder sb = new StringBuilder();
// String sCurrentLine;
// 
// try (BufferedReader br = new BufferedReader(new FileReader(path))) {
// 
// while ((sCurrentLine = br.readLine()) != null) {
// sb.append(sCurrentLine);
// }
// 
// } catch (IOException e) {
// e.printStackTrace();
// }
// 
// // Verify the received object list
// List<Object> objectList =
// defaultYangCodecHandler.decode(sb.toString(),
// XML, EDIT_CONFIG_REQUEST);
// Iterator<Object> iterator = objectList.iterator();
// while (iterator.hasNext()) {
// Object object = iterator.next();
// if (object.getClass().getSimpleName()
// .equals(LOGISTIC_MOD)) {
// LogisticsManagerOpParam logistics =
// (LogisticsManagerOpParam) object;
// DefaultPurchasingSupervisor purchasingSupervisor =
// (DefaultPurchasingSupervisor) logistics
// .purchasingSupervisor();
// 
// assertEquals(AM_OBJ + "purchase-super: operation type", DELETE,
// purchasingSupervisor.yangPurchasingSupervisorOpType());
// assertEquals(AM_OBJ + "customs-super: leaf value", "abc",
// logistics.customsSupervisor());
// assertEquals(AM_OBJ + "purchase-spec: leaf value", "bcd",
// logistics.purchasingSupervisor()
// .purchasingSpecialist());
// assertEquals(AM_OBJ + "purchase-support: leaf value",
// "cde", logistics.purchasingSupervisor()
// .support());
// 
// } else if (object.getClass().getSimpleName()
// .equals(MERCHA_MOD)) {
// MerchandisersupervisorOpParam merchandisersupervisorOpParam =
// (MerchandisersupervisorOpParam) object;
// assertEquals(AM_OBJ + "merchandiser-super: leaf value",
// "abc", merchandisersupervisorOpParam.supervisor());
// } else {
// assertEquals(AM_OBJ, LOGISTIC_MOD, object
// .getClass().getSimpleName());
// assertEquals(AM_OBJ, MERCHA_MOD, object
// .getClass().getSimpleName());
// }
// }
// }
private void processPurchasingSpecObj(List<Object> objectList) {
    Iterator<Object> iterator = objectList.iterator();
    while (iterator.hasNext()) {
        Object object = iterator.next();
        if (object.getClass().getSimpleName().equals("LogisticsManagerOpParam")) {
            LogisticsManagerOpParam logisticsManagerOpParam = (LogisticsManagerOpParam) object;
            assertEquals(AM_OBJ + "purchasing-spec: leaf value", "bcd", logisticsManagerOpParam.purchasingSupervisor().purchasingSpecialist());
        } else {
            assertEquals(AM_OBJ, "LogisticsManagerOpParam", object.getClass().getSimpleName());
        }
    }
}
#method_after
// /**
// * Unit test case in which verifying object for xml string with config as root name and
// * operation type.
// */
// @Test
// public void proceessCodecDecodeFunctionForOperTypeTest() {
// String path = "src/test/resources/ychTestResourceFiles/configrootnameOperationType.xml";
// testYangSchemaNodeProvider.processSchemaRegistry(null);
// DefaultYangSchemaRegistry schemaRegistry =
// testYangSchemaNodeProvider.getDefaultYangSchemaRegistry();
// 
// YangCodecRegistry.initializeDefaultCodec();
// DefaultYangCodecHandler defaultYangCodecHandler =
// new DefaultYangCodecHandler(schemaRegistry);
// 
// StringBuilder sb = new StringBuilder();
// String sCurrentLine;
// 
// try (BufferedReader br = new BufferedReader(new FileReader(path))) {
// 
// while ((sCurrentLine = br.readLine()) != null) {
// sb.append(sCurrentLine);
// }
// 
// } catch (IOException e) {
// e.printStackTrace();
// }
// 
// // Verify the received object list
// List<Object> objectList =
// defaultYangCodecHandler.decode(sb.toString(),
// XML, EDIT_CONFIG_REQUEST);
// Iterator<Object> iterator = objectList.iterator();
// while (iterator.hasNext()) {
// Object object = iterator.next();
// if (object.getClass().getSimpleName()
// .equals(LOGISTIC_MOD)) {
// LogisticsManagerOpParam logistics =
// (LogisticsManagerOpParam) object;
// DefaultPurchasingSupervisor purchasingSupervisor =
// (DefaultPurchasingSupervisor) logistics
// .purchasingSupervisor();
// 
// assertEquals(AM_OBJ + "purchase-super: operation type", DELETE,
// purchasingSupervisor.yangPurchasingSupervisorOpType());
// assertEquals(AM_OBJ + "customs-super: leaf value", "abc",
// logistics.customsSupervisor());
// assertEquals(AM_OBJ + "purchase-spec: leaf value", "bcd",
// logistics.purchasingSupervisor()
// .purchasingSpecialist());
// assertEquals(AM_OBJ + "purchase-support: leaf value",
// "cde", logistics.purchasingSupervisor()
// .support());
// 
// } else if (object.getClass().getSimpleName()
// .equals(MERCHA_MOD)) {
// MerchandisersupervisorOpParam merchandisersupervisorOpParam =
// (MerchandisersupervisorOpParam) object;
// assertEquals(AM_OBJ + "merchandiser-super: leaf value",
// "abc", merchandisersupervisorOpParam.supervisor());
// } else {
// assertEquals(AM_OBJ, LOGISTIC_MOD, object
// .getClass().getSimpleName());
// assertEquals(AM_OBJ, MERCHA_MOD, object
// .getClass().getSimpleName());
// }
// }
// }
private void processPurchasingSpecObj(List<Object> objectList) {
    Iterator<Object> iterator = objectList.iterator();
    while (iterator.hasNext()) {
        Object object = iterator.next();
        if ("LogisticsManagerOpParam".equals(object.getClass().getSimpleName())) {
            LogisticsManagerOpParam logisticsManagerOpParam = (LogisticsManagerOpParam) object;
            assertEquals(AM_OBJ + "purchasing-spec: leaf value", "bcd", logisticsManagerOpParam.purchasingSupervisor().purchasingSpecialist());
        } else {
            assertEquals(AM_OBJ, "LogisticsManagerOpParam", object.getClass().getSimpleName());
        }
    }
}
#end_block

#method_before
public static ExtensionTreatment buildExtension(DeviceService deviceService, DeviceId deviceId, Ip4Address remoteIp) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && !device.is(ExtensionTreatmentResolver.class)) {
        log.error("The extension treatment is not supported");
        return null;
    }
    if (device == null) {
        return null;
    }
    ExtensionTreatmentResolver resolver = device.as(ExtensionTreatmentResolver.class);
    ExtensionTreatment treatment = resolver.getExtensionInstruction(NICIRA_SET_TUNNEL_DST.type());
    try {
        treatment.setPropertyValue(TUNNEL_DST, remoteIp);
        return treatment;
    } catch (ExtensionPropertyException e) {
        log.warn("Failed to get tunnelDst extension treatment for {}", deviceId);
        return null;
    }
}
#method_after
public static ExtensionTreatment buildExtension(DeviceService deviceService, DeviceId deviceId, Ip4Address remoteIp) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        return null;
    }
    if (!device.is(ExtensionTreatmentResolver.class)) {
        log.error("The extension treatment is not supported");
        return null;
    }
    ExtensionTreatmentResolver resolver = device.as(ExtensionTreatmentResolver.class);
    ExtensionTreatment treatment = resolver.getExtensionInstruction(NICIRA_SET_TUNNEL_DST.type());
    try {
        treatment.setPropertyValue(TUNNEL_DST, remoteIp);
        return treatment;
    } catch (ExtensionPropertyException e) {
        log.warn("Failed to get tunnelDst extension treatment for {}", deviceId);
        return null;
    }
}
#end_block

#method_before
private void removeTeNode(TeNodeKey nodeKey, boolean teNodeRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo != null && CollectionUtils.isNotEmpty(intTopo.teNodeKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teNodeKeys().remove(nodeKey);
    }
    // Then remove it from teNodeMap
    InternalTeNode node = teNodeMap.remove(nodeKey);
    if (node != null) {
        removeTeNodeMapEntrys(node);
    }
    // Remove it from networkNodeMap
    if (teNodeRemove && node != null) {
        removeNetworkNode(node.networkNodeKey(), teNodeRemove);
    }
}
#method_after
private void removeTeNode(TeNodeKey nodeKey, boolean teNodeRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo != null && CollectionUtils.isNotEmpty(intTopo.teNodeKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teNodeKeys().remove(nodeKey);
    }
    // Then remove it from teNodeMap
    InternalTeNode node = teNodeMap.remove(nodeKey);
    if (node == null) {
        log.error("No node found for nodeKey {}", nodeKey);
        return;
    }
    removeTeNodeMapEntrys(node);
    // Remove it from networkNodeMap
    if (teNodeRemove && node != null) {
        removeNetworkNode(node.networkNodeKey(), teNodeRemove);
    }
}
#end_block

#method_before
@Override
public boolean addConnectedRouter(LispRouterId routerId, LispRouter router) {
    if (connectedRouters.get(routerId) != null) {
        log.info("Trying to add connectedRouter but found a previous " + "value for routerId: {}", routerId);
        return false;
    } else {
        log.info("Added router {}", routerId);
        connectedRouters.put(routerId, router);
        for (LispRouterListener listener : lispRouterListeners) {
            listener.routerAdded(routerId);
        }
        return true;
    }
}
#method_after
@Override
public boolean addConnectedRouter(LispRouterId routerId, LispRouter router) {
    if (connectedRouters.get(routerId) != null) {
        log.warn("Trying to add connectedRouter but found a previous " + "value for routerId: {}", routerId);
        return false;
    } else {
        log.info("Added router {}", routerId);
        connectedRouters.put(routerId, router);
        for (LispRouterListener listener : lispRouterListeners) {
            listener.routerAdded(routerId);
        }
        return true;
    }
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    String interfaces = getInterfaces();
    if (interfaces != null && !interfaces.equals(EMPTY_STRING)) {
        Collection<PortStatistics> portStats = getPortStatistics(interfaces);
        return ImmutableList.copyOf(portStats);
    }
    return null;
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    String interfaces = getInterfaces();
    if (StringUtils.isNotBlank(interfaces)) {
        Collection<PortStatistics> portStats = getPortStatistics(interfaces);
        return ImmutableList.copyOf(portStats);
    }
    return null;
}
#end_block

#method_before
@Override
public void emit(NetworkId networkId, OutboundPacket packet) {
    NodeId myId = clusterService.getLocalNode().id();
    NodeId master = mastershipService.getMasterFor(packet.sendThrough());
    if (master == null) {
        log.warn("No master found for {}", packet.sendThrough());
        return;
    }
    log.info("master {} found for {}", myId, packet.sendThrough());
    if (myId.equals(master)) {
        notifyDelegate(networkId, new PacketEvent(EMIT, packet));
        return;
    }
    communicationService.unicast(packet, PACKET_OUT_SUBJECT, SERIALIZER::encode, master).whenComplete((r, error) -> {
        if (error != null) {
            log.warn("Failed to send packet-out to {}", master, error);
        }
    });
}
#method_after
@Override
public void emit(NetworkId networkId, OutboundPacket packet) {
    NodeId myId = clusterService.getLocalNode().id();
// TODO revive this when there is MastershipService support for virtual devices
// NodeId master = mastershipService.getMasterFor(packet.sendThrough());
// 
// if (master == null) {
// log.warn("No master found for {}", packet.sendThrough());
// return;
// }
// 
// log.debug("master {} found for {}", myId, packet.sendThrough());
// if (myId.equals(master)) {
// notifyDelegate(networkId, new PacketEvent(EMIT, packet));
// return;
// }
// 
// communicationService.unicast(packet, PACKET_OUT_SUBJECT, SERIALIZER::encode, master)
// .whenComplete((r, error) -> {
// if (error != null) {
// log.warn("Failed to send packet-out to {}", master, error);
// }
// });
}
#end_block

#method_before
@Test
public void testAddRemoveVirtualHost() {
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork1 = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork2 = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    manager.createVirtualHost(virtualNetwork2.id(), HID2, MAC2, VLAN2, LOC2, IPSET2);
    Set<VirtualHost> virtualHosts1 = manager.getVirtualHosts(virtualNetwork1.id());
    assertNotNull("The virtual host set should not be null", virtualHosts1);
    assertEquals("The virtual host set size did not match.", 1, virtualHosts1.size());
    Set<VirtualHost> virtualHosts2 = manager.getVirtualHosts(virtualNetwork2.id());
    assertNotNull("The virtual host set should not be null", virtualHosts2);
    assertEquals("The virtual host set size did not match.", 1, virtualHosts2.size());
    for (VirtualHost virtualHost : virtualHosts1) {
        manager.removeVirtualHost(virtualNetwork1.id(), virtualHost.id());
        // attempt to remove the same virtual host again.
        manager.removeVirtualHost(virtualNetwork1.id(), virtualHost.id());
    }
    virtualHosts1 = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts1.isEmpty());
    // Add/remove the virtual host again.
    VirtualHost virtualHost = manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    manager.removeVirtualHost(virtualHost.networkId(), virtualHost.id());
    virtualHosts1 = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts1.isEmpty());
}
#method_after
@Test
public void testAddRemoveVirtualHost() {
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork1 = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork2 = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualDevice virtualDevice1 = manager.createVirtualDevice(virtualNetwork1.id(), DID1);
    VirtualDevice virtualDevice2 = manager.createVirtualDevice(virtualNetwork2.id(), DID2);
    ConnectPoint hostCp1 = new ConnectPoint(DID1, P1);
    ConnectPoint hostCp2 = new ConnectPoint(DID2, P2);
    manager.createVirtualPort(virtualNetwork1.id(), hostCp1.deviceId(), hostCp1.port(), new ConnectPoint(virtualDevice1.id(), hostCp1.port()));
    manager.createVirtualPort(virtualNetwork2.id(), hostCp2.deviceId(), hostCp2.port(), new ConnectPoint(virtualDevice2.id(), hostCp2.port()));
    manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    manager.createVirtualHost(virtualNetwork2.id(), HID2, MAC2, VLAN2, LOC2, IPSET2);
    Set<VirtualHost> virtualHosts1 = manager.getVirtualHosts(virtualNetwork1.id());
    assertNotNull("The virtual host set should not be null", virtualHosts1);
    assertEquals("The virtual host set size did not match.", 1, virtualHosts1.size());
    Set<VirtualHost> virtualHosts2 = manager.getVirtualHosts(virtualNetwork2.id());
    assertNotNull("The virtual host set should not be null", virtualHosts2);
    assertEquals("The virtual host set size did not match.", 1, virtualHosts2.size());
    for (VirtualHost virtualHost : virtualHosts1) {
        manager.removeVirtualHost(virtualNetwork1.id(), virtualHost.id());
        // attempt to remove the same virtual host again.
        manager.removeVirtualHost(virtualNetwork1.id(), virtualHost.id());
    }
    virtualHosts1 = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts1.isEmpty());
    // Add/remove the virtual host again.
    VirtualHost virtualHost = manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    manager.removeVirtualHost(virtualHost.networkId(), virtualHost.id());
    virtualHosts1 = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts1.isEmpty());
}
#end_block

#method_before
@Test
public void emit2Test() {
    OutboundPacket packet = new DefaultOutboundPacket(VDID2, DefaultTrafficTreatment.emptyTreatment(), ByteBuffer.allocate(5));
    packetManager1.emit(packet);
    assertNull("Packet should not have been emmitted", emittedPacket);
}
#method_after
@Test
@Ignore("Ignore until there is MastershipService support for virtual devices")
public void emit2Test() {
    OutboundPacket packet = new DefaultOutboundPacket(VDID2, DefaultTrafficTreatment.emptyTreatment(), ByteBuffer.allocate(5));
    packetManager1.emit(packet);
    assertNull("Packet should not have been emmitted", emittedPacket);
}
#end_block

#method_before
protected boolean checkPath(Path path, List<Constraint> constraints) {
    for (Constraint constraint : constraints) {
        if (!constraint.validate(path, resourceService::isAvailable)) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPath(Path path, List<Constraint> constraints) {
    if (path == null) {
        return false;
    }
    for (Constraint constraint : constraints) {
        if (!constraint.validate(path, resourceService::isAvailable)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static Map<String, YangNode> getNodes(YangModel model) {
    Set<YangNode> nodes = new HashSet<>();
    Map<String, YangNode> nodeMap = new LinkedHashMap<>();
    Iterator<YangModule> it = model.getYangModules().iterator();
    YangModule module;
    InputStream is;
    if (it.hasNext()) {
        module = it.next();
        is = module.getMetadata();
        ObjectInputStream os;
        try {
            os = new ObjectInputStream(is);
            nodes.addAll((Set<YangNode>) os.readObject());
            os.close();
            is.close();
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException("failed to deserialize model" + e.getLocalizedMessage());
        }
    }
    addLinkerAndJavaInfo(nodes);
    for (YangNode n : nodes) {
        nodeMap.put(getInterfaceClassName(n), n);
        try {
            if (n.isRpcPresent() || n.isNotificationPresent()) {
                nodeMap.put(getServiceName(n), n);
            }
        } catch (DataModelException e) {
            throw new RuntimeException("failed to add service info after " + "fetching nodes from model");
        }
    }
    return nodeMap;
}
#method_after
public static Set<YangNode> getNodes(YangModel model) {
    Set<YangNode> nodes = new HashSet<>();
    for (YangModule info : model.getYangModules()) {
        YangModuleExtendedInfo ex = (YangModuleExtendedInfo) info;
        nodes.add(ex.getSchema());
    }
    return nodes;
}
#end_block

#method_before
public static YangModel processYangModel(String path, List<YangNode> curNodes) {
    YangModel.Builder b = DefaultYangModel.builder();
    YangModuleId id;
    Iterator<YangNode> it = curNodes.iterator();
    while (it.hasNext()) {
        YangSchemaNode node = it.next();
        id = processModuleId((YangNode) node);
        YangModule module = new DefaultYangModule(id, get(node.getFileName()), get(path));
        b.addModule(id, module);
    }
    return b.build();
}
#method_after
public static YangModel processYangModel(String path, List<YangNode> curNodes) {
    YangModel.Builder b = DefaultYangModel.builder();
    YangModuleId id;
    for (YangNode node : curNodes) {
        id = processModuleId(node);
        YangModuleExtendedInfo module = new YangModuleExtendedInfo(id, get(node.getFileName()), get(path));
        module.setSchema(node);
        b.addModule(id, module);
    }
    return b.build();
}
#end_block

#method_before
private static String getJarPathFromBundleLocation(String mvnLocationPath, String currentDirectory) {
    StringBuilder builder = new StringBuilder();
    builder.append(currentDirectory).append(SYSTEM);
    StringBuilder ver = new StringBuilder();
    if (mvnLocationPath.contains(MAVEN)) {
        String[] strArray = mvnLocationPath.split(MAVEN);
        if (strArray[1].contains(File.separator)) {
            String[] split = strArray[1].split(File.separator);
            if (split[0].contains(PERIOD)) {
                String[] groupId = split[0].split(Pattern.quote(PERIOD));
                for (String s : groupId) {
                    builder.append(s).append(SLASH);
                }
                for (int i = 1; i < split.length; i++) {
                    builder.append(split[i]).append(SLASH);
                    ver.append(split[i]).append(HYPHEN);
                }
                builder.append(ver);
                builder.deleteCharAt(builder.length() - 1);
                return builder.toString();
            }
        }
    }
    return null;
}
#method_after
private static String getJarPathFromBundleLocation(String mvnLocationPath, String currentDirectory) {
    String path = currentDirectory + SYSTEM;
    if (mvnLocationPath.contains(MAVEN)) {
        String[] strArray = mvnLocationPath.split(MAVEN);
        if (strArray[1].contains(File.separator)) {
            String[] split = strArray[1].split(File.separator);
            if (split[0].contains(PERIOD)) {
                String[] groupId = split[0].split(Pattern.quote(PERIOD));
                return path + groupId[0] + SLASH + groupId[1] + SLASH + split[1] + SLASH + split[2] + SLASH + split[1] + HYPHEN + split[2];
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void registerModel(ModelRegistrationParam param) {
    YangModel model = checkNotNull(param.getYangModel(), "Model must not be null");
    Map<String, YangNode> curNodes = getNodes(model);
    models.add(model);
    // TODO: changing for models-demo app to work.
    if (checkForAppInfo(param)) {
        for (Map.Entry<YangModuleId, AppModuleInfo> entry : param.appModuleInfoMap().entrySet()) {
            registerModule(curNodes, entry.getValue());
        }
    } else {
        // TODO: check this after demo1:
        registerWhenAppInfoNull(curNodes);
    }
    updateChildContext(curNodes);
}
#method_after
@Override
public void registerModel(ModelRegistrationParam param) {
    YangModel model = checkNotNull(param.getYangModel(), "Model must not be null");
    Set<YangNode> curNodes = getNodes(model);
    models.add(model);
    String name;
    Class<?> service;
    AppModuleInfo info;
    // adding class info if added by application.
    for (YangModuleId id : model.getYangModulesId()) {
        info = param.getAppModuleInfo(id);
        if (info != null) {
            service = info.getModuleClass();
            name = service.getName();
            if (!registerClassStore.containsKey(name)) {
                registerClassStore.put(name, service);
            }
        }
    }
    // Register all the YANG nodes.
    registerModule(curNodes);
    // update child context
    updateChildContext(curNodes);
}
#end_block

#method_before
private void registerModule(Map<String, YangNode> curNodes, AppModuleInfo info) {
    Class<?> service;
    service = info.getModuleClass();
    String name = service.getName();
    if (!verifyIfApplicationAlreadyRegistered(service)) {
        if (!registerClassStore.containsKey(name)) {
            registerClassStore.put(name, service);
        }
        if (curNodes != null && !curNodes.isEmpty()) {
            processRegistration(service, curNodes);
        }
    }
}
#method_after
private void registerModule(Set<YangNode> curNodes) {
    String name;
    // register all the nodes present in YANG model.
    if (curNodes != null && !curNodes.isEmpty()) {
        for (YangNode node : curNodes) {
            name = getInterfaceClassName(node);
            if (!regClassNameKeyStore.containsKey(name)) {
                processApplicationContext(node, name);
            } else {
                log.info("class already registered with model registry " + "{}", name);
            }
        }
    }
}
#end_block

#method_before
@Override
public void unregisterModel(ModelRegistrationParam param) {
    synchronized (DefaultYangModelRegistry.class) {
        YangModel model = checkNotNull(param.getYangModel(), "Model must not be null");
        models.remove(model);
        // TODO: changing for models-demo app to work
        if (checkForAppInfo(param)) {
            for (Map.Entry<YangModuleId, AppModuleInfo> entry : param.appModuleInfoMap().entrySet()) {
                unregisterModule(entry.getValue());
            }
        } else {
            for (Map.Entry<String, YangNode> e : getNodes(model).entrySet()) {
                processUnReg(getInterfaceClassName(e.getValue()));
            }
        }
    }
}
#method_after
@Override
public void unregisterModel(ModelRegistrationParam param) {
    synchronized (DefaultYangModelRegistry.class) {
        YangModel model = checkNotNull(param.getYangModel(), "Model must not be null");
        models.remove(model);
        // Unregister all yang files
        Set<YangNode> curNodes = getNodes(model);
        for (YangNode node : curNodes) {
            processUnReg(getInterfaceClassName(node));
        }
    }
}
#end_block

#method_before
private void processUnReg(String serviceName) {
    YangSchemaNode curNode = regClassNameKeyStore.get(serviceName);
    if (curNode != null) {
        removeSchemaNode(curNode);
        regClassNameKeyStore.remove(getInterfaceClassName(curNode));
        qNameKeyStore.remove(getInterfaceClassName(curNode).toLowerCase());
        nameSpaceSchemaStore.remove(curNode.getNameSpace().getModuleNamespace());
        log.info(" service class {} of model is " + "unregistered.", serviceName);
    } else {
        log.error("Either {} service was not registered or " + "already unregistered from model " + "registry.", serviceName);
    }
}
#method_after
private void processUnReg(String serviceName) {
    YangSchemaNode curNode = regClassNameKeyStore.get(serviceName);
    if (curNode != null) {
        removeSchemaNode(curNode);
        regClassNameKeyStore.remove(serviceName);
        qNameKeyStore.remove(serviceName.toLowerCase());
        nameSpaceSchemaStore.remove(curNode.getNameSpace().getModuleNamespace());
        registerClassStore.remove(serviceName);
        log.info(" service class {} of model is " + "unregistered.", serviceName);
    } else {
        log.error("Either {} service was not registered or " + "already unregistered from model " + "registry.", serviceName);
    }
}
#end_block

#method_before
private void updateChildContext(Map<String, YangNode> nodes) {
    // Preparing schema id for logical node with name "/"
    for (Map.Entry<String, YangNode> node : nodes.entrySet()) {
        node.getValue().setLeafRootContext(this);
        YangNode child = node.getValue().getChild();
        while (child != null) {
            if (child instanceof YangChoice) {
                updateSchemaContextForChoiceChild(child);
            } else if (child instanceof SchemaDataNode) {
                child.setRootContext(this);
            }
            child = child.getNextSibling();
        }
    }
}
#method_after
private void updateChildContext(Set<YangNode> nodes) {
    // Preparing schema id for logical node with name "/"
    for (YangNode node : nodes) {
        node.setLeafRootContext(this);
        YangNode child = node.getChild();
        while (child != null) {
            if (child instanceof YangChoice) {
                updateSchemaContextForChoiceChild(child);
            } else if (child instanceof SchemaDataNode) {
                child.setRootContext(this);
            }
            child = child.getNextSibling();
        }
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.getAppId(APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    nodeStore = storageService.<String, OpenstackNode>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("openstack-nodestore").withApplicationId(appId).build();
    gatewayNodeMap = storageService.<DeviceId, GatewayNode>consistentMapBuilder().withSerializer(Serializer.using(GATEWAYNODE_SERIALIZER.build())).withName(GATEWAYNODE_MAP_NAME).withApplicationId(appId).build();
    nodeStore.addListener(nodeStoreListener);
    deviceService.addListener(deviceListener);
    configRegistry.registerConfigFactory(configFactory);
    configRegistry.addListener(configListener);
    componentConfigService.registerProperties(getClass());
    selectGroupHandler = new SelectGroupHandler(groupService, deviceService, driverService, appId);
    readConfiguration();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.getAppId(APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    nodeStore = storageService.<String, OpenstackNode>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("openstack-nodestore").withApplicationId(appId).build();
    nodeStore.addListener(nodeStoreListener);
    deviceService.addListener(deviceListener);
    configRegistry.registerConfigFactory(configFactory);
    configRegistry.addListener(configListener);
    componentConfigService.registerProperties(getClass());
    selectGroupHandler = new SelectGroupHandler(groupService, deviceService, driverService, appId);
    readConfiguration();
    log.info("Started");
}
#end_block

#method_before
@Override
public void processCompleteState(OpenstackNode node) {
    process(new OpenstackNodeEvent(COMPLETE, node));
    log.info("Finished init {}", node.hostname());
}
#method_after
@Override
public void processCompleteState(OpenstackNode node) {
    process(new OpenstackNodeEvent(COMPLETE, node));
    switch(node.type()) {
        case COMPUTE:
            selectGroupHandler.createGatewayGroup(node.intBridge(), gatewayNodes());
            break;
        case GATEWAY:
            updateGatewayGroup(node, true);
            break;
        default:
            break;
    }
    log.info("Finished init {}", node.hostname());
}
#end_block

#method_before
@Override
public void processIncompleteState(OpenstackNode node) {
    process(new OpenstackNodeEvent(INCOMPLETE, node));
}
#method_after
@Override
public void processIncompleteState(OpenstackNode node) {
    process(new OpenstackNodeEvent(INCOMPLETE, node));
    if (node.type().equals(NodeType.GATEWAY)) {
        updateGatewayGroup(node, false);
    }
}
#end_block

#method_before
private void updateGatewayGroup(GatewayNode gatewayNode, boolean isInsert) {
    Tools.stream(deviceService.getAvailableDevices()).forEach(device -> {
        Tools.stream(groupService.getGroups(device.id(), appId)).forEach(group -> {
            selectGroupHandler.updateGatewayGroupBuckets(device.id(), ImmutableList.of(gatewayNode), isInsert);
            log.trace("Updated gateway group on {}", device.id());
        });
    });
}
#method_after
private void updateGatewayGroup(OpenstackNode gatewayNode, boolean isInsert) {
    nodeStore.values().stream().map(Versioned::value).filter(node -> node.type().equals(NodeType.COMPUTE)).filter(node -> node.state().equals(COMPLETE)).forEach(node -> {
        selectGroupHandler.updateGatewayGroupBuckets(node.intBridge(), ImmutableList.of(gatewayNode), isInsert);
        log.trace("Updated gateway group on {}", node.intBridge());
    });
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        // TODO implement OVSDB port event so that we can handle updates on the OVSDB
        case PORT_ADDED:
            eventExecutor.execute(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.execute(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.execute(() -> handler.connected(device));
            } else {
                eventExecutor.execute(() -> handler.disconnected(device));
            }
            break;
        case DEVICE_SUSPENDED:
        case DEVICE_REMOVED:
            deleteGatewayNode(getGatewayNode(device.id()));
            log.warn("Gateway with device ID {} is disconnected", device.id());
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        // TODO implement OVSDB port event so that we can handle updates on the OVSDB
        case PORT_ADDED:
            eventExecutor.execute(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.execute(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.execute(() -> handler.connected(device));
            } else {
                eventExecutor.execute(() -> handler.disconnected(device));
                log.warn("OpenstackNode with device ID {} is disconnected", device.id());
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
public GroupId createGatewayGroup(DeviceId srcDeviceId, List<GatewayNode> nodeList) {
    List<GroupBucket> bucketList = generateBucketsForSelectGroup(srcDeviceId, nodeList);
    GroupId groupId = getGroupId(srcDeviceId);
    GroupDescription groupDescription = new DefaultGroupDescription(srcDeviceId, GroupDescription.Type.SELECT, new GroupBuckets(bucketList), getGroupKey(srcDeviceId), groupId.id(), appId);
    groupService.addGroup(groupDescription);
    return groupId;
}
#method_after
public GroupId createGatewayGroup(DeviceId srcDeviceId, List<OpenstackNode> gatewayNodeList) {
    List<GroupBucket> bucketList = generateBucketsForSelectGroup(srcDeviceId, gatewayNodeList);
    GroupId groupId = getGroupId(srcDeviceId);
    GroupDescription groupDescription = new DefaultGroupDescription(srcDeviceId, GroupDescription.Type.SELECT, new GroupBuckets(bucketList), getGroupKey(srcDeviceId), groupId.id(), appId);
    groupService.addGroup(groupDescription);
    return groupId;
}
#end_block

#method_before
public void updateGatewayGroupBuckets(DeviceId deviceId, List<GatewayNode> nodeList, boolean isInsert) {
    List<GroupBucket> bucketList = generateBucketsForSelectGroup(deviceId, nodeList);
    GroupKey groupKey = getGroupKey(deviceId);
    if (isInsert) {
        groupService.addBucketsToGroup(deviceId, groupKey, new GroupBuckets(bucketList), groupKey, appId);
    } else {
        groupService.removeBucketsFromGroup(deviceId, groupKey, new GroupBuckets(bucketList), groupKey, appId);
    }
}
#method_after
public void updateGatewayGroupBuckets(DeviceId deviceId, List<OpenstackNode> gatewayNodeList, boolean isInsert) {
    List<GroupBucket> bucketList = generateBucketsForSelectGroup(deviceId, gatewayNodeList);
    GroupKey groupKey = getGroupKey(deviceId);
    if (groupService.getGroup(deviceId, groupKey) == null) {
        log.error("There's no group in compute node {}", deviceId);
        return;
    }
    if (isInsert) {
        groupService.addBucketsToGroup(deviceId, groupKey, new GroupBuckets(bucketList), groupKey, appId);
    } else {
        groupService.removeBucketsFromGroup(deviceId, groupKey, new GroupBuckets(bucketList), groupKey, appId);
    }
}
#end_block

#method_before
private List<GroupBucket> generateBucketsForSelectGroup(DeviceId deviceId, List<GatewayNode> nodeList) {
    List<GroupBucket> bucketList = Lists.newArrayList();
    nodeList.forEach(node -> {
        TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().extension(buildNiciraExtenstion(deviceId, node.getDataIpAddress()), deviceId).setOutput(getTunnelPort(deviceId)).build();
        bucketList.add(createSelectGroupBucket(tBuilder));
    });
    return bucketList;
}
#method_after
private List<GroupBucket> generateBucketsForSelectGroup(DeviceId deviceId, List<OpenstackNode> gatewayNodeList) {
    List<GroupBucket> bucketList = Lists.newArrayList();
    gatewayNodeList.forEach(node -> {
        TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().extension(buildNiciraExtenstion(deviceId, node.dataIp().get().getIp4Address()), deviceId).setOutput(getTunnelPort(deviceId)).build();
        bucketList.add(createSelectGroupBucket(tBuilder));
    });
    return bucketList;
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.getGatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        eventExecutor.execute(() -> processArpPacket(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.gatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        eventExecutor.execute(() -> processArpPacket(context, ethernet));
    }
}
#end_block

#method_before
private void requestPacket(ApplicationId appId) {
    TrafficSelector icmpSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).build();
    osNodeService.getGatewayDeviceIds().forEach(gateway -> {
        packetService.requestPackets(icmpSelector, PacketPriority.CONTROL, appId, Optional.of(gateway));
        log.debug("Requested ICMP packet to {}", gateway);
    });
}
#method_after
private void requestPacket(ApplicationId appId) {
    TrafficSelector icmpSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).build();
    osNodeService.gatewayDeviceIds().forEach(gateway -> {
        packetService.requestPackets(icmpSelector, PacketPriority.CONTROL, appId, Optional.of(gateway));
        log.debug("Requested ICMP packet to {}", gateway);
    });
}
#end_block

#method_before
private void sendRequestForExternal(IPv4 ipPacket, DeviceId srcDevice, IpAddress srcNatIp) {
    ICMP icmpReq = (ICMP) ipPacket.getPayload();
    icmpReq.resetChecksum();
    ipPacket.setSourceAddress(srcNatIp.getIp4Address().toInt()).resetChecksum();
    ipPacket.setPayload(icmpReq);
    Ethernet icmpRequestEth = new Ethernet();
    icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(DEFAULT_GATEWAY_MAC).setDestinationMACAddress(DEFAULT_EXTERNAL_ROUTER_MAC).setPayload(ipPacket);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(osNodeService.getUplinkPort(srcDevice)).build();
    OutboundPacket packet = new DefaultOutboundPacket(srcDevice, treatment, ByteBuffer.wrap(icmpRequestEth.serialize()));
    packetService.emit(packet);
}
#method_after
private void sendRequestForExternal(IPv4 ipPacket, DeviceId srcDevice, IpAddress srcNatIp) {
    ICMP icmpReq = (ICMP) ipPacket.getPayload();
    icmpReq.resetChecksum();
    ipPacket.setSourceAddress(srcNatIp.getIp4Address().toInt()).resetChecksum();
    ipPacket.setPayload(icmpReq);
    Ethernet icmpRequestEth = new Ethernet();
    icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(DEFAULT_GATEWAY_MAC).setDestinationMACAddress(DEFAULT_EXTERNAL_ROUTER_MAC).setPayload(ipPacket);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(osNodeService.externalPort(srcDevice).get()).build();
    OutboundPacket packet = new DefaultOutboundPacket(srcDevice, treatment, ByteBuffer.wrap(icmpRequestEth.serialize()));
    packetService.emit(packet);
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.getGatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null || ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        return;
    }
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    if (iPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
        eventExecutor.execute(() -> processIcmpPacket(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.gatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null || ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        return;
    }
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    if (iPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
        eventExecutor.execute(() -> processIcmpPacket(context, ethernet));
    }
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
            if (osNode.type() == GATEWAY) {
                log.info("GATEWAY node {} detected", osNode.hostname());
                eventExecutor.execute(() -> {
                    // TODO add events to scalable gateway so that we
                    // don't need to add gateway here and there
                    GatewayNode gnode = GatewayNode.builder().gatewayDeviceId(osNode.intBridge()).dataIpAddress(osNode.dataIp().get().getIp4Address()).uplinkIntf(osNode.externalPortName().get()).build();
                    osNodeService.addGatewayNode(gnode);
                    requestPacket(appId);
                });
            }
            break;
        case INIT:
        case DEVICE_CREATED:
        case INCOMPLETE:
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
            if (osNode.type() == GATEWAY) {
                log.info("GATEWAY node {} detected", osNode.hostname());
                eventExecutor.execute(() -> {
                    requestPacket(appId);
                });
            }
            break;
        case INIT:
        case DEVICE_CREATED:
        case INCOMPLETE:
        default:
            break;
    }
}
#end_block

#method_before
private void setSourceNat(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> {
        setRulesToGateway(osNode.intBridge(), osNodeService.getGatewayGroupId(osNode.intBridge()), Long.valueOf(osNet.getProviderSegID()), IpPrefix.valueOf(osSubnet.getCidr()), install);
    });
    // take the first outgoing packet to controller for source NAT
    osNodeService.getGatewayDeviceIds().forEach(gwDeviceId -> setRulesToController(gwDeviceId, Long.valueOf(osNet.getProviderSegID()), IpPrefix.valueOf(osSubnet.getCidr()), install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#method_after
private void setSourceNat(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> {
        setRulesToGateway(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge()), Long.valueOf(osNet.getProviderSegID()), IpPrefix.valueOf(osSubnet.getCidr()), install);
    });
    // take the first outgoing packet to controller for source NAT
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setRulesToController(gwDeviceId, Long.valueOf(osNet.getProviderSegID()), IpPrefix.valueOf(osSubnet.getCidr()), install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.getGatewayGroupId(osNode.intBridge()), Long.valueOf(network.getProviderSegID()), IpAddress.valueOf(osSubnet.getGateway()), install));
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.getGatewayDeviceIds().forEach(gwDeviceId -> setGatewayIcmpRule(gatewayIp, gwDeviceId, install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge()), Long.valueOf(network.getProviderSegID()), IpAddress.valueOf(osSubnet.getGateway()), install));
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setGatewayIcmpRule(gatewayIp, gwDeviceId, install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
private void setDownstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    Optional<IpAddress> dataIp = osNodeService.dataIp(instPort.deviceId());
    if (!dataIp.isPresent()) {
        log.warn(ERR_FLOW + "compute node {} is not ready", floatingIp, instPort.deviceId());
        return;
    }
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector externalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).build();
    osNodeService.getGatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment externalTreatment = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address()).setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(osNodeService.tunnelPort(gnodeId).get()).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, gnodeId, externalSelector, externalTreatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_FLOATING_EXTERNAL, install);
        // access from one VM to the other via floating IP
        TrafficSelector internalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).matchInPort(osNodeService.tunnelPort(gnodeId).get()).build();
        TrafficTreatment internalTreatment = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address()).setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(PortNumber.IN_PORT).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, gnodeId, internalSelector, internalTreatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_FLOATING_INTERNAL, install);
    });
}
#method_after
private void setDownstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    Optional<IpAddress> dataIp = osNodeService.dataIp(instPort.deviceId());
    if (!dataIp.isPresent()) {
        log.warn(ERR_FLOW + "compute node {} is not ready", floatingIp, instPort.deviceId());
        return;
    }
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector externalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).build();
    osNodeService.gatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment externalTreatment = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address()).setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(osNodeService.tunnelPort(gnodeId).get()).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, gnodeId, externalSelector, externalTreatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_FLOATING_EXTERNAL, install);
        // access from one VM to the other via floating IP
        TrafficSelector internalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).matchInPort(osNodeService.tunnelPort(gnodeId).get()).build();
        TrafficTreatment internalTreatment = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address()).setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(PortNumber.IN_PORT).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, gnodeId, internalSelector, internalTreatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_FLOATING_INTERNAL, install);
    });
}
#end_block

#method_before
private void setUpstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(osNet.getProviderSegID())).matchIPSrc(instPort.ipAddress().toIpPrefix()).build();
    osNodeService.getGatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setIpSrc(floating.getIp4Address()).setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(Constants.DEFAULT_EXTERNAL_ROUTER_MAC).setOutput(osNodeService.getUplinkPort(gnodeId)).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, gnodeId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_FLOATING_EXTERNAL, install);
    });
}
#method_after
private void setUpstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(osNet.getProviderSegID())).matchIPSrc(instPort.ipAddress().toIpPrefix()).build();
    osNodeService.gatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setIpSrc(floating.getIp4Address()).setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(Constants.DEFAULT_EXTERNAL_ROUTER_MAC).setOutput(osNodeService.externalPort(gnodeId).get()).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, gnodeId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_FLOATING_EXTERNAL, install);
    });
}
#end_block

#method_before
private void setDownstreamRules(InstancePort srcInstPort, Long srcVni, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    IpAddress internalIp = IpAddress.valueOf(iPacket.getSourceAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setTunnelId(srcVni).setEthDst(packetIn.parsed().getSourceMAC()).setIpDst(internalIp);
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(patPort);
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(patPort);
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    osNodeService.getGatewayDeviceIds().forEach(deviceId -> {
        DeviceId srcDeviceId = srcInstPort.deviceId();
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.extension(RulePopulatorUtil.buildExtension(deviceService, deviceId, osNodeService.dataIp(srcDeviceId).get().getIp4Address()), deviceId).setOutput(osNodeService.tunnelPort(deviceId).get());
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tmpBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY_SNAT_RULE).makeTemporary(TIME_OUT_SNAT_RULE).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#method_after
private void setDownstreamRules(InstancePort srcInstPort, Long srcVni, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    IpAddress internalIp = IpAddress.valueOf(iPacket.getSourceAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setTunnelId(srcVni).setEthDst(packetIn.parsed().getSourceMAC()).setIpDst(internalIp);
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(patPort);
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(patPort);
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    osNodeService.gatewayDeviceIds().forEach(deviceId -> {
        DeviceId srcDeviceId = srcInstPort.deviceId();
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.extension(RulePopulatorUtil.buildExtension(deviceService, deviceId, osNodeService.dataIp(srcDeviceId).get().getIp4Address()), deviceId).setOutput(osNodeService.tunnelPort(deviceId).get());
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tmpBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY_SNAT_RULE).makeTemporary(TIME_OUT_SNAT_RULE).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
private void setUpstreamRules(Long srcVni, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(srcVni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    osNodeService.getGatewayDeviceIds().forEach(deviceId -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.setOutput(osNodeService.getUplinkPort(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tmpBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY_SNAT_RULE).makeTemporary(TIME_OUT_SNAT_RULE).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#method_after
private void setUpstreamRules(Long srcVni, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(srcVni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    osNodeService.gatewayDeviceIds().forEach(deviceId -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.setOutput(osNodeService.externalPort(deviceId).get());
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tmpBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY_SNAT_RULE).makeTemporary(TIME_OUT_SNAT_RULE).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
private void packetOut(Ethernet ethPacketIn, DeviceId srcDevice, int patPort, IpAddress externalIp) {
    IPv4 iPacket = (IPv4) ethPacketIn.getPayload();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            tcpPacket.setSourcePort(patPort);
            tcpPacket.resetChecksum();
            tcpPacket.setParent(iPacket);
            iPacket.setPayload(tcpPacket);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            udpPacket.setSourcePort(patPort);
            udpPacket.resetChecksum();
            udpPacket.setParent(iPacket);
            iPacket.setPayload(udpPacket);
            break;
        default:
            log.trace("Temporally, this method can process UDP and TCP protocol.");
            return;
    }
    iPacket.setSourceAddress(externalIp.toString());
    iPacket.resetChecksum();
    iPacket.setParent(ethPacketIn);
    ethPacketIn.setDestinationMACAddress(DEFAULT_EXTERNAL_ROUTER_MAC);
    ethPacketIn.setPayload(iPacket);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(osNodeService.getUplinkPort(srcDevice)).build();
    ethPacketIn.resetChecksum();
    packetService.emit(new DefaultOutboundPacket(srcDevice, treatment, ByteBuffer.wrap(ethPacketIn.serialize())));
}
#method_after
private void packetOut(Ethernet ethPacketIn, DeviceId srcDevice, int patPort, IpAddress externalIp) {
    IPv4 iPacket = (IPv4) ethPacketIn.getPayload();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            tcpPacket.setSourcePort(patPort);
            tcpPacket.resetChecksum();
            tcpPacket.setParent(iPacket);
            iPacket.setPayload(tcpPacket);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            udpPacket.setSourcePort(patPort);
            udpPacket.resetChecksum();
            udpPacket.setParent(iPacket);
            iPacket.setPayload(udpPacket);
            break;
        default:
            log.trace("Temporally, this method can process UDP and TCP protocol.");
            return;
    }
    iPacket.setSourceAddress(externalIp.toString());
    iPacket.resetChecksum();
    iPacket.setParent(ethPacketIn);
    ethPacketIn.setDestinationMACAddress(DEFAULT_EXTERNAL_ROUTER_MAC);
    ethPacketIn.setPayload(iPacket);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(osNodeService.externalPort(srcDevice).get()).build();
    ethPacketIn.resetChecksum();
    packetService.emit(new DefaultOutboundPacket(srcDevice, treatment, ByteBuffer.wrap(ethPacketIn.serialize())));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.getGatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet eth = pkt.parsed();
    if (eth == null || eth.getEtherType() == Ethernet.TYPE_ARP) {
        return;
    }
    IPv4 iPacket = (IPv4) eth.getPayload();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_ICMP:
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                // don't process DHCP
                break;
            }
        default:
            eventExecutor.execute(() -> processSnatPacket(context, eth));
            break;
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.gatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet eth = pkt.parsed();
    if (eth == null || eth.getEtherType() == Ethernet.TYPE_ARP) {
        return;
    }
    IPv4 iPacket = (IPv4) eth.getPayload();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_ICMP:
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                // don't process DHCP
                break;
            }
        default:
            eventExecutor.execute(() -> processSnatPacket(context, eth));
            break;
    }
}
#end_block

#method_before
protected void removeBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED && nextObjective.type() != NextObjective.Type.BROADCAST) {
        log.warn("RemoveBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    Set<PortNumber> portsToRemove = Sets.newHashSet();
    Collection<TrafficTreatment> treatments = nextObjective.next();
    for (TrafficTreatment treatment : treatments) {
        // find the bucket to remove by noting the outport, and figuring out the
        // top-level group in the group-chain that indirectly references the port
        PortNumber portToRemove = readOutPortFromTreatment(treatment);
        if (portToRemove == null) {
            log.warn("treatment {} of next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", treatment, nextObjective.id(), deviceId);
        } else {
            portsToRemove.add(portToRemove);
        }
    }
    if (portsToRemove.isEmpty()) {
        log.warn("next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
    }
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // last group in group chain should have a single bucket pointing to port
        GroupKey groupWithPort = gkeys.peekLast();
        Group group = groupService.getGroup(deviceId, groupWithPort);
        if (group == null) {
            log.warn("Inconsistent group chain found when removing bucket" + "for next:{} in dev:{}", nextObjective.id(), deviceId);
            continue;
        }
        if (group.buckets().buckets().isEmpty()) {
            log.warn("Can't get output port information from group {} " + "because there is no bucket in the group.", group);
            continue;
        }
        PortNumber pout = readOutPortFromTreatment(group.buckets().buckets().get(0).treatment());
        if (portsToRemove.contains(pout)) {
            chainsToRemove.add(gkeys);
        }
    }
    if (chainsToRemove.isEmpty()) {
        log.warn("Could not find appropriate group-chain for removing bucket" + " for next id {} in dev:{}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    List<GroupBucket> bucketsToRemove = Lists.newArrayList();
    // first group key is the one we want to modify
    GroupKey modGroupKey = chainsToRemove.get(0).peekFirst();
    Group modGroup = groupService.getGroup(deviceId, modGroupKey);
    for (Deque<GroupKey> foundChain : chainsToRemove) {
        // second group key is the one we wish to remove the reference to
        if (foundChain.size() < 2) {
            // additional check to make sure second group key exist in
            // the chain.
            log.warn("Can't find second group key from chain {}", foundChain);
            continue;
        }
        GroupKey pointedGroupKey = foundChain.stream().collect(Collectors.toList()).get(1);
        Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
        if (pointedGroup == null) {
            continue;
        }
        GroupBucket bucket;
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        } else {
            bucket = DefaultGroupBucket.createAllGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        }
        bucketsToRemove.add(bucket);
    }
    GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
    // for debug log
    List<String> pointedGroupIds;
    pointedGroupIds = bucketsToRemove.stream().map(GroupBucket::treatment).map(TrafficTreatment::allInstructions).flatMap(List::stream).filter(inst -> inst instanceof Instructions.GroupInstruction).map(inst -> (Instructions.GroupInstruction) inst).map(Instructions.GroupInstruction::groupId).map(GroupId::id).map(Integer::toHexString).map(id -> HEX_PREFIX + id).collect(Collectors.toList());
    log.debug("Removing buckets from group id 0x{} pointing to group id(s) {} " + "for next id {} in device {}", Integer.toHexString(modGroup.id().id()), pointedGroupIds, nextObjective.id(), deviceId);
    addPendingUpdateNextObjective(modGroupKey, nextObjective);
    groupService.removeBucketsFromGroup(deviceId, modGroupKey, removeBuckets, modGroupKey, nextObjective.appId());
    // update store
    allActiveKeys.removeAll(chainsToRemove);
    // top level group which still exists.
    if (allActiveKeys.isEmpty()) {
        ArrayDeque<GroupKey> top = new ArrayDeque<>();
        top.add(modGroupKey);
        allActiveKeys.add(top);
    }
    flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allActiveKeys, nextObjective));
}
#method_after
protected void removeBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED && nextObjective.type() != NextObjective.Type.BROADCAST) {
        log.warn("RemoveBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    Set<PortNumber> portsToRemove = Sets.newHashSet();
    Collection<TrafficTreatment> treatments = nextObjective.next();
    for (TrafficTreatment treatment : treatments) {
        // find the bucket to remove by noting the outport, and figuring out the
        // top-level group in the group-chain that indirectly references the port
        PortNumber portToRemove = readOutPortFromTreatment(treatment);
        if (portToRemove == null) {
            log.warn("treatment {} of next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", treatment, nextObjective.id(), deviceId);
        } else {
            portsToRemove.add(portToRemove);
        }
    }
    if (portsToRemove.isEmpty()) {
        log.warn("next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
    }
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // last group in group chain should have a single bucket pointing to port
        GroupKey groupWithPort = gkeys.peekLast();
        Group group = groupService.getGroup(deviceId, groupWithPort);
        if (group == null) {
            log.warn("Inconsistent group chain found when removing bucket" + "for next:{} in dev:{}", nextObjective.id(), deviceId);
            continue;
        }
        if (group.buckets().buckets().isEmpty()) {
            log.warn("Can't get output port information from group {} " + "because there is no bucket in the group.", group.id().toString());
            continue;
        }
        PortNumber pout = readOutPortFromTreatment(group.buckets().buckets().get(0).treatment());
        if (portsToRemove.contains(pout)) {
            chainsToRemove.add(gkeys);
        }
    }
    if (chainsToRemove.isEmpty()) {
        log.warn("Could not find appropriate group-chain for removing bucket" + " for next id {} in dev:{}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    List<GroupBucket> bucketsToRemove = Lists.newArrayList();
    // first group key is the one we want to modify
    GroupKey modGroupKey = chainsToRemove.get(0).peekFirst();
    Group modGroup = groupService.getGroup(deviceId, modGroupKey);
    for (Deque<GroupKey> foundChain : chainsToRemove) {
        // second group key is the one we wish to remove the reference to
        if (foundChain.size() < 2) {
            // additional check to make sure second group key exist in
            // the chain.
            log.warn("Can't find second group key from chain {}", foundChain);
            continue;
        }
        GroupKey pointedGroupKey = foundChain.stream().collect(Collectors.toList()).get(1);
        Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
        if (pointedGroup == null) {
            continue;
        }
        GroupBucket bucket;
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            bucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        } else {
            bucket = DefaultGroupBucket.createAllGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        }
        bucketsToRemove.add(bucket);
    }
    GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
    // for debug log
    List<String> pointedGroupIds;
    pointedGroupIds = bucketsToRemove.stream().map(GroupBucket::treatment).map(TrafficTreatment::allInstructions).flatMap(List::stream).filter(inst -> inst instanceof Instructions.GroupInstruction).map(inst -> (Instructions.GroupInstruction) inst).map(Instructions.GroupInstruction::groupId).map(GroupId::id).map(Integer::toHexString).map(id -> HEX_PREFIX + id).collect(Collectors.toList());
    log.debug("Removing buckets from group id 0x{} pointing to group id(s) {} " + "for next id {} in device {}", Integer.toHexString(modGroup.id().id()), pointedGroupIds, nextObjective.id(), deviceId);
    addPendingUpdateNextObjective(modGroupKey, nextObjective);
    groupService.removeBucketsFromGroup(deviceId, modGroupKey, removeBuckets, modGroupKey, nextObjective.appId());
    // update store
    allActiveKeys.removeAll(chainsToRemove);
    // top level group which still exists.
    if (allActiveKeys.isEmpty()) {
        ArrayDeque<GroupKey> top = new ArrayDeque<>();
        top.add(modGroupKey);
        allActiveKeys.add(top);
    }
    flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allActiveKeys, nextObjective));
}
#end_block

#method_before
void processLsAckMessage(OspfMessage ospfMessage, ChannelHandlerContext ctx) throws Exception {
    log.debug("OspfChannelHandler::processLsAckMessage");
    LsAcknowledge lsAckPacket = (LsAcknowledge) ospfMessage;
    // check it is present in listOfNeighbors
    OspfNbrImpl nbr = (OspfNbrImpl) neighbouringRouter(lsAckPacket.routerId().toString());
    if (nbr != null) {
        if (nbr.getState().getValue() < OspfNeighborState.EXCHANGE.getValue()) {
            // discard the packet.
            return;
        } else {
            // process ls acknowledgements
            Iterator itr = lsAckPacket.getLinkStateHeaders().iterator();
            while (itr.hasNext()) {
                LsaHeader lsRequest = (LsaHeader) itr.next();
                if (lsRequest != null) {
                    OspfLsa ospfLsa = (OspfLsa) nbr.getPendingReTxList().get(((OspfAreaImpl) ospfArea).getLsaKey(lsRequest));
                    if (ospfLsa != null) {
                        String isSame = ((OspfLsdbImpl) ospfArea.database()).isNewerOrSameLsa(lsRequest, (LsaHeader) ospfLsa);
                        if (isSame.equals("same")) {
                            nbr.getPendingReTxList().remove(((OspfAreaImpl) ospfArea).getLsaKey(lsRequest));
                        }
                    }
                }
            }
        }
    }
}
#method_after
void processLsAckMessage(OspfMessage ospfMessage, ChannelHandlerContext ctx) throws Exception {
    log.debug("OspfChannelHandler::processLsAckMessage");
    LsAcknowledge lsAckPacket = (LsAcknowledge) ospfMessage;
    // check it is present in listOfNeighbors
    OspfNbrImpl nbr = (OspfNbrImpl) neighbouringRouter(lsAckPacket.routerId().toString());
    if (nbr != null) {
        if (nbr.getState().getValue() < OspfNeighborState.EXCHANGE.getValue()) {
            // discard the packet.
            return;
        } else {
            // process ls acknowledgements
            Iterator itr = lsAckPacket.getLinkStateHeaders().iterator();
            while (itr.hasNext()) {
                LsaHeader lsRequest = (LsaHeader) itr.next();
                OspfLsa ospfLsa = (OspfLsa) nbr.getPendingReTxList().get(((OspfAreaImpl) ospfArea).getLsaKey(lsRequest));
                if (ospfLsa != null) {
                    String isSame = ((OspfLsdbImpl) ospfArea.database()).isNewerOrSameLsa(lsRequest, (LsaHeader) ospfLsa);
                    if (isSame.equals("same")) {
                        nbr.getPendingReTxList().remove(((OspfAreaImpl) ospfArea).getLsaKey(lsRequest));
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public VirtualPort addPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet == null) {
        virtualPortSet = new HashSet<>();
    }
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    checkState(!virtualPortExists(networkId, deviceId, portNumber), "The requested Port Number is already in use.");
    VirtualPort virtualPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(virtualPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_ADDED, networkId, device, virtualPort));
    return virtualPort;
}
#method_after
@Override
public VirtualPort addPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet == null) {
        virtualPortSet = new HashSet<>();
    }
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    checkState(!virtualPortExists(networkId, deviceId, portNumber), "The requested Port Number has been added.");
    VirtualPort virtualPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(virtualPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_ADDED, networkId, device, virtualPort));
    return virtualPort;
}
#end_block

#method_before
@Override
public void bindPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    VirtualPort vPort = virtualPortSet.stream().filter(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber)).findFirst().get();
    checkNotNull(vPort, "The virtual port has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    virtualPortSet.remove(vPort);
    vPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(vPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_UPDATED, networkId, device, vPort));
}
#method_after
@Override
public void bindPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    Optional<VirtualPort> virtualPortOptional = virtualPortSet.stream().filter(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber)).findFirst();
    checkState(virtualPortOptional.isPresent(), "The virtual port has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    VirtualPort vPort = virtualPortOptional.get();
    virtualPortSet.remove(vPort);
    vPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(vPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_UPDATED, networkId, device, vPort));
}
#end_block

#method_before
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    checkNotNull(networkIdVirtualPortSetMap.get(networkId), "No port has been created for NetworkId: " + networkId);
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    Set<VirtualPort> virtualPortSet = new HashSet<>();
    networkIdVirtualPortSetMap.get(networkId).forEach(port -> {
        if (port.element().id().equals(deviceId) && port.number().equals(portNumber)) {
            virtualPortSet.add(port);
        }
    });
    if (!virtualPortSet.isEmpty()) {
        AtomicBoolean portRemoved = new AtomicBoolean(false);
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return new HashSet<>();
            } else {
                portRemoved.set(true);
                return new HashSet<>(Sets.difference(existingVirtualPorts, virtualPortSet));
            }
        });
        if (portRemoved.get()) {
            virtualPortSet.forEach(virtualPort -> notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_REMOVED, networkId, device, virtualPort)));
            // Remove all the virtual links connected to this virtual port
            Set<VirtualLink> existingVirtualLinks = networkIdVirtualLinkSetMap.get(networkId);
            if (existingVirtualLinks != null && !existingVirtualLinks.isEmpty()) {
                Set<VirtualLink> virtualLinkSet = new HashSet<>();
                ConnectPoint cp = new ConnectPoint(deviceId, portNumber);
                existingVirtualLinks.forEach(virtualLink -> {
                    if (virtualLink.src().equals(cp) || virtualLink.dst().equals(cp)) {
                        virtualLinkSet.add(virtualLink);
                    }
                });
                virtualLinkSet.forEach(virtualLink -> removeLink(networkId, virtualLink.src(), virtualLink.dst()));
            }
            // Remove all the hosts connected to this virtual port
            Set<HostId> hostIdSet = new HashSet<>();
            hostIdVirtualHostMap.forEach((hostId, virtualHost) -> {
                if (virtualHost.location().deviceId().equals(deviceId) && virtualHost.location().port().equals(portNumber)) {
                    hostIdSet.add(hostId);
                }
            });
            hostIdSet.forEach(hostId -> removeHost(networkId, hostId));
        }
    }
}
#method_after
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    VirtualDevice device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    if (networkIdVirtualPortSetMap.get(networkId) == null) {
        log.warn("No port has been created for NetworkId: {}", networkId);
        return;
    }
    Set<VirtualPort> virtualPortSet = new HashSet<>();
    networkIdVirtualPortSetMap.get(networkId).forEach(port -> {
        if (port.element().id().equals(deviceId) && port.number().equals(portNumber)) {
            virtualPortSet.add(port);
        }
    });
    if (!virtualPortSet.isEmpty()) {
        AtomicBoolean portRemoved = new AtomicBoolean(false);
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return new HashSet<>();
            } else {
                portRemoved.set(true);
                return new HashSet<>(Sets.difference(existingVirtualPorts, virtualPortSet));
            }
        });
        if (portRemoved.get()) {
            virtualPortSet.forEach(virtualPort -> notifyDelegate(new VirtualNetworkEvent(VirtualNetworkEvent.Type.VIRTUAL_PORT_REMOVED, networkId, device, virtualPort)));
            // Remove all the virtual links connected to this virtual port
            Set<VirtualLink> existingVirtualLinks = networkIdVirtualLinkSetMap.get(networkId);
            if (existingVirtualLinks != null && !existingVirtualLinks.isEmpty()) {
                Set<VirtualLink> virtualLinkSet = new HashSet<>();
                ConnectPoint cp = new ConnectPoint(deviceId, portNumber);
                existingVirtualLinks.forEach(virtualLink -> {
                    if (virtualLink.src().equals(cp) || virtualLink.dst().equals(cp)) {
                        virtualLinkSet.add(virtualLink);
                    }
                });
                virtualLinkSet.forEach(virtualLink -> removeLink(networkId, virtualLink.src(), virtualLink.dst()));
            }
            // Remove all the hosts connected to this virtual port
            Set<HostId> hostIdSet = new HashSet<>();
            hostIdVirtualHostMap.forEach((hostId, virtualHost) -> {
                if (virtualHost.location().deviceId().equals(deviceId) && virtualHost.location().port().equals(portNumber)) {
                    hostIdSet.add(hostId);
                }
            });
            hostIdSet.forEach(hostId -> removeHost(networkId, hostId));
        }
    }
}
#end_block

#method_before
@Test
public void testRemoveAllElements() {
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork1 = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualDevice virtualDevice1 = manager.createVirtualDevice(virtualNetwork1.id(), DID1);
    VirtualDevice virtualDevice2 = manager.createVirtualDevice(virtualNetwork1.id(), DID2);
    ConnectPoint src = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(1));
    manager.createVirtualPort(virtualNetwork1.id(), src.deviceId(), src.port(), new ConnectPoint(virtualDevice2.id(), src.port()));
    ConnectPoint dst = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(2));
    manager.createVirtualPort(virtualNetwork1.id(), dst.deviceId(), dst.port(), new ConnectPoint(virtualDevice2.id(), dst.port()));
    manager.createVirtualLink(virtualNetwork1.id(), src, dst);
    manager.createVirtualLink(virtualNetwork1.id(), dst, src);
    ConnectPoint hostCp = new ConnectPoint(DID1, P1);
    manager.createVirtualPort(virtualNetwork1.id(), hostCp.deviceId(), hostCp.port(), new ConnectPoint(virtualDevice1.id(), hostCp.port()));
    manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    manager.removeVirtualPort(virtualNetwork1.id(), DID1, PortNumber.portNumber(1));
    Set<VirtualLink> virtualLinks = manager.getVirtualLinks(virtualNetwork1.id());
    assertTrue("The virtual link set should be empty.", virtualLinks.isEmpty());
    manager.removeVirtualPort(virtualNetwork1.id(), DID1, P1);
    Set<VirtualHost> virtualHosts = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts.isEmpty());
    manager.createVirtualPort(virtualNetwork1.id(), src.deviceId(), src.port(), new ConnectPoint(virtualDevice1.id(), src.port()));
    manager.createVirtualLink(virtualNetwork1.id(), src, dst);
    manager.createVirtualLink(virtualNetwork1.id(), dst, src);
    manager.createVirtualPort(virtualNetwork1.id(), hostCp.deviceId(), hostCp.port(), new ConnectPoint(virtualDevice1.id(), hostCp.port()));
    manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    manager.removeVirtualDevice(virtualNetwork1.id(), DID1);
    Set<VirtualPort> virtualPorts = manager.getVirtualPorts(virtualNetwork1.id(), DID1);
    assertTrue("The virtual port set of DID1 should be empty", virtualPorts.isEmpty());
    virtualLinks = manager.getVirtualLinks(virtualNetwork1.id());
    assertTrue("The virtual link set should be empty.", virtualLinks.isEmpty());
    virtualHosts = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts.isEmpty());
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue1));
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    Set<VirtualNetwork> virtualNetworks = manager.getVirtualNetworks(TenantId.tenantId(tenantIdValue1));
    assertNotNull("The virtual network set should not be null", virtualNetworks);
    assertTrue("The virtual network set should be empty.", virtualNetworks.isEmpty());
}
#method_after
@Test
public void testRemoveAllElements() {
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork1 = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualDevice virtualDevice1 = manager.createVirtualDevice(virtualNetwork1.id(), DID1);
    VirtualDevice virtualDevice2 = manager.createVirtualDevice(virtualNetwork1.id(), DID2);
    ConnectPoint src = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(1));
    manager.createVirtualPort(virtualNetwork1.id(), src.deviceId(), src.port(), new ConnectPoint(PHYDID1, PortNumber.portNumber(1)));
    ConnectPoint dst = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(2));
    manager.createVirtualPort(virtualNetwork1.id(), dst.deviceId(), dst.port(), new ConnectPoint(PHYDID2, PortNumber.portNumber(2)));
    manager.createVirtualLink(virtualNetwork1.id(), src, dst);
    manager.createVirtualLink(virtualNetwork1.id(), dst, src);
    ConnectPoint hostCp = new ConnectPoint(DID1, P1);
    manager.createVirtualPort(virtualNetwork1.id(), hostCp.deviceId(), hostCp.port(), new ConnectPoint(PHYDID1, P1));
    manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    // When a virtual port is removed, all virtual links connected to it should also be removed.
    manager.removeVirtualPort(virtualNetwork1.id(), DID1, PortNumber.portNumber(1));
    Set<VirtualLink> virtualLinks = manager.getVirtualLinks(virtualNetwork1.id());
    assertTrue("The virtual link set should be empty.", virtualLinks.isEmpty());
    // When a virtual port is removed, all virtual hosts located to it should also be removed.
    manager.removeVirtualPort(virtualNetwork1.id(), DID1, P1);
    Set<VirtualHost> virtualHosts = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts.isEmpty());
    manager.createVirtualPort(virtualNetwork1.id(), src.deviceId(), src.port(), new ConnectPoint(PHYDID1, PortNumber.portNumber(1)));
    manager.createVirtualLink(virtualNetwork1.id(), src, dst);
    manager.createVirtualLink(virtualNetwork1.id(), dst, src);
    manager.createVirtualPort(virtualNetwork1.id(), hostCp.deviceId(), hostCp.port(), new ConnectPoint(PHYDID1, P1));
    manager.createVirtualHost(virtualNetwork1.id(), HID1, MAC1, VLAN1, LOC1, IPSET1);
    // When a virtual device is removed, all virtual ports, hosts and links depended on it should also be removed.
    manager.removeVirtualDevice(virtualNetwork1.id(), DID1);
    Set<VirtualPort> virtualPorts = manager.getVirtualPorts(virtualNetwork1.id(), DID1);
    assertTrue("The virtual port set of DID1 should be empty", virtualPorts.isEmpty());
    virtualLinks = manager.getVirtualLinks(virtualNetwork1.id());
    assertTrue("The virtual link set should be empty.", virtualLinks.isEmpty());
    virtualHosts = manager.getVirtualHosts(virtualNetwork1.id());
    assertTrue("The virtual host set should be empty.", virtualHosts.isEmpty());
    // When a tenantId is removed, all the virtual networks belonging to it should also be removed.
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue1));
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    Set<VirtualNetwork> virtualNetworks = manager.getVirtualNetworks(TenantId.tenantId(tenantIdValue1));
    assertNotNull("The virtual network set should not be null", virtualNetworks);
    assertTrue("The virtual network set should be empty.", virtualNetworks.isEmpty());
}
#end_block

#method_before
@Override
public String getConfiguration(String type) {
    return getConfiguration(TargetConfig.valueOf(type));
}
#method_after
@Override
public String getConfiguration(String type) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    DeviceId ofDeviceId = handler.data().deviceId();
    Preconditions.checkNotNull(controller, "Netconf controller is null");
    try {
        return controller.getDevicesMap().get(ofDeviceId).getSession().getConfig(TargetConfig.valueOf(type));
    } catch (IOException e) {
        log.error("Configuration could not be retrieved {}", e.getMessage());
    }
    return UNABLE_TO_READ_CONFIG;
}
#end_block

#method_before
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        int connectTimeout = NetconfControllerImpl.netconfConnectTimeout;
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device" + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKeyFile() != null && deviceInfo.getKeyFile().canRead()) {
                log.debug("Authenticating with key file to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKeyFile(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#method_after
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        int connectTimeout = NetconfControllerImpl.netconfConnectTimeout;
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device " + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKeyFile() != null && deviceInfo.getKeyFile().canRead()) {
                log.debug("Authenticating with key file to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKeyFile(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#end_block

#method_before
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl(), replies);
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session.", e);
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#method_after
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl(), replies);
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session {} ", e.getMessage());
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#end_block

#method_before
private void checkAndRestablishSession() throws NetconfException {
    if (sshSession.getState() != 2) {
        try {
            startSshSession();
        } catch (IOException e) {
            log.debug("The connection with {} was reopened", deviceInfo.getDeviceId());
            try {
                startConnection();
            } catch (IOException e2) {
                log.error("No connection {} for device", netconfConnection, e2);
                throw new NetconfException("Cannot re-open the connection with device" + deviceInfo, e);
            }
        }
    }
}
#method_after
private void checkAndRestablishSession() throws NetconfException {
    if (sshSession.getState() != 2) {
        try {
            log.debug("The session with {} was reopened", deviceInfo.getDeviceId());
            startSshSession();
        } catch (IOException e) {
            log.debug("The connection with {} was reopened", deviceInfo.getDeviceId());
            try {
                connectionActive = false;
                replies.clear();
                messageIdInteger.set(0);
                startConnection();
            } catch (IOException e2) {
                log.error("No connection {} for device {}", netconfConnection, e.getMessage());
                throw new NetconfException("Cannot re-open the connection with device" + deviceInfo, e);
            }
        }
    }
}
#end_block

#method_before
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    if (completedReply != null) {
        completedReply.complete(event.getMessagePayload());
    }
}
#method_after
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    log.debug("messageID {}, waiting replies messageIDs {}", messageId, replies.keySet());
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    if (completedReply != null) {
        completedReply.complete(event.getMessagePayload());
    }
}
#end_block

#method_before
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    multicastAddressCodec = context.codec(LispMulticastAddress.class);
    assertThat(multicastAddressCodec, notNullValue());
}
#method_after
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    multicastAddressCodec = context.codec(LispMulticastAddress.class);
    assertThat("Multicast address codec should not be null", multicastAddressCodec, notNullValue());
}
#end_block

#method_before
@Test
public void testLispMulticastAddressEncode() {
    LispMulticastAddress address = new LispMulticastAddress.Builder().withInstanceId(INSTANCE_ID).withSrcMaskLength(SRC_MASK_LENGTH).withGrpMaskLength(GRP_MASK_LENGTH).withSrcAddress(MappingAddresses.ipv4MappingAddress(SRC_ADDRESS_PREFIX)).withGrpAddress(MappingAddresses.ipv4MappingAddress(GRP_ADDRESS_PREFIX)).build();
    ObjectNode addressJson = multicastAddressCodec.encode(address, context);
    assertThat(addressJson, LispMulticastAddressJsonMatcher.matchesMulticastAddress(address));
}
#method_after
@Test
public void testLispMulticastAddressEncode() {
    LispMulticastAddress address = new LispMulticastAddress.Builder().withInstanceId(INSTANCE_ID).withSrcMaskLength(SRC_MASK_LENGTH).withGrpMaskLength(GRP_MASK_LENGTH).withSrcAddress(MappingAddresses.ipv4MappingAddress(SRC_ADDRESS_PREFIX)).withGrpAddress(MappingAddresses.ipv4MappingAddress(GRP_ADDRESS_PREFIX)).build();
    ObjectNode addressJson = multicastAddressCodec.encode(address, context);
    assertThat("errors in encoding Multicast address JSON", addressJson, LispMulticastAddressJsonMatcher.matchesMulticastAddress(address));
}
#end_block

#method_before
private LispMulticastAddress getLispMulticastAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispMulticastAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat(json, notNullValue());
    LispMulticastAddress multicastAddress = multicastAddressCodec.decode((ObjectNode) json, context);
    assertThat(multicastAddress, notNullValue());
    return multicastAddress;
}
#method_after
private LispMulticastAddress getLispMulticastAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispMulticastAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat("JSON string should not be null", json, notNullValue());
    LispMulticastAddress multicastAddress = multicastAddressCodec.decode((ObjectNode) json, context);
    assertThat("decoded address should not be null", multicastAddress, notNullValue());
    return multicastAddress;
}
#end_block

#method_before
@Override
public ObjectNode encode(LispListAddress address, CodecContext context) {
    checkNotNull(address, "LispListAddress cannot be null");
    final ObjectNode result = context.mapper().createObjectNode();
    final JsonCodec<MappingAddress> addressCodec = context.codec(MappingAddress.class);
    if (address.getIpv4() != null) {
        ObjectNode ipv4Node = addressCodec.encode(address.getIpv4(), context);
        result.set(IPV4, ipv4Node);
    }
    if (address.getIpv6() != null) {
        ObjectNode ipv6Node = addressCodec.encode(address.getIpv6(), context);
        result.set(IPV6, ipv6Node);
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(LispListAddress address, CodecContext context) {
    checkNotNull(address, "LispListAddress cannot be null");
    final ObjectNode result = context.mapper().createObjectNode();
    final JsonCodec<MappingAddress> addressCodec = context.codec(MappingAddress.class);
    if (address.getIpv4() != null) {
        ObjectNode ipv4Node = addressCodec.encode(address.getIpv4(), context);
        result.set(IPV4, ipv4Node);
    }
    if (address.getIpv6() != null) {
        ObjectNode ipv6Node = addressCodec.encode(address.getIpv6(), context);
        result.set(IPV6, ipv6Node);
    }
    if (address.getIpv4() == null && address.getIpv6() == null) {
        log.error("Either IPv4 or IPv6 address should be specified.");
    }
    return result;
}
#end_block

#method_before
@Override
public LispListAddress decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<MappingAddress> addressCodec = context.codec(MappingAddress.class);
    ObjectNode ipv4Json = get(json, IPV4);
    ObjectNode ipv6Json = get(json, IPV6);
    MappingAddress ipv4Address = null;
    MappingAddress ipv6Address = null;
    if (ipv4Json != null) {
        ipv4Address = addressCodec.decode(ipv4Json, context);
    }
    if (ipv6Json != null) {
        ipv6Address = addressCodec.decode(ipv6Json, context);
    }
    return new LispListAddress.Builder().withIpv4(ipv4Address).withIpv6(ipv6Address).build();
}
#method_after
@Override
public LispListAddress decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<MappingAddress> addressCodec = context.codec(MappingAddress.class);
    ObjectNode ipv4Json = get(json, IPV4);
    ObjectNode ipv6Json = get(json, IPV6);
    MappingAddress ipv4Address = null;
    MappingAddress ipv6Address = null;
    if (ipv4Json != null) {
        ipv4Address = addressCodec.decode(ipv4Json, context);
    }
    if (ipv6Json != null) {
        ipv6Address = addressCodec.decode(ipv6Json, context);
    }
    if (ipv4Json == null && ipv6Json == null) {
        log.error("Either IPv4 or IPv6 address should be specified.");
    }
    return new LispListAddress.Builder().withIpv4(ipv4Address).withIpv6(ipv6Address).build();
}
#end_block

#method_before
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    listAddressCodec = context.codec(LispListAddress.class);
    assertThat(listAddressCodec, notNullValue());
}
#method_after
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    listAddressCodec = context.codec(LispListAddress.class);
    assertThat("List address codec should not be null", listAddressCodec, notNullValue());
}
#end_block

#method_before
@Test
public void testLispListAddressEncode() {
    LispListAddress address = new LispListAddress.Builder().withIpv4(MappingAddresses.ipv4MappingAddress(IPV4_PREFIX)).withIpv6(MappingAddresses.ipv6MappingAddress(IPV6_PREFIX)).build();
    ObjectNode addressJson = listAddressCodec.encode(address, context);
    assertThat(addressJson, LispListAddressJsonMatcher.matchesListAddress(address));
}
#method_after
@Test
public void testLispListAddressEncode() {
    LispListAddress address = new LispListAddress.Builder().withIpv4(MappingAddresses.ipv4MappingAddress(IPV4_PREFIX)).withIpv6(MappingAddresses.ipv6MappingAddress(IPV6_PREFIX)).build();
    ObjectNode addressJson = listAddressCodec.encode(address, context);
    assertThat("errors in encoding List address JSON", addressJson, LispListAddressJsonMatcher.matchesListAddress(address));
}
#end_block

#method_before
private LispListAddress getLispListAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispListAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat(json, notNullValue());
    LispListAddress listAddress = listAddressCodec.decode((ObjectNode) json, context);
    assertThat(listAddress, notNullValue());
    return listAddress;
}
#method_after
private LispListAddress getLispListAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispListAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat("JSON string should not be null", json, notNullValue());
    LispListAddress listAddress = listAddressCodec.decode((ObjectNode) json, context);
    assertThat("decoded address should not be null", listAddress, notNullValue());
    return listAddress;
}
#end_block

#method_before
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    gcAddressCodec = context.codec(LispGcAddress.class);
    assertThat(gcAddressCodec, notNullValue());
}
#method_after
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    gcAddressCodec = context.codec(LispGcAddress.class);
    assertThat("Geo Coordinate address codec should not be null", gcAddressCodec, notNullValue());
}
#end_block

#method_before
@Test
public void testLispGcAddressEncode() {
    LispGcAddress address = new LispGcAddress.Builder().withIsNorth(NORTH).withLatitudeDegree(LATITUDE_DEGREE).withLatitudeMinute(LATITUDE_MINUTE).withLatitudeSecond(LATITUDE_SECOND).withIsEast(EAST).withLongitudeDegree(LONGITUDE_DEGREE).withLongitudeMinute(LONGITUDE_MINUTE).withLongitudeSecond(LONGITUDE_SECOND).withAltitude(ALTITUDE).withAddress(MappingAddresses.ipv4MappingAddress(IPV4_PREFIX)).build();
    ObjectNode addressJson = gcAddressCodec.encode(address, context);
    assertThat(addressJson, LispGcAddressJsonMatcher.matchesGcAddress(address));
}
#method_after
@Test
public void testLispGcAddressEncode() {
    LispGcAddress address = new LispGcAddress.Builder().withIsNorth(NORTH).withLatitudeDegree(LATITUDE_DEGREE).withLatitudeMinute(LATITUDE_MINUTE).withLatitudeSecond(LATITUDE_SECOND).withIsEast(EAST).withLongitudeDegree(LONGITUDE_DEGREE).withLongitudeMinute(LONGITUDE_MINUTE).withLongitudeSecond(LONGITUDE_SECOND).withAltitude(ALTITUDE).withAddress(MappingAddresses.ipv4MappingAddress(IPV4_PREFIX)).build();
    ObjectNode addressJson = gcAddressCodec.encode(address, context);
    assertThat("errors in encoding Geo Coordinate address JSON", addressJson, LispGcAddressJsonMatcher.matchesGcAddress(address));
}
#end_block

#method_before
private LispGcAddress getLispGcAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispGcAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat(json, notNullValue());
    LispGcAddress gcAddress = gcAddressCodec.decode((ObjectNode) json, context);
    assertThat(gcAddress, notNullValue());
    return gcAddress;
}
#method_after
private LispGcAddress getLispGcAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispGcAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat("JSON string should not be null", json, notNullValue());
    LispGcAddress gcAddress = gcAddressCodec.decode((ObjectNode) json, context);
    assertThat("Decoded address should not be null", gcAddress, notNullValue());
    return gcAddress;
}
#end_block

#method_before
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    asAddressCodec = context.codec(LispAsAddress.class);
    assertThat(asAddressCodec, notNullValue());
}
#method_after
@Before
public void setUp() {
    CodecManager manager = new CodecManager();
    registrator = new LispMappingExtensionCodecRegistrator();
    registrator.codecService = manager;
    registrator.activate();
    context = new LispMappingExtensionCodecContextAdapter(registrator.codecService);
    asAddressCodec = context.codec(LispAsAddress.class);
    assertThat("AS address codec should not be null", asAddressCodec, notNullValue());
}
#end_block

#method_before
@Test
public void testLispAsAddressEncode() {
    LispAsAddress address = new LispAsAddress.Builder().withAsNumber(AS_NUMBER).withAddress(MappingAddresses.ipv4MappingAddress(IPV4_PREFIX)).build();
    ObjectNode addressJson = asAddressCodec.encode(address, context);
    assertThat(addressJson, LispAsAddressJsonMatcher.matchesAsAddress(address));
}
#method_after
@Test
public void testLispAsAddressEncode() {
    LispAsAddress address = new LispAsAddress.Builder().withAsNumber(AS_NUMBER).withAddress(MappingAddresses.ipv4MappingAddress(IPV4_PREFIX)).build();
    ObjectNode addressJson = asAddressCodec.encode(address, context);
    assertThat("errors in encoding AS address JSON", addressJson, LispAsAddressJsonMatcher.matchesAsAddress(address));
}
#end_block

#method_before
private LispAsAddress getLispAsAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispAsAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat(json, notNullValue());
    LispAsAddress asAddress = asAddressCodec.decode((ObjectNode) json, context);
    assertThat(asAddress, notNullValue());
    return asAddress;
}
#method_after
private LispAsAddress getLispAsAddress(String resourceName) throws IOException {
    InputStream jsonStream = LispAsAddressCodecTest.class.getResourceAsStream(resourceName);
    JsonNode json = context.mapper().readTree(jsonStream);
    assertThat("JSON string should not be null", json, notNullValue());
    LispAsAddress asAddress = asAddressCodec.decode((ObjectNode) json, context);
    assertThat("Decoded address should not be null", asAddress, notNullValue());
    return asAddress;
}
#end_block

#method_before
@Override
protected void execute() {
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    adminService.startAgent(NetworkId.networkId(networkId));
    print("Successfully stopped OFAgent for network %s", networkId);
}
#method_after
@Override
protected void execute() {
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    adminService.startAgent(NetworkId.networkId(networkId));
    print("Successfully started OFAgent for network %s", networkId);
}
#end_block

#method_before
@Override
protected void execute() {
    if (!isValidController(strCtrl)) {
        error("Invalid strCtrl string %s, must be IP:PORT", strCtrl);
        return;
    }
    OFAgentService service = get(OFAgentService.class);
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent existing = service.agent(NetworkId.networkId(networkId));
    if (existing == null) {
        error("OFAgent for network %s does not exist", networkId);
        return;
    }
    String[] temp = strCtrl.split(":");
    OFAgent updated = DefaultOFAgent.builder().from(existing).addController(DefaultOFController.of(IpAddress.valueOf(temp[0]), TpPort.tpPort(Integer.valueOf(temp[1])))).build();
    adminService.updateAgent(updated);
}
#method_after
@Override
protected void execute() {
    if (!isValidController(strCtrl)) {
        error("Invalid controller string %s, must be IP:PORT", strCtrl);
        return;
    }
    OFAgentService service = get(OFAgentService.class);
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent existing = service.agent(NetworkId.networkId(networkId));
    if (existing == null) {
        error("OFAgent for network %s does not exist", networkId);
        return;
    }
    String[] temp = strCtrl.split(":");
    OFAgent updated = DefaultOFAgent.builder().from(existing).addController(DefaultOFController.of(IpAddress.valueOf(temp[0]), TpPort.tpPort(Integer.valueOf(temp[1])))).build();
    adminService.updateAgent(updated);
}
#end_block

#method_before
@Override
protected void execute() {
    if (!isValidController(strCtrl)) {
        error("Invalid strCtrl string %s, must be IP:PORT", strCtrl);
        return;
    }
    OFAgentService service = get(OFAgentService.class);
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent existing = service.agent(NetworkId.networkId(networkId));
    if (existing == null) {
        error("OFAgent for network %s does not exist", networkId);
        return;
    }
    String[] temp = strCtrl.split(":");
    OFAgent updated = DefaultOFAgent.builder().from(existing).deleteController(DefaultOFController.of(IpAddress.valueOf(temp[0]), TpPort.tpPort(Integer.valueOf(temp[1])))).build();
    adminService.updateAgent(updated);
}
#method_after
@Override
protected void execute() {
    if (!isValidController(strCtrl)) {
        error("Invalid controller string %s, must be IP:PORT", strCtrl);
        return;
    }
    OFAgentService service = get(OFAgentService.class);
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent existing = service.agent(NetworkId.networkId(networkId));
    if (existing == null) {
        error("OFAgent for network %s does not exist", networkId);
        return;
    }
    String[] temp = strCtrl.split(":");
    OFAgent updated = DefaultOFAgent.builder().from(existing).deleteController(DefaultOFController.of(IpAddress.valueOf(temp[0]), TpPort.tpPort(Integer.valueOf(temp[1])))).build();
    adminService.updateAgent(updated);
}
#end_block

#method_before
// ////////////////////////////////////
// ICMP Echo/Reply Protocol     //
// ////////////////////////////////////
public void processIcmp(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv4 ipv4Packet = (IPv4) eth.getPayload();
    Ip4Address destinationAddress = Ip4Address.valueOf(ipv4Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIpv4(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    // ICMP to the router IP or gateway IP
    if (((ICMP) ipv4Packet.getPayload()).getIcmpType() == ICMP.TYPE_ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp4Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpResponse(eth, inPort);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv4Packet, destinationAddress);
    // ICMP for any known host
    } else if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        // TODO: known host packet should not be coming to controller - resend flows?
        srManager.ipHandler.forwardPackets(deviceId, destinationAddress);
    // ICMP for an unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, inPort);
    // ICMP for an unknown host
    } else {
        log.debug("ICMP request for unknown host {} ", destinationAddress);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv4Packet, destinationAddress);
    }
}
#method_after
// ////////////////////////////////////
// ICMP Echo/Reply Protocol     //
// ////////////////////////////////////
public void processIcmp(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv4 ipv4Packet = (IPv4) eth.getPayload();
    Ip4Address destinationAddress = Ip4Address.valueOf(ipv4Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIpv4(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    // ICMP to the router IP or gateway IP
    if (((ICMP) ipv4Packet.getPayload()).getIcmpType() == ICMP.TYPE_ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp4Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpResponse(eth, inPort);
    } else {
        log.trace("Ignore ICMP that targets for {}", destinationAddress);
    }
    // We remove the packet from the queue
    srManager.ipHandler.dequeuePacket(ipv4Packet, destinationAddress);
}
#end_block

#method_before
// /////////////////////////////////////////
// ICMPv6 Echo/Reply Protocol       //
// /////////////////////////////////////////
public void processIcmpv6(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv6 ipv6Packet = (IPv6) eth.getPayload();
    Ip6Address destinationAddress = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    ICMP6 icmp6 = (ICMP6) ipv6Packet.getPayload();
    // ICMP to the router IP or gateway IP
    if (icmp6.getIcmpType() == ICMP6.ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp6Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpv6Response(eth, inPort);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv6Packet, destinationAddress);
    // ICMP for any known host
    } else if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        // TODO: known host packet should not be coming to controller - resend flows?
        srManager.ipHandler.forwardPackets(deviceId, destinationAddress);
    // ICMP for an unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        sendNdpRequest(deviceId, destinationAddress, inPort);
    // ICMP for an unknown host or not configured host
    } else {
        log.debug("ICMPv6 request for unknown host or not configured host {} ", destinationAddress);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv6Packet, destinationAddress);
    }
}
#method_after
// /////////////////////////////////////////
// ICMPv6 Echo/Reply Protocol       //
// /////////////////////////////////////////
public void processIcmpv6(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv6 ipv6Packet = (IPv6) eth.getPayload();
    Ip6Address destinationAddress = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    ICMP6 icmp6 = (ICMP6) ipv6Packet.getPayload();
    // ICMP to the router IP or gateway IP
    if (icmp6.getIcmpType() == ICMP6.ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp6Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpv6Response(eth, inPort);
    } else {
        log.trace("Ignore ICMPv6 that targets for {}", destinationAddress);
    }
}
#end_block

#method_before
// /////////////////////////////////////////
// ICMPv6 Neighbour Discovery Protocol  //
// /////////////////////////////////////////
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    /*
         * First we validate the ndp packet
         */
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore NDP packets come from suppressed ports
        pkt.drop();
        return;
    }
    if (!validateSrcIp(pkt)) {
        log.trace("Ignore NDP packet discovered on {} with unexpected src ip address {}.", pkt.inPort(), pkt.sender());
        pkt.drop();
        return;
    }
    if (pkt.type() == NeighbourMessageType.REQUEST) {
        handleNdpRequest(pkt, hostService);
    } else {
        handleNdpReply(pkt, hostService);
    }
}
#method_after
// /////////////////////////////////////////
// ICMPv6 Neighbour Discovery Protocol  //
// /////////////////////////////////////////
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    // First we validate the ndp packet
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore NDP packets come from suppressed ports
        pkt.drop();
        return;
    }
    if (pkt.type() == NeighbourMessageType.REQUEST) {
        handleNdpRequest(pkt, hostService);
    } else {
        handleNdpReply(pkt, hostService);
    }
}
#end_block

#method_before
public void sendNdpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip6Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    if (!getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress)) {
        log.warn("Aborting sendNdpRequest, we cannot get all the information needed");
        return;
    }
    /*
         * We have to compute the dst mac address and dst
         * ip address.
         */
    byte[] dstIp = IPv6.getSolicitNodeAddress(targetAddress.toOctets());
    byte[] dstMac = IPv6.getMCastMacAddress(dstIp);
    /*
         * Creates the request.
         */
    Ethernet ndpRequest = NeighborSolicitation.buildNdpSolicit(targetAddress.toOctets(), senderIpAddress, dstIp, senderMacAddress, dstMac, VlanId.NONE);
    flood(ndpRequest, inPort, targetAddress);
}
#method_after
public void sendNdpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip6Address.BYTE_LENGTH];
    // Retrieves device info.
    if (!getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress)) {
        log.warn("Aborting sendNdpRequest, we cannot get all the information needed");
        return;
    }
    // We have to compute the dst mac address and dst ip address.
    byte[] dstIp = IPv6.getSolicitNodeAddress(targetAddress.toOctets());
    byte[] dstMac = IPv6.getMCastMacAddress(dstIp);
    // Creates the request.
    Ethernet ndpRequest = NeighborSolicitation.buildNdpSolicit(targetAddress.toOctets(), senderIpAddress, dstIp, senderMacAddress, dstMac, VlanId.NONE);
    flood(ndpRequest, inPort, targetAddress);
}
#end_block

#method_before
protected void updatePendingGroups(GroupKey gkey, GroupChainElem gce) {
    pendingGroups.asMap().compute(gkey, (k, val) -> {
        if (val == null) {
            val = Collections.newSetFromMap(new ConcurrentHashMap<GroupChainElem, Boolean>());
        }
        val.add(gce);
        return val;
    });
}
#method_after
protected void updatePendingGroups(GroupKey gkey, GroupChainElem gce) {
    pendingGroups.asMap().compute(gkey, (k, val) -> {
        if (val == null) {
            val = Sets.newConcurrentHashSet();
        }
        val.add(gce);
        return val;
    });
}
#end_block

#method_before
@Override
public int compare(PathAttrNlriDetailsLocalRib pathNlriDetails1, PathAttrNlriDetailsLocalRib pathNlriDetails2) {
    if (pathNlriDetails1 == null) {
        return -1;
    }
    if (pathNlriDetails2 == null) {
        return 1;
    }
    if (pathNlriDetails1.equals(pathNlriDetails2)) {
        return 0;
    }
    List<BgpValueType> o1 = pathNlriDetails1.localRibNlridetails().pathAttributes();
    List<BgpValueType> o2 = pathNlriDetails2.localRibNlridetails().pathAttributes();
    ListIterator<BgpValueType> listIteratorObj1 = o1.listIterator();
    ListIterator<BgpValueType> listIteratorObj2 = o2.listIterator();
    storeAttr(listIteratorObj1, listIteratorObj2);
    // prefer attribute with higher local preference
    if (obj1LocPref != null || obj2LocPref != null && (obj1LocPref != null && !obj1LocPref.equals(obj2LocPref))) {
        return compareLocalPref(obj1LocPref, obj2LocPref);
    }
    // prefer attribute with shortest Aspath
    if (!obj1Aspath.equals(obj2Aspath)) {
        Integer obj1Size = countASSize(obj1Aspath);
        Integer obj2Size = countASSize(obj2Aspath);
        if (!obj1Size.equals(obj2Size)) {
            return compareAsPath(obj1Size, obj2Size);
        }
    }
    // prefer attribute with lowest origin type
    if (!obj1Origin.equals(obj2Origin)) {
        return compareOrigin(obj1Origin, obj2Origin);
    }
    // prefer attribute with lowest MED
    if (obj1Med != null || obj2Med != null && (obj1Med != null && !obj1Med.equals(obj2Med))) {
        return compareMed(obj1Med, obj2Med);
    }
    return 0;
}
#method_after
@Override
public int compare(PathAttrNlriDetailsLocalRib pathNlriDetails1, PathAttrNlriDetailsLocalRib pathNlriDetails2) {
    if (pathNlriDetails1 == null) {
        return -1;
    }
    if (pathNlriDetails2 == null) {
        return 1;
    }
    if (pathNlriDetails1.equals(pathNlriDetails2)) {
        return 0;
    }
    List<BgpValueType> o1 = pathNlriDetails1.localRibNlridetails().pathAttributes();
    List<BgpValueType> o2 = pathNlriDetails2.localRibNlridetails().pathAttributes();
    ListIterator<BgpValueType> listIteratorObj1 = o1.listIterator();
    ListIterator<BgpValueType> listIteratorObj2 = o2.listIterator();
    storeAttr(listIteratorObj1, listIteratorObj2);
    // prefer attribute with higher local preference
    if (obj1LocPref != null || obj2LocPref != null && (obj1LocPref != null && !obj1LocPref.equals(obj2LocPref))) {
        return compareLocalPref(obj1LocPref, obj2LocPref);
    }
    // prefer attribute with shortest Aspath
    if (!obj1Aspath.equals(obj2Aspath)) {
        Integer obj1Size = countASSize(obj1Aspath);
        Integer obj2Size = countASSize(obj2Aspath);
        if (!obj1Size.equals(obj2Size)) {
            return compareAsPath(obj1Size, obj2Size);
        }
    }
    // prefer attribute with lowest origin type
    if (!obj1Origin.equals(obj2Origin)) {
        return compareOrigin(obj1Origin, obj2Origin);
    }
    // prefer attribute with lowest MED
    if (obj1Med != null || obj2Med != null && (obj1Med != null && !obj1Med.equals(obj2Med))) {
        return compareMed(obj1Med, obj2Med);
    }
    if (!pathNlriDetails1.equals(pathNlriDetails2)) {
        return comparePeerDetails(pathNlriDetails1, pathNlriDetails2);
    }
    return 0;
}
#end_block

#method_before
int comparePeerDetails(PathAttrNlriDetailsLocalRib pathNlriDetails1, PathAttrNlriDetailsLocalRib pathNlriDetails2) {
    // consider EBGP over IBGP
    if (pathNlriDetails1.isLocalRibIbgpSession() != pathNlriDetails2.isLocalRibIbgpSession()) {
        if (pathNlriDetails1 == null || pathNlriDetails1.isLocalRibIbgpSession()) {
            return -1;
        }
        if (pathNlriDetails2 == null || pathNlriDetails2.isLocalRibIbgpSession()) {
            return 1;
        }
    }
    // prefer lowest BGP identifier value.
    if (pathNlriDetails1.localRibIdentifier() != pathNlriDetails2.localRibIdentifier()) {
        return ((Integer) pathNlriDetails2.localRibIdentifier()).compareTo(pathNlriDetails1.localRibIdentifier());
    }
    // prefer lowest peer address
    if (pathNlriDetails1.localRibIpAddress() != pathNlriDetails2.localRibIpAddress()) {
        return pathNlriDetails2.localRibIpAddress().compareTo(pathNlriDetails1.localRibIpAddress());
    }
    return 0;
}
#method_after
int comparePeerDetails(PathAttrNlriDetailsLocalRib pathNlriDetails1, PathAttrNlriDetailsLocalRib pathNlriDetails2) {
    // consider EBGP over IBGP
    if (pathNlriDetails1.isLocalRibIbgpSession() != pathNlriDetails2.isLocalRibIbgpSession()) {
        if (pathNlriDetails1.isLocalRibIbgpSession()) {
            return -1;
        }
        if (pathNlriDetails2.isLocalRibIbgpSession()) {
            return 1;
        }
    }
    // prefer lowest BGP identifier value.
    if (pathNlriDetails1.localRibIdentifier() != pathNlriDetails2.localRibIdentifier()) {
        return ((Integer) pathNlriDetails2.localRibIdentifier()).compareTo(pathNlriDetails1.localRibIdentifier());
    }
    // prefer lowest peer address
    if (pathNlriDetails1.localRibIpAddress() != pathNlriDetails2.localRibIpAddress()) {
        return pathNlriDetails2.localRibIpAddress().compareTo(pathNlriDetails1.localRibIpAddress());
    }
    return 0;
}
#end_block

#method_before
static String getIdFromModId(ModelObjectId id, boolean isIns) {
    if (id == null) {
        return null;
    }
    List<AtomicPath> paths = id.atomicPaths();
    int size = paths.size();
    if (size == 1) {
        return CONS_DEVICES;
    } else if (size == 2) {
        if (isIns) {
            return ((org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.instance.rev20160623.ietfnetworkinstance.devices.DeviceKeys) ((MultiInstanceNode) paths.get(1)).key()).deviceid();
        } else {
            return ((DeviceKeys) ((MultiInstanceNode) paths.get(1)).key()).deviceid();
        }
    } else {
        throw new IllegalArgumentException(MODEL_OBJ_ID_LIMIT);
    }
}
#method_after
static String getIdFromModId(ModelObjectId id, boolean isIns) {
    if (id == null) {
        return null;
    }
    List<AtomicPath> paths = id.atomicPaths();
    int size = paths.size();
    switch(size) {
        case 1:
            return CONS_DEVICES;
        case 2:
            return getDevId(paths, isIns);
        default:
            throw new IllegalArgumentException(MODEL_OBJ_ID_LIMIT);
    }
}
#end_block

#method_before
private void remVpnBgp(DeviceInfo dev) {
    BgpInfo devBgp = dev.bgpInfo();
    l3VpnStore.removeBgpInfo(devBgp);
    BgpInfo delInfo = new BgpInfo();
    delInfo.vpnName(devBgp.vpnName());
    String id = dev.deviceId().toString();
    Map<BgpInfo, DeviceId> bgpMap = l3VpnStore.getBgpInfo();
    BgpDriverInfo driConfig = getVpnBgpDelModObj(bgpMap, id);
    ModelObjectData driData = dev.processDeleteBgpInfo(driverService, delInfo, driConfig);
    ResourceData resData = modelConverter.createDataNode(driData);
    deleteFromStore(resData);
    l3VpnStore.removeBgpInfo(devBgp);
}
#method_after
private void remVpnBgp(DeviceInfo dev) {
    BgpInfo devBgp = dev.bgpInfo();
    if (devBgp != null) {
        l3VpnStore.removeBgpInfo(devBgp);
        BgpInfo delInfo = new BgpInfo();
        delInfo.vpnName(devBgp.vpnName());
        String id = dev.deviceId().toString();
        Map<BgpInfo, DeviceId> bgpMap = l3VpnStore.getBgpInfo();
        BgpDriverInfo driConfig = getVpnBgpDelModObj(bgpMap, id);
        ModelObjectData driData = dev.processDeleteBgpInfo(driverService, delInfo, driConfig);
        ResourceData resData = modelConverter.createDataNode(driData);
        deleteFromStore(resData);
        l3VpnStore.removeBgpInfo(devBgp);
    }
}
#end_block

#method_before
/**
 * Deletes the resource data that is received from the driver, after
 * converting from the model object data.
 *
 * @param resData resource data
 */
private void deleteFromStore(ResourceData resData) {
    if (resData != null) {
        configService.deleteNodeRecursive(resData.resourceId());
    }
}
#method_after
private void deleteFromStore(ResourceData resData) {
    if (resData != null) {
        configService.deleteNodeRecursive(resData.resourceId());
    }
}
#end_block

#method_before
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
    // Port statistics discovery
    if (device.is(PortStatisticsDiscovery.class)) {
        PortStatisticsDiscovery d = device.as(PortStatisticsDiscovery.class);
        providerService.updatePortStatistics(deviceId, d.discoverPortStatistics());
    } else {
        log.warn("No port statistics getter behaviour for device {}", deviceId);
    }
}
#method_after
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
    // Port statistics discovery
    updatePortStatistics(device);
}
#end_block

#method_before
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
    // Port statistics discovery
    if (device.is(PortDescriptionDiscovery.class)) {
        PortDescriptionDiscovery d = device.as(PortDescriptionDiscovery.class);
        providerService.updatePortStatistics(deviceId, d.discoverPortStatistics());
    } else {
        log.warn("No port statistics getter behaviour for device {}", deviceId);
    }
}
#method_after
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
    // Port statistics discovery
    if (device.is(PortStatisticsDiscovery.class)) {
        PortStatisticsDiscovery d = device.as(PortStatisticsDiscovery.class);
        providerService.updatePortStatistics(deviceId, d.discoverPortStatistics());
    } else {
        log.warn("No port statistics getter behaviour for device {}", deviceId);
    }
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective fwd) {
    if (checkForMulticast(fwd)) {
        processMulticastRule(fwd);
        return;
    }
    TrafficTreatment treatment = fwd.treatment();
    List<Instruction> instructions = treatment.allInstructions();
    Optional<Instruction> vlanIntruction = instructions.stream().filter(i -> i.type() == Instruction.Type.L2MODIFICATION).filter(i -> ((L2ModificationInstruction) i).subtype() == L2ModificationInstruction.L2SubType.VLAN_PUSH || ((L2ModificationInstruction) i).subtype() == L2ModificationInstruction.L2SubType.VLAN_POP).findAny();
    if (vlanIntruction.isPresent()) {
        L2ModificationInstruction vlanIns = (L2ModificationInstruction) vlanIntruction.get();
        if (vlanIns.subtype() == L2ModificationInstruction.L2SubType.VLAN_PUSH) {
            installUpstreamRules(fwd);
        } else if (vlanIns.subtype() == L2ModificationInstruction.L2SubType.VLAN_POP) {
            installDownstreamRules(fwd);
        } else {
            log.error("Unknown OLT operation: {}", fwd);
            fail(fwd, ObjectiveError.UNSUPPORTED);
            return;
        }
        pass(fwd);
    } else {
        TrafficSelector selector = fwd.selector();
        EthTypeCriterion ethType = (EthTypeCriterion) filterForCriterion(fwd.selector().criteria(), Criterion.Type.ETH_TYPE);
        if (ethType != null && ethType.ethType().equals(EthType.EtherType.EAPOL.ethType())) {
            return;
        }
        if (fwd.treatment() != null) {
            // Deal with SPECIFIC and VERSATILE in the same manner.
            FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(fwd.treatment());
            if (fwd.permanent()) {
                ruleBuilder.makePermanent();
            } else {
                ruleBuilder.makeTemporary(fwd.timeout());
            }
            installObjective(ruleBuilder, fwd);
        } else {
            log.error("No treatment error: {}", fwd);
            fail(fwd, ObjectiveError.UNSUPPORTED);
        }
    }
}
#method_after
@Override
public void forward(ForwardingObjective fwd) {
    if (checkForMulticast(fwd)) {
        processMulticastRule(fwd);
        return;
    }
    if (checkForEAPOL(fwd)) {
        log.warn("Discarding EAPOL flow which is not supported on this pipeline");
        return;
    }
    TrafficTreatment treatment = fwd.treatment();
    List<Instruction> instructions = treatment.allInstructions();
    Optional<Instruction> vlanIntruction = instructions.stream().filter(i -> i.type() == Instruction.Type.L2MODIFICATION).filter(i -> ((L2ModificationInstruction) i).subtype() == L2ModificationInstruction.L2SubType.VLAN_PUSH || ((L2ModificationInstruction) i).subtype() == L2ModificationInstruction.L2SubType.VLAN_POP).findAny();
    if (vlanIntruction.isPresent()) {
        L2ModificationInstruction vlanIns = (L2ModificationInstruction) vlanIntruction.get();
        if (vlanIns.subtype() == L2ModificationInstruction.L2SubType.VLAN_PUSH) {
            installUpstreamRules(fwd);
        } else if (vlanIns.subtype() == L2ModificationInstruction.L2SubType.VLAN_POP) {
            installDownstreamRules(fwd);
        } else {
            log.error("Unknown OLT operation: {}", fwd);
            fail(fwd, ObjectiveError.UNSUPPORTED);
            return;
        }
        pass(fwd);
    } else {
        TrafficSelector selector = fwd.selector();
        if (fwd.treatment() != null) {
            // Deal with SPECIFIC and VERSATILE in the same manner.
            FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(fwd.treatment());
            if (fwd.permanent()) {
                ruleBuilder.makePermanent();
            } else {
                ruleBuilder.makeTemporary(fwd.timeout());
            }
            installObjective(ruleBuilder, fwd);
        } else {
            log.error("No treatment error: {}", fwd);
            fail(fwd, ObjectiveError.UNSUPPORTED);
        }
    }
}
#end_block

