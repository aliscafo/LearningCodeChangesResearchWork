967
#method_before
// The domain realm section is the following section
// [domain_realm]
// .example.com = EXAMPLE.COM
private String appendDomainRealms(List<String> realms) throws AuthenticationException {
    StringBuffer text = new StringBuffer(" [domain_realm]\n");
    if (!domainRealmMappingFileExits()) {
        for (String realm : realms) {
            text.append("\t" + realm.toLowerCase() + " = " + realm.toUpperCase() + "\n");
        }
    } else {
        // This can be useful in case the realm is not an upper case of the domain
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(domainRealmMappingFile), "UTF-8"))) {
            while (true) {
                String readLine = reader.readLine();
                if (readLine == null) {
                    break;
                }
                text.append("\t").append(readLine).append("\n");
            }
        } catch (FileNotFoundException e) {
        // This exception should not really happen as we check that the file exists at
        // domainRealmMappingFileExits()
        } catch (IOException e) {
        }
    }
    return text.toString();
}
#method_after
// The domain realm section is the following section
// [domain_realm]
// .example.com = EXAMPLE.COM
private String appendDomainRealms(List<String> realms) throws AuthenticationException {
    StringBuffer text = new StringBuffer(" [domain_realm]\n");
    if (!domainRealmMappingFileExits()) {
        for (String realm : realms) {
            text.append("\t" + realm.toLowerCase() + " = " + realm.toUpperCase() + "\n");
        }
    } else {
        // This can be useful in case the realm is not an upper case of the domain
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(domainRealmMappingFile), java.nio.charset.Charset.defaultCharset().displayName()))) {
            while (true) {
                String readLine = reader.readLine();
                if (readLine == null) {
                    break;
                }
                text.append("\t").append(readLine).append("\n");
            }
        } catch (FileNotFoundException e) {
        // This exception should not really happen as we check that the file exists at
        // domainRealmMappingFileExits()
        } catch (IOException e) {
        }
    }
    return text.toString();
}
#end_block

#method_before
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#method_after
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    modelTimer.setRefreshRate(readRefreshRate());
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#end_block

#method_before
protected void listenOnManualRefresh() {
    refreshPanel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (manualRefreshCallback != null) {
                manualRefreshCallback.onManualRefresh();
            }
            controller.refresh();
        }
    });
}
#method_after
protected void listenOnManualRefresh() {
    refreshPanel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (manualRefreshCallback != null) {
                manualRefreshCallback.onManualRefresh();
            }
            ManualRefreshEvent.fire(AbstractRefreshManager.this);
            controller.refresh();
        }
    });
}
#end_block

#method_before
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    getModelTimer().setRefreshRate(readRefreshRate());
    updateTimer();
}
#method_after
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    updateTimer();
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    getModelProvider().getModel().getTimer().addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            getView().setRefreshButtonVisibility(!getModelProvider().getModel().getTimer().isActive());
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getEventBus().addHandler(ManualRefreshEvent.getType(), new ManualRefreshHandler() {

        @Override
        public void onManualRefresh(ManualRefreshEvent event) {
            if (SubTabHostInterfacePresenter.this.isVisible() && SubTabHostInterfacePresenter.this.getModelProvider().getModel().equals(event.getSource())) {
                getView().removeContent();
            }
        }
    }));
    getModelProvider().getModel().getTimer().addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            getView().setRefreshButtonVisibility(!getModelProvider().getModel().getTimer().isActive());
        }
    });
}
#end_block

#method_before
private boolean activateDataCenter() {
    boolean result = false;
    _fenceSpmCalled = false;
    StorageDomain masterDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePool().getId()), new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain != null && masterDomain.getStatus() != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.InActive)) {
        if (!getStoragePool().isLocal()) {
            // if only one\"the fenced" host connected to sp in dc
            if (getAmountOfVdssInPoll() == 1) {
                resetIrs();
                result = true;
            } else {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        SpmStatusResult statusResult = (SpmStatusResult) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vds.getId(), getStoragePool().getId())).getReturnValue();
                        log.infoFormat("Trying to fence spm {0} via vds {1}", _problematicVds.getName(), vds.getName());
                        if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceSpmStorage, new FenceSpmStorageVDSCommandParameters(vds.getId(), getStoragePool().getId(), statusResult.getSpmId(), statusResult.getSpmLVER())).getSucceeded()) {
                            resetIrs();
                            result = true;
                            _fenceSpmCalled = true;
                            break;
                        }
                    } catch (java.lang.Exception e) {
                        log.warnFormat("Could not fence spm on vds {0}", vds.getName());
                    }
                }
            }
        } else {
            resetIrs();
            result = true;
        }
    } else {
        result = true;
    }
    return result;
}
#method_after
private boolean activateDataCenter() {
    boolean result = false;
    _fenceSpmCalled = false;
    StorageDomain masterDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePool().getId()), new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain != null && masterDomain.getStatus() != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.InActive)) {
        if (!getStoragePool().isLocal()) {
            // if only one\"the fenced" host connected to sp in dc
            if (getAmountOfVdssInPool() == 1) {
                resetIrs();
                result = true;
            } else {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        SpmStatusResult statusResult = (SpmStatusResult) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vds.getId(), getStoragePool().getId())).getReturnValue();
                        log.infoFormat("Trying to fence spm {0} via vds {1}", _problematicVds.getName(), vds.getName());
                        if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceSpmStorage, new FenceSpmStorageVDSCommandParameters(vds.getId(), getStoragePool().getId(), statusResult.getSpmId(), statusResult.getSpmLVER())).getSucceeded()) {
                            resetIrs();
                            result = true;
                            _fenceSpmCalled = true;
                            break;
                        }
                    } catch (java.lang.Exception e) {
                        log.warnFormat("Could not fence spm on vds {0}", vds.getName());
                    }
                }
            }
        } else {
            resetIrs();
            result = true;
        }
    } else {
        result = true;
    }
    return result;
}
#end_block

#method_before
private void mainLogic() {
    try {
        try {
            log.debug("Start event notification service iteration");
            // Clear filter chain
            firstMatchSimpleFilter.clearFilterEntries();
            // Read Database subscriptions first
            firstMatchSimpleFilter.addFilterEntries(eventsManager.getAuditLogEventSubscribers());
            // Backward compatibility, aim to remove (can be replaced by "FILTER")
            String dbDownSubscribers = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
            if (!StringUtils.isEmpty(dbDownSubscribers)) {
                for (String subscriber : dbDownSubscribers.split(",")) {
                    new FirstMatchSimpleFilter.FilterEntry(EventsManager.DATABASE_UNREACHABLE, false, EventNotificationMethod.SMTP.name(), subscriber);
                }
            }
            // Add configurations subscription
            firstMatchSimpleFilter.addFilterEntries(configurationFilters);
            for (AuditLogEvent event : eventsManager.getAuditLogEvents()) {
                firstMatchSimpleFilter.processEvent(event);
                eventsManager.updateAuditLogEventProcessed(event.getId());
            }
            deleteObsoleteHistoryData();
            log.debug("Finished event notification service iteration");
        } catch (SQLException se) {
            distributeDbDownEvent();
            throw se;
        }
    } catch (Throwable t) {
        log.error(String.format("Failed to run the service."), t);
    }
}
#method_after
private void mainLogic() {
    try {
        try {
            log.debug("Start event notification service iteration");
            // Clear filter chain
            firstMatchSimpleFilter.clearFilterEntries();
            // Read Database subscriptions first
            firstMatchSimpleFilter.addFilterEntries(eventsManager.getAuditLogEventSubscribers());
            // Backward compatibility, aim to remove (can be replaced by "FILTER")
            String dbDownSubscribers = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
            if (!StringUtils.isEmpty(dbDownSubscribers)) {
                for (String subscriber : dbDownSubscribers.split(",")) {
                    new FirstMatchSimpleFilter.FilterEntry(EventsManager.DATABASE_UNREACHABLE, false, EventNotificationMethod.SMTP.getAsString(), subscriber);
                }
            }
            // Add configurations subscription
            firstMatchSimpleFilter.addFilterEntries(configurationFilters);
            for (AuditLogEvent event : eventsManager.getAuditLogEvents()) {
                firstMatchSimpleFilter.processEvent(event);
                eventsManager.updateAuditLogEventProcessed(event.getId());
            }
            deleteObsoleteHistoryData();
            log.debug("Finished event notification service iteration");
        } catch (SQLException se) {
            distributeDbDownEvent();
            throw se;
        }
    } catch (Throwable t) {
        log.error(String.format("Failed to run the service."), t);
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    for (String domain : LdapBrokerUtils.getDomainsList()) {
        Map<ExtensionProperties, Object> dirContext = new EnumMap<>(ExtensionProperties.class);
        Properties dirProps = new Properties();
        dirProps.put("ovirt.engine.aaa.authz.profile.name", domain);
        dirContext.put(ExtensionProperties.CONFIGURATION, dirProps);
        dirContext.put(ExtensionProperties.NAME, domain);
        Directory directory = new ProvisionalDirectory();
        directory.setContext(dirContext);
        directory.init();
        Map<ExtensionProperties, Object> authContext = new EnumMap<>(ExtensionProperties.class);
        Properties authProps = new Properties();
        authProps.put("ovirt.engine.aaa.authn.profile.name", domain);
        authContext.put(ExtensionProperties.CONFIGURATION, authProps);
        authContext.put(ExtensionProperties.NAME, domain);
        Authenticator authenticator = new ProvisionalAuthenticator();
        authenticator.setContext(authContext);
        authenticator.init();
        AuthenticationProfile profile = new AuthenticationProfile(authenticator, directory);
        AuthenticationProfileRepository.getInstance().registerProfile(profile);
    }
    ExtensionManager.getInstance().load();
    AuthenticationProfileRepository.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    for (String domain : LdapBrokerUtils.getDomainsList()) {
        Map<ExtensionProperties, Object> dirContext = new EnumMap<>(ExtensionProperties.class);
        Properties dirProps = new Properties();
        dirProps.put("ovirt.engine.aaa.authz.profile.name", domain);
        dirContext.put(ExtensionProperties.CONFIGURATION, dirProps);
        dirContext.put(ExtensionProperties.NAME, domain);
        Directory directory = new ProvisionalDirectory();
        directory.setContext(dirContext);
        directory.init();
        Map<ExtensionProperties, Object> authContext = new EnumMap<>(ExtensionProperties.class);
        Properties authProps = new Properties();
        authProps.put("ovirt.engine.aaa.authn.profile.name", domain);
        authContext.put(ExtensionProperties.CONFIGURATION, authProps);
        authContext.put(ExtensionProperties.NAME, domain);
        Authenticator authenticator = new ProvisionalAuthenticator();
        authenticator.setContext(authContext);
        authenticator.init();
        AuthenticationProfile profile = new AuthenticationProfile(authenticator, directory);
        AuthenticationProfileRepository.getInstance().registerProfile(profile);
    }
    AuthenticationProfileRepository.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#end_block

#method_before
public void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#method_after
private void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#end_block

#method_before
private void activate() {
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper ENGINE_EXTENSION_ENABLE_<NAME> entry exists at the engine config.
        entry.enabled = EngineLocalConfig.getInstance().getBoolean("ENGINE_EXTENSION_ENABLE_" + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
}
#method_after
private void activate() {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper entry exists at the engine config.
        entry.enabled = config.getBoolean(ENGINE_EXTENSION_ENABLED + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                entry.enabled = false;
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void init() {
    admin = new DirectoryUser(getProfileName(), ADMIN_ID, ADMIN_NAME);
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authorization");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    admin = new DirectoryUser(getProfileName(), ADMIN_ID, ADMIN_NAME);
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authorization (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Provisional Authentication (LbapBroker code based)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Provisional Authorization (LbapBroker code based)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authorization (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
public void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#method_after
private void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#end_block

#method_before
private void activate() {
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper ENGINE_EXTENSION_ENABLE_<NAME> entry exists at the engine config.
        entry.enabled = EngineLocalConfig.getInstance().getBoolean("ENGINE_EXTENSION_ENABLE_" + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
    log.info("Activated extensions list: ");
    for (ExtensionEntry entry : loadedEntries.values()) {
        if (entry.extension != null) {
            log.info(String.format("Name: %1$s Author %2$s Version %3$s Home: %4$s License: %5$s", emptyIfNull(entry.extension.getContext().get(ExtensionProperties.EXTENSION_NAME)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.AUTHOR)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.VERSION)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.HOME)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.LICENSE))));
        }
    }
    log.info("End of activated extensions list");
}
#method_after
private void activate() {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper entry exists at the engine config.
        entry.enabled = config.getBoolean(ENGINE_EXTENSION_ENABLED + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                entry.enabled = false;
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
    logEnabledExtensions();
}
#end_block

#method_before
private String emptyIfNull(Object value) {
    return value == null ? "" : value.toString();
}
#method_after
private Object emptyIfNull(Object value) {
    return value == null ? "" : value;
}
#end_block

#method_before
private Guid createTemplate() {
    VmTemplate blankTemplate = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    DiskImage templateDiskImage = getEnclosingCommand().getParameters().getDiskImage();
    // Following the same convention as the glance disk name, using a GlanceTemplate prefix, followed by a short identifier
    String vmTemplateName = "GlanceTemplate-" + Guid.newGuid().toString().substring(0, 7);
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    if (getEnclosingCommand().getParameters().getClusterId() != null) {
        masterVm.setVdsGroupId(getEnclosingCommand().getParameters().getClusterId());
    }
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContexForTasks(getEnclosingCommand().getExecutionContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#method_after
private Guid createTemplate() {
    VmTemplate blankTemplate = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    DiskImage templateDiskImage = getEnclosingCommand().getParameters().getDiskImage();
    // Following the same convention as the glance disk name, using a GlanceTemplate prefix, followed by a short identifier
    String vmTemplateName = "GlanceTemplate-" + Guid.newGuid().toString().substring(0, 7);
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    // Setting the cluster ID, and other related properties derived from it
    if (getEnclosingCommand().getParameters().getClusterId() != null) {
        masterVm.setVdsGroupId(getEnclosingCommand().getParameters().getClusterId());
        VDSGroup vdsGroup = getVdsGroup(masterVm.getVdsGroupId());
        masterVm.setOsId(osRepository.getDefaultOSes().get(vdsGroup.getArchitecture()));
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(masterVm.getOsId(), vdsGroup.getcompatibility_version()).get(0);
        masterVm.setDefaultDisplayType(defaultDisplayType);
    }
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContexForTasks(getEnclosingCommand().getExecutionContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#end_block

#method_before
protected void updateClusters(Guid storagePoolId) {
    INewAsyncCallback callback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ImportExportRepoImageBaseModel model = (ImportExportRepoImageBaseModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            model.getCluster().setItems(clusters);
            model.getCluster().setIsEmpty(clusters.isEmpty());
            model.updateControlsAvailability();
            stopProgress();
        }
    };
    startProgress(null);
    if (storagePoolId != null) {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback), storagePoolId);
    } else {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback));
    }
}
#method_after
protected void updateClusters(Guid storagePoolId) {
    INewAsyncCallback callback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ImportExportRepoImageBaseModel model = (ImportExportRepoImageBaseModel) target;
            List<VDSGroup> clusters = AsyncDataProvider.filterClustersWithoutArchitecture((List<VDSGroup>) returnValue);
            model.getCluster().setItems(clusters);
            model.getCluster().setIsEmpty(clusters.isEmpty());
            model.updateControlsAvailability();
            stopProgress();
        }
    };
    startProgress(null);
    if (storagePoolId != null) {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback), storagePoolId);
    } else {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback));
    }
}
#end_block

#method_before
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    models.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    models.add(fcpDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    GlusterDataModel.setRole(StorageDomainType.Data);
    models.add(GlusterDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    models.add(localDataModel);
    return models;
}
#method_after
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    models.add(nfsDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    models.add(GlusterDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    models.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    models.add(localDataModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.Data);
    }
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    models.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    models.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    models.add(nfsIsoModel);
    return models;
}
#method_after
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.ISO);
    }
    return models;
}
#end_block

#method_before
@Override
public final void run() {
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "].run() called");
    if (repetitions > 0) {
        repetitions--;
    } else if (repetitions == 0) {
        cycleRate();
    }
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    "GridTimer[" + name + "] Executing! Current Rate: " + rateCycle[currentRate] + ":" + getRefreshRate() + // $NON-NLS-1$
    " Reps: " + repetitions);
    execute();
}
#method_after
@Override
public final void run() {
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "].run() called");
    if (repetitions > 0) {
        repetitions--;
    } else if (repetitions == 0) {
        cycleRate();
    }
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$
    "GridTimer[" + name + "] Executing! Current Rate: " + rateCycle[currentRate] + ":" + // $NON-NLS-1$
    getRefreshRate() + // $NON-NLS-1$
    " Reps: " + repetitions);
    execute();
}
#end_block

#method_before
public void setRefreshRate(int interval) {
    if (getRefreshRate() == interval) {
        return;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "]: Refresh Rate set to: " + interval);
    // set the NORMAL interval
    normalInterval = interval;
    ValueChangeEvent.fire(this, getRefreshRate());
}
#method_after
public void setRefreshRate(int interval) {
    if (getRefreshRate() == interval) {
        return;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "]: Refresh Rate set to: " + interval);
    // set the NORMAL interval
    normalInterval = interval;
    GridTimerStateChangeEvent.fire(this, getRefreshRate());
}
#end_block

#method_before
private void cycleRate() {
    currentRate = (currentRate + 1) % rateCycle.length;
    RATE rate = rateCycle[currentRate];
    repetitions = rate.getRepetitions();
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
    "GridTimer[" + name + "] Rate Cycled: Current Rate: " + rate + " Reps: " + repetitions + " Interval: " + rate.getInterval());
    cancel();
    start();
    if (rate == RATE.NORMAL) {
        ValueChangeEvent.fire(this, getRefreshRate());
    }
}
#method_after
private void cycleRate() {
    currentRate = (currentRate + 1) % rateCycle.length;
    RATE rate = rateCycle[currentRate];
    repetitions = rate.getRepetitions();
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$
    "GridTimer[" + name + "] Rate Cycled: Current Rate: " + rate + " Reps: " + repetitions + // $NON-NLS-1$ //$NON-NLS-2$
    " Interval: " + rate.getInterval());
    cancel();
    start();
    if (rate == RATE.NORMAL) {
        GridTimerStateChangeEvent.fire(this, getRefreshRate());
    }
}
#end_block

#method_before
public final void setEventBus(EventBus eventBus) {
    if (eventBus == null) {
        unregisterHandlers();
        this.eventBus = null;
    } else if (this.eventBus == null || this.eventBus != eventBus) {
        this.eventBus = eventBus;
        registerHandlers();
    }
}
#method_after
public final void setEventBus(EventBus eventBus) {
    // $NON-NLS-1$
    assert eventBus != null : "EventBus cannot be null";
    // $NON-NLS-1$
    assert this.eventBus == null : "EventBus is already set";
    this.eventBus = eventBus;
    registerHandlers();
}
#end_block

#method_before
protected void registerHandlers() {
// No-op, sub classes override.
}
#method_after
protected void registerHandlers() {
// No-op, override as necessary
}
#end_block

#method_before
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#method_after
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    modelTimer.setRefreshRate(readRefreshRate());
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#end_block

#method_before
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    getModelTimer().setRefreshRate(readRefreshRate());
    updateTimer();
}
#method_after
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    updateTimer();
}
#end_block

#method_before
public void setSearchString(String value) {
    if (!ObjectUtils.objectsEqual(searchString, value)) {
        searchString = value;
        searchStringChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchString"));
    }
}
#method_after
public void setSearchString(String value) {
    if (!ObjectUtils.objectsEqual(searchString, value)) {
        searchString = value;
        pagingSearchString = null;
        searchStringChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchString"));
    }
}
#end_block

#method_before
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            int newInterval = event.getValue();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval);
            }
        }
    });
}
#method_after
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            int newInterval = event.getRefreshRate();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval);
            }
        }
    });
}
#end_block

#method_before
protected void searchNextPage() {
    setSearchStringPage(getNextSearchPageNumber());
    getSearchCommand().execute();
}
#method_after
protected void searchNextPage() {
    searchString = stripPageKeyword(searchString);
    setSearchStringPage(getNextSearchPageNumber());
    getSearchCommand().execute();
}
#end_block

#method_before
protected void searchPreviousPage() {
    setSearchStringPage(getPreviousSearchPageNumber());
    getSearchCommand().execute();
}
#method_after
protected void searchPreviousPage() {
    searchString = stripPageKeyword(searchString);
    setSearchStringPage(getPreviousSearchPageNumber());
    getSearchCommand().execute();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getid())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (paramConnection.getstorage_type() == StorageType.NFS && !new NfsMountPointConstraint().isValid(paramConnection.getconnection(), null)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (paramConnection.getstorage_type() == StorageType.POSIXFS && (StringUtils.isEmpty(paramConnection.getVfsType()))) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && StringUtils.isEmpty(paramConnection.getiqn())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && (StringUtils.isEmpty(paramConnection.getport()) || Integer.parseInt(paramConnection.getport()) <= 0)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
    }
    if (checkIsConnectionFieldEmpty(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failCanDoAction(VdcBllMessages.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getid())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (paramConnection.getstorage_type() == StorageType.NFS && !new NfsMountPointConstraint().isValid(paramConnection.getconnection(), null)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (paramConnection.getstorage_type() == StorageType.POSIXFS && (StringUtils.isEmpty(paramConnection.getVfsType()))) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && StringUtils.isEmpty(paramConnection.getiqn())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && !isValidStorageConnectionPort(paramConnection.getport())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
    }
    if (checkIsConnectionFieldEmpty(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failCanDoAction(VdcBllMessages.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(false);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
protected void initializeVds() {
    initializeVds(true);
}
#method_after
protected void initializeVds() {
    initializeVds(false);
}
#end_block

#method_before
protected void initializeVds(boolean expectHostToBeFound) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId(), expectHostToBeFound));
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddVds, new AddVdsVDSCommandParameters(getVdsId()));
}
#method_after
protected void initializeVds(boolean newHost) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId(), newHost));
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddVds, new AddVdsVDSCommandParameters(getVdsId()));
}
#end_block

#method_before
public void RemoveVds(Guid vdsId) {
    RemoveVds(vdsId, true);
}
#method_after
public void RemoveVds(Guid vdsId) {
    RemoveVds(vdsId, false);
}
#end_block

#method_before
public void RemoveVds(Guid vdsId, boolean errorIfManagerNotFound) {
    VdsManager vdsManager = GetVdsManager(vdsId, errorIfManagerNotFound);
    if (vdsManager != null) {
        vdsManager.dispose();
        vdsManagersDict.remove(vdsId);
    }
}
#method_after
public void RemoveVds(Guid vdsId, boolean newHost) {
    VdsManager vdsManager = GetVdsManager(vdsId, newHost);
    if (vdsManager != null) {
        vdsManager.dispose();
        vdsManagersDict.remove(vdsId);
    }
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId) {
    return GetVdsManager(vdsId, true);
}
#method_after
public VdsManager GetVdsManager(Guid vdsId) {
    return GetVdsManager(vdsId, false);
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId, boolean errorIfManagerNotFound) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (errorIfManagerNotFound) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        } else {
            log.infoFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#method_after
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    ResourceManager.getInstance().RemoveVds(getVdsId(), parameters.isErrorIfHostDoesntExist());
}
#method_after
@Override
protected void executeVdsIdCommand() {
    ResourceManager.getInstance().RemoveVds(getVdsId(), parameters.isNewHost());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DirectoryEntry other = (DirectoryEntry) obj;
    return ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(status, other.status) && ObjectUtils.objectsEqual(directoryName, other.directoryName);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DirectoryEntry other = (DirectoryEntry) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(status, other.status) && ObjectUtils.objectsEqual(directoryName, other.directoryName));
}
#end_block

#method_before
public static AuthenticationProfileRepository getInstance() {
    return instance;
}
#method_after
public static AuthenticationProfileRepository getInstance() {
    if (instance == null) {
        synchronized (AuthenticationProfileRepository.class) {
            if (instance == null) {
                instance = new AuthenticationProfileRepository();
            }
        }
    }
    return instance;
}
#end_block

#method_before
public void registerProfile(String name, AuthenticationProfile profile) {
    profiles.put(name, profile);
}
#method_after
public void registerProfile(AuthenticationProfile profile) {
    profiles.put(profile.getName(), profile);
}
#end_block

#method_before
public Authenticator create(Configuration config) throws ConfigurationException {
    String profileName = config.getString(PROFILE_NAME_KEY);
    Authenticator authenticator = createImpl(profileName, config);
    return authenticator;
}
#method_after
public Authenticator create(Configuration config) throws ConfigurationException {
    return createImpl(config.getString(PROFILE_NAME_KEY), config);
}
#end_block

#method_before
public VM getVmFromConfiguration(String configuration, Guid vmId, Guid snapshotId) {
    VM vm;
    if (configuration != null) {
        vm = getVmWithConfiguration(configuration, vmId);
        Snapshot snapshot = getSnapshotDao().get(snapshotId);
        if (snapshot != null && snapshot.getType() != Snapshot.SnapshotType.PREVIEW) {
            // No need to mark disks of 'PREVIEW' snapshot as illegal
            // as it represents previous 'Active VM' state.
            markImagesIllegalIfNotInDb(vm, snapshotId);
        }
    } else {
        vm = getVmWithoutConfiguration(vmId, snapshotId);
    }
    VmHandler.updateDisksForVm(vm, vm.getImages());
    return vm;
}
#method_after
public VM getVmFromConfiguration(String configuration, Guid vmId, Guid snapshotId) {
    VM vm;
    if (configuration != null) {
        vm = getVmWithConfiguration(configuration, vmId);
        Snapshot snapshot = getSnapshotDao().get(snapshotId);
        if (snapshot != null && snapshot.getType() != Snapshot.SnapshotType.PREVIEW) {
            // No need to mark disks of 'PREVIEW' snapshot as illegal
            // as it represents previous 'Active VM' state and no operations
            // on disks can be done while previewing a snapshot.
            markImagesIllegalIfNotInDb(vm, snapshotId);
        }
    } else {
        vm = getVmWithoutConfiguration(vmId, snapshotId);
    }
    VmHandler.updateDisksForVm(vm, vm.getImages());
    return vm;
}
#end_block

#method_before
@Override
public IsoListReturnForXmlRpc getIsoList(String spUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getIsoList(spUUID);
        IsoListReturnForXmlRpc wrapper = new IsoListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public FileStatsReturnForXmlRpc getIsoList(String spUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getIsoList(spUUID);
        FileStatsReturnForXmlRpc wrapper = new FileStatsReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.isHostedEngine()) {
                            // The Hosted Engine vm is migrated by the HA agent
                            continue;
                        }
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Unassigned));
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ActivateVds, new ActivateVdsVDSCommandParameters(getVdsId()));
        setSucceeded(returnValue.getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#method_after
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Unassigned));
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ActivateVds, new ActivateVdsVDSCommandParameters(getVdsId()));
        setSucceeded(returnValue.getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        } else {
            // We didn't manage to activate host. Set its status to Error
            runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Error));
        }
    }
    logMonitorLockReleased("Activate");
}
#end_block

#method_before
public HaMaintenanceMode getMode() {
    return this.mode;
}
#method_after
public HaMaintenanceMode getMode() {
    return mode;
}
#end_block

#method_before
public boolean getIsEnabled() {
    return this.enabled;
}
#method_after
public boolean getIsEnabled() {
    return enabled;
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private void assignTags() {
    if (getWindow() != null) {
        return;
    }
    TagListModel model = new TagListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignTagsTitle());
    // $NON-NLS-1$
    model.setHashName("assign_tags_vms");
    getAttachedTagsToSelectedVMs(model);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAssignTags", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void assignTags() {
    if (getWindow() != null) {
        return;
    }
    TagListModel model = new TagListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignTagsTitle());
    model.setHelpTag(HelpTag.assign_tags_vms);
    // $NON-NLS-1$
    model.setHashName("assign_tags_vms");
    getAttachedTagsToSelectedVMs(model);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAssignTags", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    model.setHelpTag(HelpTag.editConsole);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameter.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnExportNoTemplates", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("CancelConfirmation", this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameter.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnExportNoTemplates", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("CancelConfirmation", this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#method_after
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#method_after
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    // $NON-NLS-1$
    model.setHashName(actionName + "_virtual_machine");
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(// $NON-NLS-1$
    "Shutdown", constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#method_after
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(// $NON-NLS-1$
    "Stop", constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#method_after
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(// $NON-NLS-1$
    "Reboot", constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void setGlobalHaMaintenance(boolean enabled) {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (!vm.isHostedEngine()) {
        return;
    }
    SetHaMaintenanceParameters params = new SetHaMaintenanceParameters(vm.getRunOnVds(), HaMaintenanceMode.GLOBAL, enabled);
    Frontend.getInstance().runAction(VdcActionType.SetHaMaintenance, params, null, this);
}
#method_after
private void setGlobalHaMaintenance(boolean enabled) {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (!vm.isHostedEngine()) {
        return;
    }
    SetHaMaintenanceParameters params = new SetHaMaintenanceParameters(vm.getRunOnVds(), HaMaintenanceMode.GLOBAL, enabled);
    Frontend.getInstance().runAction(VdcActionType.SetHaMaintenance, params);
}
#end_block

#method_before
private void updateHaMaintenanceAvailability(List items) {
    if (items == null || items.size() != 1) {
        setHaMaintenanceAvailability(false);
        return;
    }
    VM vm = (VM) getSelectedItem();
    if (vm == null || !vm.isHostedEngine() || vm.getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        setHaMaintenanceAvailability(false);
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(vm.getRunOnVds()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded() || response.getReturnValue() == null) {
                setHaMaintenanceAvailability(false);
            } else {
                VDS vds = response.getReturnValue();
                setHaMaintenanceAvailability(vds.getHighlyAvailableIsConfigured());
            }
        }
    }, true));
}
#method_after
private void updateHaMaintenanceAvailability(List items) {
    if (items == null || items.size() != 1) {
        setHaMaintenanceAvailability(false);
        return;
    }
    VM vm = (VM) getSelectedItem();
    if (vm == null || !vm.isHostedEngine() || vm.getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        setHaMaintenanceAvailability(false);
    } else {
        setHaMaintenanceAvailability(true);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    SetHaMaintenanceParameters params = (SetHaMaintenanceParameters) getParameters();
    try {
        succeeded = runVdsCommand(VDSCommandType.SetHaMaintenanceMode, new SetHaMaintenanceModeVDSCommandParameters(getVds(), params.getMode(), params.getIsEnabled())).getSucceeded();
    } catch (VdcBLLException e) {
        log.errorFormat("Could not {0} {1} Hosted Engine HA maintenance mode on host {2}", (params.getIsEnabled() ? "enable" : "disable"), params.getMode().name().toLowerCase(), getVdsName());
    }
    getReturnValue().setSucceeded(succeeded);
}
#method_after
@Override
protected void executeCommand() {
    boolean succeeded = false;
    SetHaMaintenanceParameters params = getParameters();
    try {
        succeeded = runVdsCommand(VDSCommandType.SetHaMaintenanceMode, new SetHaMaintenanceModeVDSCommandParameters(getVds(), params.getMode(), params.getIsEnabled())).getSucceeded();
    } catch (VdcBLLException e) {
        log.errorFormat("Could not {0} {1} Hosted Engine HA maintenance mode on host {2}", (params.getIsEnabled() ? "enable" : "disable"), params.getMode().name().toLowerCase(), getVdsName());
    }
    getReturnValue().setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VdsValidator vdsValidator = new VdsValidator(getVds());
    if (!validate(vdsValidator.exists()) || !validate(vdsValidator.isUp())) {
        return false;
    }
    if (getVds().getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_MAINT_NOT_SUPPORTED);
    }
    if (getVds().getHighlyAvailableIsConfigured()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_NOT_CONFIGURED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VdsValidator vdsValidator = new VdsValidator(getVds());
    if (!validate(vdsValidator.exists()) || !validate(vdsValidator.isUp())) {
        return false;
    }
    if (getVds().getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_MAINT_NOT_SUPPORTED);
    }
    if (!getVds().getHighlyAvailableIsConfigured()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_NOT_CONFIGURED);
    }
    return true;
}
#end_block

#method_before
public Integer getHighlyAvailableScore() {
    return this.mVdsStatistics.getHighlyAvailableScore();
}
#method_after
public int getHighlyAvailableScore() {
    return this.mVdsStatistics.getHighlyAvailableScore();
}
#end_block

#method_before
public void setHighlyAvailableScore(Integer value) {
    this.mVdsStatistics.setHighlyAvailableScore(value);
}
#method_after
public void setHighlyAvailableScore(int value) {
    this.mVdsStatistics.setHighlyAvailableScore(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableIsConfigured() {
    return this.mVdsStatistics.getHighlyAvailableIsConfigured();
}
#method_after
public boolean getHighlyAvailableIsConfigured() {
    return this.mVdsStatistics.getHighlyAvailableIsConfigured();
}
#end_block

#method_before
public void setHighlyAvailableIsConfigured(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsConfigured(value);
}
#method_after
public void setHighlyAvailableIsConfigured(boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsConfigured(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableIsActive() {
    return this.mVdsStatistics.getHighlyAvailableIsActive();
}
#method_after
public boolean getHighlyAvailableIsActive() {
    return this.mVdsStatistics.getHighlyAvailableIsActive();
}
#end_block

#method_before
public void setHighlyAvailableIsActive(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsActive(value);
}
#method_after
public void setHighlyAvailableIsActive(boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsActive(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableGlobalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableGlobalMaintenance();
}
#method_after
public boolean getHighlyAvailableGlobalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableGlobalMaintenance();
}
#end_block

#method_before
public void setHighlyAvailableGlobalMaintenance(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableGlobalMaintenance(value);
}
#method_after
public void setHighlyAvailableGlobalMaintenance(boolean value) {
    this.mVdsStatistics.setHighlyAvailableGlobalMaintenance(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableLocalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableLocalMaintenance();
}
#method_after
public boolean getHighlyAvailableLocalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableLocalMaintenance();
}
#end_block

#method_before
public void setHighlyAvailableLocalMaintenance(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableLocalMaintenance(value);
}
#method_after
public void setHighlyAvailableLocalMaintenance(boolean value) {
    this.mVdsStatistics.setHighlyAvailableLocalMaintenance(value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((cpu_idle == null) ? 0 : cpu_idle.hashCode());
    result = prime * result + ((cpu_load == null) ? 0 : cpu_load.hashCode());
    result = prime * result + ((cpu_sys == null) ? 0 : cpu_sys.hashCode());
    result = prime * result + ((cpu_user == null) ? 0 : cpu_user.hashCode());
    result = prime * result + ((mem_available == null) ? 0 : mem_available.hashCode());
    result = prime * result + ((memFree == null) ? 0 : memFree.hashCode());
    result = prime * result + ((mem_shared == null) ? 0 : mem_shared.hashCode());
    result = prime * result + ((usage_cpu_percent == null) ? 0 : usage_cpu_percent.hashCode());
    result = prime * result + ((usage_network_percent == null) ? 0 : usage_network_percent.hashCode());
    result = prime * result + ((ksm_state == null) ? 0 : ksm_state.hashCode());
    result = prime * result + ((ksm_pages == null) ? 0 : ksm_pages.hashCode());
    result = prime * result + ((ksm_cpu_percent == null) ? 0 : ksm_cpu_percent.hashCode());
    result = prime * result + ((swap_total == null) ? 0 : swap_total.hashCode());
    result = prime * result + ((swap_free == null) ? 0 : swap_free.hashCode());
    result = prime * result + ((highlyAvailableScore == null) ? 0 : highlyAvailableScore.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + ((highlyAvailableIsConfigured == null) ? 0 : highlyAvailableIsConfigured.hashCode());
    result = prime * result + ((highlyAvailableIsActive == null) ? 0 : highlyAvailableIsActive.hashCode());
    result = prime * result + ((highlyAvailableGlobalMaintenance == null) ? 0 : highlyAvailableGlobalMaintenance.hashCode());
    result = prime * result + ((highlyAvailableLocalMaintenance == null) ? 0 : highlyAvailableLocalMaintenance.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((cpu_idle == null) ? 0 : cpu_idle.hashCode());
    result = prime * result + ((cpu_load == null) ? 0 : cpu_load.hashCode());
    result = prime * result + ((cpu_sys == null) ? 0 : cpu_sys.hashCode());
    result = prime * result + ((cpu_user == null) ? 0 : cpu_user.hashCode());
    result = prime * result + ((mem_available == null) ? 0 : mem_available.hashCode());
    result = prime * result + ((memFree == null) ? 0 : memFree.hashCode());
    result = prime * result + ((mem_shared == null) ? 0 : mem_shared.hashCode());
    result = prime * result + ((usage_cpu_percent == null) ? 0 : usage_cpu_percent.hashCode());
    result = prime * result + ((usage_network_percent == null) ? 0 : usage_network_percent.hashCode());
    result = prime * result + ((ksm_state == null) ? 0 : ksm_state.hashCode());
    result = prime * result + ((ksm_pages == null) ? 0 : ksm_pages.hashCode());
    result = prime * result + ((ksm_cpu_percent == null) ? 0 : ksm_cpu_percent.hashCode());
    result = prime * result + ((swap_total == null) ? 0 : swap_total.hashCode());
    result = prime * result + ((swap_free == null) ? 0 : swap_free.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + highlyAvailableScore;
    result = prime * result + (highlyAvailableIsConfigured ? 1231 : 1237);
    result = prime * result + (highlyAvailableIsActive ? 1231 : 1237);
    result = prime * result + (highlyAvailableGlobalMaintenance ? 1231 : 1237);
    result = prime * result + (highlyAvailableLocalMaintenance ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatistics other = (VdsStatistics) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.bigDecimalEqual(cpu_idle, other.cpu_idle) && ObjectUtils.bigDecimalEqual(cpu_load, other.cpu_load) && ObjectUtils.bigDecimalEqual(cpu_sys, other.cpu_sys) && ObjectUtils.bigDecimalEqual(cpu_user, other.cpu_user) && ObjectUtils.objectsEqual(mem_available, other.mem_available) && ObjectUtils.objectsEqual(memFree, other.memFree) && ObjectUtils.objectsEqual(mem_shared, other.mem_shared) && ObjectUtils.objectsEqual(usage_cpu_percent, other.usage_cpu_percent) && ObjectUtils.objectsEqual(usage_network_percent, other.usage_network_percent) && ObjectUtils.objectsEqual(ksm_state, other.ksm_state) && ObjectUtils.objectsEqual(ksm_pages, other.ksm_pages) && ObjectUtils.objectsEqual(ksm_cpu_percent, other.ksm_cpu_percent) && ObjectUtils.objectsEqual(swap_total, other.swap_total) && ObjectUtils.objectsEqual(swap_free, other.swap_free) && ObjectUtils.objectsEqual(highlyAvailableScore, other.highlyAvailableScore) && (anonymousHugePages == other.anonymousHugePages) && ObjectUtils.objectsEqual(highlyAvailableIsConfigured, other.highlyAvailableIsConfigured) && ObjectUtils.objectsEqual(highlyAvailableIsActive, other.highlyAvailableIsActive) && ObjectUtils.objectsEqual(highlyAvailableGlobalMaintenance, other.highlyAvailableGlobalMaintenance) && ObjectUtils.objectsEqual(highlyAvailableLocalMaintenance, other.highlyAvailableLocalMaintenance));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatistics other = (VdsStatistics) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.bigDecimalEqual(cpu_idle, other.cpu_idle) && ObjectUtils.bigDecimalEqual(cpu_load, other.cpu_load) && ObjectUtils.bigDecimalEqual(cpu_sys, other.cpu_sys) && ObjectUtils.bigDecimalEqual(cpu_user, other.cpu_user) && ObjectUtils.objectsEqual(mem_available, other.mem_available) && ObjectUtils.objectsEqual(memFree, other.memFree) && ObjectUtils.objectsEqual(mem_shared, other.mem_shared) && ObjectUtils.objectsEqual(usage_cpu_percent, other.usage_cpu_percent) && ObjectUtils.objectsEqual(usage_network_percent, other.usage_network_percent) && ObjectUtils.objectsEqual(ksm_state, other.ksm_state) && ObjectUtils.objectsEqual(ksm_pages, other.ksm_pages) && ObjectUtils.objectsEqual(ksm_cpu_percent, other.ksm_cpu_percent) && ObjectUtils.objectsEqual(swap_total, other.swap_total) && ObjectUtils.objectsEqual(swap_free, other.swap_free) && (anonymousHugePages == other.anonymousHugePages) && (highlyAvailableScore == other.highlyAvailableScore) && (highlyAvailableIsConfigured == other.highlyAvailableIsConfigured) && (highlyAvailableIsActive == other.highlyAvailableIsActive) && (highlyAvailableGlobalMaintenance == other.highlyAvailableGlobalMaintenance) && (highlyAvailableLocalMaintenance == other.highlyAvailableLocalMaintenance));
}
#end_block

#method_before
public Integer getHighlyAvailableScore() {
    return highlyAvailableScore;
}
#method_after
public int getHighlyAvailableScore() {
    return highlyAvailableScore;
}
#end_block

#method_before
public void setHighlyAvailableScore(Integer value) {
    highlyAvailableScore = value;
}
#method_after
public void setHighlyAvailableScore(int value) {
    highlyAvailableScore = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableIsConfigured() {
    return highlyAvailableIsConfigured;
}
#method_after
public boolean getHighlyAvailableIsConfigured() {
    return highlyAvailableIsConfigured;
}
#end_block

#method_before
public void setHighlyAvailableIsConfigured(Boolean value) {
    highlyAvailableIsConfigured = value;
}
#method_after
public void setHighlyAvailableIsConfigured(boolean value) {
    highlyAvailableIsConfigured = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableIsActive() {
    return highlyAvailableIsActive;
}
#method_after
public boolean getHighlyAvailableIsActive() {
    return highlyAvailableIsActive;
}
#end_block

#method_before
public void setHighlyAvailableIsActive(Boolean value) {
    highlyAvailableIsActive = value;
}
#method_after
public void setHighlyAvailableIsActive(boolean value) {
    highlyAvailableIsActive = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableGlobalMaintenance() {
    return highlyAvailableGlobalMaintenance;
}
#method_after
public boolean getHighlyAvailableGlobalMaintenance() {
    return highlyAvailableGlobalMaintenance;
}
#end_block

#method_before
public void setHighlyAvailableGlobalMaintenance(Boolean value) {
    highlyAvailableGlobalMaintenance = value;
}
#method_after
public void setHighlyAvailableGlobalMaintenance(boolean value) {
    highlyAvailableGlobalMaintenance = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableLocalMaintenance() {
    return highlyAvailableLocalMaintenance;
}
#method_after
public boolean getHighlyAvailableLocalMaintenance() {
    return highlyAvailableLocalMaintenance;
}
#end_block

#method_before
public void setHighlyAvailableLocalMaintenance(Boolean value) {
    highlyAvailableLocalMaintenance = value;
}
#method_after
public void setHighlyAvailableLocalMaintenance(boolean value) {
    highlyAvailableLocalMaintenance = value;
}
#end_block

#method_before
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#method_after
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, new Comparator<RpmVersion>() {

                    @Override
                    public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                        return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                    }
                });
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debugFormat("scheduling started, correlation Id: {0}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debugFormat("Scheduling ended, correlation Id: {0}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debugFormat("scheduling started, correlation Id: {0}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debugFormat("Scheduling ended, correlation Id: {0}", correlationId);
    }
}
#end_block

#method_before
private Guid selectBestHost(VDSGroup cluster, VM vm, Guid destHostId, List<VDS> vdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // it passed filters return it
    if (destHostId != null) {
        for (VDS vds : vdsList) {
            if (destHostId.equals(vds.getId())) {
                return destHostId;
            }
        }
    }
    if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
        return vdsList.get(0).getId();
    }
    if (shouldWeighClusterHosts(cluster, vdsList)) {
        return runFunctions(policy.getFunctions(), vdsList, vm, parameters);
    }
    if (!vdsList.isEmpty()) {
        return vdsList.get(0).getId();
    }
    return null;
}
#method_after
private Guid selectBestHost(VDSGroup cluster, VM vm, Guid destHostId, List<VDS> vdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // it passed filters, return it
    if (destHostId != null) {
        for (VDS vds : vdsList) {
            if (destHostId.equals(vds.getId())) {
                return destHostId;
            }
        }
    }
    List<Pair<Guid, Integer>> functions = policy.getFunctions();
    if (functions != null && !functions.isEmpty() && shouldWeighClusterHosts(cluster, vdsList)) {
        Guid bestHostByFunctions = runFunctions(functions, vdsList, vm, parameters);
        if (bestHostByFunctions != null) {
            return bestHostByFunctions;
        }
    }
    return vdsList.get(0).getId();
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#end_block

#method_before
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && list.size() > 0) {
        List<VDS> toRemoveList = new ArrayList<VDS>();
        Set<Guid> listSet = new HashSet<Guid>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#method_after
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<VDS>();
        Set<Guid> listSet = new HashSet<Guid>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.getPolicyUnit().isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.size() == 0) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.getPolicyUnit().isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
protected Guid runFunctions(ArrayList<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    ArrayList<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<Pair<PolicyUnitImpl, Integer>>();
    ArrayList<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<Pair<PolicyUnitImpl, Integer>>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && externalScoreFunctions.size() > 0) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#method_after
protected Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#end_block

#method_before
private Map<Guid, Integer> runInternalFunctions(ArrayList<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostCostTable = new HashMap<Guid, Integer>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        List<Pair<Guid, Integer>> scoreResult = pair.getFirst().score(hostList, vm, parameters);
        for (Pair<Guid, Integer> result : scoreResult) {
            Guid hostId = result.getFirst();
            if (hostCostTable.get(hostId) == null) {
                hostCostTable.put(hostId, 0);
            }
            hostCostTable.put(hostId, hostCostTable.get(hostId) + pair.getSecond() * result.getSecond());
        }
    }
    return hostCostTable;
}
#method_after
private Map<Guid, Integer> runInternalFunctions(List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostCostTable = new HashMap<Guid, Integer>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        List<Pair<Guid, Integer>> scoreResult = pair.getFirst().score(hostList, vm, parameters);
        for (Pair<Guid, Integer> result : scoreResult) {
            Guid hostId = result.getFirst();
            if (hostCostTable.get(hostId) == null) {
                hostCostTable.put(hostId, 0);
            }
            hostCostTable.put(hostId, hostCostTable.get(hostId) + pair.getSecond() * result.getSecond());
        }
    }
    return hostCostTable;
}
#end_block

#method_before
private void runExternalFunctions(ArrayList<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> hostCostTable) {
    List<Pair<String, Integer>> scoreNameAndWeight = new ArrayList<Pair<String, Integer>>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        scoreNameAndWeight.add(new Pair<String, Integer>(pair.getFirst().getPolicyUnit().getName(), pair.getSecond()));
    }
    List<Guid> hostIDs = new ArrayList<Guid>();
    for (VDS vds : hostList) {
        hostIDs.add(vds.getId());
    }
    List<Pair<Guid, Integer>> externalScores = ExternalSchedulerFactory.getInstance().runScores(scoreNameAndWeight, hostIDs, vm.getId(), parameters);
    if (externalScores != null) {
        sumScoreResults(hostCostTable, externalScores);
    }
}
#method_after
private void runExternalFunctions(List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> hostCostTable) {
    List<Pair<String, Integer>> scoreNameAndWeight = new ArrayList<Pair<String, Integer>>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        scoreNameAndWeight.add(new Pair<String, Integer>(pair.getFirst().getPolicyUnit().getName(), pair.getSecond()));
    }
    List<Guid> hostIDs = new ArrayList<Guid>();
    for (VDS vds : hostList) {
        hostIDs.add(vds.getId());
    }
    List<Pair<Guid, Integer>> externalScores = ExternalSchedulerFactory.getInstance().runScores(scoreNameAndWeight, hostIDs, vm.getId(), parameters);
    if (externalScores != null) {
        sumScoreResults(hostCostTable, externalScores);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(returnedFailedHosts, ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
@Override
public void dispatchEvent(Event event, String address) {
    sendQueue.add(new DispatchAttempt(event, address));
}
#method_after
@Override
public void dispatchEvent(AuditLogEvent event, String address) {
    if (StringUtils.isEmpty(address)) {
        log.error("Address is empty, cannot distribute message." + event.getName());
    } else {
        sendQueue.add(new DispatchAttempt(event, address));
    }
}
#end_block

#method_before
@Override
public void idle() {
    DispatchAttempt dispatchAttempt = sendQueue.remove();
    Event event = dispatchAttempt.getEvent();
    String address = dispatchAttempt.getAddress();
    // throw an exception if not AuditLogEvent
    AuditLogEvent auditLogEvent;
    auditLogEvent = (AuditLogEvent) event;
    EventMessageContent message = new EventMessageContent();
    message.prepareMessage(hostName, auditLogEvent, isBodyHtml);
    if (StringUtils.isEmpty(address)) {
        log.error("Address is empty, cannot distribute message." + event.getName());
        return;
    }
    log.info(String.format("Send email to [%s]%n subject:%n [%s]", address, message.getMessageSubject()));
    if (log.isDebugEnabled()) {
        log.debug(String.format("body:%n [%s]", message.getMessageBody()));
    }
    String errorMessage = null;
    boolean success = false;
    try {
        mailSender.send(address, message.getMessageSubject(), message.getMessageBody());
        setChanged();
        notifyObservers(DispatchData.success(event, address, EventNotificationMethod.EMAIL));
        success = true;
    } catch (MessagingException ex) {
        errorMessage = ex.getMessage();
    }
    dispatchAttempt.setAttempts(dispatchAttempt.getAttempts() + 1);
    // Could not send after ATTEMPTS attempts.
    if (!success) {
        if (dispatchAttempt.getAttempts() < maxRetries) {
            sendQueue.add(dispatchAttempt);
        } else {
            // fail
            setChanged();
            notifyObservers(DispatchData.failure(event, address, EventNotificationMethod.EMAIL, errorMessage));
        }
    }
}
#method_after
@Override
public void idle() {
    if (lastSendInterval++ >= sendIntervals) {
        lastSendInterval = 0;
        Iterator<DispatchAttempt> iterator = sendQueue.iterator();
        while (iterator.hasNext()) {
            DispatchAttempt attempt = iterator.next();
            try {
                EventMessageContent message = new EventMessageContent();
                message.prepareMessage(hostName, attempt.event, isBodyHtml);
                log.info(String.format("Send email to [%s]%n subject:%n [%s]", attempt.address, message.getMessageSubject()));
                if (log.isDebugEnabled()) {
                    log.debug(String.format("body:%n [%s]", message.getMessageBody()));
                }
                sendMail(attempt.address, message.getMessageSubject(), message.getMessageBody());
                notifyObservers(DispatchResult.success(attempt.event, attempt.address, EventNotificationMethod.EMAIL));
                iterator.remove();
            } catch (Exception ex) {
                attempt.retries++;
                if (attempt.retries >= retries) {
                    notifyObservers(DispatchResult.failure(attempt.event, attempt.address, EventNotificationMethod.EMAIL, ex.getMessage()));
                    iterator.remove();
                }
            }
        }
    }
}
#end_block

#method_before
public void validate() {
    validateCommon();
    validateSmtp();
    validateFilter();
}
#method_after
public void validate() {
    validateCommon();
}
#end_block

#method_before
private void validateCommon() {
    requireAll(NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION, NotificationProperties.IDLE_INTERVAL);
    // validate mandatory and non empty properties
    requireOne(NotificationProperties.MAIL_SERVER);
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.IDLE_INTERVAL }) {
        validateNonNegative(property);
    }
}
#method_after
private void validateCommon() {
    requireAll(DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD, ENGINE_INTERVAL_IN_SECONDS, ENGINE_TIMEOUT_IN_SECONDS, INTERVAL_IN_SECONDS, IS_HTTPS_PROTOCOL, REPEAT_NON_RESPONSIVE_NOTIFICATION, IDLE_INTERVAL);
    // validate non negative args
    for (String property : new String[] { DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD, IDLE_INTERVAL }) {
        validateNonNegetive(property);
    }
}
#end_block

#method_before
private void requireAll(String... mandatoryProperties) {
    for (String property : mandatoryProperties) {
        if (StringUtils.isEmpty(getProperty(property, true))) {
            throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "'%s' is missing", property));
        }
    }
}
#method_after
public void requireAll(String... mandatoryProperties) {
    for (String property : mandatoryProperties) {
        if (StringUtils.isEmpty(getProperty(property, true))) {
            throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "'%s' is missing", property));
        }
    }
}
#end_block

#method_before
private void requireOne(String... mandatoryProperties) {
    boolean provided = false;
    for (String property : mandatoryProperties) {
        if (isConfigured(property)) {
            provided = true;
        }
    }
    if (!provided) {
        StringBuilder sb = new StringBuilder(100);
        sb.append(GENERIC_MESSAGE);
        String prefix = " ";
        for (String property : mandatoryProperties) {
            sb.append(prefix).append(property);
            prefix = " or ";
        }
        sb.append(" must be defined");
        throw new IllegalArgumentException(sb.toString());
    }
}
#method_after
public void requireOne(String... mandatoryProperties) {
    boolean provided = false;
    for (String property : mandatoryProperties) {
        if (isConfigured(property)) {
            provided = true;
        }
    }
    if (!provided) {
        StringBuilder sb = new StringBuilder(100);
        sb.append(GENERIC_MESSAGE);
        String prefix = " ";
        for (String property : mandatoryProperties) {
            sb.append(prefix).append(property);
            prefix = " or ";
        }
        sb.append(" must be defined");
        throw new IllegalArgumentException(sb.toString());
    }
}
#end_block

#method_before
private void validateEmail(String propName, String propVal) {
    if (!StringUtils.isEmpty(propVal)) {
        try {
            new InternetAddress(propVal);
        } catch (Exception ex) {
            throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "invalid format in '%s'", propName), ex);
        }
    }
}
#method_after
public InternetAddress validateEmail(String property) {
    try {
        InternetAddress ret = null;
        String value = getProperty(property);
        if (!StringUtils.isEmpty(value)) {
            ret = new InternetAddress(value);
        }
        return ret;
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "invalid format in '%s'", property), ex);
    }
}
#end_block

#method_before
@Override
public void run() {
    log.debug("Start event notification service iteration");
    processEvents();
    long now = new Date(0).getTime();
    if (now - lastIdle >= getIdleInterval())
        for (Transport transport : transports) {
            log.debug(String.format("Transport %s is idle", transport.getName()));
            transport.idle();
        }
    lastIdle = now;
    log.debug("Finished event notification service iteration");
}
#method_after
@Override
public void run() {
    markOldEventsAsProcessed();
    ShutdownHook shutdownHook = ShutdownHook.getInstance();
    ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
    shutdownHook.addScheduledExecutorService(exec);
    shutdownHook.addServiceHandler(exec.scheduleWithFixedDelay(new Runnable() {

        @Override
        public void run() {
            mainLogic();
        }
    }, 1, prop.getLong(NotificationProperties.INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
    shutdownHook.addServiceHandler(exec.scheduleWithFixedDelay(new Runnable() {

        @Override
        public void run() {
            idle();
        }
    }, 1, prop.getLong(NotificationProperties.IDLE_INTERVAL), TimeUnit.SECONDS));
}
#end_block

#method_before
private void markOldEventsAsProcessed() {
    log.debug("Processing old events");
    final int updatedEvents = eventsManager.markOldEventsAsProcessed(prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
    if (updatedEvents > 0) {
        log.debug(updatedEvents + " old records were marked as processed in the \"audit_log\" table.");
    }
}
#method_after
private void markOldEventsAsProcessed() {
    eventsManager.markOldEventsAsProcessed(prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
}
#end_block

#method_before
@Override
public void run() {
    try {
        log.debug("Start event notification service iteration");
        List<AuditLogEventSubscriber> eventSubscribers = getEventSubscribers(false);
        List<AuditLogSubscriber> subscribers = getSubscribers(false);
        List<AuditLogEvent> events = eventsManager.getAuditLogEvents(false);
        distributeEvents(events, eventSubscribers, subscribers);
        deleteObsoleteHistoryData();
        log.debug("Finished event notification service iteration");
    } catch (Throwable e) {
        if (isConnectionException(e)) {
            log.info("Connection exception while querying for notifications.", e);
            distributeDbDownEvent();
        }
        if (!Thread.interrupted()) {
            log.error(String.format("Failed to run the service: [%s]", e.getMessage()), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        try {
            log.debug("Start event notification service iteration");
            // Clear filter chain
            firstMatchSimpleFilter.clearFilterEntries();
            // Read Database subscriptions first
            firstMatchSimpleFilter.addFilterEntries(eventsManager.getAuditLogEventSubscribers());
            // Backward compatibility, aim to remove (can be replaced by "FILTER")
            String dbDownSubscribers = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
            if (!StringUtils.isEmpty(dbDownSubscribers)) {
                for (String subscriber : dbDownSubscribers.split(",")) {
                    new FirstMatchSimpleFilter.FilterEntry(EventsManager.DATABASE_UNREACHABLE, false, EventNotificationMethod.EMAIL.name(), subscriber);
                }
            }
            // Add configurations subscription
            firstMatchSimpleFilter.addFilterEntries(configurationFilters);
            for (AuditLogEvent event : eventsManager.getAuditLogEvents()) {
                firstMatchSimpleFilter.processEvent(event);
                eventsManager.updateAuditLogEventProcessed(event.getId());
            }
            deleteObsoleteHistoryData();
            log.debug("Finished event notification service iteration");
        } catch (SQLException se) {
            distributeDbDownEvent();
            throw se;
        }
    } catch (Throwable t) {
        log.error(String.format("Failed to run the service."), t);
    }
}
#end_block

#method_before
private void deleteObsoleteHistoryData() throws SQLException {
    if (prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY) > 0) {
        final int deletedRecords = eventsManager.deleteObsoleteHistoryData(prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
        if (deletedRecords > 0) {
            log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
        }
    }
}
#method_after
private void deleteObsoleteHistoryData() throws SQLException {
    eventsManager.deleteObsoleteHistoryData(prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
}
#end_block

#method_before
private void distributeDbDownEvent() {
    if (failedQueries == 0) {
        try {
            distributeEvents(eventsManager.getAuditLogEvents(true), getEventSubscribers(true), getSubscribers(true));
        } catch (Exception e) {
            log.error("Failed to dispatch query failure email message", e);
        // Don't rethrow. we don't want to mask the original query exception.
        }
    }
    int failedQueriesNotificationThreshold = prop.getInteger(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    failedQueries = (failedQueries + 1) % failedQueriesNotificationThreshold;
}
#method_after
private void distributeDbDownEvent() {
    firstMatchSimpleFilter.clearFilterEntries();
    firstMatchSimpleFilter.addFilterEntries(configurationFilters);
    if (failedQueries == 0) {
        try {
            firstMatchSimpleFilter.processEvent(eventsManager.createDBDownEvent());
        } catch (Exception e) {
            log.error(String.format("Failed to dispatch %s event", EventsManager.DATABASE_UNREACHABLE), e);
        // Don't rethrow. we don't want to mask the original query exception.
        }
    }
    int failedQueriesNotificationThreshold = prop.getInteger(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    failedQueries = (failedQueries + 1) % failedQueriesNotificationThreshold;
}
#end_block

#method_before
private Map<String, String> populateEventMap() {
    Map<String, String> eventMap = new HashMap<>();
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT em.event_up_name, em.event_down_name " + "FROM event_map em;");
        rs = ps.executeQuery();
        while (rs.next()) {
            eventMap.put(rs.getString("event_up_name"), rs.getString("event_down_name"));
        }
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed to query for event subscribers.", e);
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventMap;
}
#method_after
private Map<String, String> populateEventMap() throws SQLException {
    Map<String, String> eventMap = new HashMap<>();
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT em.event_up_name, em.event_down_name " + "FROM event_map em;");
        rs = ps.executeQuery();
        while (rs.next()) {
            eventMap.put(rs.getString("event_up_name"), rs.getString("event_down_name"));
        }
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventMap;
}
#end_block

#method_before
public List<AuditLogEventSubscriber> getAuditLogEventSubscribers() {
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    List<AuditLogEventSubscriber> eventSubscribers = new ArrayList<>();
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT event_subscriber.event_up_name, " + "       event_subscriber.method_address, " + "       event_subscriber.notification_method " + "FROM event_subscriber ");
        rs = ps.executeQuery();
        while (rs.next()) {
            String eventUpName = rs.getString("event_up_name");
            eventSubscribers.add(EventSubscriberFactory.createEventSubscriber(rs.getString("notification_method"), rs.getString("method_address"), eventUpName, true));
            String eventDownName = eventMap.get(eventUpName);
            if (eventDownName != null) {
                eventSubscribers.add(EventSubscriberFactory.createEventSubscriber(rs.getString("notification_method"), rs.getString("method_address"), eventDownName, true));
            }
        }
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed to query for event subscribers.", e);
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventSubscribers;
}
#method_after
public List<FirstMatchSimpleFilter.FilterEntry> getAuditLogEventSubscribers() throws SQLException {
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    List<FirstMatchSimpleFilter.FilterEntry> eventSubscribers = new ArrayList<>();
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT event_subscriber.event_up_name, " + "       event_subscriber.method_address, " + "       event_subscriber.notification_method " + "FROM event_subscriber ");
        rs = ps.executeQuery();
        while (rs.next()) {
            String eventUpName = rs.getString("event_up_name");
            String eventDownName = eventMap.get(eventUpName);
            eventSubscribers.add(new FirstMatchSimpleFilter.FilterEntry(eventUpName, false, rs.getString("notification_method"), rs.getString("method_address")));
            if (eventDownName != null) {
                eventSubscribers.add(new FirstMatchSimpleFilter.FilterEntry(eventDownName, false, rs.getString("notification_method"), rs.getString("method_address")));
            }
        }
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventSubscribers;
}
#end_block

#method_before
public List<AuditLogEvent> getAuditLogEvents(boolean dbDown) {
    List<AuditLogEvent> auditLogEvents = new ArrayList<>();
    if (dbDown) {
        auditLogEvents.add(createDBDownEvent());
    } else {
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            connection = ds.getConnection();
            ps = connection.prepareStatement("" + "SELECT al.audit_log_id, al.log_type_name, " + "       em_down.event_down_name," + "       al.user_id, al.user_name, " + "       al.vm_id, al.vm_name, al.vm_template_id, al.vm_template_name, " + "       al.vds_id, al.vds_name, al.storage_pool_id, al.storage_pool_name, " + "       al.storage_domain_id, al.storage_domain_name, " + "       al.log_time, al.severity, al.message " + "FROM audit_log al " + "LEFT JOIN event_map em_down ON al.log_type_name = em_down.event_down_name " + "WHERE al.processed = FALSE ;");
            rs = ps.executeQuery();
            while (rs.next()) {
                auditLogEvents.add(extractAuditLogEvent(rs));
            }
        } catch (SQLException e) {
            throw new NotificationServiceException("Failed to query for events.", e);
        } finally {
            DbUtils.closeQuietly(rs, ps, connection);
        }
    }
    if (log.isDebugEnabled()) {
        log.debug(String.format("%d unprocessed events read from audit_log database table.", auditLogEvents.size()));
        for (int i = 0; i < auditLogEvents.size(); i++) {
            log.debug(String.format("event %d => %s", i, auditLogEvents.get(i).toString()));
        }
    }
    return auditLogEvents;
}
#method_after
public List<AuditLogEvent> getAuditLogEvents() throws SQLException {
    List<AuditLogEvent> auditLogEvents = new ArrayList<>();
    HashSet<String> downEvents = new HashSet<>(eventMap.values());
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT al.audit_log_id, al.log_type_name, " + "       al.user_id, al.user_name, " + "       al.vm_id, al.vm_name, al.vm_template_id, al.vm_template_name, " + "       al.vds_id, al.vds_name, al.storage_pool_id, al.storage_pool_name, " + "       al.storage_domain_id, al.storage_domain_name, " + "       al.log_time, al.severity, al.message " + "FROM audit_log al " + "WHERE al.processed = FALSE ;");
        rs = ps.executeQuery();
        while (rs.next()) {
            auditLogEvents.add(extractAuditLogEvent(rs, downEvents));
        }
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    if (log.isDebugEnabled()) {
        log.debug(String.format("%d unprocessed events read from audit_log database table.", auditLogEvents.size()));
        for (int i = 0; i < auditLogEvents.size(); i++) {
            log.debug(String.format("event %d => %s", i, auditLogEvents.get(i).toString()));
        }
    }
    return auditLogEvents;
}
#end_block

#method_before
private AuditLogEvent extractAuditLogEvent(ResultSet rs) throws SQLException {
    AuditLogEvent auditLogEvent = new AuditLogEvent();
    auditLogEvent.setId(rs.getLong("audit_log_id"));
    auditLogEvent.setLogTypeName(rs.getString("log_type_name"));
    final String eventDownName = rs.getString("event_down_name");
    if (eventDownName != null) {
        auditLogEvent.setType(AuditLogEventType.resolveMessage);
    } else {
        auditLogEvent.setType(AuditLogEventType.alertMessage);
    }
    auditLogEvent.setUserId(Guid.createGuidFromString(rs.getString("user_id")));
    auditLogEvent.setUserName(rs.getString("user_name"));
    auditLogEvent.setVmId(Guid.createGuidFromString(rs.getString("vm_id")));
    auditLogEvent.setVmName(rs.getString("vm_name"));
    auditLogEvent.setVmTemplateId(Guid.createGuidFromString(rs.getString("vm_template_id")));
    auditLogEvent.setVmTemplateName(rs.getString("vm_template_name"));
    auditLogEvent.setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
    auditLogEvent.setVdsName(rs.getString("vds_name"));
    auditLogEvent.setStoragePoolId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_pool_id")));
    auditLogEvent.setStoragePoolName(rs.getString("storage_pool_name"));
    auditLogEvent.setStorageDomainId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_domain_id")));
    auditLogEvent.setStorageDomainName(rs.getString("storage_domain_name"));
    auditLogEvent.setLogTime(rs.getTimestamp("log_time"));
    auditLogEvent.setSeverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    auditLogEvent.setMessage(rs.getString("message"));
    return auditLogEvent;
}
#method_after
private AuditLogEvent extractAuditLogEvent(ResultSet rs, Set<String> downEvents) throws SQLException {
    AuditLogEvent auditLogEvent = new AuditLogEvent();
    auditLogEvent.setId(rs.getLong("audit_log_id"));
    auditLogEvent.setLogTypeName(rs.getString("log_type_name"));
    if (downEvents.contains(auditLogEvent.getLogTypeName())) {
        auditLogEvent.setType(AuditLogEventType.resolveMessage);
    } else {
        auditLogEvent.setType(AuditLogEventType.alertMessage);
    }
    auditLogEvent.setUserId(Guid.createGuidFromString(rs.getString("user_id")));
    auditLogEvent.setUserName(rs.getString("user_name"));
    auditLogEvent.setVmId(Guid.createGuidFromString(rs.getString("vm_id")));
    auditLogEvent.setVmName(rs.getString("vm_name"));
    auditLogEvent.setVmTemplateId(Guid.createGuidFromString(rs.getString("vm_template_id")));
    auditLogEvent.setVmTemplateName(rs.getString("vm_template_name"));
    auditLogEvent.setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
    auditLogEvent.setVdsName(rs.getString("vds_name"));
    auditLogEvent.setStoragePoolId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_pool_id")));
    auditLogEvent.setStoragePoolName(rs.getString("storage_pool_name"));
    auditLogEvent.setStorageDomainId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_domain_id")));
    auditLogEvent.setStorageDomainName(rs.getString("storage_domain_name"));
    auditLogEvent.setLogTime(rs.getTimestamp("log_time"));
    auditLogEvent.setSeverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    auditLogEvent.setMessage(rs.getString("message"));
    return auditLogEvent;
}
#end_block

#method_before
private AuditLogEvent createDBDownEvent() {
    final AuditLogEvent dbDownEvent = new AuditLogEvent();
    dbDownEvent.setLogTime(new Date());
    dbDownEvent.setType(AuditLogEventType.alertMessage);
    dbDownEvent.setLogTypeName(DATABASE_UNREACHABLE);
    dbDownEvent.setMessage("Failed to query for notifications. Database Connection refused.");
    dbDownEvent.setSeverity(AuditLogSeverity.ERROR);
    return dbDownEvent;
}
#method_after
public AuditLogEvent createDBDownEvent() {
    final AuditLogEvent dbDownEvent = new AuditLogEvent();
    dbDownEvent.setLogTime(new Date());
    dbDownEvent.setType(AuditLogEventType.alertMessage);
    dbDownEvent.setLogTypeName(DATABASE_UNREACHABLE);
    dbDownEvent.setMessage("Failed to query for notifications. Database Connection refused.");
    dbDownEvent.setSeverity(AuditLogSeverity.ERROR);
    return dbDownEvent;
}
#end_block

#method_before
public int markOldEventsAsProcessed(int daysToSendOnStartup) {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -daysToSendOnStartup);
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("" + "UPDATE audit_log " + "SET  processed = 'true' " + "WHERE processed = 'false' AND log_time < ? ;");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed mark old events as processed.", e);
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
    return updatedRecords;
}
#method_after
public void markOldEventsAsProcessed(int daysToSendOnStartup) {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -daysToSendOnStartup);
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("" + "UPDATE audit_log " + "SET  processed = 'true' " + "WHERE processed = 'false' AND log_time < ? ;");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
        if (updatedRecords > 0) {
            log.debug(updatedRecords + " old records were marked as processed in the \"audit_log\" table.");
        }
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed mark old events as processed.", e);
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
}
#end_block

#method_before
public int deleteObsoleteHistoryData(int daysToKeepHistory) throws SQLException {
    Calendar cal = Calendar.getInstance();
    cal.setTime(new Date());
    cal.add(Calendar.DATE, -daysToKeepHistory);
    Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
    Connection connection = null;
    PreparedStatement deleteStmt = null;
    int deletedRecords;
    try {
        connection = ds.getConnection();
        deleteStmt = connection.prepareStatement("" + "DELETE " + "FROM event_notification_hist " + "WHERE sent_at < ? ;");
        deleteStmt.setTimestamp(1, startDeleteFrom);
        deletedRecords = deleteStmt.executeUpdate();
    } finally {
        DbUtils.closeQuietly(deleteStmt, connection);
    }
    return deletedRecords;
}
#method_after
public void deleteObsoleteHistoryData(int daysToKeepHistory) throws SQLException {
    if (daysToKeepHistory > 0) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -daysToKeepHistory);
        Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
        Connection connection = null;
        PreparedStatement deleteStmt = null;
        int deletedRecords;
        try {
            connection = ds.getConnection();
            deleteStmt = connection.prepareStatement("" + "DELETE " + "FROM event_notification_hist " + "WHERE sent_at < ? ;");
            deleteStmt.setTimestamp(1, startDeleteFrom);
            deletedRecords = deleteStmt.executeUpdate();
            if (deletedRecords > 0) {
                log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
            }
        } finally {
            DbUtils.closeQuietly(deleteStmt, connection);
        }
    }
}
#end_block

#method_before
private void validateCommon() {
    requireAll(NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION);
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
}
#method_after
private void validateCommon() {
    requireAll(DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD, ENGINE_INTERVAL_IN_SECONDS, ENGINE_TIMEOUT_IN_SECONDS, INTERVAL_IN_SECONDS, IS_HTTPS_PROTOCOL, REPEAT_NON_RESPONSIVE_NOTIFICATION);
    // validate non negative args
    for (String property : new String[] { DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
}
#end_block

#method_before
public int validateInteger(String property) {
    final String stringVal = getProperty(property);
    try {
        return Integer.parseInt(getProperty(property));
    } catch (NumberFormatException exception) {
        throw new IllegalArgumentException(String.format("'%s' must be an integer.", property));
    }
}
#method_after
public int validateInteger(String property) {
    try {
        return Integer.parseInt(getProperty(property));
    } catch (NumberFormatException exception) {
        throw new IllegalArgumentException(String.format("'%s' must be an integer.", property));
    }
}
#end_block

#method_before
private void initConfigurationProperties() throws NotificationServiceException {
    daysToKeepHistory = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_KEEP_HISTORY);
    daysToSendOnStartup = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_SEND_ON_STARTUP);
    failedQueriesNotificationThreshold = getNonNegativeIntegerProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    methodsMapper = new NotificationMethodsMapper(prop);
    failedQueriesEventSender = methodsMapper.getEventSender(EventNotificationMethods.EMAIL);
}
#method_after
private void initConfigurationProperties() throws NotificationServiceException {
    daysToKeepHistory = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_KEEP_HISTORY);
    daysToSendOnStartup = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_SEND_ON_STARTUP);
    failedQueriesNotificationThreshold = getNonNegativeIntegerProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    methodsMapper = new NotificationMethodsMapper(prop);
    failedQueriesEventSender = methodsMapper.getEventSender(EventNotificationMethod.EMAIL);
}
#end_block

#method_before
private event_notification_hist geteventNotificationHist(EventAuditLogSubscriber eals, boolean isNotified, String reason) {
    event_notification_hist eventHistory = new event_notification_hist();
    eventHistory.setaudit_log_id(eals.getaudit_log_id());
    eventHistory.setevent_name(eals.getevent_up_name());
    eventHistory.setmethod_type(EventNotificationMethods.forValue(eals.getmethod_id()).name());
    eventHistory.setreason(reason);
    eventHistory.setsent_at(new Date());
    eventHistory.setstatus(isNotified);
    eventHistory.setsubscriber_id(eals.getsubscriber_id());
    return eventHistory;
}
#method_after
private event_notification_hist geteventNotificationHist(EventAuditLogSubscriber eals, boolean isNotified, String reason) {
    event_notification_hist eventHistory = new event_notification_hist();
    eventHistory.setaudit_log_id(eals.getaudit_log_id());
    eventHistory.setevent_name(eals.getevent_up_name());
    eventHistory.setmethod_type(EventNotificationMethod.forMethodId(eals.getmethod_id()).name());
    eventHistory.setreason(reason);
    eventHistory.setsent_at(new Date());
    eventHistory.setstatus(isNotified);
    eventHistory.setsubscriber_id(eals.getsubscriber_id());
    return eventHistory;
}
#end_block

#method_before
private void initFailedQueriesEventSubscribers() {
    String emailRecipients = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
    if (StringUtils.isEmpty(emailRecipients)) {
        return;
    }
    List<EventAuditLogSubscriber> failedQueriesEventSubscribers = new LinkedList<>();
    for (String email : emailRecipients.split(",")) {
        EventAuditLogSubscriber eals = new EventAuditLogSubscriber();
        eals.setevent_type(MessageHelper.MessageType.alertMessage.getEventType());
        eals.setevent_up_name("DATABASE_UNREACHABLE");
        eals.setmethod_id(EventNotificationMethods.EMAIL.getValue());
        eals.setmethod_address(StringUtils.strip(email));
        eals.setmessage("Failed to query for notifications. Database Connection refused.");
        eals.setseverity(AuditLogSeverity.ERROR.getValue());
        failedQueriesEventSubscribers.add(eals);
    }
    this.failedQueriesEventSubscribers = failedQueriesEventSubscribers;
}
#method_after
private void initFailedQueriesEventSubscribers() {
    String emailRecipients = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
    if (StringUtils.isEmpty(emailRecipients)) {
        return;
    }
    List<EventAuditLogSubscriber> failedQueriesEventSubscribers = new LinkedList<>();
    for (String email : emailRecipients.split(",")) {
        EventAuditLogSubscriber eals = new EventAuditLogSubscriber();
        eals.setevent_type(MessageHelper.MessageType.alertMessage.getEventType());
        eals.setevent_up_name("DATABASE_UNREACHABLE");
        eals.setmethod_id(EventNotificationMethod.EMAIL.getMethodId());
        eals.setmethod_address(StringUtils.strip(email));
        eals.setmessage("Failed to query for notifications. Database Connection refused.");
        eals.setseverity(AuditLogSeverity.ERROR.getValue());
        failedQueriesEventSubscribers.add(eals);
    }
    this.failedQueriesEventSubscribers = failedQueriesEventSubscribers;
}
#end_block

#method_before
public EventSender getEventSender(int intValue) {
    return eventSenders.get(EventNotificationMethods.forValue(intValue));
}
#method_after
public EventSender getEventSender(EventNotificationMethod method) {
    return eventSenders.get(method);
}
#end_block

#method_before
public EventSender getEventSender(int intValue) {
    return eventSenders.get(EventNotificationMethods.forValue(intValue));
}
#method_after
public EventSender getEventSender(int methodId) {
    return eventSenders.get(EventNotificationMethod.forMethodId(methodId));
}
#end_block

#method_before
private static Map<String, String> getMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.redhat.com");
    prop.put(NotificationProperties.MAIL_USER, "dev-null@redhat.com");
    prop.put(NotificationProperties.HTML_MESSAGE_FORMAT, "true");
    return prop;
}
#method_after
private static Map<String, String> getMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.redhat.com");
    prop.put(NotificationProperties.MAIL_USER, "dev-null@redhat.com");
    prop.put(NotificationProperties.HTML_MESSAGE_FORMAT, "true");
    prop.put(NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE);
    return prop;
}
#end_block

#method_before
private static Map<String, String> getSecuredMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.gmail.com");
    prop.put(NotificationProperties.MAIL_PORT, "465");
    prop.put(NotificationProperties.MAIL_USER, "mailtest.redhat@gmail.com");
    prop.put(NotificationProperties.MAIL_PASSWORD, "q1!w2@e3#!");
    prop.put(NotificationProperties.MAIL_FROM, "dev-null@redhat.com");
    prop.put(NotificationProperties.MAIL_ENABLE_SSL, "true");
    return prop;
}
#method_after
private static Map<String, String> getSecuredMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.gmail.com");
    prop.put(NotificationProperties.MAIL_PORT, "465");
    prop.put(NotificationProperties.MAIL_USER, "mailtest.redhat@gmail.com");
    prop.put(NotificationProperties.MAIL_PASSWORD, "q1!w2@e3#!");
    prop.put(NotificationProperties.MAIL_FROM, "dev-null@redhat.com");
    prop.put(NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL);
    return prop;
}
#end_block

#method_before
private void distributeEvent(List<AuditLogEventSubscriber> eventSubscribers, AuditLogEvent event) throws SQLException {
    for (AuditLogEventSubscriber subscriber : eventSubscribers) {
        if (subscriber.isSubscribed(event)) {
            EventSender method = notificationMethodsMapper.getEventSender(subscriber.getEventNotificationMethod());
            EventSenderResult sendResult;
            try {
                sendResult = method.send(event, subscriber);
            } catch (Exception e) {
                log.error("Failed to dispatch message", e);
                sendResult = new EventSenderResult();
                sendResult.setSent(false);
                sendResult.setReason(e.getMessage());
            }
            eventsManager.addEventNotificationHistoryRecord(event, subscriber, sendResult);
            eventsManager.updateAuditLogEventProcessed(event.getId(), log);
        }
    }
}
#method_after
private void distributeEvent(List<AuditLogEventSubscriber> eventSubscribers, AuditLogEvent event) throws SQLException {
    for (AuditLogEventSubscriber subscriber : eventSubscribers) {
        if (subscriber.isSubscribed(event)) {
            Transport sender = notificationMethodsMapper.getEventSender(subscriber.getEventNotificationMethod());
            EventSenderResult sendResult;
            try {
                sendResult = sender.send(event, subscriber);
            } catch (Exception e) {
                log.error("Failed to dispatch message", e);
                sendResult = new EventSenderResult();
                sendResult.setSent(false);
                sendResult.setReason(e.getMessage());
            }
            eventsManager.addEventNotificationHistoryRecord(event, subscriber, sendResult);
            eventsManager.updateAuditLogEventProcessed(event.getId(), log);
        }
    }
}
#end_block

#method_before
private void deleteObsoleteHistoryData() throws SQLException {
    if (prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY) > 0) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
        Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
        Connection connection = null;
        PreparedStatement deleteStmt = null;
        int deletedRecords;
        try {
            connection = ds.getConnection();
            deleteStmt = connection.prepareStatement("DELETE FROM event_notification_hist WHERE sent_at < ?");
            deleteStmt.setTimestamp(1, startDeleteFrom);
            deletedRecords = deleteStmt.executeUpdate();
        } finally {
            if (deleteStmt != null) {
                deleteStmt.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        if (deletedRecords > 0) {
            log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
        }
    }
}
#method_after
private void deleteObsoleteHistoryData() throws SQLException {
    if (prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY) > 0) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
        Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
        Connection connection = null;
        PreparedStatement deleteStmt = null;
        int deletedRecords;
        try {
            connection = ds.getConnection();
            deleteStmt = connection.prepareStatement("delete from event_notification_hist where sent_at < ?");
            deleteStmt.setTimestamp(1, startDeleteFrom);
            deletedRecords = deleteStmt.executeUpdate();
        } finally {
            if (deleteStmt != null) {
                deleteStmt.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        if (deletedRecords > 0) {
            log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
        }
    }
}
#end_block

#method_before
private void markOldEventsAsProcessed() throws SQLException {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("UPDATE audit_log SET " + "processed = 'true' " + "WHERE " + "processed = 'false' " + "AND log_time < ?");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
    if (updatedRecords > 0) {
        log.debug(updatedRecords + " old records were marked as processed in the \"audit_log\" table.");
    }
}
#method_after
private void markOldEventsAsProcessed() throws SQLException {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("update audit_log set " + "processed = 'true' " + "where " + "processed = 'false' " + "and log_time < ?");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
    if (updatedRecords > 0) {
        log.debug(updatedRecords + " old records were marked as processed in the \"audit_log\" table.");
    }
}
#end_block

#method_before
private void updateAuditLogEventProcessed(EventAuditLogSubscriber eventSubscriber) throws SQLException {
    Connection connection = null;
    PreparedStatement ps = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("UPDATE audit_log SET processed = 'true' WHERE audit_log_id = ?");
        ps.setLong(1, eventSubscriber.getaudit_log_id());
        int updated = ps.executeUpdate();
        if (updated != 1) {
            log.error("Failed to mark audit_log entry as processed for audit_log_id: " + eventSubscriber.getaudit_log_id());
        }
    } finally {
        DbUtils.closeQuietly(ps, connection);
    }
}
#method_after
private void updateAuditLogEventProcessed(EventAuditLogSubscriber eventSubscriber) throws SQLException {
    Connection connection = null;
    PreparedStatement ps = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("update audit_log set processed = 'true' where audit_log_id = ?");
        ps.setLong(1, eventSubscriber.getaudit_log_id());
        int updated = ps.executeUpdate();
        if (updated != 1) {
            log.error("Failed to mark audit_log entry as processed for audit_log_id: " + eventSubscriber.getaudit_log_id());
        }
    } finally {
        DbUtils.closeQuietly(ps, connection);
    }
}
#end_block

#method_before
public void validate() {
    // validate mandatory and non empty properties
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.MAIL_PORT, NotificationProperties.MAIL_SERVER, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION }) {
        if (StringUtils.isEmpty(getProperty(property))) {
            throw new IllegalArgumentException(String.format("Check configuration file, '%s' is missing", property));
        }
    }
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
    if (!isSmtpEncryptionOptionValid()) {
        throw new IllegalArgumentException(String.format("Check configuration file, '%s' value has to be one of: '%s', '%s', '%s'.", NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL, NotificationProperties.MAIL_SMTP_ENCRYPTION_TLS));
    }
    // try to resolve MAIL_SERVER host
    try {
        InetAddress.getAllByName(getProperty(NotificationProperties.MAIL_SERVER));
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format("Check configuration file, cannot verify '%s' value", NotificationProperties.MAIL_SERVER), ex);
    }
    // validate email addresses
    for (String property : new String[] { NotificationProperties.MAIL_USER, NotificationProperties.MAIL_FROM, NotificationProperties.MAIL_REPLY_TO }) {
        String candidate = getProperty(property);
        if (!StringUtils.isEmpty(candidate)) {
            try {
                new InternetAddress(candidate);
            } catch (Exception ex) {
                throw new IllegalArgumentException(String.format("Check configuration file, invalid format in '%s'", property), ex);
            }
        }
    }
    // validate mail user value
    String emailUser = getProperty(NotificationProperties.MAIL_USER, true);
    if (StringUtils.isEmpty(emailUser) && (MAIL_SMTP_ENCRYPTION_SSL.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || MAIL_SMTP_ENCRYPTION_TLS.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || StringUtils.isNotEmpty(getProperty(NotificationProperties.MAIL_PASSWORD, true)))) {
        throw new IllegalArgumentException(String.format("'%s' must be set when SSL or TLS is enabled or when password is set", NotificationProperties.MAIL_USER));
    }
}
#method_after
public void validate() {
    // validate mandatory and non empty properties
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.MAIL_PORT, NotificationProperties.MAIL_SERVER, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION }) {
        if (StringUtils.isEmpty(getProperty(property))) {
            throw new IllegalArgumentException(String.format("Check configuration file, '%s' is missing", property));
        }
    }
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
    if (!isSmtpEncryptionOptionValid()) {
        throw new IllegalArgumentException(String.format("Check configuration file, '%s' value has to be one of: '%s', '%s', '%s'.", NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL, NotificationProperties.MAIL_SMTP_ENCRYPTION_TLS));
    }
    boolean mailPortValid = false;
    try {
        int port = new Integer(getProperty(MAIL_PORT));
        if (port > 0 && port < 65536) {
            mailPortValid = true;
        }
    } catch (NumberFormatException ex) {
    }
    if (!mailPortValid) {
        throw new IllegalArgumentException(String.format("Check configuration file, MAIL_PORT value has to be in range from 1 to 65535," + " currently '%s'", getProperty(MAIL_PORT)));
    }
    // try to resolve MAIL_SERVER host
    try {
        InetAddress.getAllByName(getProperty(NotificationProperties.MAIL_SERVER));
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format("Check configuration file, cannot verify '%s' value", NotificationProperties.MAIL_SERVER), ex);
    }
    // validate email addresses
    for (String property : new String[] { NotificationProperties.MAIL_USER, NotificationProperties.MAIL_FROM, NotificationProperties.MAIL_REPLY_TO }) {
        String candidate = getProperty(property);
        if (!StringUtils.isEmpty(candidate)) {
            try {
                new InternetAddress(candidate);
            } catch (Exception ex) {
                throw new IllegalArgumentException(String.format("Check configuration file, invalid format in '%s'", property), ex);
            }
        }
    }
    // validate mail user value
    String emailUser = getProperty(NotificationProperties.MAIL_USER, true);
    if (StringUtils.isEmpty(emailUser) && (MAIL_SMTP_ENCRYPTION_SSL.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || MAIL_SMTP_ENCRYPTION_TLS.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || StringUtils.isNotEmpty(getProperty(NotificationProperties.MAIL_PASSWORD, true)))) {
        throw new IllegalArgumentException(String.format("'%s' must be set when SSL or TLS is enabled or when password is set", NotificationProperties.MAIL_USER));
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    EventNotificationMethod eventNotificationMethod = getParameters().getEventSubscriber().getevent_notification_method();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, eventNotificationMethod)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        if (eventNotificationMethod != null) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                String domain = getParameters().getDomain();
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    // If an exception is thrown while trying, handle it and and fail with the relevant message
                    try {
                        user = UserCommandBase.initUser(getParameters().getSessionId(), domain, subscriberId);
                        retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
                    } catch (VdcBLLException vdcBllException) {
                        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
                        retValue = false;
                    }
                } else {
                    retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(String.format("$eventName %1$s", eventName));
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    EventNotificationMethod eventNotificationMethod = getParameters().getEventSubscriber().getevent_notification_method();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, eventNotificationMethod)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        if (eventNotificationMethod != null) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                    retValue = false;
                } else {
                    retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(String.format("$eventName %1$s", eventName));
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getAvailableNotificationEvents();
    Translator eventNotificationEntityTranslator = EnumTranslator.create(EventNotificationEntity.class);
    Translator auditLogTypeTranslator = EnumTranslator.create(AuditLogType.class);
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(eventNotificationEntityTranslator.containsKey(eventType) ? eventNotificationEntityTranslator.get(eventType) : eventType.toString());
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = auditLogTypeTranslator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    model.setHelpTag(HelpTag.add_event_notification);
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getAvailableNotificationEvents();
    Translator eventNotificationEntityTranslator = EnumTranslator.create(EventNotificationEntity.class);
    Translator auditLogTypeTranslator = EnumTranslator.create(AuditLogType.class);
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(eventNotificationEntityTranslator.containsKey(eventType) ? eventNotificationEntityTranslator.get(eventType) : eventType.toString());
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = auditLogTypeTranslator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getManageEventsCommand()) {
        manageEvents();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getManageEventsCommand()) {
        manageEvents();
    }
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    }
    if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(_vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            ResourceManager.getInstance().getEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase(_vds.getId());
    logable.addCustomValue("VdsStatus", _vds.getStatus().toString());
    auditLog(logable, AuditLogType.VDS_DETECTED);
}
#method_after
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (_vds.getStatus() != VDSStatus.Up) {
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("HostStatus", _vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                if (lunFromMap != null && lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    _vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    // Go over all the vms and determine which ones require updating
    // Update only running VMs
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null && vmDynamic.getStatus() != VMStatus.MigratingTo) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and determine which ones require updating
    // Update only running VMs
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null && vmDynamic.getStatus() != VMStatus.MigratingTo) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (!vmsToUpdateFromVds.isEmpty()) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        // => cacheVm == null
        {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        props.remove("runOnce");
        props.remove("cpuName");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // remove all fields that should not be checked:
        props.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains(VmDynamic.STATUS_FIELD_NAME) && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove(VmDynamic.STATUS_FIELD_NAME);
        }
        // if anything else changed
        if (!props.isEmpty()) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

#method_before
private void addVmInterfaceStatisticsToList(List<VmNetworkInterface> list) {
    if (list.size() <= 0) {
        return;
    }
    _vmInterfaceStatisticsToSave.put(list.get(0).getVmId(), list);
}
#method_after
private void addVmInterfaceStatisticsToList(List<VmNetworkInterface> list) {
    if (list.isEmpty()) {
        return;
    }
    _vmInterfaceStatisticsToSave.put(list.get(0).getVmId(), list);
}
#end_block

#method_before
protected List<LUNs> getVmLunDisksToSave() {
    return Collections.unmodifiableList(_vmLunDisksToSave);
}
#method_after
protected List<LUNs> getVmLunDisksToSave() {
    return Collections.unmodifiableList(vmLunDisksToSave);
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setStorageType(StorageType.valueOf(xmlRpcStruct.get("type").toString()));
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    } else {
        vm.setCurrentCd(null);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
}
#end_block

#method_before
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
    }
}
#method_after
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        if (FeatureSupported.hostNetworkQos(Collections.max(host.getSupportedClusterVersionsSet()))) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(network, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            iface.setQos(qosMapper.deserialize());
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.isHostedEngine()) {
                            // The Hosted Engine vm is migrated by the HA agent
                            continue;
                        }
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(vmListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (StringHelper.stringsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (StringHelper.stringsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    StringHelper.stringsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (ObjectUtils.objectsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    ObjectUtils.objectsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        onExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        onShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnReboot")) {
        onReboot();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
public void getConfiguration() {
    String currentDomainNameEntry = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomainNameEntry, DOMAIN_SEPERATOR, null);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    Set<String> domainNames = new TreeSet<String>(domainNameEntry.getDomainNames());
    for (String domain : domainNames) {
        String authMode = getDomainAuthMode(domain);
        String userName = adUserNameEntry.getValueForDomain(domain);
        System.out.println("Domain: " + domain);
        System.out.println("\tUser name: " + userName);
    }
}
#method_after
public void getConfiguration() {
    String currentDomainNameEntry = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomainNameEntry, DOMAIN_SEPERATOR, null);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    for (String domain : createDomainNameList(domainNameEntry.getDomainNames(), true)) {
        String authMode = getDomainAuthMode(domain);
        String userName = adUserNameEntry.getValueForDomain(domain);
        System.out.println("Domain: " + domain);
        System.out.println("\tUser name: " + userName);
    }
}
#end_block

#method_before
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    List<Entry<String, String>> gssapiDomainValues = new ArrayList<>(gssapiDomains.getValues());
    if (isValidate) {
        // sort domains so validate report looks better
        Collections.sort(gssapiDomainValues, createDomainComparator());
    }
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName + "\n");
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && args.contains(ARG_REPORT)) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#method_after
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    for (String domain : createDomainNameList(gssapiDomains.getDomainNames(), isValidate)) {
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName + "\n");
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && args.contains(ARG_REPORT)) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#end_block

#method_before
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    List<Entry<String, String>> simpleDomainValues = new ArrayList<>(simpleDomains.getValues());
    if (isValidate) {
        // sort domains so validate report looks better
        Collections.sort(simpleDomainValues, createDomainComparator());
    }
    StringBuffer userGuid = new StringBuffer();
    for (Entry<String, String> currDomain : simpleDomainValues) {
        String domain = currDomain.getKey();
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (args.contains(ARG_REPORT)) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#method_after
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    StringBuffer userGuid = new StringBuffer();
    for (String domain : createDomainNameList(simpleDomains.getDomainNames(), isValidate)) {
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (args.contains(ARG_REPORT)) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#end_block

#method_before
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, PersistentSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (!NetworkUtils.isLabeled(nic)) {
        return;
    }
    for (String label : nic.getLabels()) {
        // configure networks by target cluster assignment
        List<Network> targetLabeledNetworks = targetNetworksByLabel.get(label);
        if (targetLabeledNetworks != null) {
            for (Network net : targetLabeledNetworks) {
                if (targetNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                    configureNetwork(nic, params.getInterfaces(), net);
                } else if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
        // remove labeled networks originated in source cluster but not assigned to target cluster
        List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
        if (sourceLabeledNetworks != null) {
            for (Network net : sourceLabeledNetworks) {
                if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
    }
}
#method_after
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, PersistentSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (!NetworkUtils.isLabeled(nic)) {
        return;
    }
    for (String label : nic.getLabels()) {
        // remove labeled networks originated in source cluster but not assigned to target cluster
        List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
        if (sourceLabeledNetworks != null) {
            for (Network net : sourceLabeledNetworks) {
                if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
        // configure networks by target cluster assignment
        List<Network> targetLabeledNetworks = targetNetworksByLabel.get(label);
        if (targetLabeledNetworks != null) {
            for (Network net : targetLabeledNetworks) {
                if (targetNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                    configureNetwork(nic, params.getInterfaces(), net);
                } else if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
    }
}
#end_block

#method_before
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    model.setHelpTag(HelpTag.new_data_center);
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setEntity(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_data_center");
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDataCenterTitle());
    model.setHelpTag(HelpTag.remove_data_center);
    // $NON-NLS-1$
    model.setHashName("remove_data_center");
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void forceRemove() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceRemoveDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("force_remove_data_center");
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnForceRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void forceRemove() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceRemoveDataCenterTitle());
    model.setHelpTag(HelpTag.force_remove_data_center);
    // $NON-NLS-1$
    model.setHashName("force_remove_data_center");
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnForceRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#method_after
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#end_block

#method_before
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#method_after
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        confirmModel.setHelpTag(HelpTag.change_data_center_compatibility_version);
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    Version v = VersionStorageFormatUtil.getEarliestVersionSupported(newFormat);
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg(v.getValue()));
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
private void promptNoQuotaInDCMessage() {
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDCQuotaEnforcementModeTitle());
    // $NON-NLS-1$
    confirmModel.setHashName("change_data_center_quota_enforcement_mode");
    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDCQuotaEnforcementMsg());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSaveInternal", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    getConfirmWindow().getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("CancelConfirmation", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    getConfirmWindow().getCommands().add(tempVar2);
}
#method_after
private void promptNoQuotaInDCMessage() {
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDCQuotaEnforcementModeTitle());
    confirmModel.setHelpTag(HelpTag.change_data_center_quota_enforcement_mode);
    // $NON-NLS-1$
    confirmModel.setHashName("change_data_center_quota_enforcement_mode");
    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDCQuotaEnforcementMsg());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSaveInternal", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    getConfirmWindow().getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("CancelConfirmation", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    getConfirmWindow().getCommands().add(tempVar2);
}
#end_block

#method_before
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    AsyncDataProvider.getDataCenterStorageConnectionsByType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
            iscsiBondListModel.setIsAvailable(!connections.isEmpty());
        }
    }), storagePool.getId(), StorageType.ISCSI);
}
#method_after
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    AsyncDataProvider.getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            boolean hasIscsiStorage = false;
            ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
            for (StorageServerConnections connection : connections) {
                if (connection.getstorage_type() == StorageType.ISCSI) {
                    hasIscsiStorage = true;
                    break;
                }
            }
            iscsiBondListModel.setIsAvailable(hasIscsiStorage);
        }
    }), storagePool.getId(), StorageType.ISCSI);
}
#end_block

#method_before
private void initializeStorageTargetsList() {
    AsyncDataProvider.getDataCenterStorageConnectionsByType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<StorageServerConnections> selected = new ArrayList<StorageServerConnections>();
            ArrayList<StorageServerConnections> conns = (ArrayList<StorageServerConnections>) returnValue;
            Set<String> iscsiBonded = isBondExist() ? new HashSet<String>(getIscsiBond().getStorageConnectionIds()) : Collections.<String>emptySet();
            for (StorageServerConnections conn : conns) {
                if (iscsiBonded.contains(conn.getid())) {
                    selected.add(conn);
                }
            }
            IscsiBondModel model = (IscsiBondModel) target;
            model.getStorageTargets().setItems(conns);
            model.getStorageTargets().setSelectedItems(selected);
        }
    }), getStoragePool().getId(), StorageType.ISCSI);
}
#method_after
private void initializeStorageTargetsList() {
    AsyncDataProvider.getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<StorageServerConnections> selected = new ArrayList<StorageServerConnections>();
            ArrayList<StorageServerConnections> conns = (ArrayList<StorageServerConnections>) returnValue;
            Set<String> iscsiBonded = isBondExist() ? new HashSet<String>(getIscsiBond().getStorageConnectionIds()) : Collections.<String>emptySet();
            for (StorageServerConnections conn : conns) {
                if (iscsiBonded.contains(conn.getid())) {
                    selected.add(conn);
                }
            }
            IscsiBondModel model = (IscsiBondModel) target;
            model.getStorageTargets().setItems(conns);
            model.getStorageTargets().setSelectedItems(selected);
        }
    }), getStoragePool().getId(), StorageType.ISCSI);
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Iterable<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI }));
    return diskInterfaces;
}
#method_after
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            HashMap<Integer, String> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            String defaultValue = result.get(DEFAULT_OS_ID);
            osNames = new MapWithDefaults<Integer, String>(result, defaultValue);
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Integer, Map<Version, List<DisplayType>>> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            displayTypes = new MapWithDefaults<Integer, Map<Version, List<DisplayType>>>(result, result.get(DEFAULT_OS_ID));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setkernel_url((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setkernel_params((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setinitrd_url((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#end_block

#method_before
public static void updateVmInitFromDB(VmBase vm, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    vm.setVmInit(db.get(vm.getId()));
    if (secure && vm.getVmInit() != null) {
        vm.getVmInit().setPasswordSet(!StringUtils.isEmpty(vm.getVmInit().getRootPassword()));
        vm.getVmInit().setRootPassword(null);
    }
}
#method_after
public static void updateVmInitFromDB(VmBase vm, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    vm.setVmInit(db.get(vm.getId()));
    if (vm.getVmInit() != null) {
        if (secure) {
            vm.getVmInit().setPasswordAlreadyStored(!StringUtils.isEmpty(vm.getVmInit().getRootPassword()));
            vm.getVmInit().setRootPassword(null);
        } else {
            vm.getVmInit().setPasswordAlreadyStored(false);
        }
    }
}
#end_block

#method_before
public static void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInitDAO db = DbFacade.getInstance().getVmInitDao();
        VmInit oldVmInit = db.get(vm.getId());
        if (oldVmInit == null) {
            db.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordSet()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            db.update(vm.getVmInit());
        }
    }
}
#method_after
public static void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInitDAO db = DbFacade.getInstance().getVmInitDao();
        VmInit oldVmInit = db.get(vm.getId());
        if (oldVmInit == null) {
            db.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            db.update(vm.getVmInit());
        }
    }
}
#end_block

#method_before
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, long sizeRequested, Map<StorageDomain, Integer> domain2reservedSpaceInDomain) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    for (StorageDomain currDomain : domainsInPool) {
        long reservedSizeForDisks = domain2reservedSpaceInDomain.containsKey(currDomain) ? domain2reservedSpaceInDomain.get(currDomain) : 0;
        long sizeNeeded = sizeRequested + reservedSizeForDisks;
        if ((currDomain.getStorageDomainType().equals(StorageDomainType.Master) || currDomain.getStorageDomainType().equals(StorageDomainType.Data)) && currDomain.getStatus() == StorageDomainStatus.Active && doesStorageDomainHaveSpaceForRequest(currDomain, sizeNeeded)) {
            return currDomain;
        }
    }
    return null;
}
#method_after
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, long sizeRequested, Map<StorageDomain, Integer> domain2reservedSpaceInDomain) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    for (StorageDomain currDomain : domainsInPool) {
        long reservedSizeForDisks = domain2reservedSpaceInDomain.containsKey(currDomain) ? domain2reservedSpaceInDomain.get(currDomain) : 0;
        long sizeNeeded = sizeRequested + reservedSizeForDisks;
        if (currDomain.getStorageDomainType().isDataDomain() && currDomain.getStatus() == StorageDomainStatus.Active && doesStorageDomainHaveSpaceForRequest(currDomain, sizeNeeded)) {
            return currDomain;
        }
    }
    return null;
}
#end_block

#method_before
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    // if not proven to be hidden, show it
    boolean isWindows = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    getDomain().setIsAvailable(isWindows);
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordSet());
        getPasswordSet().setIsChangable(vmInit.isPasswordSet());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#method_after
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    // if not proven to be hidden, show it
    boolean isWindows = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    getDomain().setIsAvailable(isWindows);
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname((String) getHostname().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordSet((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname((String) getHostname().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            } else {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
            }
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            }
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl();
    } catch (SQLException e) {
        throw new ManageDomainsResult("Please verify the following:\n1. Your database credentials are valid.\n2. The database machine is accessible.\n3. The database service is running", ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#method_after
public void init() throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(args.get(ARG_CONFIG_FILE));
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl();
    } catch (SQLException e) {
        throw new ManageDomainsResult("Please verify the following:\n1. Your database credentials are valid.\n2. The database machine is accessible.\n3. The database service is running", ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#end_block

#method_before
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    util = new ManageDomains();
    CLIParser parser = new CLIParser(args);
    String configFilePath = CONF_FILE_PATH;
    if (parser.hasArg(Arguments.configFile.name())) {
        configFilePath = parser.getArg(Arguments.configFile.name());
    }
    if (parser.hasArg(Arguments.report.name())) {
        util.reportAllErrors = true;
    }
    if (parser.hasArg(Arguments.addPermissions.name())) {
        util.addPermissions = true;
    }
    try {
        // it's existence is checked during the parser validation
        String engineConfigProperties = parser.getArg(Arguments.propertiesFile.name());
        util.init(configFilePath);
        util.validate(parser);
        util.createConfigurationProvider(engineConfigProperties);
        util.runCommand(parser);
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    try {
        ManageDomainsArguments mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
            System.exit(0);
        } else {
            util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
private void createConfigurationProvider(String engineConfigProperties) throws ManageDomainsResult {
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#method_after
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        if (changePasswordUrl == null) {
            changePasswordUrl = "";
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser);
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.hasArg(Arguments.forceDelete.name()));
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#method_after
private void runCommand() throws ManageDomainsResult {
    String action = args.get(ARG_ACTION);
    if (ACTION_ADD.equals(action)) {
        addDomain();
    } else if (ACTION_EDIT.equals(action)) {
        editDomain();
    } else if (ACTION_DELETE.equals(action)) {
        deleteDomain();
    } else if (ACTION_VALIDATE.equals(action)) {
        validate();
    } else if (ACTION_LIST.equals(action)) {
        getConfiguration();
    }
}
#end_block

#method_before
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput() throws ManageDomainsResult {
    String pass = null;
    if (args.contains(ARG_PASSWORD_FILE)) {
        try {
            pass = readPasswordFile(args.get(ARG_PASSWORD_FILE));
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else {
        pass = readInteractively("Enter password:", true);
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
protected List<String> getLdapServers(CLIParser parser, String domainName) throws ManageDomainsResult {
    String argValue = parser.getArg(Arguments.ldapServers.toString().toLowerCase());
    if (StringUtils.isEmpty(argValue)) {
        LdapSRVLocator locator = new LdapSRVLocator();
        DnsSRVResult ldapDnsResult = null;
        boolean foundServers = true;
        try {
            InetAddress ia = InetAddress.getByName(domainName);
            ia.getCanonicalHostName();
        } catch (UnknownHostException e) {
            foundServers = false;
        }
        try {
            ldapDnsResult = locator.getLdapServers(domainName);
            if (!foundSrvRecords(ldapDnsResult)) {
                foundServers = false;
            }
        } catch (Exception ex) {
            foundServers = false;
        }
        if (!foundServers) {
            throw new ManageDomainsResult("Could not locate LDAP servers to be used to validate the input of the utility", ManageDomainsResultEnum.NO_LDAP_SERVERS_FOR_DOMAIN, domainName);
        }
        ArrayList<String> result = new ArrayList<String>();
        for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
            result.add(ldapDnsResult.getAddresses()[counter]);
        }
        return result;
    }
    return new ArrayList<String>(Arrays.asList(argValue.split(",")));
}
#method_after
protected List<String> getLdapServers(String domainName) throws ManageDomainsResult {
    ArrayList<String> servers = new ArrayList<String>();
    String argValue = args.get(ARG_LDAP_SERVERS);
    if (StringUtils.isEmpty(argValue)) {
        LdapSRVLocator locator = new LdapSRVLocator();
        DnsSRVResult ldapDnsResult = null;
        boolean foundServers = true;
        try {
            ldapDnsResult = locator.getLdapServers(domainName);
            if (!foundSrvRecords(ldapDnsResult)) {
                foundServers = false;
            }
        } catch (Exception ex) {
            foundServers = false;
        }
        if (!foundServers) {
            throw new ManageDomainsResult("Could not locate LDAP servers to be used to validate the input of the utility", ManageDomainsResultEnum.NO_LDAP_SERVERS_FOR_DOMAIN, domainName);
        }
        for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
            // In case the address provides a port, don't keep it, we currently assume only the port
            // defined at ConfigValues.ldapServerPort is being used.
            String[] addressParts = ldapDnsResult.getAddresses()[counter].split(":");
            servers.add(addressParts[0]);
        }
    } else {
        servers = new ArrayList<String>(Arrays.asList(argValue.split(",")));
        for (String server : servers) {
            try {
                for (InetAddress ip : InetAddress.getAllByName(server)) {
                    ip.getCanonicalHostName();
                    log.debug(String.format("Successfuly resolved IP '%s' for server '%s'", ip.getHostAddress(), server));
                }
            } catch (Exception ex) {
                String msg = String.format("Cannot resolve LDAP server hostname '%s'. Details: %s,", server, ex.getMessage());
                log.warn(msg, ex);
                System.err.println(msg);
            }
        }
    }
    return servers;
}
#end_block

#method_before
public void addDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    adUserNameEntry.setValueForDomain(domainName, parser.getArg(Arguments.user.toString()));
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput(parser));
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    String ldapServersStr = parser.getArg(Arguments.ldapServers.name());
    if (!StringUtils.isEmpty(ldapServersStr)) {
        // Replacing "," with ";" - from user perspective of the utility, passing comma delimited string makes more sense and more natural
        // But "," is used as domain separate character when storing to DB.
        ldapServersStr = ldapServersStr.replace(',', ';');
        ldapServersEntry.setValueForDomain(domainName, ldapServersStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = null;
    try {
        changePasswordUrlStr = getChangePasswordMsg();
    } catch (UnsupportedEncodingException e) {
        log.error("Error in encoding the change password message. ", e);
    }
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
private void printSuccessMessage(String domainName, String action) {
    if (addPermissions) {
        System.out.print(String.format(SUCCESS_MESSAGE_FOR_ACTION_WITH_ADD_PERMISSIONS, "added", domainName));
    }
    System.out.println(SERVICE_RESTART_MESSAGE);
}
#method_after
private void printSuccessMessage(String domainName, String action) {
    if (args.contains(ARG_ADD_PERMISSIONS)) {
        System.out.print(String.format(SUCCESS_MESSAGE_FOR_ACTION_WITH_ADD_PERMISSIONS, "added", domainName));
    }
    System.out.println(SERVICE_RESTART_MESSAGE);
}
#end_block

#method_before
private void handleAddPermissions(String domainName, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUserIdEntry) {
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else if (!userHasPermissions(adUserNameEntry, adUserIdEntry)) {
        System.out.println(String.format(INFO_ABOUT_NOT_ADDING_PERMISSIONS, domainName));
    }
}
#method_after
private void handleAddPermissions(String domainName, String userName, String userId) {
    if (args.contains(ARG_ADD_PERMISSIONS)) {
        updatePermissionsTable(userName, domainName, userId);
    } else if (!userHasPermissions(userName, domainName)) {
        System.out.println(String.format(INFO_ABOUT_NOT_ADDING_PERMISSIONS, domainName));
    }
}
#end_block

#method_before
private ManageDomainsResult updatePermissionsTable(DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUseridEntry) {
    try {
        Set<Entry<String, String>> userNameValues = adUserNameEntry.getValues();
        for (Entry<String, String> currUserEntry : userNameValues) {
            String currDomain = currUserEntry.getKey();
            String currUser = currUserEntry.getValue();
            String guid = adUseridEntry.getValueForDomain(currDomain);
            daoImpl.updatePermissionsTable(guid, currUser, currDomain);
        }
        return OK_RESULT;
    } catch (SQLException e) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_CHANGES_IN_DATABASE, e.getMessage());
    }
}
#method_after
private ManageDomainsResult updatePermissionsTable(String userName, String domainName, String adUserId) {
    try {
        daoImpl.updatePermissionsTable(adUserId, userName, domainName);
        return OK_RESULT;
    } catch (SQLException e) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_CHANGES_IN_DATABASE, e.getMessage());
    }
}
#end_block

#method_before
private boolean userHasPermissions(DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUseridEntry) {
    try {
        Set<Entry<String, String>> userNameValues = adUserNameEntry.getValues();
        for (Entry<String, String> currUserEntry : userNameValues) {
            String currDomain = currUserEntry.getKey();
            String currUser = currUserEntry.getValue();
            if (daoImpl.getUserHasPermissions(currUser, currDomain)) {
                return true;
            }
        }
    } catch (SQLException e) {
        log.error(e);
    }
    return false;
}
#method_after
private boolean userHasPermissions(String userName, String domainName) {
    boolean result = false;
    try {
        result = daoImpl.getUserHasPermissions(userName, domainName);
    } catch (SQLException ex) {
        log.error("Error testing user permissions", ex);
    }
    return result;
}
#end_block

#method_before
public void editDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode;
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    authMode = getDomainAuthMode(domainName);
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = parser.getArg(Arguments.user.toString());
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput(parser);
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain() throws ManageDomainsResult {
    String authMode;
    String domainName = args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.contains(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.contains(ARG_PROVIDER)) {
        ldapProviderType = args.getLdapProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        try {
            changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordMsg());
        } catch (UnsupportedEncodingException e) {
            log.error("Error in encoding the change password message. ", e);
        }
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#method_after
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (!args.contains(ARG_LDAP_SERVERS) && useDnsLookup) {
                // The arguments do not contain a list of ldap servers, the
                // kerberos configuration should not be created according to it if
                // useDnsLookup is set to true as in this case the kdc and the domain_realm information
                // will be resolved by DNS during kerberos negotiation.
                ldapServersPerGSSAPIDomains = Collections.emptyMap();
            }
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#end_block

#method_before
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    Set<Entry<String, String>> gssapiDomainValues = gssapiDomains.getValues();
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName);
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && reportAllErrors) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#method_after
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    Set<Entry<String, String>> gssapiDomainValues = gssapiDomains.getValues();
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName);
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && args.contains(ARG_REPORT)) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#end_block

#method_before
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    Set<Entry<String, String>> simpleDomainValues = simpleDomains.getValues();
    StringBuffer userGuid = new StringBuffer();
    for (Entry<String, String> currDomain : simpleDomainValues) {
        String domain = currDomain.getKey();
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (reportAllErrors) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#method_after
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    Set<Entry<String, String>> simpleDomainValues = simpleDomains.getValues();
    StringBuffer userGuid = new StringBuffer();
    for (Entry<String, String> currDomain : simpleDomainValues) {
        String domain = currDomain.getKey();
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (args.contains(ARG_REPORT)) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordMsg, changePasswordUrlEntry);
    }
}
#end_block

#method_before
public void deleteDomain(String domainName, boolean forceDelete) throws ManageDomainsResult {
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !forceDelete) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!forceDelete && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#method_after
public void deleteDomain() throws ManageDomainsResult {
    String domainName = args.get(ARG_DOMAIN).toLowerCase();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !args.contains(ARG_FORCE)) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!args.contains(ARG_FORCE) && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String changePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(changePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    changePasswordUrlEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePasswordUrlEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#end_block

#method_before
private boolean confirmDeleteDomain(String domainName) {
    String response = null;
    while (StringUtils.isBlank(response) || (!StringUtils.equalsIgnoreCase(response, "yes") && !StringUtils.equalsIgnoreCase(response, "no"))) {
        System.out.println("Are you sure you like to delete domain " + domainName + " (yes/no) : ");
        response = System.console().readLine();
    }
    return response.equals("yes");
}
#method_after
private boolean confirmDeleteDomain(String domainName) {
    String response = null;
    while (StringUtils.isBlank(response) || (!StringUtils.equalsIgnoreCase(response, "yes") && !StringUtils.equalsIgnoreCase(response, "no"))) {
        System.out.print("Are you sure you like to delete domain " + domainName + " (yes/no): ");
        response = System.console().readLine();
    }
    return response.equals("yes");
}
#end_block

#method_before
private static void deleteFile(String filePath) {
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
    }
}
#method_after
private static void deleteFile(String filePath) {
    File file = new File(filePath);
    if (file.exists()) {
        if (!file.delete()) {
            log.info("Failed deleting file " + file.getAbsolutePath() + ". Continuing anyway.");
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<IVdcQueryable>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case AdGroup:
            {
                returnValue = searchAdGroups();
                break;
            }
        case AdUser:
            {
                returnValue = searchAdUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        default:
            {
                log.errorFormat("Search object type not handled: {0}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<IVdcQueryable>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case DirectoryGroup:
            {
                returnValue = searchDirectoryGroups();
                break;
            }
        case DirectoryUser:
            {
                returnValue = searchDirectoryUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case DBGroup:
            {
                returnValue = searchDbGroups();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        default:
            {
                log.errorFormat("Search object type not handled: {0}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.UpdateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#method_after
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.updateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().Subtract(data.getDate());
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.CreateADSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.CreateBackendSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Config.<Integer>GetValue(ConfigValues.SearchResultsLimit) : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), searchObj.getSearchObjectStr(), new Date(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            int maxValue = Integer.MAX_VALUE;
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? maxValue : Math.min(maxValue, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
protected String getDefaultDomain() {
    return LdapBrokerUtils.getDomainsList().get(0);
}
#method_after
protected String getDefaultDomain() {
    return DirectoryManager.getInstance().getDirectories().get(0).getName();
}
#end_block

#method_before
private static String getQuotaRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.QUOTA_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.QUOTA_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getQuotaRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.QUOTA_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.QUOTA_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getDiskImageRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.DISK_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.DISK_OBJ_NAME) + ".* ";
    System.out.println("DiskImageRegExp: " + query);
    return query;
}
#method_after
private static String getDiskImageRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.DISK_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.DISK_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVMRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VM_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VM_OBJ_NAME) + ".* ";
    System.out.println("VMRegExp: " + query);
    return query;
}
#method_after
private static String getVMRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VM_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VM_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVdsRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VDS_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VDS_OBJ_NAME) + ".* ";
    System.out.println("VdsRegExp: " + query);
    return query;
}
#method_after
private static String getVdsRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDS_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDS_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVdsGroupRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VDC_CLUSTER_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VDC_CLUSTER_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getVdsGroupRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getStoragePoolRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getStoragePoolRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
// return ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*"
// + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".* "
// + search.getPrimeryKeyName(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*";
}
#method_after
private static String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getNetworkRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.NETWORK_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.NETWORK_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getNetworkRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.NETWORK_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.NETWORK_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private SqlInjectionChecker getSqlInjectionChecker() throws Exception {
    // GWT lacks support of reflection.
    if (((String) Config.GetValue(ConfigValues.DBEngine)).equalsIgnoreCase("postgres")) {
        return new PostgresSqlInjectionChecker();
    } else {
        throw new IllegalStateException("Failed to get correct sql injection checker instance name :" + SqlInjectionChecker.class);
    }
}
#method_after
private SqlInjectionChecker getSqlInjectionChecker() throws Exception {
    // GWT lacks support of reflection.
    if (((String) Config.getValue(ConfigValues.DBEngine)).equalsIgnoreCase("postgres")) {
        return new PostgresSqlInjectionChecker();
    } else {
        throw new IllegalStateException("Failed to get correct sql injection checker instance name :" + SqlInjectionChecker.class);
    }
}
#end_block

#method_before
@Override
public SyntaxContainer analyzeSyntaxState(final String searchText, boolean final2) {
    final SyntaxContainer syntaxContainer = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter curConditionFieldAC = null;
    IAutoCompleter curConditionRelationAC = null;
    final List<String> freeTextObjSearched = new ArrayList<String>();
    char[] searchCharArr = searchText.toCharArray();
    int curStartPos = 0;
    String tryNextObj = "";
    boolean keepValid;
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        final SyntaxObjectType curState = syntaxContainer.getState();
        final char curChar = searchCharArr[idx];
        if (mDisAllowedChars.contains(curChar)) {
            syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
            return syntaxContainer;
        }
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION) && (curState != SyntaxObjectType.COLON) && (curState != SyntaxObjectType.CONDITION_VALUE) && (curState != SyntaxObjectType.OR) && (curState != SyntaxObjectType.AND)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return syntaxContainer;
                    }
                } else {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    syntaxContainer.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case CROSS_REF_OBJ:
                String curRefObj = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                }
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (mDotAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.DOT, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!"".equals(tryNextObj)) && (curConditionRelationAC.validate(tryNextObj))) {
                    // i.e. the relation object has another charecter
                    break;
                } else if (curConditionRelationAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!curConditionRelationAC.validateCompletion(nextObject)) && (!mDotAC.validateCompletion(nextObject))) {
                    syntaxContainer.setErr(SyntaxError.INVALID_POST_CROSS_REF_OBJ, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                tryNextObj = "";
                break;
            case DOT:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                if (curConditionFieldAC == null) {
                    syntaxContainer.setErr(SyntaxError.CANT_GET_CONDITION_FIELD_AC, curStartPos, idx);
                    return syntaxContainer;
                }
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                }
                break;
            case AND:
            case OR:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject, syntaxContainer);
                    curStartPos = tempRefObject.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            curRefObj = syntaxContainer.getSearchObjectStr();
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                            syntaxContainer.setvalid(true);
                            keepValid = true;
                        }
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_OR_AND_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case COLON:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSortbyAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mPageAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject2 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject2, syntaxContainer);
                    curStartPos = tempRefObject2.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            freeTextObjSearched.add(syntaxContainer.getSearchObjectStr());
                        }
                        keepValid = true;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_COLON_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case CONDITION_VALUE:
                nextObject = nextObject.trim();
                if (nextObject.length() > 0) {
                    keepValid = false;
                    curRefObj = syntaxContainer.getSearchObjectStr();
                    curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                    if (curConditionFieldAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSortbyAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mPageAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                        if (// Check that this
                        searchCharArr.length >= idx + 2) // maybe a
                        // plural
                        {
                            // Validate that the next character is an 's'
                            if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                                // Then just move things along.
                                idx++;
                                StringBuilder sb = new StringBuilder(nextObject);
                                sb.append('S');
                                nextObject = sb.toString();
                            }
                        }
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mAndAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.AND, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mOrAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.OR, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject)) && (!mAndAC.validateCompletion(nextObject)) && (!mOrAC.validateCompletion(nextObject))) {
                        RefObject<Integer> tempRefObject3 = new RefObject<Integer>(curStartPos);
                        ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject3, syntaxContainer);
                        curStartPos = tempRefObject3.argvalue;
                        if (ans != ValueParseResult.Err) {
                            if (ans == ValueParseResult.FreeText) {
                                if (freeTextObjSearched.contains(curRefObj)) {
                                    syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                    return syntaxContainer;
                                }
                                freeTextObjSearched.add(curRefObj);
                                syntaxContainer.setvalid(true);
                                keepValid = true;
                            }
                        } else {
                            syntaxContainer.setErr(SyntaxError.INVALID_POST_CONDITION_VALUE_PHRASE, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                    }
                    if (keepValid == false) {
                        syntaxContainer.setvalid(false);
                    }
                }
                break;
            case CONDITION_FIELD:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                String curConditionField = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                curConditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(curRefObj, curConditionField);
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (curConditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!curConditionRelationAC.validate(nextObject)) {
                    if (!curConditionRelationAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                syntaxContainer.setvalid(false);
                tryNextObj = "";
                break;
            case CONDITION_RELATION:
                {
                    RefObject<Integer> tempRefObject4 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject4, syntaxContainer);
                    curStartPos = tempRefObject4.argvalue;
                    if (ans == ValueParseResult.Err) {
                        return syntaxContainer;
                    }
                    if (ans == ValueParseResult.FreeText) {
                        if (syntaxContainer.getPreviousSyntaxObjectType(2) == SyntaxObjectType.CROSS_REF_OBJ) {
                            curRefObj = syntaxContainer.getObjSingularName(syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ));
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                        }
                    }
                }
                break;
            case SORTBY:
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_FIELD, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE:
                Integer pageNumber = IntegerCompat.tryParse(nextObject);
                if (pageNumber == null) {
                    syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
                    return syntaxContainer;
                } else {
                    final StringBuilder buff = new StringBuilder();
                    int pos = idx;
                    // parsing the whole page number (can be more than one char)
                    while (pos < searchText.length() - 1 && Character.isDigit(nextObject.charAt(0))) {
                        buff.append(nextObject);
                        pos++;
                        strRealObj = searchText.substring(pos, pos + 1);
                        nextObject = strRealObj.toUpperCase();
                    }
                    buff.append(nextObject);
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE_VALUE, buff.toString(), curStartPos, idx + buff.length());
                    // update index position
                    idx = pos + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case SORT_FIELD:
                if (!mSortDirectionAC.validate(nextObject)) {
                    if (!mSortDirectionAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_DIRECTION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_DIRECTION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE_VALUE:
                if (curChar != ' ') {
                    syntaxContainer.setErr(SyntaxError.NOTHING_COMES_AFTER_PAGE_VALUE, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                break;
            case SORT_DIRECTION:
                if (!mPageAC.validate(nextObject)) {
                    if (!mPageAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_PAGE_FEILD, curStartPos, idx);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            default:
                syntaxContainer.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return syntaxContainer;
        }
    }
    return syntaxContainer;
}
#method_after
@Override
public SyntaxContainer analyzeSyntaxState(final String searchText, boolean final2) {
    final SyntaxContainer syntaxContainer = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter curConditionFieldAC = null;
    IAutoCompleter curConditionRelationAC = null;
    final List<String> freeTextObjSearched = new ArrayList<String>();
    char[] searchCharArr = searchText.toCharArray();
    int curStartPos = 0;
    String tryNextObj = "";
    boolean keepValid;
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        final SyntaxObjectType curState = syntaxContainer.getState();
        final char curChar = searchCharArr[idx];
        if (mDisAllowedChars.contains(curChar)) {
            syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
            return syntaxContainer;
        }
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION) && (curState != SyntaxObjectType.COLON) && (curState != SyntaxObjectType.CONDITION_VALUE) && (curState != SyntaxObjectType.OR) && (curState != SyntaxObjectType.AND)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return syntaxContainer;
                    }
                } else {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    syntaxContainer.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case CROSS_REF_OBJ:
                String curRefObj = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                }
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (mDotAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.DOT, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!"".equals(tryNextObj)) && (curConditionRelationAC.validate(tryNextObj))) {
                    // i.e. the relation object has another charecter
                    break;
                } else if (curConditionRelationAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!curConditionRelationAC.validateCompletion(nextObject)) && (!mDotAC.validateCompletion(nextObject))) {
                    syntaxContainer.setErr(SyntaxError.INVALID_POST_CROSS_REF_OBJ, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                tryNextObj = "";
                break;
            case DOT:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                if (curConditionFieldAC == null) {
                    syntaxContainer.setErr(SyntaxError.CANT_GET_CONDITION_FIELD_AC, curStartPos, idx);
                    return syntaxContainer;
                }
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                }
                break;
            case AND:
            case OR:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject, syntaxContainer);
                    curStartPos = tempRefObject.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            curRefObj = syntaxContainer.getSearchObjectStr();
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                            syntaxContainer.setvalid(true);
                            keepValid = true;
                        }
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_OR_AND_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case COLON:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSortbyAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mPageAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject2 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject2, syntaxContainer);
                    curStartPos = tempRefObject2.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            freeTextObjSearched.add(syntaxContainer.getSearchObjectStr());
                        }
                        keepValid = true;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_COLON_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case CONDITION_VALUE:
                nextObject = nextObject.trim();
                if (nextObject.length() > 0) {
                    keepValid = false;
                    curRefObj = syntaxContainer.getSearchObjectStr();
                    curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                    if (curConditionFieldAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSortbyAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mPageAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                        if (searchCharArr.length >= idx + 2) {
                            // Validate that the next character is an 's'
                            if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                                // Then just move things along.
                                idx++;
                                StringBuilder sb = new StringBuilder(nextObject);
                                sb.append('S');
                                nextObject = sb.toString();
                            }
                        }
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mAndAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.AND, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mOrAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.OR, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject)) && (!mAndAC.validateCompletion(nextObject)) && (!mOrAC.validateCompletion(nextObject))) {
                        RefObject<Integer> tempRefObject3 = new RefObject<Integer>(curStartPos);
                        ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject3, syntaxContainer);
                        curStartPos = tempRefObject3.argvalue;
                        if (ans != ValueParseResult.Err) {
                            if (ans == ValueParseResult.FreeText) {
                                if (freeTextObjSearched.contains(curRefObj)) {
                                    syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                    return syntaxContainer;
                                }
                                freeTextObjSearched.add(curRefObj);
                                syntaxContainer.setvalid(true);
                                keepValid = true;
                            }
                        } else {
                            syntaxContainer.setErr(SyntaxError.INVALID_POST_CONDITION_VALUE_PHRASE, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                    }
                    if (keepValid == false) {
                        syntaxContainer.setvalid(false);
                    }
                }
                break;
            case CONDITION_FIELD:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                String curConditionField = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                curConditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(curRefObj, curConditionField);
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (curConditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!curConditionRelationAC.validate(nextObject)) {
                    if (!curConditionRelationAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                syntaxContainer.setvalid(false);
                tryNextObj = "";
                break;
            case CONDITION_RELATION:
                {
                    RefObject<Integer> tempRefObject4 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject4, syntaxContainer);
                    curStartPos = tempRefObject4.argvalue;
                    if (ans == ValueParseResult.Err) {
                        return syntaxContainer;
                    }
                    if (ans == ValueParseResult.FreeText) {
                        if (syntaxContainer.getPreviousSyntaxObjectType(2) == SyntaxObjectType.CROSS_REF_OBJ) {
                            curRefObj = syntaxContainer.getObjSingularName(syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ));
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                        }
                    }
                }
                break;
            case SORTBY:
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_FIELD, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE:
                Integer pageNumber = IntegerCompat.tryParse(nextObject);
                if (pageNumber == null) {
                    syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
                    return syntaxContainer;
                } else {
                    final StringBuilder buff = new StringBuilder();
                    int pos = idx;
                    // parsing the whole page number (can be more than one char)
                    while (pos < searchText.length() - 1 && Character.isDigit(nextObject.charAt(0))) {
                        buff.append(nextObject);
                        pos++;
                        strRealObj = searchText.substring(pos, pos + 1);
                        nextObject = strRealObj.toUpperCase();
                    }
                    buff.append(nextObject);
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE_VALUE, buff.toString(), curStartPos, idx + buff.length());
                    // update index position
                    idx = pos + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case SORT_FIELD:
                if (!mSortDirectionAC.validate(nextObject)) {
                    if (!mSortDirectionAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_DIRECTION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_DIRECTION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE_VALUE:
                if (curChar != ' ') {
                    syntaxContainer.setErr(SyntaxError.NOTHING_COMES_AFTER_PAGE_VALUE, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                break;
            case SORT_DIRECTION:
                if (!mPageAC.validate(nextObject)) {
                    if (!mPageAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_PAGE_FEILD, curStartPos, idx);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            default:
                syntaxContainer.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return syntaxContainer;
        }
    }
    return syntaxContainer;
}
#end_block

#method_before
@Override
public SyntaxContainer getCompletion(String searchText) {
    SyntaxContainer retval = analyzeSyntaxState(searchText, false);
    if (retval.getError() == SyntaxError.NO_ERROR) {
        IConditionFieldAutoCompleter conditionFieldAC;
        IAutoCompleter conditionRelationAC;
        IConditionValueAutoCompleter conditionValueAC;
        int lastIdx = retval.getLastHandledIndex();
        String curPartialWord = "";
        if (lastIdx < searchText.length()) {
            curPartialWord = searchText.substring(lastIdx, searchText.length());
            curPartialWord = curPartialWord.trim();
        }
        SyntaxObjectType curState = retval.getState();
        for (int idx = 0; idx < mStateMap.get(curState).length; idx++) {
            switch(mStateMap.get(curState)[idx]) {
                case SEARCH_OBJECT:
                    retval.addToACList(mSearchObjectAC.getCompletion(curPartialWord));
                    break;
                case CROSS_REF_OBJ:
                    IAutoCompleter crossRefAC = mSearchObjectAC.getCrossRefAutoCompleter(retval.getFirst().getBody());
                    if (crossRefAC != null) {
                        retval.addToACList(crossRefAC.getCompletion(curPartialWord));
                    }
                    break;
                case DOT:
                    retval.addToACList(mDotAC.getCompletion(curPartialWord));
                    break;
                case COLON:
                    retval.addToACList(mColonAC.getCompletion(curPartialWord));
                    break;
                case AND:
                    retval.addToACList(mAndAC.getCompletion(curPartialWord));
                    break;
                case OR:
                    retval.addToACList(mOrAC.getCompletion(curPartialWord));
                    break;
                case CONDITION_FIELD:
                    String relObj = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(relObj);
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case CONDITION_RELATION:
                    {
                        if (curState == SyntaxObjectType.CONDITION_FIELD) {
                            relObj = retval.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                            String fldName = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                            conditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(relObj, fldName);
                        } else // curState == SyntaxObjectType.CROSS_REF_OBJ
                        {
                            relObj = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                            conditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                        }
                        if (conditionRelationAC != null) {
                            retval.addToACList(conditionRelationAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case CONDITION_VALUE:
                    {
                        relObj = retval.getPreviousSyntaxObject(3, SyntaxObjectType.CROSS_REF_OBJ);
                        String fldName = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CONDITION_FIELD);
                        conditionValueAC = mSearchObjectAC.getFieldValueAutoCompleter(relObj, fldName);
                        if (conditionValueAC != null) {
                            retval.addToACList(conditionValueAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case SORTBY:
                    retval.addToACList(mSortbyAC.getCompletion(curPartialWord));
                    break;
                case PAGE:
                    retval.addToACList(mPageAC.getCompletion(curPartialWord));
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(retval.getSearchObjectStr());
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case SORT_DIRECTION:
                    retval.addToACList(mSortDirectionAC.getCompletion(curPartialWord));
                    break;
            }
        }
    }
    return retval;
}
#method_after
@Override
public SyntaxContainer getCompletion(String searchText) {
    SyntaxContainer retval = analyzeSyntaxState(searchText, false);
    if (retval.getError() == SyntaxError.NO_ERROR) {
        IConditionFieldAutoCompleter conditionFieldAC;
        IAutoCompleter conditionRelationAC;
        IConditionValueAutoCompleter conditionValueAC;
        int lastIdx = retval.getLastHandledIndex();
        String curPartialWord = "";
        if (lastIdx < searchText.length()) {
            curPartialWord = searchText.substring(lastIdx, searchText.length());
            curPartialWord = curPartialWord.trim();
        }
        SyntaxObjectType curState = retval.getState();
        for (int idx = 0; idx < mStateMap.get(curState).length; idx++) {
            switch(mStateMap.get(curState)[idx]) {
                case SEARCH_OBJECT:
                    retval.addToACList(mSearchObjectAC.getCompletion(curPartialWord));
                    break;
                case CROSS_REF_OBJ:
                    IAutoCompleter crossRefAC = mSearchObjectAC.getCrossRefAutoCompleter(retval.getFirst().getBody());
                    if (crossRefAC != null) {
                        retval.addToACList(crossRefAC.getCompletion(curPartialWord));
                    }
                    break;
                case DOT:
                    retval.addToACList(mDotAC.getCompletion(curPartialWord));
                    break;
                case COLON:
                    retval.addToACList(mColonAC.getCompletion(curPartialWord));
                    break;
                case AND:
                    retval.addToACList(mAndAC.getCompletion(curPartialWord));
                    break;
                case OR:
                    retval.addToACList(mOrAC.getCompletion(curPartialWord));
                    break;
                case CONDITION_FIELD:
                    String relObj = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(relObj);
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case CONDITION_RELATION:
                    {
                        if (curState == SyntaxObjectType.CONDITION_FIELD) {
                            relObj = retval.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                            String fldName = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                            conditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(relObj, fldName);
                        } else {
                            // curState == SyntaxObjectType.CROSS_REF_OBJ
                            relObj = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                            conditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                        }
                        if (conditionRelationAC != null) {
                            retval.addToACList(conditionRelationAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case CONDITION_VALUE:
                    {
                        relObj = retval.getPreviousSyntaxObject(3, SyntaxObjectType.CROSS_REF_OBJ);
                        String fldName = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CONDITION_FIELD);
                        conditionValueAC = mSearchObjectAC.getFieldValueAutoCompleter(relObj, fldName);
                        if (conditionValueAC != null) {
                            retval.addToACList(conditionValueAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case SORTBY:
                    retval.addToACList(mSortbyAC.getCompletion(curPartialWord));
                    break;
                case PAGE:
                    retval.addToACList(mPageAC.getCompletion(curPartialWord));
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(retval.getSearchObjectStr());
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case SORT_DIRECTION:
                    retval.addToACList(mSortDirectionAC.getCompletion(curPartialWord));
                    break;
            }
        }
    }
    return retval;
}
#end_block

#method_before
private String generateFromStatement(SyntaxContainer syntax, boolean useTags) {
    LinkedList<String> innerJoins = new LinkedList<String>();
    ArrayList<String> refObjList = syntax.getCrossRefObjList();
    String searchObjStr = syntax.getSearchObjectStr();
    if (refObjList.size() > 0) {
        if (SearchObjects.TEMPLATE_OBJ_NAME.equals(searchObjStr)) {
            innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.TEMPLATE_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
            if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                refObjList.remove(SearchObjects.VM_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.AUDIT_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.AUDIT_OBJ_NAME));
                refObjList.remove(SearchObjects.AUDIT_OBJ_NAME);
            }
        } else if (SearchObjects.VDS_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) || (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.VDC_USER_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDS_OBJ_NAME)) || (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.AUDIT_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.AUDIT_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
        } else if (SearchObjects.DISK_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.DISK_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
            }
        }
    }
    for (String cro : refObjList) {
        innerJoins.addLast(mSearchObjectAC.getInnerJoin(searchObjStr, cro));
    }
    if (useTags) {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableName(searchObjStr));
    } else {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr));
    }
    StringBuilder sb = new StringBuilder();
    for (String part : innerJoins) {
        sb.append(" ");
        sb.append(part);
        sb.append(" ");
    }
    return sb.toString();
}
#method_after
private String generateFromStatement(SyntaxContainer syntax, boolean useTags) {
    LinkedList<String> innerJoins = new LinkedList<String>();
    ArrayList<String> refObjList = syntax.getCrossRefObjList();
    String searchObjStr = syntax.getSearchObjectStr();
    if (refObjList.size() > 0) {
        if (SearchObjects.TEMPLATE_OBJ_NAME.equals(searchObjStr)) {
            innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.TEMPLATE_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
            if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                refObjList.remove(SearchObjects.VM_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.AUDIT_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.AUDIT_OBJ_NAME));
                refObjList.remove(SearchObjects.AUDIT_OBJ_NAME);
            }
        } else if (SearchObjects.VDS_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.VDC_USER_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDS_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.AUDIT_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.AUDIT_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
        } else if (SearchObjects.DISK_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.DISK_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
            }
        }
    }
    for (String cro : refObjList) {
        innerJoins.addLast(mSearchObjectAC.getInnerJoin(searchObjStr, cro));
    }
    if (useTags) {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableName(searchObjStr));
    } else {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr));
    }
    StringBuilder sb = new StringBuilder();
    for (String part : innerJoins) {
        sb.append(" ");
        sb.append(part);
        sb.append(" ");
    }
    return sb.toString();
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        boolean generalQuery = false;
        String innerQuery;
        if (!wherePhrase.toString().contains("tag") && (searchObjStr.equals(SearchObjects.VDS_OBJ_NAME) || searchObjStr.equals(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME))) {
            innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableNameWithOutTags, "*", generateFromStatement(syntax, false), wherePhrase);
            generalQuery = true;
        } else {
            innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        }
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (generalQuery) {
            inQuery = "(" + innerQuery;
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>GetValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        boolean generalQuery = false;
        String innerQuery;
        if (!wherePhrase.toString().contains(TAG_COLUMN_NAME_IN_CRITERIA) && !wherePhrase.toString().contains(".") && (searchObjStr.equals(SearchObjects.VDS_OBJ_NAME) || searchObjStr.equals(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME))) {
            innerQuery = getInnerQuery(tableNameWithOutTags, "*", generateFromStatement(syntax, false), wherePhrase);
            generalQuery = true;
        } else {
            innerQuery = getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase);
        }
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else if (generalQuery) {
            inQuery = "(" + innerQuery;
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
protected String getPagePhrase(SyntaxContainer syntax, String pageNumber) {
    String result = "";
    Integer page = IntegerCompat.tryParse(pageNumber);
    if (page == null) {
        page = 1;
    }
    PagingType pagingType = getPagingType();
    if (pagingType != null) {
        String pagingSyntax = Config.<String>GetValue(ConfigValues.DBPagingSyntax);
        switch(pagingType) {
            case Range:
                result = StringFormat.format(pagingSyntax, (page - 1) * syntax.getMaxCount() + 1, page * syntax.getMaxCount());
                break;
            case Offset:
                result = StringFormat.format(pagingSyntax, (page - 1) * syntax.getMaxCount() + 1, syntax.getMaxCount());
                break;
        }
    }
    return result;
}
#method_after
protected String getPagePhrase(SyntaxContainer syntax, String pageNumber) {
    String result = "";
    Integer page = IntegerCompat.tryParse(pageNumber);
    if (page == null) {
        page = 1;
    }
    PagingType pagingType = getPagingType();
    if (pagingType != null) {
        String pagingSyntax = Config.<String>getValue(ConfigValues.DBPagingSyntax);
        BigInteger bigPage = BigInteger.valueOf(page);
        BigInteger bigCount = BigInteger.valueOf(syntax.getMaxCount());
        BigInteger bigX = bigPage.subtract(BigInteger.ONE).multiply(bigCount).add(BigInteger.ONE);
        BigInteger bigY = bigPage.multiply(bigCount);
        switch(pagingType) {
            case Range:
                result = StringFormat.format(pagingSyntax, bigX, bigY);
                break;
            case Offset:
                result = StringFormat.format(pagingSyntax, bigX, bigCount);
                break;
        }
    }
    return result;
}
#end_block

#method_before
private PagingType getPagingType() {
    String val = Config.<String>GetValue(ConfigValues.DBPagingType);
    PagingType type = null;
    try {
        type = PagingType.valueOf(val);
    } catch (Exception e) {
        log.error("Unknown paging type " + val);
    }
    return type;
}
#method_after
private PagingType getPagingType() {
    String val = Config.<String>getValue(ConfigValues.DBPagingType);
    PagingType type = null;
    try {
        type = PagingType.valueOf(val);
    } catch (Exception e) {
        log.error("Unknown paging type " + val);
    }
    return type;
}
#end_block

#method_before
private String generateSafeConditionStatement(final SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final String safeValue) {
    IConditionFieldAutoCompleter conditionFieldAC;
    IConditionValueAutoCompleter conditionValueAC = null;
    // check for sql injection
    String fieldName = "";
    String objName;
    ConditionType conditionType;
    SyntaxObject previous = objIter.previous();
    SyntaxObject prev = previous;
    SyntaxObjectType prevType = prev.getType();
    if (prevType != SyntaxObjectType.CONDITION_RELATION) {
        // free text of default search object
        objName = searchObjStr;
        conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
        conditionType = ConditionType.FreeText;
    } else {
        prev = objIter.previous();
        if (prev.getType() == SyntaxObjectType.CROSS_REF_OBJ) {
            // free text
            // search
            // for some
            // object
            objName = prev.getBody();
            conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
            conditionType = ConditionType.FreeTextSpecificObj;
        } else // if (prev.getType() == SyntaxObjectType.CONDITION_FIELD)
        {
            fieldName = prev.getBody();
            prev = objIter.previous();
            if (prev.getType() != SyntaxObjectType.DOT) {
                // standard condition with default AC (search obj)
                objName = searchObjStr;
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                conditionType = ConditionType.ConditionWithDefaultObj;
            } else {
                // standard condition with specific AC
                prev = objIter.previous();
                objName = prev.getBody();
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
                conditionType = ConditionType.ConditionwithSpesificObj;
            }
        }
        conditionValueAC = conditionFieldAC.getFieldValueAutoCompleter(fieldName);
    }
    final BaseConditionFieldAutoCompleter conditionAsBase = (BaseConditionFieldAutoCompleter) ((conditionFieldAC instanceof BaseConditionFieldAutoCompleter) ? conditionFieldAC : null);
    final Class<?> curType = conditionAsBase != null ? conditionAsBase.getTypeDictionary().get(fieldName) : null;
    final String customizedValue = buildCustomizedValue(obj, conditionFieldAC, conditionValueAC, safeValue, fieldName, curType);
    final String customizedRelation = buildCustomizedRelation(caseSensitive, conditionFieldAC, conditionValueAC, fieldName, previous, prevType);
    return buildCondition(caseSensitive, conditionFieldAC, customizedValue, customizedRelation, fieldName, objName, conditionType);
}
#method_after
private String generateSafeConditionStatement(final SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final String safeValue) {
    IConditionFieldAutoCompleter conditionFieldAC;
    IConditionValueAutoCompleter conditionValueAC = null;
    // check for sql injection
    String fieldName = "";
    String objName;
    ConditionType conditionType;
    SyntaxObject previous = objIter.previous();
    SyntaxObject prev = previous;
    SyntaxObjectType prevType = prev.getType();
    if (prevType != SyntaxObjectType.CONDITION_RELATION) {
        // free text of default search object
        objName = searchObjStr;
        conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
        conditionType = ConditionType.FreeText;
    } else {
        prev = objIter.previous();
        if (prev.getType() == SyntaxObjectType.CROSS_REF_OBJ) {
            // free text
            // search
            // for some
            // object
            objName = prev.getBody();
            conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
            conditionType = ConditionType.FreeTextSpecificObj;
        } else {
            // if (prev.getType() == SyntaxObjectType.CONDITION_FIELD)
            fieldName = prev.getBody();
            prev = objIter.previous();
            if (prev.getType() != SyntaxObjectType.DOT) {
                // standard condition with default AC (search obj)
                objName = searchObjStr;
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                conditionType = ConditionType.ConditionWithDefaultObj;
            } else {
                // standard condition with specific AC
                prev = objIter.previous();
                objName = prev.getBody();
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
                conditionType = ConditionType.ConditionwithSpesificObj;
            }
        }
        conditionValueAC = conditionFieldAC.getFieldValueAutoCompleter(fieldName);
    }
    final BaseConditionFieldAutoCompleter conditionAsBase = (BaseConditionFieldAutoCompleter) ((conditionFieldAC instanceof BaseConditionFieldAutoCompleter) ? conditionFieldAC : null);
    final Class<?> curType = conditionAsBase != null ? conditionAsBase.getTypeDictionary().get(fieldName) : null;
    final String customizedValue = buildCustomizedValue(obj, conditionFieldAC, conditionValueAC, safeValue, fieldName, curType);
    final String customizedRelation = buildCustomizedRelation(caseSensitive, conditionFieldAC, conditionValueAC, fieldName, previous, prevType);
    return buildCondition(caseSensitive, conditionFieldAC, customizedValue, customizedRelation, fieldName, objName, conditionType);
}
#end_block

#method_before
final String buildCondition(boolean caseSensitive, IConditionFieldAutoCompleter conditionFieldAC, String customizedValue, String customizedRelation, String fieldName, String objName, ConditionType conditionType) {
    final String tableName = mSearchObjectAC.getRelatedTableName(objName);
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>GetValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        customizedValue = customizedValue.replace("_", replaceWith);
    }
    switch(conditionType) {
        case FreeText:
        case FreeTextSpecificObj:
            return conditionFieldAC.buildFreeTextConditionSql(tableName, customizedRelation, customizedValue, caseSensitive);
        case ConditionWithDefaultObj:
        case ConditionwithSpesificObj:
            return conditionFieldAC.buildConditionSql(fieldName, customizedValue, customizedRelation, tableName, caseSensitive);
        default:
            return "";
    }
}
#method_after
final String buildCondition(boolean caseSensitive, IConditionFieldAutoCompleter conditionFieldAC, String customizedValue, String customizedRelation, String fieldName, String objName, ConditionType conditionType) {
    final String tableName = mSearchObjectAC.getRelatedTableName(objName);
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>getValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        customizedValue = customizedValue.replace("_", replaceWith);
    }
    switch(conditionType) {
        case FreeText:
        case FreeTextSpecificObj:
            return conditionFieldAC.buildFreeTextConditionSql(tableName, customizedRelation, customizedValue, caseSensitive);
        case ConditionWithDefaultObj:
        case ConditionwithSpesificObj:
            return conditionFieldAC.buildConditionSql(fieldName, customizedValue, customizedRelation, tableName, caseSensitive);
        default:
            return "";
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isDiskInterfaceSupportReadOnly())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isDiskInterfaceSupportReadOnly()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isDiskInterfaceSupportReadOnly()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSizeAndAlias()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#end_block

#method_before
private boolean shouldUpdateDiskProperties() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isWipeAfterDelete() != getNewDisk().isWipeAfterDelete() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio() || !StringUtils.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription()) || !StringUtils.equals(getOldDisk().getDiskAlias(), getNewDisk().getDiskAlias());
}
#method_after
private boolean shouldUpdateDiskProperties() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isWipeAfterDelete() != getNewDisk().isWipeAfterDelete() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio() || !StringUtils.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription());
}
#end_block

#method_before
@Test
public void readOnlyIsNotSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isDiskInterfaceSupportReadOnly(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IDE_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR));
}
#method_after
@Test
public void readOnlyIsNotSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IDE_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR));
}
#end_block

#method_before
@Test
public void readOnlyIsSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.VirtIO);
    assertThat(validator.isDiskInterfaceSupportReadOnly(), isValid());
    disk.setReadOnly(false);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isDiskInterfaceSupportReadOnly(), isValid());
}
#method_after
@Test
public void readOnlyIsSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.VirtIO);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), isValid());
    disk.setReadOnly(false);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), isValid());
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(any(List.class));
    when(diskValidator.isDiskInterfaceSupportReadOnly()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(any(List.class));
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#method_after
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#end_block

#method_before
public static boolean isSet(Object o, String name) {
    if (o != null) {
        Method m = getMethod(o, IS_SET_ROOT + name);
        Object ret = invoke(o, m);
        return ret != null && ret instanceof Boolean && ((Boolean) ret).booleanValue();
    }
    return false;
}
#method_after
public static boolean isSet(Object o, String name) {
    boolean set = false;
    if (o != null) {
        Method m = getMethod(o, IS_SET_ROOT + name);
        Object ret = invoke(o, m);
        if (ret != null && ret instanceof Boolean && ((Boolean) ret).booleanValue()) {
            // for Strings we also have to check that the value is not empty.
            if (getReturnType(o, name).equals(String.class)) {
                Object result = invoke(o, getGetter(o, name));
                String resultAsString = (String) result;
                if (!resultAsString.isEmpty()) {
                    set = true;
                }
            } else {
                set = true;
            }
        }
    }
    return set;
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            // (Integer.MAX_VALUE - 1) is used since in SyntaxChecker code we use getMaxCount() + 1
            // If a number > maxValue is given then maxValue will be used
            int maxValue = Integer.MAX_VALUE - 1;
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? maxValue : Math.min(maxValue, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            int maxValue = Integer.MAX_VALUE;
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? maxValue : Math.min(maxValue, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
private void DiskInterface_SelectedItemChanged() {
    boolean isInternal = (Boolean) getIsInternal().getEntity();
    DiskInterface diskInterface = (DiskInterface) getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    if (DiskInterface.IDE.equals(diskInterface) && !Boolean.TRUE.equals(getIsReadOnly().getEntity())) {
        getIsReadOnly().setIsChangable(false);
    } else if (isEditEnabled()) {
        getIsReadOnly().setIsChangable(true);
    }
}
#method_after
private void DiskInterface_SelectedItemChanged() {
    boolean isInternal = (Boolean) getIsInternal().getEntity();
    DiskInterface diskInterface = (DiskInterface) getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    updateReadOnlyChangeability();
}
#end_block

#method_before
protected void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    ConfirmationModel confirmationModel = new ConfirmationModel();
    setConfirmWindow(confirmationModel);
    confirmationModel.setTitle(CONSTANTS.forceStorageDomainCreation());
    confirmationModel.setMessage(CONSTANTS.lunsAlreadyPartOfSD());
    // $NON-NLS-1$
    confirmationModel.setHashName("force_lun_disk_creation");
    confirmationModel.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand forceSaveCommand = new UICommand("OnForceSave", this);
    forceSaveCommand.setTitle(CONSTANTS.ok());
    forceSaveCommand.setIsDefault(true);
    confirmationModel.getCommands().add(forceSaveCommand);
    // $NON-NLS-1$
    UICommand cancelconfirmCommand = new UICommand("CancelConfirm", this);
    cancelconfirmCommand.setTitle(CONSTANTS.cancel());
    cancelconfirmCommand.setIsCancel(true);
    confirmationModel.getCommands().add(cancelconfirmCommand);
}
#method_after
protected void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    ConfirmationModel confirmationModel = new ConfirmationModel();
    setConfirmWindow(confirmationModel);
    confirmationModel.setTitle(CONSTANTS.forceStorageDomainCreation());
    confirmationModel.setMessage(CONSTANTS.lunsAlreadyPartOfSD());
    confirmationModel.setHelpTag(HelpTag.force_lun_disk_creation);
    // $NON-NLS-1$
    confirmationModel.setHashName("force_lun_disk_creation");
    confirmationModel.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand forceSaveCommand = new UICommand("OnForceSave", this);
    forceSaveCommand.setTitle(CONSTANTS.ok());
    forceSaveCommand.setIsDefault(true);
    confirmationModel.getCommands().add(forceSaveCommand);
    // $NON-NLS-1$
    UICommand cancelconfirmCommand = new UICommand("CancelConfirm", this);
    cancelconfirmCommand.setTitle(CONSTANTS.cancel());
    cancelconfirmCommand.setIsCancel(true);
    confirmationModel.getCommands().add(cancelconfirmCommand);
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getSize().setEntity(diskImage.getSizeInGigabytes());
        getIsInternal().setEntity(true);
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }, getHash()), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getIsInternal().setEntity(false);
        getSizeExtend().setIsAvailable(false);
    }
    if (getDisk().getDiskInterface() == DiskInterface.IDE) {
        getIsReadOnly().setIsChangable(false);
    }
}
#method_after
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getSize().setEntity(diskImage.getSizeInGigabytes());
        getIsInternal().setEntity(true);
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }, getHash()), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getIsInternal().setEntity(false);
        getSizeExtend().setIsAvailable(false);
    }
    updateReadOnlyChangeability();
}
#end_block

#method_before
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getDescription().setIsChangable(false);
        getAlias().setIsChangable(false);
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getIsWipeAfterDelete().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#method_after
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getDescription().setIsChangable(false);
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getIsWipeAfterDelete().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#end_block

#method_before
private void newEntity() {
    final VM vm = getEntity();
    if (getWindow() != null) {
        return;
    }
    NewDiskModel model = new NewDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(vm);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#method_after
private void newEntity() {
    final VM vm = getEntity();
    if (getWindow() != null) {
        return;
    }
    NewDiskModel model = new NewDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    model.setHelpTag(HelpTag.new_virtual_disk);
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(vm);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#end_block

#method_before
private void changeQuota() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    ChangeQuotaModel model = new ChangeQuotaModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignQuotaForDisk());
    // $NON-NLS-1$
    model.setHashName("change_quota_disks");
    model.startProgress(null);
    model.init(disks);
    // $NON-NLS-1$
    UICommand command = new UICommand("onChangeQuota", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void changeQuota() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    ChangeQuotaModel model = new ChangeQuotaModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignQuotaForDisk());
    model.setHelpTag(HelpTag.change_quota_disks);
    // $NON-NLS-1$
    model.setHashName("change_quota_disks");
    model.startProgress(null);
    model.init(disks);
    // $NON-NLS-1$
    UICommand command = new UICommand("onChangeQuota", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#end_block

#method_before
private void edit() {
    final Disk disk = (Disk) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    EditDiskModel model = new EditDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().editVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("edit_virtual_disk");
    model.setVm(getEntity());
    model.setDisk(disk);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#method_after
private void edit() {
    final Disk disk = (Disk) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    EditDiskModel model = new EditDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().editVirtualDiskTitle());
    model.setHelpTag(HelpTag.edit_virtual_disk);
    // $NON-NLS-1$
    model.setHashName("edit_virtual_disk");
    model.setVm(getEntity());
    model.setDisk(disk);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    model.setHelpTag(HelpTag.remove_disk);
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void plug(boolean plug) {
    VM vm = getEntity();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        disk.setPlugged(plug);
        paramerterList.add(new HotPlugDiskToVmParameters(vm.getId(), disk.getId()));
    }
    VdcActionType plugAction = VdcActionType.HotPlugDiskToVm;
    if (!plug) {
        plugAction = VdcActionType.HotUnPlugDiskFromVm;
    }
    Frontend.getInstance().runMultipleAction(plugAction, paramerterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#method_after
private void plug() {
    Frontend.getInstance().runMultipleAction(VdcActionType.HotPlugDiskToVm, createHotPlugDiskToVmParameters(true), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#end_block

#method_before
private void confirmUnplug() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().deactivateVmDisksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDeactivateVMDisksMsg());
    // $NON-NLS-1$
    model.setHashName("deactivate_vm_disk");
    setWindow(model);
    model.getLatch().setEntity(false);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((Disk) selected).getDiskAlias());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand unPlug = new UICommand("OnConfirmUnplug", this);
    unPlug.setTitle(ConstantsManager.getInstance().getConstants().ok());
    unPlug.setIsDefault(true);
    model.getCommands().add(unPlug);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#method_after
private void confirmUnplug() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().deactivateVmDisksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDeactivateVMDisksMsg());
    // $NON-NLS-1$
    model.setHashName("deactivate_vm_disk");
    setWindow(model);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((Disk) selected).getDiskAlias());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand unPlug = new UICommand("OnUnplug", this);
    unPlug.setTitle(ConstantsManager.getInstance().getConstants().ok());
    unPlug.setIsDefault(true);
    model.getCommands().add(unPlug);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#end_block

#method_before
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    boolean vmIsUp = vm.getStatus() == VMStatus.Up;
    model.setVmUp(vmIsUp);
    model.setWarningAvailable(vmIsUp);
    if (vmIsUp) {
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationStorageFilteringNote());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#method_after
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    boolean vmIsUp = vm.getStatus() == VMStatus.Up;
    model.setVmUp(vmIsUp);
    model.setWarningAvailable(vmIsUp);
    if (vmIsUp) {
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationStorageFilteringNote());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disk);
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#end_block

#method_before
private void updateActionAvailability() {
    Disk disk = (Disk) getSelectedItem();
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(disk != null && isSingleDiskSelected() && !isDiskLocked(disk) && (isVmDown() || !disk.getPlugged() || (isExtendImageSizeSupported() && isExtendImageSizeEnabled())));
    getRemoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && isRemoveCommandAvailable());
    getMoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && (isMoveCommandAvailable() || isLiveMoveCommandAvailable()));
    updateGetAlignmentCommandAvailability();
    updateScanAlignmentEnabled();
    getPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(true));
    getUnPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(false));
    ChangeQuotaModel.updateChangeQuotaActionAvailability(getItems() != null ? (List<Disk>) getItems() : null, getSelectedItems() != null ? (List<Disk>) getSelectedItems() : null, getSystemTreeSelectedItem(), getChangeQuotaCommand());
}
#method_after
private void updateActionAvailability() {
    Disk disk = (Disk) getSelectedItem();
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(disk != null && isSingleDiskSelected() && !isDiskLocked(disk) && (isVmDown() || !disk.getPlugged() || (isExtendImageSizeSupported() && isExtendImageSizeEnabled())));
    getRemoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && isRemoveCommandAvailable());
    getMoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && (isMoveCommandAvailable() || isLiveMoveCommandAvailable()));
    updateScanAlignmentCommandAvailability();
    getPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(true));
    getUnPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(false));
    ChangeQuotaModel.updateChangeQuotaActionAvailability(getItems() != null ? (List<Disk>) getItems() : null, getSelectedItems() != null ? (List<Disk>) getSelectedItems() : null, getSystemTreeSelectedItem(), getChangeQuotaCommand());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getMoveCommand()) {
        move();
    } else if (command == getScanAlignmentCommand()) {
        scanAlignment();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (command == getPlugCommand()) {
        plug(true);
    } else if (command == getUnPlugCommand()) {
        confirmUnplug();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfirmUnplug")) {
        plug(false);
    } else if (command == getChangeQuotaCommand()) {
        changeQuota();
    } else if (command.getName().equals("onChangeQuota")) {
        // $NON-NLS-1$
        onChangeQuota();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getMoveCommand()) {
        move();
    } else if (command == getScanAlignmentCommand()) {
        scanAlignment();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (command == getPlugCommand()) {
        plug();
    } else if (command == getUnPlugCommand()) {
        confirmUnplug();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnUnplug")) {
        unplug();
    } else if (command == getChangeQuotaCommand()) {
        changeQuota();
    } else if (command.getName().equals("onChangeQuota")) {
        // $NON-NLS-1$
        onChangeQuota();
    }
}
#end_block

#method_before
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (args.contains(ARG_LDAP_SERVERS)) {
                krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            } else {
                krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, Collections.EMPTY_MAP);
            }
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#method_after
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (!args.contains(ARG_LDAP_SERVERS) && useDnsLookup) {
                // The arguments do not contain a list of ldap servers, the
                // kerberos configuration should not be created according to it if
                // useDnsLookup is set to true as in this case the kdc and the domain_realm information
                // will be resolved by DNS during kerberos negotiation.
                ldapServersPerGSSAPIDomains = Collections.emptyMap();
            }
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#end_block

#method_before
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    updateWanColorDepthOptions(spice);
    updateWANDisableEffects(spice);
    spice.setSpiceProxyEnabled(isSpiceProxyDefined());
}
#method_after
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    updateWanColorDepthOptions(spice);
    updateWANDisableEffects(spice);
}
#end_block

#method_before
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "userportal.json", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // TODO: don't hardcode userportal application name here
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "userportal.json", documentationFileFetchedEvent);
}
#end_block

#method_before
public static String getPath(String hashName) {
    String path = null;
    if (hashName != null && documentationPathMap != null) {
        path = documentationPathMap.get(hashName);
    }
    return path;
}
#method_after
public static String getPath(String helpTag) {
    String path = null;
    if (helpTag != null && documentationPathMap != null) {
        path = documentationPathMap.get(helpTag);
    }
    return path;
}
#end_block

#method_before
public static void init(String fileContent) {
    // fileContent is a JSON object with all unknown fields
    Mapping mapping = JsonUtils.safeEval(fileContent);
    JSONObject mappingJson = new JSONObject(mapping);
    documentationPathMap = new HashMap<String, String>();
    for (String docTag : mappingJson.keySet()) {
        JSONValue url = mappingJson.get(docTag);
        JSONString urlString = url.isString();
        if (docTag != null && urlString != null && !docTag.isEmpty() && !urlString.stringValue().isEmpty() && !documentationPathMap.containsKey(docTag)) {
            documentationPathMap.put(docTag, urlString.stringValue());
        }
    }
}
#method_after
public static void init(String fileContent) {
    // fileContent is a JSON object with all unknown fields
    Mapping mapping = JsonUtils.safeEval(fileContent);
    JSONObject mappingJson = new JSONObject(mapping);
    documentationPathMap = new HashMap<String, String>();
    for (String docTag : mappingJson.keySet()) {
        JSONString urlString = mappingJson.get(docTag).isString();
        if (docTag != null && urlString != null && !docTag.isEmpty() && !urlString.stringValue().isEmpty() && !documentationPathMap.containsKey(docTag)) {
            documentationPathMap.put(docTag, urlString.stringValue());
        }
    }
}
#end_block

#method_before
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    spice.setWANDisableEffects(new ArrayList<WANDisableEffects>());
    spice.setWanOptionsEnabled(false);
    spice.setSpiceProxyEnabled(isSpiceProxyDefined());
}
#method_after
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    spice.setWANDisableEffects(new ArrayList<WANDisableEffects>());
    spice.setWanOptionsEnabled(false);
}
#end_block

#method_before
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "webadmin.json", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // TODO: don't hard code webadmin application name here
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "webadmin.json", documentationFileFetchedEvent);
}
#end_block

#method_before
@Override
public void edit(GuideModel object) {
    driver.edit(object);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            GuideModel guideModel = (GuideModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Progress".equals(propertyName)) {
                // $NON-NLS-1$
                if (guideModel.getProgress() == null) {
                    // Check whether there any available actions.
                    boolean hasAllowedActions = false;
                    for (Object item : Linq.concat(guideModel.getCompulsoryActions(), guideModel.getOptionalActions())) {
                        UICommand command = (UICommand) item;
                        if (command.getIsExecutionAllowed()) {
                            hasAllowedActions = true;
                            break;
                        }
                    }
                    // Choose an appropriate message matching the entity type (DC, Cluster or VM).
                    String message = null;
                    if (guideModel instanceof DataCenterGuideModel) {
                        message = constants.guidePopupConfiguredDataCenterLabel();
                    } else if (guideModel instanceof ClusterGuideModel) {
                        message = constants.guidePopupConfiguredClusterLabel();
                    } else if (guideModel instanceof VmGuideModel) {
                        message = constants.guidePopupConfiguredVmLabel();
                    }
                    if (!hasAllowedActions) {
                        if (!guideModel.getNote().getIsAvailable()) {
                            infoLabel.setText(message);
                        } else {
                            infoLabel.setText(configurationCompleted);
                            noteLabel.setText(guideModel.getNote().getEntity());
                        }
                        compulsorySection.setVisible(false);
                        optionalSection.setVisible(false);
                        // Rename dialog button.
                        guideModel.getCommands().get(0).setTitle(null);
                        guideModel.getCommands().get(0).setTitle(ConstantsManager.getInstance().getConstants().ok());
                    } else if (guideModel.getCompulsoryActions().isEmpty()) {
                        infoLabel.setText(configurationCompleted);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(false);
                    } else if (guideModel.getOptionalActions().isEmpty()) {
                        updateCreatedLabel(guideModel);
                        optionalSection.setVisible(false);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(true);
                    } else {
                        infoLabel.setText(unconfigured);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(false);
                    }
                }
                updateActionsPanels(guideModel);
            } else if ("Window".equals(propertyName)) {
                // $NON-NLS-1$
                if (guideModel.getLastExecutedCommand().getName().equals("Cancel")) {
                    // $NON-NLS-1$
                    redrawActionsPanels();
                }
            }
        }
    });
}
#method_after
@Override
public void edit(GuideModel object) {
    driver.edit(object);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            GuideModel guideModel = (GuideModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if (PropertyChangedEventArgs.Args.PROGRESS.toString().equals(propertyName)) {
                if (guideModel.getProgress() == null) {
                    // Check whether there any available actions.
                    boolean hasAllowedActions = false;
                    for (Object item : Linq.concat(guideModel.getCompulsoryActions(), guideModel.getOptionalActions())) {
                        UICommand command = (UICommand) item;
                        if (command.getIsExecutionAllowed()) {
                            hasAllowedActions = true;
                            break;
                        }
                    }
                    // Choose an appropriate message matching the entity type (DC, Cluster or VM).
                    String message = null;
                    if (guideModel instanceof DataCenterGuideModel) {
                        message = constants.guidePopupConfiguredDataCenterLabel();
                    } else if (guideModel instanceof ClusterGuideModel) {
                        message = constants.guidePopupConfiguredClusterLabel();
                    } else if (guideModel instanceof VmGuideModel) {
                        message = constants.guidePopupConfiguredVmLabel();
                    }
                    if (!hasAllowedActions) {
                        if (!guideModel.getNote().getIsAvailable()) {
                            infoLabel.setText(message);
                        } else {
                            infoLabel.setText(configurationCompleted);
                            noteLabel.setText(guideModel.getNote().getEntity());
                        }
                        compulsorySection.setVisible(false);
                        optionalSection.setVisible(false);
                        // Rename dialog button.
                        guideModel.getCommands().get(0).setTitle(null);
                        guideModel.getCommands().get(0).setTitle(ConstantsManager.getInstance().getConstants().ok());
                    } else if (guideModel.getCompulsoryActions().isEmpty()) {
                        infoLabel.setText(configurationCompleted);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(false);
                    } else if (guideModel.getOptionalActions().isEmpty()) {
                        updateCreatedLabel(guideModel);
                        optionalSection.setVisible(false);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(true);
                    } else {
                        infoLabel.setText(unconfigured);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(false);
                    }
                }
                updateActionsPanels(guideModel);
            } else if ("Window".equals(propertyName)) {
                // $NON-NLS-1$
                if (guideModel.getLastExecutedCommand().getName().equals("Cancel")) {
                    // $NON-NLS-1$
                    redrawActionsPanels();
                }
            }
        }
    });
}
#end_block

#method_before
private SnapshotVDSCommandParameters buildLiveSnapshotParameters(Snapshot snapshot) {
    List<Disk> pluggedDisksForVm = getDiskDao().getAllForVm(getVm().getId(), true);
    List<DiskImage> filteredPluggedDisksForVm = ImagesHandler.filterImageDisks(pluggedDisksForVm, false, true, true);
    List<DiskImage> filteredPluggedDisks = ImagesHandler.imagesIntersection(filteredPluggedDisksForVm, getDisksList());
    if (FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion())) {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks, snapshot.getMemoryVolume());
    } else {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks);
    }
}
#method_after
private SnapshotVDSCommandParameters buildLiveSnapshotParameters(Snapshot snapshot) {
    List<Disk> pluggedDisksForVm = getDiskDao().getAllForVm(getVm().getId(), true);
    List<DiskImage> filteredPluggedDisksForVm = ImagesHandler.filterImageDisks(pluggedDisksForVm, false, true, true);
    // 'filteredPluggedDisks' should contain only disks from 'getDisksList()' that are plugged to the VM.
    List<DiskImage> filteredPluggedDisks = ImagesHandler.imagesIntersection(filteredPluggedDisksForVm, getDisksList());
    if (FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion())) {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks, snapshot.getMemoryVolume());
    } else {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks);
    }
}
#end_block

#method_before
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    model.getLatch().setEntity(false);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#method_after
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#end_block

#method_before
private void onMaintenance() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase();
        parameters.setStorageDomainId(getEntity().getId());
        if (a.getStoragePoolId() != null) {
            parameters.setStoragePoolId(a.getStoragePoolId());
        }
        list.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void onMaintenance() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase();
        parameters.setStorageDomainId(getEntity().getId());
        if (a.getStoragePoolId() != null) {
            parameters.setStoragePoolId(a.getStoragePoolId());
        }
        list.add(parameters);
    }
    final ConfirmationModel confirmationModel = (ConfirmationModel) getWindow();
    confirmationModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            confirmationModel.stopProgress();
            setWindow(null);
        }
    }, null);
}
#end_block

#method_before
public void onMaintenance() {
    // Frontend.RunMultipleActions(VdcActionType.DeactivateStorageDomain,
    // SelectedItems.Cast<storage_domains>()
    // .Select(a => (VdcActionParametersBase)new StorageDomainPoolParametersBase(a.id, Entity.id))
    // .ToList()
    // );
    ArrayList<VdcActionParametersBase> pb = new ArrayList<VdcActionParametersBase>();
    for (StorageDomain a : Linq.<StorageDomain>cast(getSelectedItems())) {
        pb.add(new StorageDomainPoolParametersBase(a.getId(), getEntity().getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, pb);
}
#method_after
public void onMaintenance() {
    // Frontend.RunMultipleActions(VdcActionType.DeactivateStorageDomain,
    // SelectedItems.Cast<storage_domains>()
    // .Select(a => (VdcActionParametersBase)new StorageDomainPoolParametersBase(a.id, Entity.id))
    // .ToList()
    // );
    ArrayList<VdcActionParametersBase> pb = new ArrayList<VdcActionParametersBase>();
    for (StorageDomain a : Linq.<StorageDomain>cast(getSelectedItems())) {
        pb.add(new StorageDomainPoolParametersBase(a.getId(), getEntity().getId()));
    }
    final ConfirmationModel confirmationModel = (ConfirmationModel) getWindow();
    confirmationModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, pb, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            confirmationModel.stopProgress();
            setWindow(null);
        }
    });
}
#end_block

#method_before
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    model.getLatch().setEntity(false);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#method_after
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    // Defer size calculations until sizes are available.
    Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

        @Override
        public void execute() {
            int minWidth = calculateWidgetMinWidthNeeded();
            contentPanel.getElement().getStyle().setProperty(MIN_WIDTH, minWidth, Unit.PX);
            if (widgetMinWidth > 0) {
                siblingWidth = calculateSiblingWidth();
            }
            for (int i = 0; i < contentPanel.getWidgetCount() - 1; i++) {
                originallyVisible.add(contentPanel.getWidget(i).isVisible());
            }
            initializeCascadeMenuPanel();
        }
    });
    resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent resizeEvent) {
            initializeCascadeMenuPanel();
        }
    });
    eventBus.addHandler(HeaderOffsetChangeEvent.getType(), new HeaderOffsetChangeEvent.HeaderOffsetChangeHandler() {

        @Override
        public void onHeaderOffsetChange(HeaderOffsetChangeEvent event) {
            initializeCascadeMenuPanel();
            // Unregister the resize handler, we don't need it because resizes trigger the
            // HeaderOffsetChangeEvents.
            unregisterResizeHandler();
        }
    });
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    // Defer size calculations until sizes are available.
    Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

        @Override
        public void execute() {
            int minWidth = calculateWidgetMinWidthNeeded();
            contentPanel.getElement().getStyle().setProperty(MIN_WIDTH, minWidth, Unit.PX);
            if (widgetMinWidth > 0) {
                siblingWidth = calculateSiblingWidth();
            }
            initializeCascadeMenuPanel();
        }
    });
    resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent resizeEvent) {
            initializeCascadeMenuPanel();
        }
    });
    eventBus.addHandler(HeaderOffsetChangeEvent.getType(), new HeaderOffsetChangeEvent.HeaderOffsetChangeHandler() {

        @Override
        public void onHeaderOffsetChange(HeaderOffsetChangeEvent event) {
            initializeCascadeMenuPanel();
            // Unregister the resize handler, we don't need it because resizes trigger the
            // HeaderOffsetChangeEvents.
            unregisterResizeHandler();
        }
    });
}
#end_block

#method_before
private void toggleVisibleWidgets(int currentWidth) {
    int widgetWidth = 0;
    boolean foundEdge = false;
    if (contentPanel.getWidgetCount() > 1) {
        for (int i = 0; i < contentPanel.getWidgetCount() - 1; i++) {
            if (!originallyVisible.get(i)) {
                continue;
            }
            Widget widget = contentPanel.getWidget(i);
            // temporarily show the widget, so we get the actual width of the widget.
            widget.setVisible(true);
            if (foundEdge || (widgetWidth + widget.getOffsetWidth() > currentWidth)) {
                widget.setVisible(false);
                toolbarOnlyActionButtonList.get(i).setCascaded(true);
                foundEdge = true;
            } else {
                toolbarOnlyActionButtonList.get(i).setCascaded(false);
                widgetWidth += widget.getOffsetWidth();
            }
        }
    }
}
#method_after
private void toggleVisibleWidgets(int currentWidth) {
    int widgetWidth = 0;
    boolean foundEdge = false;
    if (contentPanel.getWidgetCount() > 1) {
        for (int i = 0; i < contentPanel.getWidgetCount() - 1; i++) {
            Widget widget = contentPanel.getWidget(i);
            if (originallyVisible.get(widget)) {
                // temporarily show the widget, so we get the actual width of the widget.
                widget.setVisible(true);
                if (foundEdge || (widgetWidth + widget.getOffsetWidth() > currentWidth)) {
                    widget.setVisible(false);
                    toolbarOnlyActionButtonList.get(i).setCascaded(true);
                    foundEdge = true;
                } else {
                    toolbarOnlyActionButtonList.get(i).setCascaded(false);
                    widgetWidth += widget.getOffsetWidth();
                }
            }
        }
    }
}
#end_block

#method_before
void updateActionButton(ActionButton button, ActionButtonDefinition<T> buttonDef) {
    button.asWidget().setVisible(buttonDef.isAccessible(getSelectedItems()) && buttonDef.isVisible(getSelectedItems()) && !buttonDef.isCascaded());
    button.setEnabled(buttonDef.isEnabled(getSelectedItems()));
    button.setTitle(buttonDef.getButtonToolTip() != null ? buttonDef.getButtonToolTip() : buttonDef.getTitle());
}
#method_after
void updateActionButton(ActionButton button, ActionButtonDefinition<T> buttonDef) {
    button.asWidget().setVisible(buttonDef.isAccessible(getSelectedItems()) && buttonDef.isVisible(getSelectedItems()) && !buttonDef.isCascaded());
    button.setEnabled(buttonDef.isEnabled(getSelectedItems()));
    button.setTitle(buttonDef.getButtonToolTip() != null ? buttonDef.getButtonToolTip() : buttonDef.getTitle());
    originallyVisible.put(button.asWidget(), buttonDef.isAccessible(getSelectedItems()) && buttonDef.isVisible(getSelectedItems()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (ObjectUtils.notEqual(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            VmDeviceUtils.clearNicAddress(getInterface().getVmId(), getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getCompensationContext().snapshotEntity(oldIface);
                getVmNicDao().update(getInterface());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool) {
            if (succeeded) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            } else {
                MacPoolManager.getInstance().freeMac(getMacAddress());
            }
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (ObjectUtils.notEqual(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            getVmDeviceDao().clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getCompensationContext().snapshotEntity(oldIface);
                getVmNicDao().update(getInterface());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool) {
            if (succeeded) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            } else {
                MacPoolManager.getInstance().freeMac(getMacAddress());
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean mustChangeAddress(int oldType, int newType) {
    return (oldType == VmInterfaceType.spaprVlan.getValue() && newType != VmInterfaceType.spaprVlan.getValue()) || (oldType != VmInterfaceType.spaprVlan.getValue() && newType == VmInterfaceType.spaprVlan.getValue());
}
#method_after
private boolean mustChangeAddress(int oldType, int newType) {
    int spaprVlanType = VmInterfaceType.spaprVlan.getValue();
    return oldType == spaprVlanType ^ newType == spaprVlanType;
}
#end_block

#method_before
/**
 * Test the following where each word should be the completion for the earlier portion Vms : Events =
 */
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#method_after
@Test
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#end_block

#method_before
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#method_after
@Test
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#end_block

#method_before
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#method_after
@Test
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#end_block

#method_before
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.audit_log_id FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#method_after
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.* FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = innerQuery + " and (not deleted";
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
/**
 * Test the following where each word should be the completion for the earlier portion Vms : Events =
 */
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#method_after
@Test
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#end_block

#method_before
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#method_after
@Test
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#end_block

#method_before
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#method_after
@Test
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#end_block

#method_before
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.audit_log_id FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#method_after
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.* FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = innerQuery + " and (not deleted";
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
public final String consoleClientResourcesUrl() {
    String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
    boolean isAbsolute = url.contains("://");
    return isAbsolute ? url : // $NON-NLS-1$
    Window.Location.getProtocol() + "//" + Window.Location.getHost() + "/" + BaseContextPathData.getInstance().getRelativePath() + // $NON-NLS-1$
    url;
}
#method_after
public final String consoleClientResourcesUrl() {
    String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
    boolean isAbsolute = UriUtils.extractScheme(url) != null;
    return isAbsolute ? url : // $NON-NLS-1$
    "/" + BaseContextPathData.getInstance().getRelativePath() + url;
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    int osType = getModel().getOSType().getSelectedItem();
    updateVirtioScsiEnabled(vm.getId(), osType);
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    Integer osType = getModel().getOSType().getSelectedItem();
    if (osType != null) {
        updateVirtioScsiEnabled(vm.getId(), osType);
    }
}
#end_block

#method_before
protected void updateVirtioScsiEnabled(final Guid vmId, int osId) {
    VDSGroup cluster = getModel().getSelectedCluster();
    Version clusterVersion = cluster != null ? cluster.getcompatibility_version() : null;
    AsyncDataProvider.getDiskInterfaceList(osId, clusterVersion, new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue;
            boolean isOsSupportVirtioScsi = diskInterfaces.contains(DiskInterface.VirtIO_SCSI);
            getModel().getIsVirtioScsiEnabled().setIsChangable(isOsSupportVirtioScsi);
            if (!isOsSupportVirtioScsi) {
                getModel().getIsVirtioScsiEnabled().setEntity(false);
                getModel().getIsVirtioScsiEnabled().setChangeProhibitionReason(constants.cannotEnableVirtioScsiForOs());
            } else {
                if (Guid.isNullOrEmpty(vmId)) {
                    VDSGroup cluster = getModel().getSelectedCluster();
                    boolean isVirtioScsiEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, cluster.getcompatibility_version().getValue());
                    getModel().getIsVirtioScsiEnabled().setEntity(isVirtioScsiEnabled);
                } else {
                    AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(getModel(), new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            getModel().getIsVirtioScsiEnabled().setEntity((Boolean) returnValue);
                        }
                    }), vmId);
                }
            }
        }
    }));
}
#method_after
protected void updateVirtioScsiEnabled(final Guid vmId, int osId) {
    final VDSGroup cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getDiskInterfaceList(osId, cluster.getcompatibility_version(), new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue;
            boolean isOsSupportVirtioScsi = diskInterfaces.contains(DiskInterface.VirtIO_SCSI);
            getModel().getIsVirtioScsiEnabled().setIsChangable(isOsSupportVirtioScsi);
            if (!isOsSupportVirtioScsi) {
                getModel().getIsVirtioScsiEnabled().setEntity(false);
                getModel().getIsVirtioScsiEnabled().setChangeProhibitionReason(constants.cannotEnableVirtioScsiForOs());
            } else {
                if (Guid.isNullOrEmpty(vmId)) {
                    boolean isVirtioScsiEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, cluster.getcompatibility_version().getValue());
                    getModel().getIsVirtioScsiEnabled().setEntity(isVirtioScsiEnabled);
                } else {
                    AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(getModel(), new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            getModel().getIsVirtioScsiEnabled().setEntity((Boolean) returnValue);
                        }
                    }), vmId);
                }
            }
        }
    }));
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    int osType = getModel().getOSType().getSelectedItem();
    if (template != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    Integer osType = getModel().getOSType().getSelectedItem();
    if (template != null && osType != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    int osType = getModel().getOSType().getSelectedItem();
    if (template != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    Integer osType = getModel().getOSType().getSelectedItem();
    if (template != null && osType != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#end_block

#method_before
@Override
public void updateIfNeeded(VdsDynamic vdsDynamic) {
    VdsDynamic dbData = get(vdsDynamic.getId());
    if (!dbData.equals(vdsDynamic)) {
        update(vdsDynamic);
    } else {
        log.info("Ignored an unneeded update of VdsDynamic");
    }
}
#method_after
@Override
public void updateIfNeeded(VdsDynamic vdsDynamic) {
    VdsDynamic dbData = get(vdsDynamic.getId());
    if (!dbData.equals(vdsDynamic)) {
        update(vdsDynamic);
    } else {
        log.debug("Ignored an unneeded update of VdsDynamic");
    }
}
#end_block

#method_before
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    try {
        ManageDomainsArguments mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
        } else {
            util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    try {
        ManageDomainsArguments mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
            System.exit(0);
        } else {
            util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordUrl);
        if (changePasswordUrl == null) {
            changePasswordUrl = "";
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#method_after
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        if (changePasswordUrl == null) {
            changePasswordUrl = "";
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private String getPasswordInput() throws ManageDomainsResult {
    String pass = null;
    if (args.contains(ARG_PASSWORD_FILE)) {
        try {
            pass = readPasswordFile(args.get(ARG_PASSWORD_FILE));
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput() throws ManageDomainsResult {
    String pass = null;
    if (args.contains(ARG_PASSWORD_FILE)) {
        try {
            pass = readPasswordFile(args.get(ARG_PASSWORD_FILE));
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else {
        pass = readInteractively("Enter password:", true);
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = args.get(ARG_CHANGE_PASSWORD_URL);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (args.contains(ARG_CHANGE_PASSWORD_URL)) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = null;
    try {
        changePasswordUrlStr = getChangePasswordMsg();
    } catch (UnsupportedEncodingException e) {
        log.error("Error in encoding the change password message. ", e);
    }
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
public void editDomain() throws ManageDomainsResult {
    System.out.println("editting domain");
    String authMode;
    String domainName = args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.contains(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.contains(ARG_PROVIDER)) {
        ldapProviderType = args.getLdapProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (args.contains(ARG_CHANGE_PASSWORD_URL)) {
        changePaswordUrlEntry.setValueForDomain(domainName, args.get(ARG_CHANGE_PASSWORD_URL));
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain() throws ManageDomainsResult {
    String authMode;
    String domainName = args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.contains(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.contains(ARG_PROVIDER)) {
        ldapProviderType = args.getLdapProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        try {
            changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordMsg());
        } catch (UnsupportedEncodingException e) {
            log.error("Error in encoding the change password message. ", e);
        }
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (args.contains(ARG_CHANGE_PASSWORD_URL)) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordUrl, changePasswordUrlEntry);
    }
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordMsg, changePasswordUrlEntry);
    }
}
#end_block

#method_before
public void deleteDomain() throws ManageDomainsResult {
    String domainName = args.get(ARG_DOMAIN).toLowerCase();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !args.contains(ARG_FORCE_DELETE)) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!args.contains(ARG_FORCE_DELETE) && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String changePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(changePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    changePasswordUrlEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePasswordUrlEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#method_after
public void deleteDomain() throws ManageDomainsResult {
    String domainName = args.get(ARG_DOMAIN).toLowerCase();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !args.contains(ARG_FORCE)) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!args.contains(ARG_FORCE) && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String changePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(changePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    changePasswordUrlEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePasswordUrlEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#end_block

#method_before
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (FileWriter fw = new FileWriter(propFile)) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordUrl.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#method_after
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (FileWriter fw = new FileWriter(propFile)) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordMsg.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#end_block

#method_before
public void parse(String[] args) throws ManageDomainsResult {
    if (args.length < 1 || "--help".equals(args[0])) {
        // print help
        argMap.put(ARG_HELP, null);
        return;
    }
    if (!isValidAction(args[0])) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, args[0]);
    }
    String action = args[0];
    argMap.put(ARG_ACTION, action);
    Map<String, String> parsed;
    if (args.length > 1) {
        // entered more args then just action
        try {
            ExtendedCliParser parser = new ExtendedCliParser();
            parsed = parser.parse(Arrays.copyOfRange(args, 1, args.length));
        } catch (IllegalArgumentException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT, ex.getMessage());
        }
    } else {
        parsed = Collections.<String, String>emptyMap();
    }
    if (!parsed.isEmpty()) {
        if (parsed.containsKey(ARG_HELP)) {
            // print help
            argMap.put(ARG_HELP, null);
            return;
        }
        // config file can be entered for all actions
        moveArgsValues(parsed, ARG_CONFIG_FILE);
        checkRequiredArgsValue(ARG_CONFIG_FILE);
        if (ACTION_ADD.equals(action)) {
            moveArgsValues(parsed, ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_LDAP_SERVERS, ARG_ADD_PERMISSIONS, ARG_CHANGE_PASSWORD_URL);
            checkRequiredArgs(ARG_DOMAIN, ARG_PROVIDER, ARG_USER);
            checkRequiredArgsValue(ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_CHANGE_PASSWORD_URL);
        } else if (ACTION_EDIT.equals(action)) {
            moveArgsValues(parsed, ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_LDAP_SERVERS, ARG_ADD_PERMISSIONS, ARG_CHANGE_PASSWORD_URL);
            checkRequiredArgs(ARG_DOMAIN);
            checkRequiredArgsValue(ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_CHANGE_PASSWORD_URL);
        } else if (ACTION_DELETE.equals(action)) {
            moveArgsValues(parsed, ARG_DOMAIN, ARG_FORCE_DELETE);
            checkRequiredArgs(ARG_DOMAIN);
            checkRequiredArgsValue(ARG_DOMAIN);
        } else if (ACTION_VALIDATE.equals(action)) {
            moveArgsValues(parsed, ARG_REPORT);
        }
        validateChangePasswordUrl();
        convertProvider();
        validateProvider();
    }
    // set default config file if user one was not entered
    if (!contains(ARG_CONFIG_FILE)) {
        argMap.put(ARG_CONFIG_FILE, getDefaultConfigPath());
    }
    // check if some args are left, they are invalid for action
    if (!parsed.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (String arg : parsed.keySet()) {
            sb.append(arg);
            sb.append(",");
        }
        sb.deleteCharAt(sb.length() - 1);
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_ACTION, sb.toString(), action);
    }
}
#method_after
public void parse(String[] args) throws ManageDomainsResult {
    if (args.length < 1 || ARG_HELP.equals(args[0])) {
        // print help
        argMap = new HashMap<>();
        argMap.put(ARG_HELP, null);
        return;
    }
    if (!isValidAction(args[0])) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, args[0]);
    }
    if (args.length > 1) {
        // entered more args than just action, parse them
        try {
            ExtendedCliParser parser = initParser();
            argMap = parser.parse(args, 1, args.length);
        } catch (IllegalArgumentException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR, ex.getMessage());
        }
    } else {
        argMap = new HashMap<>();
    }
    argMap.put(ARG_ACTION, args[0]);
    // check that all required args are present
    for (String arg : getRequiredArgs(get(ARG_ACTION))) {
        if (!argMap.containsKey(arg)) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_IS_REQUIRED, arg);
        }
    }
    convertProvider();
    validateProvider();
    // set default config file if user one was not entered
    if (!contains(ARG_CONFIG_FILE)) {
        argMap.put(ARG_CONFIG_FILE, getDefaultConfigPath());
    }
}
#end_block

#method_before
private void validateProvider() throws ManageDomainsResult {
    if (contains(ARG_PROVIDER)) {
        try {
            LdapProviderType.valueOfIgnoreCase(get(ARG_PROVIDER));
        } catch (IllegalArgumentException | NullPointerException ex) {
            StringBuilder sb = new StringBuilder().append(PROV_AD).append(", ").append(PROV_IPA).append(", ").append(PROV_RHDS).append(", ").append(PROV_ITDS).append(", ").append(PROV_OLDAP);
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT, "Invalid provider, valid providers are ", sb.toString());
        }
    }
}
#method_after
private void validateProvider() throws ManageDomainsResult {
    if (contains(ARG_PROVIDER)) {
        try {
            LdapProviderType.valueOfIgnoreCase(get(ARG_PROVIDER));
        } catch (IllegalArgumentException | NullPointerException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_VALUE, String.format("Invalid provider, valid providers are %s", StringUtils.join(new String[] { PROV_AD, PROV_IPA, PROV_RHDS, PROV_ITDS, PROV_OLDAP }, ", ")));
        }
    }
}
#end_block

#method_before
public Map<String, String> parse(String[] args, int from, int to) {
    if (args == null) {
        throw new IllegalArgumentException("Argumens array cannot be null");
    }
    Map<String, String> result = new HashMap<>();
    // parse arguments
    for (int i = from; i < to; ) {
        if (args[i] == null) {
            // just to be sure
            i++;
            continue;
        }
        String name = null;
        String value = null;
        if (isGnuLongArg(args[i])) {
            // parse GNU long argument
            name = parseGnuLongArgName(args[i]);
            value = parseGnuLongArgValue(args[i]);
        } else if (isPosixArg(args[i])) {
            // parse POSIX argument
            name = args[i];
            if (i + 1 < args.length) {
                if (!isPosixArg(args[i + 1]) && !isGnuLongArg(args[i + 1])) {
                    // argument has a value
                    value = args[i + 1];
                    i++;
                }
            }
        } else {
            // invalid argument format
            throw new IllegalArgumentException(String.format("Invalid argument format '%s'!", args[i]));
        }
        Argument arg = argMap.get(name);
        if (arg == null) {
            throw new IllegalArgumentException(String.format("Unknown argument '%s'!", name));
        }
        if (arg.isValueRequied() && StringUtils.isBlank(value)) {
            throw new IllegalArgumentException(String.format("Argument '%s' requires value!", name));
        }
        result.put(arg.getDestination(), value);
        i++;
    }
    return result;
}
#method_after
public Map<String, String> parse(String[] args, int from, int to) {
    if (args == null) {
        throw new IllegalArgumentException("Argumens array cannot be null");
    }
    Map<String, String> result = new HashMap<>();
    // parse arguments
    for (int i = from; i < to; ) {
        if (args[i] == null) {
            // just to be sure
            i++;
            continue;
        }
        String name = null;
        String value = null;
        if (isLongArg(args[i])) {
            // parse long argument
            name = parseLongArgName(args[i]);
            value = parseLongArgValue(args[i]);
        } else if (isShortArg(args[i])) {
            // parse short argument
            name = args[i];
            if (i + 1 < args.length) {
                if (!isShortArg(args[i + 1]) && !isLongArg(args[i + 1])) {
                    // argument has a value
                    value = args[i + 1];
                    i++;
                }
            }
        } else {
            // invalid argument format
            throw new IllegalArgumentException(String.format("Invalid argument format '%s'!", args[i]));
        }
        Argument arg = argMap.get(name);
        if (arg == null) {
            throw new IllegalArgumentException(String.format("Unknown argument '%s'!", name));
        }
        if (arg.isValueRequied() && StringUtils.isBlank(value)) {
            throw new IllegalArgumentException(String.format("Argument '%s' requires value!", name));
        }
        result.put(arg.getDestination(), value);
        i++;
    }
    return result;
}
#end_block

#method_before
@Test
public void parseArgsInRange() {
    Map<String, String> results;
    ExtendedCliParser parser = new ExtendedCliParser();
    String argName1 = "--help";
    String argName2 = "-f";
    String argName3 = "--output";
    String argValue3 = "/dev/null";
    String argName4 = "-u";
    String argValue4 = "root";
    final String[] args = { argName1, argName2, argName3 + GNU_LONG_VALUE_SEP + argValue3, argName4, argValue4 };
    parser.addArg(new ArgumentBuilder().shortName(argName2).build());
    parser.addArg(new ArgumentBuilder().longName(argName3).build());
    results = parser.parse(args, 1, 3);
    assertNotNull(results);
    assertFalse(results.isEmpty());
    assertTrue(results.containsKey(argName2));
    assertTrue(results.containsKey(argName3));
    assertEquals(argValue3, results.get(argName3));
}
#method_after
@Test
public void parseArgsInRange() {
    Map<String, String> results;
    ExtendedCliParser parser = new ExtendedCliParser();
    String argName1 = "--help";
    String argName2 = "-f";
    String argName3 = "--output";
    String argValue3 = "/dev/null";
    String argName4 = "-u";
    String argValue4 = "root";
    final String[] args = { argName1, argName2, argName3 + VALUE_SEP_LONG + argValue3, argName4, argValue4 };
    parser.addArg(new ArgumentBuilder().shortName(argName2).build());
    parser.addArg(new ArgumentBuilder().longName(argName3).build());
    results = parser.parse(args, 1, 3);
    assertNotNull(results);
    assertFalse(results.isEmpty());
    assertTrue(results.containsKey(argName2));
    assertTrue(results.containsKey(argName3));
    assertEquals(argValue3, results.get(argName3));
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            boolean concurrent = entity.isPmSecondaryConcurrent();
            // When a second agent exists, 'concurrent' field is relevant for both agents, so here we
            // set it retroactively in the first agent.
            model.getAgents().getAgents().get(0).setConcurrent(concurrent);
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(concurrent);
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    model.setAutomaticPmEnabled(!entity.isDisablePowerManagementPolicy());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            boolean concurrent = entity.isPmSecondaryConcurrent();
            // When a second agent exists, 'concurrent' field is relevant for both agents, so here we
            // set it retroactively in the first agent.
            model.getAgents().getAgents().get(0).setConcurrent(concurrent);
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(concurrent);
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#end_block

#method_before
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    util = new ManageDomains();
    CLIParser parser = new CLIParser(args);
    String configFilePath = CONF_FILE_PATH;
    if (parser.hasArg(Arguments.configFile.name())) {
        configFilePath = parser.getArg(Arguments.configFile.name());
    }
    if (parser.hasArg(Arguments.report.name())) {
        util.reportAllErrors = true;
    }
    if (parser.hasArg(Arguments.addPermissions.name())) {
        util.addPermissions = true;
    }
    try {
        // it's existence is checked during the parser validation
        String engineConfigProperties = parser.getArg(Arguments.propertiesFile.name());
        util.init(configFilePath);
        util.validate(parser);
        util.createConfigurationProvider(engineConfigProperties);
        util.runCommand(parser);
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    util = new ManageDomains();
    CLIParser parser = new CLIParser(args);
    String configFilePath = CONF_FILE_PATH;
    if (parser.hasArg(Arguments.configFile.name())) {
        configFilePath = parser.getArg(Arguments.configFile.name());
    }
    if (parser.hasArg(Arguments.report.name())) {
        util.reportAllErrors = true;
    }
    if (parser.hasArg(Arguments.addPermissions.name())) {
        util.addPermissions = true;
    }
    if (parser.hasArg(Arguments.changePasswordUrl.name())) {
        util.changePasswordUrl = true;
    }
    try {
        // it's existence is checked during the parser validation
        String engineConfigProperties = parser.getArg(Arguments.propertiesFile.name());
        util.init(configFilePath);
        util.validate(parser);
        util.createConfigurationProvider(engineConfigProperties);
        util.runCommand(parser);
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
protected String getChangePasswordUrl(CLIParser parser) throws ManageDomainsResult {
    String changePasswordUrl = parser.getArg(Arguments.changePasswordUrl.name());
    if (StringUtils.isEmpty(changePasswordUrl)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "Password change URL must not be empty");
    }
    try {
        URL url = new URL(changePasswordUrl);
    } catch (MalformedURLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "The provided string for Password change URL is not a valid URL");
    }
    return changePasswordUrl;
}
#method_after
protected String getChangePasswordUrl(CLIParser parser) throws ManageDomainsResult {
    if (!changePasswordUrl) {
        return null;
    }
    String changePasswordUrl = parser.getArg(Arguments.changePasswordUrl.name());
    if (StringUtils.isEmpty(changePasswordUrl)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "Password change URL must not be empty");
    }
    try {
        URL url = new URL(changePasswordUrl);
        log.debug("Validated that " + url + " is in correct format");
    } catch (MalformedURLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "The provided string for Password change URL is not a valid URL");
    }
    return changePasswordUrl;
}
#end_block

#method_before
public void addDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    String userName = parser.getArg(Arguments.user.toString());
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrl = getChangePasswordUrl(parser);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput(parser));
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrl);
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    String userName = parser.getArg(Arguments.user.toString());
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = getChangePasswordUrl(parser);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput(parser));
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (changePasswordUrl) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
public void editDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode;
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = parser.getArg(Arguments.user.toString());
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput(parser);
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(parser, domainName);
    if (parser.hasArg(Arguments.ldapServers.name())) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (parser.hasArg(Arguments.changePasswordUrl.name())) {
        changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordUrl(parser));
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain(CLIParser parser) throws ManageDomainsResult {
    System.out.println("editting domain");
    String authMode;
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = parser.getArg(Arguments.user.toString());
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput(parser);
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(parser, domainName);
    if (parser.hasArg(Arguments.ldapServers.name())) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (parser.hasArg(Arguments.changePasswordUrl.name())) {
        changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordUrl(parser));
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    configurationProvider.setConfigValue(ConfigValues.ChangePasswordUrl, changePasswordUrlEntry);
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (changePasswordUrl) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordUrl, changePasswordUrlEntry);
    }
}
#end_block

#method_before
@Test
public void canDoActionInvalidDestinationAndSourceDomainOfDifferentStorageSubtypes() {
    createParameters();
    StorageDomain srcStorageDomain = initStorageDomain(srcStorageId);
    srcStorageDomain.setStatus(StorageDomainStatus.Active);
    srcStorageDomain.setStorageType(StorageType.ISCSI);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setStatus(StorageDomainStatus.Active);
    srcStorageDomain.setStorageType(StorageType.NFS);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DESTINATION_AND_SOURCE_STORAGE_SUB_TYPES_DIFFERENT.toString()));
}
#method_after
private void canDoActionInvalidDestinationAndSourceDomainOfDifferentStorageSubtypes(StorageType sourceType, StorageType destType, boolean shouldSucceed) {
    createParameters();
    StorageDomain srcStorageDomain = initStorageDomain(srcStorageId);
    srcStorageDomain.setStatus(StorageDomainStatus.Active);
    srcStorageDomain.setStorageType(sourceType);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setStatus(StorageDomainStatus.Active);
    dstStorageDomain.setStorageType(destType);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    assertEquals(command.canDoAction(), shouldSucceed);
    if (!shouldSucceed) {
        assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DESTINATION_AND_SOURCE_STORAGE_SUB_TYPES_DIFFERENT.toString()));
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !isValidSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
        StorageDomain destDomain = getStorageDomainById(parameters.getStorageDomainId(), getStoragePoolId());
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getStorageDomainId()) && validateSourceStorageDomain(sourceDomain) && validateDestStorage(destDomain) && validateDestStorageAndSourceStorageOfSameTypes(destDomain, sourceDomain));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !isValidSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getStorageDomainId()) && performStorageDomainsChecks(parameters));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (getReturnValue().getTaskPlaceHolderIdList().size() > 0) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Void runInTransaction() {
                for (final Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        AsyncTaskManager.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        AsyncTaskManager.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeCapacityColumn(), constants.volumeCapacity(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
public static int parseIntegerToShort(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Short.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than Short.MAX_VALUE");
    }
    return result.intValue();
}
#method_after
public static int parseIntegerToShort(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Short.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than maximum " + Short.MAX_VALUE);
    }
    return result.intValue();
}
#end_block

#method_before
public static int parseIntegerToInt(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Integer.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than Integer.MAX_VALUE");
    }
    return result.intValue();
}
#method_after
public static int parseIntegerToInt(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Integer.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than maximum " + Integer.MAX_VALUE);
    }
    return result.intValue();
}
#end_block

#method_before
@Override
public javax.ws.rs.core.Response toResponse(InvalidValueException e) {
    Fault fault = new Fault();
    fault.setReason("Invalid Value");
    fault.setDetail(e.getMessage());
    return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
}
#method_after
@Override
public Response toResponse(InvalidValueException e) {
    Fault fault = new Fault();
    fault.setReason("Invalid Value");
    fault.setDetail(e.getMessage());
    return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
}
#end_block

#method_before
@Override
public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {
    if (entityStream == null) {
        return null;
    }
    try {
        JAXBContext ctx = getFinder(mediaType).findCacheContext(mediaType, annotations, type);
        Unmarshaller unmarshaller = ctx.createUnmarshaller();
        AbstractJAXBProvider.decorateUnmarshaller(type, annotations, mediaType, unmarshaller);
        unmarshaller.setEventHandler(errorhandler);
        Object parsedObj = unmarshaller.unmarshal(entityStream);
        if (parsedObj instanceof JAXBElement) {
            return ((JAXBElement) parsedObj).getValue();
        }
        return parsedObj;
    } catch (JAXBException e) {
        if (e.getLinkedException().getCause() instanceof InvalidValueException) {
            throw (InvalidValueException) e.getLinkedException().getCause();
        }
        throw new JAXBMarshalException(e);
    }
}
#method_after
@Override
public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {
    if (entityStream == null) {
        return null;
    }
    try {
        JAXBContext ctx = findJAXBContext(type, annotations, mediaType, true);
        Unmarshaller unmarshaller = ctx.createUnmarshaller();
        AbstractJAXBProvider.decorateUnmarshaller(type, annotations, mediaType, unmarshaller);
        unmarshaller.setEventHandler(errorhandler);
        Object parsedObj = unmarshaller.unmarshal(entityStream);
        if (parsedObj instanceof JAXBElement) {
            return ((JAXBElement) parsedObj).getValue();
        }
        return parsedObj;
    } catch (JAXBException e) {
        if (e.getLinkedException().getCause() instanceof InvalidValueException) {
            throw (InvalidValueException) e.getLinkedException().getCause();
        }
        throw new JAXBMarshalException(e);
    }
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVm, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVm, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#end_block

#method_before
public static boolean isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion, List<String> reasons) {
    boolean result = VmValidationUtils.isOsSupportedForVirtIoScsi(osId, clusterVersion);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_DOES_NOT_SUPPORT_VIRTIO_SCSI.toString());
    }
    return result;
}
#method_after
public static boolean isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion, List<String> reasons) {
    boolean result = VmValidationUtils.isDiskInterfaceSupportedByOs(osId, clusterVersion, DiskInterface.VirtIO_SCSI);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI.name());
    }
    return result;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), false);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isOsSupportedForVirtIoScsi(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version());
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version()) && isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version()) && isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#method_after
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    hotSetCpus();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getVmId(), deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getParameters().getVmId(), deviceType, device);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(getVmId());
}
#method_after
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
@Before
public void setUp() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(0, Version.v3_0)).thenReturn(0);
    when(osRepository.getMinimumRam(0, null)).thenReturn(0);
    when(osRepository.getMaximumRam(0, Version.v3_0)).thenReturn(256);
    when(osRepository.getMaximumRam(0, null)).thenReturn(256);
    when(osRepository.isWindows(0)).thenReturn(false);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.newGuid());
    group.setcompatibility_version(Version.v3_0);
    vm.setVdsGroupId(group.getId());
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
}
#end_block

#method_before
@Test
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassCanDoAction();
    group.setcompatibility_version(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassCanDoAction();
    group.setcompatibility_version(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVdsGroupDAOReturnVdsGroup();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(createVdsGroup()).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getcompatibility_version());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
private VDSGroup createVdsGroup() {
    if (vdsGroup == null) {
        vdsGroup = new VDSGroup();
        vdsGroup.setcompatibility_version(Version.v3_3);
    }
    return vdsGroup;
}
#method_after
private VDSGroup createVdsGroup() {
    if (vdsGroup == null) {
        vdsGroup = new VDSGroup();
        vdsGroup.setvds_group_id(Guid.newGuid());
        vdsGroup.setcompatibility_version(Version.v3_3);
        vdsGroup.setcpu_name("Intel Conroe Family");
        vdsGroup.setArchitecture(ArchitectureType.x86_64);
    }
    return vdsGroup;
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#end_block

#method_before
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#method_after
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#end_block

#method_before
@Override
protected boolean isMemoryStateRemovable(String memoryVolume) {
    if (memoryVolume.isEmpty()) {
        return false;
    }
    // is removed from the DB (because it is transactive command)
    return enclosingCommand.getParameters().getParentCommand() == VdcActionType.RemoveVm ? getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume) == 0 : getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume) == 1;
}
#method_after
@Override
protected boolean isMemoryStateRemovable(String memoryVolume) {
    if (memoryVolume.isEmpty()) {
        return false;
    }
    int numOfSnapshotsUsingThisMemory = getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume);
    return numOfSnapshotsUsingThisMemory == (removeOnlyIfNotUsedAtAll ? 0 : 1);
}
#end_block

#method_before
protected boolean removeMemoryVolumes(Set<String> memoryVolumes) {
    boolean result = true;
    for (String memoryVols : memoryVolumes) {
        result &= removeMemoryVolume(memoryVols);
    }
    return result;
}
#method_after
protected boolean removeMemoryVolumes(Set<String> memoryVolumes) {
    boolean allVolumesRemovedSucessfully = true;
    for (String memoryVols : memoryVolumes) {
        allVolumesRemovedSucessfully &= removeMemoryVolume(memoryVols);
    }
    return allVolumesRemovedSucessfully;
}
#end_block

#method_before
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()));
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
private RemoveMemoryVolumesParameters buildRemoveMemoryVolumesParameters(String memoryState, Guid vmId) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(memoryState, getVmId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    return parameters;
}
#method_after
private RemoveMemoryVolumesParameters buildRemoveMemoryVolumesParameters(String memoryState, Guid vmId) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(memoryState, getVmId());
    parameters.setRemoveOnlyIfNotUsedAtAll(true);
    return parameters;
}
#end_block

#method_before
public String getVmHost() {
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else {
        String vmDomain = getVmDomain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#method_after
public String getVmHost() {
    String vmDomain = (getVmInit() != null) ? getVmInit().getDomain() : null;
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else {
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurUserName == null) ? 0 : consoleCurUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurUserName, other.consoleCurUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(mExitMessage, other.mExitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd));
}
#end_block

#method_before
public String getExitMessage() {
    return mExitMessage;
}
#method_after
public String getExitMessage() {
    return exitMessage;
}
#end_block

#method_before
public void setExitMessage(String value) {
    mExitMessage = value;
}
#method_after
public void setExitMessage(String value) {
    exitMessage = value;
}
#end_block

#method_before
public String getConsoleCurrentUserName() {
    return consoleCurUserName;
}
#method_after
public String getConsoleCurrentUserName() {
    return consoleCurrentUserName;
}
#end_block

#method_before
public void setConsoleCurrentUserName(String consoleCurUserName) {
    this.consoleCurUserName = consoleCurUserName;
}
#method_after
public void setConsoleCurrentUserName(String consoleCurUserName) {
    this.consoleCurrentUserName = consoleCurUserName;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setCurrentCd(rs.getString("current_cd"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setCurrentCd(rs.getString("current_cd"));
    return entity;
}
#end_block

#method_before
@Override
public CdRom get() {
    if (QueryHelper.hasMatrixParam(getUriInfo(), CURRENT_CONSTRAINT_PARAMETER)) {
        VM vm = collection.lookupEntity(guid);
        if (vm == null) {
            return notFound();
        }
        // if the CD has changed during the run of VM
        if (vm.getCurrentCd() != null) {
            // change the iso path so the result of 'map' will contain current cd instead of the
            // persistent configuration
            vm.setIsoPath(vm.getCurrentCd());
        }
        return addLinks(populate(map(vm), vm));
    } else {
        return super.get();
    }
}
#method_after
@Override
public CdRom get() {
    final boolean getCurrent = QueryHelper.hasMatrixParam(getUriInfo(), CURRENT_CONSTRAINT_PARAMETER) && !"false".equalsIgnoreCase(QueryHelper.getMatrixConstraint(getUriInfo(), CURRENT_CONSTRAINT_PARAMETER));
    if (getCurrent) {
        VM vm = collection.lookupEntity(guid);
        if (vm == null) {
            return notFound();
        }
        // if the CD has changed during the run of VM
        if (vm.getCurrentCd() != null) {
            // change the iso path so the result of 'map' will contain current cd instead of the
            // persistent configuration
            vm.setIsoPath(vm.getCurrentCd());
        }
        return addLinks(populate(map(vm), vm));
    } else {
        return super.get();
    }
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setStorageType(StorageType.valueOf(xmlRpcStruct.get("type").toString()));
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (_vds.getStatus() != VDSStatus.Up) {
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("VdsStatus", _vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (_vds.getStatus() != VDSStatus.Up) {
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("HostStatus", _vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("VdsStatus", getVds().getStatus().toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("HostStatus", getVds().getStatus().toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning()));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not update MoM policy on host {0}", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#method_after
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning(), cluster.isEnableKsm()));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not update MoM policy on host {0}", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!hostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    return vm;
}
#end_block

#method_before
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setStorageType(instance.getStorageType());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#method_after
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    return obj;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("migration_downtime", vm.getMigrationDowntime()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("migration_downtime", vm.getMigrationDowntime()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getVmTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getVmTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), true);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
public String getVmHost() {
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else {
        String vmDomain = getVmDomain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#method_after
public String getVmHost() {
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else if (getVmInit() != null) {
        String vmDomain = getVmInit().getDomain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    return vm;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    return obj;
}
#end_block

#method_before
private HttpURLConnection createURLConnection() throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException, KeyManagementException {
    logger.debug(String.format("createURLConnection: servletURL=%s, sslIgnoreCertErrors=%s, sslIgnoreHostVerification=%s, trustStorePath=%s", servletURL, sslIgnoreCertErrors, sslIgnoreHostVerification, trustStorePath));
    URL url = new URL(servletURL);
    HttpURLConnection servletConnection = (HttpURLConnection) url.openConnection();
    if ("https".equals(url.getProtocol())) {
        TrustManager[] trustManagers;
        if (sslIgnoreCertErrors) {
            trustManagers = new TrustManager[] { new X509TrustManager() {

                @Override
                public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[] {};
                }
            } };
        } else {
            if (trustStorePassword == null || trustStorePath == null) {
                throw new RuntimeException("The Supplied URL is secured, however no trust store path or password were supplied.");
            }
            KeyStore trustStore = KeyStore.getInstance(trustStoreType);
            trustStore.load(new FileInputStream(trustStorePath), trustStorePassword.toCharArray());
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);
            trustManagers = trustManagerFactory.getTrustManagers();
        }
        SSLContext ctx = SSLContext.getInstance(sslProtocol);
        ctx.init(null, trustManagers, null);
        HttpsURLConnection httpsConnection = (HttpsURLConnection) servletConnection;
        httpsConnection.setSSLSocketFactory(ctx.getSocketFactory());
        if (sslIgnoreHostVerification) {
            httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
        }
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#method_after
private HttpURLConnection createURLConnection() throws MalformedURLException, IOException, ProtocolException {
    logger.debug(String.format("createURLConnection: servletURL=%s, sslIgnoreCertErrors=%s, sslIgnoreHostVerification=%s, trustStorePath=%s", servletURL, sslIgnoreCertErrors, sslIgnoreHostVerification, trustStorePath));
    URL url = new URL(servletURL);
    HttpURLConnection servletConnection = (HttpURLConnection) url.openConnection();
    if ("https".equals(url.getProtocol())) {
        HttpsURLConnection httpsConnection = (HttpsURLConnection) servletConnection;
        httpsConnection.setSSLSocketFactory(sslctx.getSocketFactory());
        if (sslIgnoreHostVerification) {
            httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
        }
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#end_block

#method_before
@Override
public void clearErrorMessage() {
    setErrorMessage(null);
}
#method_after
@Override
public void clearErrorMessage() {
    setErrorMessageHtml(null);
}
#end_block

#method_before
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsDisabled");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TrustedService");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateType");
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    if (_vmTemplate.getBaseTemplateId() != null) {
        _writer.WriteStartElement("BaseTemplateId");
        _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
        _writer.WriteEndElement();
    }
}
#method_after
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsDisabled");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TrustedService");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateType");
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    if (_vmTemplate.getBaseTemplateId() != null) {
        _writer.WriteStartElement("BaseTemplateId");
        _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
        _writer.WriteEndElement();
    }
    if (_vmTemplate.getTemplateVersionName() != null) {
        _writer.WriteStartElement("TemplateVersionName");
        _writer.WriteRaw(_vmTemplate.getTemplateVersionName());
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getDescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getDomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getCreationDate()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DeleteProtected");
    _writer.WriteRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.WriteEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.WriteStartElement("SsoMethod");
        _writer.WriteRaw(vmBase.getSsoMethod().toString());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.getTimeZone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.WriteEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getInitrdUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getKernelUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getKernelParams());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("Generation");
    _writer.WriteRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.WriteEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.WriteStartElement("TunnelMigration");
        _writer.WriteRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.WriteEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.WriteStartElement("VncKeyboardLayout");
        _writer.WriteRaw(vmBase.getVncKeyboardLayout());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("MinAllocatedMem");
    _writer.WriteRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsStateless");
    _writer.WriteRaw(String.valueOf(vmBase.isStateless()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsRunAndPause");
    _writer.WriteRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.WriteEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.WriteStartElement("CreatedByUserId");
        _writer.WriteRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.WriteEndElement();
    }
    if (vmBase.getTemplateVersion() != null) {
        _writer.WriteStartElement("templateVersion");
        _writer.WriteRaw(String.valueOf(vmBase.getTemplateVersion()));
        _writer.WriteEndElement();
    }
}
#method_after
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getDescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getDomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getCreationDate()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DeleteProtected");
    _writer.WriteRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.WriteEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.WriteStartElement("SsoMethod");
        _writer.WriteRaw(vmBase.getSsoMethod().toString());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.getTimeZone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.WriteEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getInitrdUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getKernelUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getKernelParams());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("Generation");
    _writer.WriteRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.WriteEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.WriteStartElement("TunnelMigration");
        _writer.WriteRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.WriteEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.WriteStartElement("VncKeyboardLayout");
        _writer.WriteRaw(vmBase.getVncKeyboardLayout());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("MinAllocatedMem");
    _writer.WriteRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsStateless");
    _writer.WriteRaw(String.valueOf(vmBase.isStateless()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsRunAndPause");
    _writer.WriteRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.WriteEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.WriteStartElement("CreatedByUserId");
        _writer.WriteRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.WriteEndElement();
    }
    if (vmBase.getTemplateVersionNumber() != null) {
        _writer.WriteStartElement("templateVersionNumber");
        _writer.WriteRaw(String.valueOf(vmBase.getTemplateVersionNumber()));
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsDisabled");
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TrustedService");
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TemplateType");
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    // in case template version is missing, we assume its version 1
    if (_vmTemplate.getTemplateVersion() == null) {
        _vmTemplate.setTemplateVersion(1);
    } else {
        // TODO: what if base template is not in the engine db? block import in canDoAction?
        node = content.SelectSingleNode("BaseTemplateId");
        if (node != null) {
            _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
        }
    }
}
#method_after
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsDisabled");
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TrustedService");
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TemplateType");
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    // in case template version is missing, we assume its version 1
    if (_vmTemplate.getTemplateVersionNumber() == null) {
        _vmTemplate.setTemplateVersionNumber(1);
    } else {
        // TODO: what if base template is not in the engine db? block import in canDoAction?
        node = content.SelectSingleNode("BaseTemplateId");
        if (node != null) {
            _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("TemplateVersionName");
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setDomain(node.innerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setTimeZone(node.innerText);
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion()))) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("SsoMethod");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("TunnelMigration");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("VncKeyboardLayout");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsRunAndPause");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("CreatedByUserId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("templateVersion");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTemplateVersion(Integer.parseInt(node.innerText));
        }
    }
    readGeneralData(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setDomain(node.innerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setTimeZone(node.innerText);
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion()))) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("SsoMethod");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("TunnelMigration");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("VncKeyboardLayout");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsRunAndPause");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("CreatedByUserId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("templateVersionNumber");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTemplateVersionNumber(Integer.parseInt(node.innerText));
        }
    }
    readGeneralData(content);
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("base_template_id", template.getBaseTemplateId());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#end_block

#method_before
private VM mockVm() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    vm.setVmtGuid(vmTemplateId);
    vm.setStaticData(getVmStatic());
    vm.setClusterArch(ArchitectureType.x86_64);
    vm.setTemplateVersion(1);
    return vm;
}
#method_after
private VM mockVm() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    vm.setVmtGuid(vmTemplateId);
    vm.setStaticData(getVmStatic());
    vm.setClusterArch(ArchitectureType.x86_64);
    vm.setTemplateVersionNumber(1);
    return vm;
}
#end_block

#method_before
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOsId(OsRepository.DEFAULT_OS);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#method_after
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOsId(OsRepository.DEFAULT_X86_OS);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#end_block

#method_before
protected Map<Guid, VmDevice> getVmInterfaceDevices() {
    List<VmDevice> vmInterfaceDevicesList = getVmDeviceDao().getVmDeviceByVmIdAndType(vmInterfacesSourceId, VmDeviceGeneralType.INTERFACE);
    Map<Guid, VmDevice> vmInterfaceDevices = new HashMap();
    for (VmDevice device : vmInterfaceDevicesList) {
        vmInterfaceDevices.put(device.getDeviceId(), device);
    }
    return vmInterfaceDevices;
}
#method_after
protected Map<Guid, VmDevice> getVmInterfaceDevices() {
    List<VmDevice> vmInterfaceDevicesList = getVmDeviceDao().getVmDeviceByVmIdAndType(vmInterfacesSourceId, VmDeviceGeneralType.INTERFACE);
    Map<Guid, VmDevice> vmInterfaceDevices = new HashMap<>();
    for (VmDevice device : vmInterfaceDevicesList) {
        vmInterfaceDevices.put(device.getDeviceId(), device);
    }
    return vmInterfaceDevices;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), false);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    // to have to correct version
    if (vmStatic.getTemplateVersion() != null) {
        vmStatic.setTemplateVersion(getVmTemplate().getTemplateVersion());
    }
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    vmStatic.setOriginalTemplateGuid(vmStatic.getVmtGuid());
    vmStatic.setOriginalTemplateName(getVmTemplate().getName());
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    // to have to correct version, otherwise set null
    if (Boolean.TRUE.equals(getParameters().getUseLatestVersion())) {
        vmStatic.setTemplateVersionNumber(null);
    } else {
        vmStatic.setTemplateVersionNumber(getVmTemplate().getTemplateVersionNumber());
    }
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    vmStatic.setOriginalTemplateGuid(vmStatic.getVmtGuid());
    vmStatic.setOriginalTemplateName(getVmTemplate().getName());
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#method_after
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    return vm;
}
#end_block

#method_before
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setManagementIp(instance.getManagementIp());
    obj.setPmUser(instance.getPmUser());
    obj.setPmPassword(instance.getPmPassword());
    obj.setPmType(instance.getPmType());
    obj.setPmOptionsMap(instance.getPmOptionsMap());
    obj.setPmSecondaryIp(instance.getManagementIp());
    obj.setPmSecondaryUser(instance.getPmUser());
    obj.setPmSecondaryPassword(instance.getPmPassword());
    obj.setPmSecondaryType(instance.getPmType());
    obj.setPmSecondaryOptionsMap(instance.getPmOptionsMap());
    obj.setpm_enabled(instance.getpm_enabled());
    obj.setPmSecondaryConcurrent(instance.isPmSecondaryConcurrent());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#method_after
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setManagementIp(instance.getManagementIp());
    obj.setPmUser(instance.getPmUser());
    obj.setPmPassword(instance.getPmPassword());
    obj.setPmType(instance.getPmType());
    obj.setPmOptionsMap(instance.getPmOptionsMap());
    obj.setPmSecondaryIp(instance.getManagementIp());
    obj.setPmSecondaryUser(instance.getPmUser());
    obj.setPmSecondaryPassword(instance.getPmPassword());
    obj.setPmSecondaryType(instance.getPmType());
    obj.setPmSecondaryOptionsMap(instance.getPmOptionsMap());
    obj.setpm_enabled(instance.getpm_enabled());
    obj.setPmSecondaryConcurrent(instance.isPmSecondaryConcurrent());
    obj.setDisablePowerManagementPolicy(instance.isDisablePowerManagementPolicy());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#end_block

#method_before
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#method_after
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setId(instance.getId());
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    return obj;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version", vm.getTemplateVersion());
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.getTemplateVersionNumber());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setOsId(rs.getInt("os"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setTemplateVersion(rs.getInt("template_version"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setOsId(rs.getInt("os"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setTemplateVersion((Integer) rs.getObject("template_version"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setTemplateVersionNumber((Integer) rs.getObject("template_version_number"));
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (getParameters().getBaseTemplateId() == null) {
        getParameters().setbaseTemplateId(getVmTemplateId());
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (getParameters().getBaseTemplateId() == null) {
        getParameters().setBaseTemplateId(getVmTemplateId());
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (getParameters().getBaseTemplateId() != null) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getParameters().getBaseTemplateId());
        if (baseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!baseTemplate.getBaseTemplateId().equals(baseTemplate.getId())) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (getParameters().getBaseTemplateId() != null) {
        VmTemplate userSelectedBaseTemplate = getVmTemplateDAO().get(getParameters().getBaseTemplateId());
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.getBaseTemplateId().equals(userSelectedBaseTemplate.getId())) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getBaseTemplateId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
@Test
public void testPosixDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    assertTrue(validator.isDcMatchingPosixCompatiblityVersion().isValid());
}
#method_after
@Test
public void testPosixDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    assertTrue(validator.isPosixSupportedInDC().isValid());
}
#end_block

#method_before
@Test
public void testPosixDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isDcMatchingPosixCompatiblityVersion();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_POSIX_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#method_after
@Test
public void testPosixDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isPosixSupportedInDC();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_POSIX_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#end_block

#method_before
@Test
public void testGlusterDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_3);
    storagePool.setIsLocal(false);
    assertTrue(validator.isDcMatchingGlusterCompatiblityVersion().isValid());
}
#method_after
@Test
public void testGlusterDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_3);
    storagePool.setIsLocal(false);
    assertTrue(validator.isGlusterSupportedInDC().isValid());
}
#end_block

#method_before
@Test
public void testGlusterDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isDcMatchingGlusterCompatiblityVersion();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_GLUSTER_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#method_after
@Test
public void testGlusterDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isGlusterSupportedInDC();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_GLUSTER_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#end_block

#method_before
@Test
public void testLocalDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(true);
    assertTrue(validator.isDcMatchingPosixCompatiblityVersion().isValid());
}
#method_after
@Test
public void testLocalDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(true);
    assertTrue(validator.isPosixSupportedInDC().isValid());
}
#end_block

#method_before
private void updateScanAlignmentEnabled() {
    if (getSelectedItem() == null) {
        setIsScanAlignmentEnabled(false);
        return;
    }
    final VM vm = getEntity();
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmDiskListModel model = (VmDiskListModel) target;
            StoragePool dataCenter = (StoragePool) returnValue;
            Version minClusterVersion = vm.getVdsGroupCompatibilityVersion();
            Version minDcVersion = dataCenter.getcompatibility_version();
            AsyncDataProvider.isCommandCompatible(new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    VmDiskListModel model = (VmDiskListModel) target;
                    boolean isCommandCompatible = (Boolean) returnValue;
                    if (!isCommandCompatible || model.getSelectedItem() == null) {
                        model.setIsScanAlignmentEnabled(false);
                        return;
                    }
                    if (((Disk) model.getSelectedItem()).getDiskStorageType() == DiskStorageType.LUN) {
                        model.setIsScanAlignmentEnabled(true);
                        return;
                    }
                    DiskImage diskImage = (DiskImage) getSelectedItem();
                    AsyncDataProvider.getStorageDomainById(new AsyncQuery(model, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object target, Object returnValue) {
                            VmDiskListModel model = (VmDiskListModel) target;
                            model.setIsScanAlignmentEnabled(((StorageDomain) returnValue).getStorageType().isBlockDomain());
                        }
                    }), diskImage.getStorageIds().get(0));
                }
            }), VdcActionType.GetDiskAlignment, minClusterVersion, minDcVersion);
        }
    }), vm.getStoragePoolId());
}
#method_after
private void updateScanAlignmentEnabled() {
    if (getSelectedItem() == null) {
        setIsScanAlignmentEnabled(false);
        return;
    }
    setIsScanAlignmentEnabled((getSelectedItem() instanceof LunDisk || isDiskOnBlockDevice((Disk) getSelectedItem())));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateQuotaCache();
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up && getMasterDomain() != null) {
        if (!StringUtils.equals(_oldStoragePool.getName(), getStoragePool().getName())) {
            runVdsCommand(VDSCommandType.SetStoragePoolDescription, new SetStoragePoolDescriptionVDSCommandParameters(getStoragePool().getId(), getStoragePool().getName()));
        }
    }
    copyUnchangedStoragePoolProperties(getStoragePool(), _oldStoragePool);
    getStoragePoolDAO().updatePartial(getStoragePool());
    updateStoragePoolFormatType();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateQuotaCache();
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        if (!StringUtils.equals(_oldStoragePool.getName(), getStoragePool().getName())) {
            runVdsCommand(VDSCommandType.SetStoragePoolDescription, new SetStoragePoolDescriptionVDSCommandParameters(getStoragePool().getId(), getStoragePool().getName()));
        }
    }
    copyUnchangedStoragePoolProperties(getStoragePool(), _oldStoragePool);
    getStoragePoolDAO().updatePartial(getStoragePool());
    updateStoragePoolFormatType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            if (getMasterDomain() != null) {
                updateMemberDomainsFormat(targetFormat);
            }
            return null;
        }
    });
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up && getMasterDomain() != null) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade procees of Storage Pool {0} has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
}
#method_after
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            return null;
        }
    });
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade procees of Storage Pool {0} has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
}
#end_block

#method_before
private static StoragePool createNewStoragePool() {
    StoragePool pool = createBasicPool();
    pool.setcompatibility_version(VERSION_1_1);
    return pool;
}
#method_after
private static StoragePool createNewStoragePool() {
    StoragePool pool = createBasicPool();
    pool.setIsLocal(false);
    pool.setcompatibility_version(VERSION_1_1);
    return pool;
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
protected boolean isStorageDomainTypeCorrect(StorageDomain storageDomain) {
    return storageDomain.isLocal() == getStoragePool().isLocal();
}
#method_after
protected boolean isStorageDomainTypeCorrect(StorageDomain storageDomain) {
    if (storageDomain.isLocal() != getStoragePool().isLocal()) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ATTACH_STORAGE_DOMAIN_STORAGE_TYPE_NOT_MATCH);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkDomainCanBeAttached(StorageDomain storageDomain) {
    return checkStorageDomainType(storageDomain) && isStorageDomainFormatCorrectForPool(storageDomain, getStoragePool()) && checkStorageDomainSharedStatusNotLocked(storageDomain) && ((storageDomain.getStorageDomainType() == StorageDomainType.ISO || storageDomain.getStorageDomainType() == StorageDomainType.ImportExport) || isStorageDomainNotInPool(storageDomain)) && isStorageDomainTypeCorrect(storageDomain) && isStorageDomainTypeCompatibleWithPool(storageDomain) && (isMixedTypesAllowedOnPool() || !isStoragePoolContainsOtherTypes(storageDomain));
}
#method_after
protected boolean checkDomainCanBeAttached(StorageDomain storageDomain) {
    if (!validateAmountOfIsoAndExportDomainsInDC(storageDomain)) {
        return false;
    }
    if (!isStorageDomainFormatCorrectForDC(storageDomain, getStoragePool())) {
        return false;
    }
    if (!checkStorageDomainSharedStatusNotLocked(storageDomain)) {
        return false;
    }
    if (!(isStorageDomainOfTypeIsoOrExport(storageDomain) || isStorageDomainNotInPool(storageDomain))) {
        return false;
    }
    if (!isStorageDomainTypeCorrect(storageDomain)) {
        return false;
    }
    if (!isStorageDomainCompatibleWithDC(storageDomain)) {
        return false;
    }
    if (!isMixedTypesAllowedInDC() && isMixedTypeDC(storageDomain)) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean isLocal() {
    return isLocal;
}
#method_after
public boolean isLocal() {
    return local;
}
#end_block

#method_before
public void setIsLocal(boolean isLocal) {
    this.isLocal = isLocal;
}
#method_after
public void setIsLocal(boolean isLocal) {
    this.local = isLocal;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((LVER == null) ? 0 : LVER.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((comment == null) ? 0 : comment.hashCode());
    result = prime * result + ((compatibilityVersion == null) ? 0 : compatibilityVersion.hashCode());
    result = prime * result + masterDomainVersion;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((recovery_mode == null) ? 0 : recovery_mode.hashCode());
    result = prime * result + ((spmVdsId == null) ? 0 : spmVdsId.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((storagePoolFormatType == null) ? 0 : storagePoolFormatType.hashCode());
    result = prime * result + ((quotaEnforcementType == null) ? 0 : quotaEnforcementType.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((LVER == null) ? 0 : LVER.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((comment == null) ? 0 : comment.hashCode());
    result = prime * result + ((compatibilityVersion == null) ? 0 : compatibilityVersion.hashCode());
    result = prime * result + masterDomainVersion;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((recovery_mode == null) ? 0 : recovery_mode.hashCode());
    result = prime * result + ((spmVdsId == null) ? 0 : spmVdsId.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + (local ? 1231 : 1237);
    result = prime * result + ((storagePoolFormatType == null) ? 0 : storagePoolFormatType.hashCode());
    result = prime * result + ((quotaEnforcementType == null) ? 0 : quotaEnforcementType.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StoragePool other = (StoragePool) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(LVER, other.LVER) && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(comment, other.comment) && ObjectUtils.objectsEqual(getcompatibility_version(), other.getcompatibility_version()) && masterDomainVersion == other.masterDomainVersion && ObjectUtils.objectsEqual(name, other.name) && recovery_mode == other.recovery_mode && ObjectUtils.objectsEqual(spmVdsId, other.spmVdsId) && status == other.status && ObjectUtils.objectsEqual(storagePoolFormatType, other.storagePoolFormatType) && quotaEnforcementType == other.quotaEnforcementType);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StoragePool other = (StoragePool) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(LVER, other.LVER) && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(comment, other.comment) && ObjectUtils.objectsEqual(getcompatibility_version(), other.getcompatibility_version()) && masterDomainVersion == other.masterDomainVersion && ObjectUtils.objectsEqual(name, other.name) && recovery_mode == other.recovery_mode && ObjectUtils.objectsEqual(spmVdsId, other.spmVdsId) && status == other.status && local == other.local && ObjectUtils.objectsEqual(storagePoolFormatType, other.storagePoolFormatType) && quotaEnforcementType == other.quotaEnforcementType);
}
#end_block

#method_before
@Override
protected DataCenter postPopulate(DataCenter model) {
    model.setLocal(new Random().nextBoolean());
    model.setStorageFormat(MappingTestHelper.shuffle(StorageFormat.class).value());
    return model;
}
#method_after
@Override
protected DataCenter postPopulate(DataCenter model) {
    model.setStorageFormat(MappingTestHelper.shuffle(StorageFormat.class).value());
    return model;
}
#end_block

#method_before
public boolean isLocal() {
    return getStorageType() == StorageType.LOCALFS;
}
#method_after
public boolean isLocal() {
    return getStorageType().isLocal();
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    iscsiBondListModel = new DataCenterIscsiBondListModel();
    list.add(iscsiBondListModel);
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType() == StorageDomainType.Master || sd.getStorageDomainType() == StorageDomainType.Data) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#method_after
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        quotaListModel.setIsAvailable(true);
    } else {
        quotaListModel.setIsAvailable(false);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null) {
        StoragePool storagePool = (StoragePool) getSelectedItem();
        quotaListModel.setIsAvailable(storagePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
        updateIscsiBondListAvailability(storagePool);
    }
}
#end_block

#method_before
@Override
public void save(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("is_local", pool.isLocal()).addValue("name", pool.getName()).addValue("status", pool.getStatus()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType()).addValue("compatibility_version", pool.getcompatibility_version());
    getCallsHandler().executeModification("Insertstorage_pool", parameterSource);
}
#method_after
@Override
public void save(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("is_local", pool.isLocal()).addValue("status", pool.getStatus()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType()).addValue("compatibility_version", pool.getcompatibility_version());
    getCallsHandler().executeModification("Insertstorage_pool", parameterSource);
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    return vm;
}
#end_block

#method_before
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#method_after
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    StoragePoolValidator storagePoolValidator = new StoragePoolValidator(getStoragePool());
    if (result && !(isStoragePoolUnique(getStoragePool().getName()))) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    } else if (!checkStoragePoolNameLengthValid()) {
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getStoragePool().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    if (result && !(isStoragePoolUnique(getStoragePool().getName()))) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    } else if (!checkStoragePoolNameLengthValid()) {
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getStoragePool().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    return result;
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    if (isLocalType) {
        return version.compareTo(new Version(3, 0)) >= 0;
    } else {
        return version.compareTo(new Version(3, 0)) >= 0;
    }
}
#method_after
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
    initPmPolicySeverities();
    initIscsiBondSeverities();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
}
#method_after
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CLUSTER_ALERT_HA_RESERVATION, AuditLogSeverity.ALERT);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!glusterVolume.isOnline()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
    }
    return true;
}
#end_block

#method_before
@Test
public void testGetCapacityInfo() {
    GlusterVolumeEntity volume = dao.getById(EXISTING_VOL_DIST_ID);
    assertNotNull("volume capacity info is not available", volume.getCapacityDetails());
    assertTrue(volume.getCapacityDetails().getTotalSize() == 50000);
    assertTrue(volume.getCapacityDetails().getUsedSize() == 5000);
    assertTrue(volume.getCapacityDetails().getFreeSize() == 45000);
    assertNotNull(volume.getCapacityDetails().getUpdatedAt());
}
#method_after
@Test
public void testGetCapacityInfo() throws ParseException {
    GlusterVolumeEntity volume = dao.getById(EXISTING_VOL_DIST_ID);
    assertNotNull("volume capacity info is not available", volume.getAdvancedDetails());
    assertTrue(volume.getAdvancedDetails().getCapacityInfo().getTotalSize() == 100000);
    assertTrue(volume.getAdvancedDetails().getCapacityInfo().getUsedSize() == 60000);
    assertTrue(volume.getAdvancedDetails().getCapacityInfo().getFreeSize() == 40000);
    assertTrue(EXPECTED_DATE_FORMAT.parse(volume.getAdvancedDetails().getUpdatedAt().toString()).equals(EXPECTED_DATE_FORMAT.parse("2014-01-21 18:12:33")));
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setCapacityDetails(fetchCapacityDatails(volume.getId()));
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        GlusterVolumeAdvancedDetails advancedDetails = fetchAdvancedDatails(volume.getId());
        if (advancedDetails != null) {
            volume.setAdvancedDetails(advancedDetails);
        }
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#end_block

#method_before
@Override
public void updateVolumeCapacityInfo(GlusterVolumeSizeInfo volumeCapacityInfo) {
    getCallsHandler().executeModification("UpdateGlusterVolumeCapacityInfo", getCustomMapSqlParameterSource().addValue("id", volumeCapacityInfo.getVolumeId()).addValue("total_space", volumeCapacityInfo.getTotalSize()).addValue("used_space", volumeCapacityInfo.getUsedSize()).addValue("free_space", volumeCapacityInfo.getFreeSize()));
}
#method_after
@Override
public void updateVolumeCapacityInfo(GlusterVolumeSizeInfo volumeCapacityInfo) {
    getCallsHandler().executeModification("UpdateGlusterVolumeDetails", createCapacityInfoParas(volumeCapacityInfo));
}
#end_block

#method_before
private Map<Guid, GlusterVolumeEntity> fetchVolumes(VDS upServer, List<VDS> existingServers) {
    Map<Guid, GlusterVolumeEntity> fetchedVolumes = null;
    while (fetchedVolumes == null && existingServers.size() > 0) {
        fetchedVolumes = fetchVolumes(upServer);
        if (fetchedVolumes == null) {
            // Couldn't fetch volumes from the up server. Mark it as non-operational
            logUtil.logServerMessage(upServer, AuditLogType.GLUSTER_VOLUME_INFO_FAILED);
            setNonOperational(upServer);
            existingServers.remove(upServer);
            upServer = getNewUpServer(existingServers, upServer);
        }
    }
    if (fetchedVolumes != null && !fetchedVolumes.isEmpty()) {
        fetchVolumeCapacityInfo(fetchedVolumes, upServer);
    }
    return fetchedVolumes;
}
#method_after
private Map<Guid, GlusterVolumeEntity> fetchVolumes(VDS upServer, List<VDS> existingServers) {
    Map<Guid, GlusterVolumeEntity> fetchedVolumes = null;
    while (fetchedVolumes == null && existingServers.size() > 0) {
        fetchedVolumes = fetchVolumes(upServer);
        if (fetchedVolumes == null) {
            // Couldn't fetch volumes from the up server. Mark it as non-operational
            logUtil.logServerMessage(upServer, AuditLogType.GLUSTER_VOLUME_INFO_FAILED);
            setNonOperational(upServer);
            existingServers.remove(upServer);
            upServer = getNewUpServer(existingServers, upServer);
        }
    }
    return fetchedVolumes;
}
#end_block

#method_before
private void updateVolume(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    updateVolumeProperties(existingVolume, fetchedVolume);
    updateVolumeCapacityInfo(existingVolume, fetchedVolume);
    updateBricks(existingVolume, fetchedVolume);
    updateOptions(existingVolume, fetchedVolume);
    updateTransportTypes(existingVolume, fetchedVolume);
}
#method_after
private void updateVolume(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    updateVolumeProperties(existingVolume, fetchedVolume);
    updateBricks(existingVolume, fetchedVolume);
    updateOptions(existingVolume, fetchedVolume);
    updateTransportTypes(existingVolume, fetchedVolume);
}
#end_block

#method_before
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshBrickStatuses(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#method_after
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshVolumeDetails(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#end_block

#method_before
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false));
    return result.getSucceeded() ? (GlusterVolumeAdvancedDetails) result.getReturnValue() : null;
}
#method_after
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false, true));
    return result.getSucceeded() ? (GlusterVolumeAdvancedDetails) result.getReturnValue() : null;
}
#end_block

#method_before
private GlusterVolumeEntity createDistVol(String volName, Guid volId) {
    GlusterVolumeEntity vol = createVolume(volName, volId);
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D1));
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D2));
    existingVolumes.add(vol);
    return vol;
}
#method_after
private GlusterVolumeEntity createDistVol(String volName, Guid volId) {
    GlusterVolumeEntity vol = createVolume(volName, volId);
    vol.getAdvancedDetails().setCapacityInfo(getCapacityInfo(volId));
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D1));
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D2));
    existingVolumes.add(vol);
    return vol;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doReturn(getVolumeCapacityInfo()).when(glusterManager).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeSizeInfo), any(GlusterVolumeVDSParameters.class));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#method_after
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#end_block

#method_before
private void verifyMocksForLightWeight() {
    InOrder inOrder = inOrder(clusterDao, vdsDao, clusterUtils, glusterManager, vdsStatisticsDao, vdsDynamicDao, vdsStaticDao, volumeDao, brickDao, optionDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    // get servers of the cluster from db
    inOrder.verify(vdsDao, times(1)).getAllForVdsGroup(CLUSTER_ID);
    // get the UP server from cluster
    inOrder.verify(clusterUtils, times(1)).getUpServer(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // servers are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchServers(existingServer1);
    // detached server SERVER_ID_3 is deleted from DB
    inOrder.verify(vdsStatisticsDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsDynamicDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsStaticDao, times(1)).remove(SERVER_ID_3);
    // detached server SERVER_ID_3 is removed from resource manager
    inOrder.verify(glusterManager, times(1)).runVdsCommand(eq(VDSCommandType.RemoveVds), any(RemoveVdsVDSCommandParameters.class));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for next operation (refresh volumes)
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // volumes are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchVolumes(any(VDS.class));
    // get volumes by cluster id to identify those that need to be removed
    inOrder.verify(volumeDao, times(1)).getByClusterId(CLUSTER_ID);
    // remove deleted volumes
    inOrder.verify(volumeDao, times(1)).removeAll(argThat(areRemovedVolumes()));
    // create new volume
    inOrder.verify(volumeDao, times(1)).save(newVolume);
    // // update volume capacity info
    // inOrder.verify(volumeDao, times(1))
    // .updateVolumeCapacityInfo((GlusterVolumeSizeInfo) getVolumeCapacityInfo().getReturnValue());
    // remove detached bricks
    inOrder.verify(brickDao, times(1)).removeAll(argThat(containsRemovedBricks()));
    // add new bricks
    inOrder.verify(brickDao, times(2)).save(argThat(isAddedBrick()));
    // add new options
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    newOptions.put(OPTION_AUTH_REJECT, existingReplVol.getOption(OPTION_AUTH_REJECT));
    List<GlusterVolumeOptionEntity> list1 = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    Collections.sort(list1);
    inOrder.verify(optionDao, times(1)).saveAll(list1);
    // update modified options
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    existingReplVol.getOption(OPTION_NFS_DISABLE).setValue(OPTION_VALUE_ON);
    existingOptions.put(OPTION_NFS_DISABLE, existingReplVol.getOption(OPTION_NFS_DISABLE));
    List<GlusterVolumeOptionEntity> list = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(list);
    inOrder.verify(optionDao, times(1)).updateAll("UpdateGlusterVolumeOption", list);
    // delete removed options
    inOrder.verify(optionDao, times(1)).removeAll(argThat(areRemovedOptions()));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
}
#method_after
private void verifyMocksForLightWeight() {
    InOrder inOrder = inOrder(clusterDao, vdsDao, clusterUtils, glusterManager, vdsStatisticsDao, vdsDynamicDao, vdsStaticDao, volumeDao, brickDao, optionDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    // get servers of the cluster from db
    inOrder.verify(vdsDao, times(1)).getAllForVdsGroup(CLUSTER_ID);
    // get the UP server from cluster
    inOrder.verify(clusterUtils, times(1)).getUpServer(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // servers are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchServers(existingServer1);
    // detached server SERVER_ID_3 is deleted from DB
    inOrder.verify(vdsStatisticsDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsDynamicDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsStaticDao, times(1)).remove(SERVER_ID_3);
    // detached server SERVER_ID_3 is removed from resource manager
    inOrder.verify(glusterManager, times(1)).runVdsCommand(eq(VDSCommandType.RemoveVds), any(RemoveVdsVDSCommandParameters.class));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for next operation (refresh volumes)
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // volumes are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchVolumes(any(VDS.class));
    // get volumes by cluster id to identify those that need to be removed
    inOrder.verify(volumeDao, times(1)).getByClusterId(CLUSTER_ID);
    // remove deleted volumes
    inOrder.verify(volumeDao, times(1)).removeAll(argThat(areRemovedVolumes()));
    // create new volume
    inOrder.verify(volumeDao, times(1)).save(newVolume);
    // remove detached bricks
    inOrder.verify(brickDao, times(1)).removeAll(argThat(containsRemovedBricks()));
    // add new bricks
    inOrder.verify(brickDao, times(2)).save(argThat(isAddedBrick()));
    // add new options
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    newOptions.put(OPTION_AUTH_REJECT, existingReplVol.getOption(OPTION_AUTH_REJECT));
    List<GlusterVolumeOptionEntity> list1 = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    Collections.sort(list1);
    inOrder.verify(optionDao, times(1)).saveAll(list1);
    // update modified options
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    existingReplVol.getOption(OPTION_NFS_DISABLE).setValue(OPTION_VALUE_ON);
    existingOptions.put(OPTION_NFS_DISABLE, existingReplVol.getOption(OPTION_NFS_DISABLE));
    List<GlusterVolumeOptionEntity> list = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(list);
    inOrder.verify(optionDao, times(1)).updateAll("UpdateGlusterVolumeOption", list);
    // delete removed options
    inOrder.verify(optionDao, times(1)).removeAll(argThat(areRemovedOptions()));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
}
#end_block

#method_before
private void mockDaos() {
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDao();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(interfaceDao).when(glusterManager).getInterfaceDao();
    doReturn(glusterServerDao).when(glusterManager).getGlusterServerDao();
    doReturn(Collections.singletonList(existingCluster)).when(clusterDao).getAll();
    doReturn(existingServers).when(vdsDao).getAllForVdsGroup(CLUSTER_ID);
    doReturn(existingDistVol).when(volumeDao).getById(EXISTING_VOL_DIST_ID);
    doReturn(existingReplVol).when(volumeDao).getById(EXISTING_VOL_REPL_ID);
    doReturn(null).when(volumeDao).getById(NEW_VOL_ID);
    doNothing().when(volumeDao).save(newVolume);
    doNothing().when(volumeDao).updateVolumeCapacityInfo((GlusterVolumeSizeInfo) getVolumeCapacityInfo().getReturnValue());
    doNothing().when(brickDao).removeAll(argThat(containsRemovedBricks()));
    doNothing().when(brickDao).save(argThat(isAddedBrick()));
    doNothing().when(optionDao).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    doNothing().when(optionDao).save(argThat(isNewOption()));
    doNothing().when(optionDao).removeAll(argThat(areRemovedOptions()));
    doReturn(existingVolumes).when(volumeDao).getByClusterId(CLUSTER_ID);
    doNothing().when(volumeDao).removeAll(argThat(areRemovedVolumes()));
    doNothing().when(brickDao).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    doNothing().when(optionDao).saveAll(argThat(areAddedOptions()));
}
#method_after
private void mockDaos() {
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDao();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(interfaceDao).when(glusterManager).getInterfaceDao();
    doReturn(glusterServerDao).when(glusterManager).getGlusterServerDao();
    doReturn(Collections.singletonList(existingCluster)).when(clusterDao).getAll();
    doReturn(existingServers).when(vdsDao).getAllForVdsGroup(CLUSTER_ID);
    doReturn(existingDistVol).when(volumeDao).getById(EXISTING_VOL_DIST_ID);
    doReturn(existingReplVol).when(volumeDao).getById(EXISTING_VOL_REPL_ID);
    doReturn(null).when(volumeDao).getById(NEW_VOL_ID);
    doNothing().when(volumeDao).save(newVolume);
    doNothing().when(brickDao).removeAll(argThat(containsRemovedBricks()));
    doNothing().when(brickDao).save(argThat(isAddedBrick()));
    doNothing().when(optionDao).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    doNothing().when(optionDao).save(argThat(isNewOption()));
    doNothing().when(optionDao).removeAll(argThat(areRemovedOptions()));
    doReturn(existingVolumes).when(volumeDao).getByClusterId(CLUSTER_ID);
    doNothing().when(volumeDao).removeAll(argThat(areRemovedVolumes()));
    doNothing().when(brickDao).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    doNothing().when(optionDao).saveAll(argThat(areAddedOptions()));
}
#end_block

#method_before
private GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(GlusterVolumeEntity volume) {
    GlusterVolumeAdvancedDetails volDetails = new GlusterVolumeAdvancedDetails();
    List<BrickDetails> brickDetailsList = new ArrayList<BrickDetails>();
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickDetails brickDetails = new BrickDetails();
        BrickProperties properties = new BrickProperties();
        properties.setBrickId(brick.getId());
        brickDetails.setBrickProperties(properties);
        properties.setStatus(brick.getStatus());
        if (volume == existingReplVol) {
            if (brick.getServerId().equals(SERVER_ID_1) && (brick.getBrickDirectory().equals(REPL_BRICK_R1D1) || brick.getBrickDirectory().equals(REPL_BRICK_R2D1))) {
                properties.setStatus(GlusterStatus.DOWN);
                bricksWithChangedStatus.add(brick);
            }
        }
        brickDetailsList.add(brickDetails);
    }
    volDetails.setBrickDetails(brickDetailsList);
    return volDetails;
}
#method_after
private GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(GlusterVolumeEntity volume) {
    GlusterVolumeAdvancedDetails volDetails = new GlusterVolumeAdvancedDetails();
    GlusterVolumeSizeInfo capacityInfo = new GlusterVolumeSizeInfo();
    capacityInfo.setVolumeId(volume.getId());
    capacityInfo.setTotalSize(600000L);
    capacityInfo.setFreeSize(200000L);
    capacityInfo.setUsedSize(400000L);
    volDetails.setCapacityInfo(capacityInfo);
    List<BrickDetails> brickDetailsList = new ArrayList<BrickDetails>();
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickDetails brickDetails = new BrickDetails();
        BrickProperties properties = new BrickProperties();
        properties.setBrickId(brick.getId());
        brickDetails.setBrickProperties(properties);
        properties.setStatus(brick.getStatus());
        if (volume == existingReplVol) {
            if (brick.getServerId().equals(SERVER_ID_1) && (brick.getBrickDirectory().equals(REPL_BRICK_R1D1) || brick.getBrickDirectory().equals(REPL_BRICK_R2D1))) {
                properties.setStatus(GlusterStatus.DOWN);
                bricksWithChangedStatus.add(brick);
            }
        }
        brickDetailsList.add(brickDetails);
    }
    volDetails.setBrickDetails(brickDetailsList);
    return volDetails;
}
#end_block

#method_before
private void verifyMocksForHeavyWeight() {
    InOrder inOrder = inOrder(clusterDao, clusterUtils, volumeDao, glusterManager, brickDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    VerificationMode mode = times(1);
    if (existingCluster.getcompatibility_version() == Version.v3_1) {
        // nothing else should happen if the cluster has compatibility level 3.1
        mode = Mockito.never();
    }
    // get the UP server from cluster
    inOrder.verify(clusterUtils, mode).getRandomUpServer(CLUSTER_ID);
    // get volumes of the cluster
    inOrder.verify(volumeDao, mode).getByClusterId(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for repl volume
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details of repl volume
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    // update brick status
    inOrder.verify(brickDao, mode).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
}
#method_after
private void verifyMocksForHeavyWeight() {
    InOrder inOrder = inOrder(clusterDao, clusterUtils, volumeDao, glusterManager, brickDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    VerificationMode mode = times(1);
    if (existingCluster.getcompatibility_version() == Version.v3_1) {
        // nothing else should happen if the cluster has compatibility level 3.1
        mode = Mockito.never();
    }
    // get the UP server from cluster
    inOrder.verify(clusterUtils, mode).getRandomUpServer(CLUSTER_ID);
    // get volumes of the cluster
    inOrder.verify(volumeDao, mode).getByClusterId(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    // Update capacity info
    inOrder.verify(volumeDao, mode).updateVolumeCapacityInfo(getVolumeAdvancedDetails(existingDistVol).getCapacityInfo());
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for repl volume
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details of repl volume
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    // Add Capacity Info
    inOrder.verify(volumeDao, mode).addVolumeCapacityInfo(getVolumeAdvancedDetails(existingReplVol).getCapacityInfo());
    // Add Capacity Info
    inOrder.verify(brickDao, mode).addBrickProperties(any(List.class));
    // update brick status
    inOrder.verify(brickDao, mode).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
}
#end_block

#method_before
@Override
public List<Statistic> getStatistics(GlusterVolumeEntity entity) {
    GlusterVolumeSizeInfo sizeInfo = entity.getCapacityDetails();
    if (sizeInfo == null) {
        return new ArrayList<Statistic>();
    }
    return asList(setDatum(clone(MEM_TOTAL_SIZE), sizeInfo.getTotalSize() * Mb), setDatum(clone(MEM_FREE_SIZE), sizeInfo.getFreeSize() * Mb), setDatum(clone(MEM_USED_SIZE), sizeInfo.getUsedSize() * Mb));
}
#method_after
@Override
public List<Statistic> getStatistics(GlusterVolumeEntity entity) {
    GlusterVolumeSizeInfo sizeInfo = entity.getAdvancedDetails().getCapacityInfo();
    if (sizeInfo == null) {
        return new ArrayList<Statistic>();
    }
    return asList(setDatum(clone(MEM_TOTAL_SIZE), sizeInfo.getTotalSize()), setDatum(clone(MEM_FREE_SIZE), sizeInfo.getFreeSize()), setDatum(clone(MEM_USED_SIZE), sizeInfo.getUsedSize()));
}
#end_block

#method_before
@Override
public Statistic adopt(Statistic statistic) {
    statistic.setGlusterVolume(clone(parent));
    return statistic;
}
#method_after
@Override
public Statistic adopt(Statistic statistic) {
    statistic.setGlusterVolume(parent);
    return statistic;
}
#end_block

#method_before
@Override
@Path("statistics")
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class) {

        @Override
        public GlusterVolumeEntity lookupEntity(Guid id) throws BackendFailureException {
            GlusterVolumeEntity volumeEntity = getEntity(GlusterVolumeEntity.class, VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(id), null, true);
            List<Guid> guids = new ArrayList<>();
            guids.add(volumeEntity.getId());
            List<GlusterVolumeSizeInfo> sizeInfos = runQuery(VdcQueryType.GetGlusterVolumeSizeInfo, new GlusterVolumeCapacityQueryParameters(volumeEntity.getClusterId(), guids)).getReturnValue();
            if (sizeInfos != null && sizeInfos.size() > 0) {
                volumeEntity.setCapacityDetails(sizeInfos.get(0));
            }
            return volumeEntity;
        }
    };
    VolumeStatisticalQuery query = new VolumeStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<GlusterVolume, GlusterVolumeEntity>(GlusterVolumeEntity.class, guid, query));
}
#method_after
@Override
@Path("statistics")
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class);
    VolumeStatisticalQuery query = new VolumeStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<GlusterVolume, GlusterVolumeEntity>(entityType, guid, query));
}
#end_block

#method_before
private void _threadMain() {
    boolean error = false;
    try {
        String line;
        while (_incoming != null && (line = _incoming.readLine()) != null) {
            log.infoFormat("update from host {0}: {1}", _vds.getHostName(), line);
            error = _messages.postOldXmlFormat(line) || error;
        }
        if (error) {
            throw new RuntimeException("Upgrade failed, please refer to logs for further information");
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during upgrade", e);
        _control.disconnect();
    }
}
#method_after
private void _threadMain() {
    boolean error = false;
    try {
        String line;
        while (_incoming != null && (line = _incoming.readLine()) != null) {
            log.infoFormat("update from host {0}: {1}", _vds.getHostName(), line);
            error = _messages.postOldXmlFormat(line) || error;
        }
        if (error) {
            throw new RuntimeException("Upgrade failed, please refer to logs for further information");
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during upgrade", e);
        try {
            _control.close();
        } catch (IOException ee) {
            log.error("Error during close", ee);
        }
    }
}
#end_block

#method_before
@Override
protected void finalize() {
    close();
}
#method_after
@Override
protected void finalize() {
    try {
        close();
    } catch (IOException e) {
        log.error("Exception during finalize", e);
    }
}
#end_block

#method_before
public void close() {
    stop();
    if (_dialog != null) {
        _dialog.disconnect();
        _dialog = null;
    }
}
#method_after
public void close() throws IOException {
    stop();
    if (_dialog != null) {
        _dialog.close();
        _dialog = null;
    }
}
#end_block

#method_before
public void execute() throws Exception {
    try {
        _setVdsStatus(VDSStatus.Installing);
        _dialog.useDefaultKeyPair();
        _dialog.setHost(_vds.getHostName());
        _dialog.connect();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Sending file %1$s to %2$s", _iso, _uploadPath));
        /*
             * Create the directory where
             * file is stored, in the past
             * it was done by vdsm, then vdsm-reg
             * well, as we use hard coded path
             * we can as well do this, until we
             * have proper node upgrade script
             * that can take the image from stdin.
             */
        _dialog.executeCommand(new SSHDialog.Sink() {

            @Override
            public void setControl(SSHDialog.Control control) {
            }

            @Override
            public void setStreams(InputStream incoming, OutputStream outgoing) {
            }

            @Override
            public void start() {
            }

            @Override
            public void stop() {
            }
        }, String.format("mkdir -p '%1$s'", new File(_uploadPath).getParent()), null);
        if (_failException != null) {
            throw _failException;
        }
        _dialog.sendFile(_iso, _uploadPath);
        _messages.post(InstallerMessages.Severity.INFO, String.format("Executing %1$s", _upgradeScriptName));
        _dialog.executeCommand(this, _upgradeScriptName, null);
        if (_failException != null) {
            throw _failException;
        }
        _setVdsStatus(VDSStatus.Reboot);
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during node {0} upgrade", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        _setVdsStatus(VDSStatus.InstallFailed);
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during node {0} upgrade", _vds.getHostName(), e);
        _setVdsStatus(VDSStatus.InstallFailed);
        if (_failException == null) {
            throw e;
        } else {
            log.errorFormat("Error during node {0} upgrade, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    }
}
#method_after
public void execute() throws Exception {
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        _dialog.useDefaultKeyPair();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String dest = Config.<String>getValue(ConfigValues.oVirtUploadPath);
        _messages.post(InstallerMessages.Severity.INFO, String.format("Sending file %1$s to %2$s", _iso, dest));
        /*
             * Create the directory where
             * file is stored, in the past
             * it was done by vdsm, then vdsm-reg
             * well, as we use hard coded path
             * we can as well do this, until we
             * have proper node upgrade script
             * that can take the image from stdin.
             */
        _dialog.executeCommand(new SSHDialog.Sink() {

            @Override
            public void setControl(SSHDialog.Control control) {
            }

            @Override
            public void setStreams(InputStream incoming, OutputStream outgoing) {
            }

            @Override
            public void start() {
            }

            @Override
            public void stop() {
            }
        }, String.format("mkdir -p '%1$s'", new File(dest).getParent()), null);
        if (_failException != null) {
            throw _failException;
        }
        _dialog.sendFile(_iso.getAbsolutePath(), dest);
        String command = Config.<String>getValue(ConfigValues.oVirtUpgradeScriptName);
        _messages.post(InstallerMessages.Severity.INFO, String.format("Executing %1$s", command));
        _dialog.executeCommand(this, command, null);
        if (_failException != null) {
            throw _failException;
        }
        _deployStatus = DeployStatus.Reboot;
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during node {0} upgrade", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during node {0} upgrade", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            log.errorFormat("Error during node {0} upgrade, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    OVirtNodeInfo Info = new OVirtNodeInfo();
    _uploadPath = Info.getUploadPath();
    _upgradeScriptName = Info.getUpgradeScriptName();
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        retValue = false;
    } else if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        retValue = false;
    } else if (isOvirtReInstallOrUpgrade()) {
        String isoFile = getParameters().getoVirtIsoFile();
        // Block re-install on non-operational Host
        if (getVds().getStatus() == VDSStatus.NonOperational) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            retValue = false;
        }
        if (!isIsoFileValid(isoFile, Info)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
            retValue = false;
        } else {
            RpmVersion ovirtHostOsVersion = VdsHandler.getOvirtHostOsVersion(getVds());
            if (ovirtHostOsVersion != null && !isIsoVersionCompatible(ovirtHostOsVersion, isoFile, Info)) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
                addCanDoActionMessage(String.format("$IsoVersion %1$s", ovirtHostOsVersion.getMajor()));
                retValue = false;
            }
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    if (getVds() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (isOvirtReInstallOrUpgrade()) {
        // Block re-install on non-operational Host
        if (getVds().getStatus() == VDSStatus.NonOperational) {
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
        }
        File iso = resolveISO(getParameters().getoVirtIsoFile());
        if (iso == null) {
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
        }
        RpmVersion ovirtHostOsVersion = VdsHandler.getOvirtHostOsVersion(getVds());
        if (!isISOCompatible(iso, ovirtHostOsVersion)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
            addCanDoActionMessage(String.format("$IsoVersion %1$s", ovirtHostOsVersion.getMajor()));
            return false;
        }
        _iso = iso;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), _isoFullPath, _uploadPath, _upgradeScriptName);
            upgrade.setCorrelationId(getCorrelationId());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getName());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getName());
            setSucceeded(true);
            if (getVds().getStatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getName(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            addCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getName());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setCorrelationId(getCorrelationId());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getVdsType()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getName(), getVds().getVdsType().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
            installer.execute();
            if (getVds().getStatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getName(), getVds().getVdsType().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getName(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            addCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() == null) {
        return;
    }
    if (isOvirtReInstallOrUpgrade()) {
        upgradeNode();
    } else {
        installHost();
    }
}
#end_block

#method_before
private boolean isOvirtReInstallOrUpgrade() {
    return getParameters().getIsReinstallOrUpgrade() && getVds().getVdsType() == VDSType.oVirtNode;
}
#method_after
private boolean isOvirtReInstallOrUpgrade() {
    return (getParameters().getIsReinstallOrUpgrade() && getVds().getVdsType() == VDSType.oVirtNode);
}
#end_block

#method_before
protected String getErrorMessage(String msg) {
    return (StringUtils.isEmpty(msg) ? GENERIC_ERROR : msg);
}
#method_after
protected String getErrorMessage(String msg) {
    return StringUtils.isEmpty(msg) ? GENERIC_ERROR : msg;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    OVirtNodeInfo Info = new OVirtNodeInfo();
    RpmVersion vdsOsVersion = getOvirtOsVersion();
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    List<String> reposUpgrade = new ArrayList<String>();
    String[] tempRepo = Info.getISOsPath().split(Info.getInfoDelimiter());
    for (int i = 0; i < tempRepo.length; i++) reposUpgrade.add(tempRepo[i]);
    for (String repo : reposUpgrade) {
        File directory = new File(repo);
        log.infoFormat("ISO Path: {0}", repo);
        if (directory.isDirectory()) {
            List<String> listOfIsoFiles = getListOfIsoFiles(directory, Info);
            log.infoFormat("List of ISOs: {0}", listOfIsoFiles);
            if (!listOfIsoFiles.isEmpty()) {
                File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
                for (File versionFile : ovirtVersionFiles) {
                    try {
                        IsoData isoData = new IsoData();
                        isoData.setVersion(readIsoVersion(versionFile));
                        String isoVersionText = isoData.getVersion();
                        isoData.setVdsmCompitibilityVersion(readVdsmCompatibiltyVersion((versionFile.getAbsolutePath().replace(OVIRT_ISO_VERSION_PREFIX, OVIRT_ISO_VDSM_COMPATIBILITY_PREFIX))));
                        if (StringUtils.isBlank(isoVersionText)) {
                            log.infoFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                            continue;
                        }
                        String[] versionParts = isoVersionText.split(",");
                        if (versionParts.length < 2) {
                            log.infoFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                            continue;
                        }
                        String majorVersionStr = versionParts[0];
                        String releaseStr = versionParts[1];
                        String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                        if (isoFileName == null) {
                            log.infoFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                            continue;
                        }
                        RpmVersion isoVersion = parseIsoFileVersion(isoFileName, majorVersionStr, Info);
                        boolean shouldAdd = false;
                        if (isoVersion != null && isIsoVersionSupported(isoVersion, Info)) {
                            if (isoData.getVdsmCompatibilityVersion() != null) {
                                shouldAdd = isIsoCompatibleForUpgradeByClusterVersion(isoData);
                            } else if (vdsOsVersion != null) {
                                if (VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                                    shouldAdd = true;
                                }
                            } else {
                                shouldAdd = true;
                            }
                        }
                        if (shouldAdd) {
                            availableISOsList.add(isoVersion);
                        }
                    } catch (RuntimeException e) {
                        log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                    }
                }
            }
        } else {
            log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
        }
    }
    log.infoFormat("availableISOsList {0}", availableISOsList);
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    VDS vds = getVdsByVdsId(getParameters().getVdsId());
    if (vds == null) {
        getQueryReturnValue().setReturnValue(availableISOsList);
        return;
    }
    RpmVersion vdsOsVersion = VdsHandler.getOvirtHostOsVersion(vds);
    String nodeOS = vds.getHostOs();
    for (OVirtNodeInfo.Entry info : OVirtNodeInfo.getInstance().get()) {
        log.debugFormat("nodeOS [{0}] | osPattern [{1}] | minimumVersion [{2}]", nodeOS, info.osPattern, info.minimumVersion);
        Matcher matcher = info.osPattern.matcher(nodeOS);
        if (matcher.matches() && info.path.isDirectory()) {
            log.debugFormat("Looking for list of ISOs in [{0}], regex [{1}]", info.path, info.isoPattern);
            for (File file : info.path.listFiles()) {
                matcher = info.isoPattern.matcher(file.getName());
                if (matcher.matches()) {
                    log.debugFormat("ISO Found [{0}]", file);
                    String version = matcher.group(1);
                    log.debugFormat("ISO Version [{0}]", version);
                    File versionFile = new File(info.path, String.format("version-%s.txt", version));
                    log.debugFormat("versionFile [{0}]", versionFile);
                    // Setting IsoData Class to get further [version] and [vdsm compatibility version] data
                    IsoData isoData = new IsoData();
                    isoData.setVersion(readIsoVersion(versionFile));
                    String isoVersionText = isoData.getVersion();
                    isoData.setVdsmCompitibilityVersion(readVdsmCompatibiltyVersion((versionFile.getAbsolutePath().replace(OVIRT_ISO_VERSION_PREFIX, OVIRT_ISO_VDSM_COMPATIBILITY_PREFIX))));
                    if (StringUtils.isEmpty(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Expected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    RpmVersion isoVersion = new RpmVersion(file.getName());
                    if (isoData.getVdsmCompatibilityVersion() != null && isIsoCompatibleForUpgradeByClusterVersion(isoData) || vdsOsVersion != null && VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                        availableISOsList.add(isoVersion);
                    }
                }
            }
        }
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#end_block

#method_before
private boolean isNewerVersion(Version isoClusterVersion) {
    VDS vds = getVdsByVdsId(getParameters().getVdsId());
    Version vdsClusterVersion = vds.getVdsGroupCompatibilityVersion();
    return (vdsClusterVersion.getMajor() == isoClusterVersion.getMajor() && vdsClusterVersion.getMinor() <= isoClusterVersion.getMinor());
}
#method_after
private boolean isNewerVersion(Version isoClusterVersion) {
    VDS vds = getVdsByVdsId(getParameters().getVdsId());
    Version vdsClusterVersion = vds.getVdsGroupCompatibilityVersion();
    log.debugFormat("vdsClusterVersion {0} isoClusterVersion {1}", vdsClusterVersion, isoClusterVersion);
    return (vdsClusterVersion.getMajor() == isoClusterVersion.getMajor() && vdsClusterVersion.getMinor() <= isoClusterVersion.getMinor());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getStorageDomain().setStorageFormat(VersionStorageFormatUtil.getPreferredForVersion(getStoragePool().getcompatibility_version(), getStoragePool().getStorageType()));
    super.executeCommand();
    if (getSucceeded()) {
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(getStorageDomain().getId(), getStoragePool().getId()));
        if (!returnValue.getSucceeded()) {
            getReturnValue().setSucceeded(false);
            getReturnValue().setFault(returnValue.getFault());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    getStorageDomain().setStorageFormat(VersionStorageFormatUtil.getPreferredForVersion(getStoragePool().getcompatibility_version(), getStorageDomain().getStorageType()));
    super.executeCommand();
    if (getSucceeded()) {
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(getStorageDomain().getId(), getStoragePool().getId()));
        if (!returnValue.getSucceeded()) {
            getReturnValue().setSucceeded(false);
            getReturnValue().setFault(returnValue.getFault());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateInitiators(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
            if (isSuccess && storageDomain != null) {
                // Synchronize LUN details comprising the storage domain with the DB
                StorageDomainParametersBase parameters = new StorageDomainParametersBase(storageDomain.getId());
                parameters.setVdsId(vdsId);
                Backend.getInstance().runInternalAction(VdcActionType.SyncLunsInfoForIscsiStorageDomain, parameters);
            }
        }
    }
    return isSuccess;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected boolean runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
            if (isSuccess && storageDomain != null) {
                // Synchronize LUN details comprising the storage domain with the DB
                StorageDomainParametersBase parameters = new StorageDomainParametersBase(storageDomain.getId());
                parameters.setVdsId(vdsId);
                Backend.getInstance().runInternalAction(VdcActionType.SyncLunsInfoForIscsiStorageDomain, parameters);
            }
        }
    }
    return isSuccess;
}
#end_block

#method_before
public static Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool) {
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getid(), Guid.Empty.toString());
    con.put("connection", connection.getconnection(), "");
    con.put("portal", connection.getportal(), "");
    con.put("port", connection.getport(), "");
    con.put("iqn", connection.getiqn(), "");
    con.put("user", connection.getuser_name(), "");
    con.put("password", connection.getpassword(), "");
    con.putIfNotEmpty("initiatorName", connection.getInitiatorName());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getcompatibility_version().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#method_after
public static Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool) {
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getid(), Guid.Empty.toString());
    con.put("connection", connection.getconnection(), "");
    con.put("portal", connection.getportal(), "");
    con.put("port", connection.getport(), "");
    con.put("iqn", connection.getiqn(), "");
    con.put("user", connection.getuser_name(), "");
    con.put("password", connection.getpassword(), "");
    con.putIfNotEmpty("initiatorName", connection.getIface());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getcompatibility_version().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#end_block

#method_before
protected Pair<Boolean, Integer> connectHostToStorage() {
    List<StorageServerConnections> connections = Arrays.asList(getConnection());
    if (getConnection().getstorage_type() == StorageType.ISCSI) {
        connections = ISCSIStorageHelper.updateInitiators(connections, getVds().getId());
    }
    Map<String, String> result = (HashMap<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), Guid.Empty, getConnection().getstorage_type(), connections)).getReturnValue();
    return new Pair<>(StorageHelperDirector.getInstance().getItem(getConnection().getstorage_type()).isConnectSucceeded(result, connections), Integer.parseInt(result.values().iterator().next()));
}
#method_after
protected Pair<Boolean, Integer> connectHostToStorage() {
    List<StorageServerConnections> connections = Arrays.asList(getConnection());
    if (getConnection().getstorage_type() == StorageType.ISCSI) {
        connections = ISCSIStorageHelper.updateIfaces(connections, getVds().getId());
    }
    Map<String, String> result = (HashMap<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), Guid.Empty, getConnection().getstorage_type(), connections)).getReturnValue();
    return new Pair<>(StorageHelperDirector.getInstance().getItem(getConnection().getstorage_type()).isConnectSucceeded(result, connections), Integer.parseInt(result.values().iterator().next()));
}
#end_block

#method_before
private boolean connectStorageServer(StorageType type, List<StorageServerConnections> connections) {
    boolean connectSucceeded = true;
    if (connections != null && connections.size() > 0) {
        if (type == StorageType.ISCSI) {
            connections = ISCSIStorageHelper.updateInitiators(connections, getVds().getId());
        }
        Map<String, String> retValues = (HashMap<String, String>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), type, connections)).getReturnValue();
        connectSucceeded = StorageHelperDirector.getInstance().getItem(type).isConnectSucceeded(retValues, connections);
        log.infoFormat("Host {0} storage connection was {1} ", getVds().getName(), connectSucceeded ? "succeeded" : "failed");
    }
    return connectSucceeded;
}
#method_after
private boolean connectStorageServer(StorageType type, List<StorageServerConnections> connections) {
    boolean connectSucceeded = true;
    if (connections != null && connections.size() > 0) {
        if (type == StorageType.ISCSI) {
            connections = ISCSIStorageHelper.updateIfaces(connections, getVds().getId());
        }
        Map<String, String> retValues = (HashMap<String, String>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), type, connections)).getReturnValue();
        connectSucceeded = StorageHelperDirector.getInstance().getItem(type).isConnectSucceeded(retValues, connections);
        log.infoFormat("Host {0} storage connection was {1} ", getVds().getName(), connectSucceeded ? "succeeded" : "failed");
    }
    return connectSucceeded;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{ id: ");
    sb.append(this.getid());
    sb.append(", connection: ");
    sb.append(this.getconnection());
    sb.append(", iqn: ");
    sb.append(this.getiqn());
    sb.append(", vfsType: ");
    sb.append(this.getVfsType());
    sb.append(", mountOptions: ");
    sb.append(this.getMountOptions());
    sb.append(", nfsVersion: ");
    sb.append(this.getNfsVersion());
    sb.append(", nfsRetrans: ");
    sb.append(this.getNfsRetrans());
    sb.append(", nfsTimeo: ");
    sb.append(this.getNfsTimeo());
    if (getInitiatorName() != null) {
        sb.append(", initiatorName: ");
        sb.append(this.getInitiatorName());
    }
    sb.append(" };");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{ id: ");
    sb.append(this.getid());
    sb.append(", connection: ");
    sb.append(this.getconnection());
    sb.append(", iqn: ");
    sb.append(this.getiqn());
    sb.append(", vfsType: ");
    sb.append(this.getVfsType());
    sb.append(", mountOptions: ");
    sb.append(this.getMountOptions());
    sb.append(", nfsVersion: ");
    sb.append(this.getNfsVersion());
    sb.append(", nfsRetrans: ");
    sb.append(this.getNfsRetrans());
    sb.append(", nfsTimeo: ");
    sb.append(this.getNfsTimeo());
    if (getIface() != null) {
        sb.append(", iface: ");
        sb.append(this.getIface());
    }
    sb.append(" };");
    return sb.toString();
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    iscsiBondListModel = new DataCenterIscsiBondListModel();
    list.add(iscsiBondListModel);
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    iscsiBundleListModel = new DataCenterIscsiBundleListModel();
    list.add(iscsiBundleListModel);
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null) {
        StoragePool storagePool = (StoragePool) getSelectedItem();
        quotaListModel.setIsAvailable(storagePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
        iscsiBondListModel.setIsAvailable(storagePool.getStorageType() == StorageType.ISCSI);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null) {
        StoragePool storagePool = (StoragePool) getSelectedItem();
        quotaListModel.setIsAvailable(storagePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
        iscsiBundleListModel.setIsAvailable(storagePool.getStorageType() == StorageType.ISCSI);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    bindPresenterWidget(IscsiBondRemovePopupPresenterWidget.class, IscsiBondRemovePopupPresenterWidget.ViewDef.class, IscsiBondRemovePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBundlePresenter.class, SubTabDataCenterIscsiBundlePresenter.ViewDef.class, SubTabDataCenterIscsiBundleView.class, SubTabDataCenterIscsiBundlePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // ISCSI Bundle
    bindPresenterWidget(IscsiBundlePopupPresenterWidget.class, IscsiBundlePopupPresenterWidget.ViewDef.class, IscsiBundlePopupView.class);
    bindPresenterWidget(IscsiBundleRemovePopupPresenterWidget.class, IscsiBundleRemovePopupPresenterWidget.ViewDef.class, IscsiBundleRemovePopupView.class);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
}
#end_block

#method_before
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    StorageDomainAndPoolQueryParameters params = new StorageDomainAndPoolQueryParameters(null, storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByStoragePoolId, params, aQuery);
}
#end_block

#method_before
private void configureNetworksOnHosts(Map<Guid, List<Network>> networksByHost, Map<Guid, Map<String, VdsNetworkInterface>> labelsToNicsByHost) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid hostId : networksByHost.keySet()) {
        AddNetworksByLabelParametersBuilder builder = new AddNetworksByLabelParametersBuilder();
        builder.buildParameters(hostId, networksByHost.get(hostId), labelsToNicsByHost.get(hostId));
    }
    getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
}
#method_after
private void configureNetworksOnHosts(Map<Guid, List<Network>> networksByHost, Map<Guid, Map<String, VdsNetworkInterface>> labelsToNicsByHost) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid hostId : networksByHost.keySet()) {
        AddNetworksByLabelParametersBuilder builder = new AddNetworksByLabelParametersBuilder();
        parameters.add(builder.buildParameters(hostId, networksByHost.get(hostId), labelsToNicsByHost.get(hostId)));
    }
    getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
}
#end_block

#method_before
protected void runCommands() {
    List<AttachNetworkToVdsGroupParameter> params = new ArrayList<>();
    Set<Guid> networkIds = new HashSet<>();
    for (CommandBase<?> command : getCommands()) {
        if (command.getReturnValue().getCanDoAction()) {
            AttachNetworkToVdsGroupParameter parameters = (AttachNetworkToVdsGroupParameter) command.getParameters();
            params.add(parameters);
            Network network = DbFacade.getInstance().getNetworkDao().get(parameters.getNetworkCluster().getNetworkId());
            if (NetworkUtils.isConfiguredByLabel(network)) {
                networkIds.add(network.getId());
            }
        }
    }
    // attaching a single network to multiple clusters can be executed using {@code AttachNetworkToVdsGroupCommand}
    if (networkIds.size() <= 1) {
        super.runCommands();
    }
    // multiple networks can be either attached or detached from a single cluster
    if (!params.isEmpty()) {
        Backend.getInstance().runInternalAction(getActionType(), new ClusterNetworksParameters(params.get(0).getVdsGroupId(), params));
    }
}
#method_after
protected void runCommands() {
    List<AttachNetworkToVdsGroupParameter> params = new ArrayList<>();
    Set<Guid> networkIds = new HashSet<>();
    for (CommandBase<?> command : getCommands()) {
        if (command.getReturnValue().getCanDoAction()) {
            AttachNetworkToVdsGroupParameter parameters = (AttachNetworkToVdsGroupParameter) command.getParameters();
            params.add(parameters);
            Network network = DbFacade.getInstance().getNetworkDao().get(parameters.getNetworkCluster().getNetworkId());
            if (NetworkUtils.isConfiguredByLabel(network)) {
                networkIds.add(network.getId());
            }
        }
    }
    // managing a single network on multiple clusters can be executed using the regular runner
    if (networkIds.size() <= 1) {
        super.runCommands();
        return;
    }
    // multiple networks can be either attached or detached from a single cluster
    if (!params.isEmpty()) {
        Backend.getInstance().runInternalAction(VdcActionType.AttachNetworksToCluster, new ClusterNetworksParameters(params.get(0).getVdsGroupId(), params));
    }
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
    initPmPolicySeverities();
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
}
#method_after
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CLUSTER_ALERT_HA_RESERVATION, AuditLogSeverity.ALERT);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(domain, other.domain) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(domain, other.domain) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    hotPlugUnplugCpus();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    hotSetCpus();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getVmId(), deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getParameters().getVmId(), deviceType, device);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(getVmId());
}
#method_after
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.shutdown(vmId, timeout, message);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message, boolean reboot) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.shutdown(vmId, timeout, message, reboot);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsmEnabled()) {
        entity.setEnableKsm(model.isKsmEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsmEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    return model;
}
#end_block

#method_before
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getPolicy(), transform.getSchedulingPolicy().getPolicy());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.isKsmEnabled(), transform.isKsmEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
}
#method_after
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getPolicy(), transform.getSchedulingPolicy().getPolicy());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.getKsm().isEnabled(), transform.getKsm().isEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()) || version.compareTo(Version.v3_4) < 0);
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    getEnableKsm().setIsChangable(version.compareTo(Version.v3_4) >= 0);
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso()) {
        staticVm.setSsoMethod(SsoUtils.fromRestToBackend(vm.getSso()));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    if (entity.getSsoMethod() != null) {
        model.setSso(SsoUtils.fromBackendToRest(entity.getSsoMethod()));
    }
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            params.setUseVnc(displayType == DisplayType.VNC);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                params.setUseVnc(displayType == DisplayType.VNC);
            }
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso()) {
        entity.setSsoMethod(SsoUtils.fromRestToBackend(model.getSso()));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso()) {
        staticVm.setSsoMethod(SsoUtils.fromRestToBackend(model.getSso()));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoUtils.fromBackendToRest(entity.getSsoMethod()));
    if (entity.getVmType() != null) {
        model.setType(VmMapper.map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(VmMapper.map(entity.getOrigin(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getDefaultDisplayType(), null));
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.isAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getDomain() != null && !entity.getDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getDomain());
        model.setDomain(domain);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(entity.getTimeZone());
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    if (entity.getVmType() != null) {
        model.setType(VmMapper.map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(VmMapper.map(entity.getOrigin(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getDefaultDisplayType(), null));
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.isAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getDomain() != null && !entity.getDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getDomain());
        model.setDomain(domain);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(entity.getTimeZone());
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    // $NON-NLS-1$
    getTable().addColumn(new CommentColumn<VM>(), constants.commentLabel(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
@Override
public void entityPropertyChanged(PropertyChangedEventArgs e) {
    updateProperties();
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        updateActionAvailability();
    }
}
#method_after
@Override
public void entityPropertyChanged(PropertyChangedEventArgs e) {
    updateProperties();
    if (// $NON-NLS-1$
    e.propertyName.equals("status")) {
        updateActionAvailability();
    }
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateCache(value);
    super.setItems(value);
}
#method_after
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateVmCache(value);
    super.setItems(value);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVm(((VM) getSelectedItem()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setDefaultVncKeyboardLayout(vm.getDefaultVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setDefaultVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.PropertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItem() == null ? null : getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        // right now we check if the vmIp is set because for some reason vm.getHasAgent() returns false even when GA is present
        if (!isCommandCompatible(VdcActionType.RebootVm, version, version) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void perform() {
    log.infoFormat("Sending reboot command for VM {0}.", getVm().getName());
    final VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RebootVm, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
    setActionReturnValue(returnValue.getReturnValue());
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void perform() {
    final VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RebootVm, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
    setActionReturnValue(returnValue.getReturnValue());
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.error("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.error("Can't login user \"{}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.error("Can't login user \"{}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.error("Can't login user \"{}\" because authentication profile \"{}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.error("Can't login user \"{}\" because the authentication profile \"{}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    boolean authenticated = passwordAuthenticator.authenticate(loginName, password.toCharArray());
    if (!authenticated) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the authentication failed.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    AuthenticationResult<?> result = passwordAuthenticator.authenticate(loginName, password);
    if (!result.isSuccessful()) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        for (VdcBllMessages msg : result.resolveMessage()) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#end_block

#method_before
@Override
protected boolean isUserAuthorizedToRunAction() {
    return true;
}
#method_after
@Override
protected boolean isUserAuthorizedToRunAction() {
    if (log.isDebugEnabled()) {
        log.debug("IsUserAutorizedToRunAction: login - no permission check");
    }
    return true;
}
#end_block

#method_before
private void updateUserData() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
        // XXX: Will look at this later.
        // DbFacade.getInstance().updateLastAdminCheckStatus(dbUser.getId());
        }
    });
}
#method_after
private void updateUserData() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
        // TODO: Will look at this later.
        // DbFacade.getInstance().updateLastAdminCheckStatus(dbUser.getId());
        }
    });
}
#end_block

#method_before
@Override
public boolean validate(Principal principal, String sessionId) {
    if (principal == null) {
        return loginFailureNoAuthType();
    }
    if (principal.getDomain() == null) {
        return loginFailure(principal, NO_DOMAIN);
    }
    LoginUserParameters params = new LoginUserParameters(principal.getDomain(), principal.getUser(), principal.getSecret());
    params.setActionType(VdcActionType.LoginUser);
    sessionHelper.setSessionId(sessionId);
    VdcReturnValueBase ret = backend.Login(sessionHelper.sessionize(params));
    if (ret.getCanDoAction() && ret.getSucceeded()) {
        return loginSuccess(principal, ret);
    } else {
        return loginFailure(principal, reasons(ret));
    }
}
#method_after
@Override
public boolean validate(Principal principal, String sessionId) {
    if (principal == null) {
        return loginFailureNoAuthType();
    }
    if (principal.getDomain() == null) {
        return loginFailure(principal, NO_DOMAIN);
    }
    LoginUserParameters params = new LoginUserParameters(principal.getDomain(), principal.getUser(), principal.getSecret());
    params.setActionType(VdcActionType.LoginUser);
    sessionHelper.setSessionId(sessionId);
    VdcReturnValueBase ret = backend.login(sessionHelper.sessionize(params));
    if (ret.getCanDoAction() && ret.getSucceeded()) {
        return loginSuccess(principal, ret);
    } else {
        return loginFailure(principal, reasons(ret));
    }
}
#end_block

#method_before
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.RunPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        DbUser user = queryReturnValue.getReturnValue();
        if (user != null) {
            principal = new Principal(user.getLoginName(), null, user.getDomain());
            sessionHelper.setSessionId(sessionId);
            current.set(user);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#method_after
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.runPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        DbUser user = queryReturnValue.getReturnValue();
        if (user != null) {
            principal = new Principal(user.getLoginName(), null, user.getDomain());
            sessionHelper.setSessionId(sessionId);
            current.set(user);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#end_block

#method_before
private ApplicationMode getApplicationMode() {
    VdcQueryReturnValue result = backend.RunPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, ConfigCommon.defaultConfigurationVersion));
    ApplicationMode appMode = null;
    if (result.getSucceeded()) {
        appMode = ApplicationMode.from((Integer) result.getReturnValue());
    } else {
        appMode = ApplicationMode.AllModes;
    }
    return appMode;
}
#method_after
private ApplicationMode getApplicationMode() {
    VdcQueryReturnValue result = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, ConfigCommon.defaultConfigurationVersion));
    ApplicationMode appMode = null;
    if (result.getSucceeded()) {
        appMode = ApplicationMode.from((Integer) result.getReturnValue());
    } else {
        appMode = ApplicationMode.AllModes;
    }
    return appMode;
}
#end_block

#method_before
private void validateSessionSucceeded(VdcQueryReturnValue ret) {
    LOG.debugFormat(VALIDATE_SESSION_SUCCESS);
    // cache user in Current so that it will be available
    // for logoff action on postProcess() traversal
    current.set(ret.getReturnValue());
}
#method_after
private void validateSessionSucceeded(VdcQueryReturnValue ret) {
    LOG.debugFormat(VALIDATE_SESSION_SUCCESS);
    // cache user in Current so that it will be available
    // for logoff action on postProcess() traversal
    current.set(ret.getReturnValue());
    current.set(getApplicationMode());
}
#end_block

#method_before
@Override
public void postProcess(ServerResponse response) {
    HttpSession httpSession = getCurrentSession(false);
    if (!current.get(MetaData.class).hasKey("async") || (!(Boolean.TRUE.equals((Boolean) current.get(MetaData.class).get("async"))))) {
        DbUser user = current.get(DbUser.class);
        if (user != null) {
            if (!persistentSession) {
                backend.Logoff(sessionHelper.sessionize(new LogoutUserParameters(user.getId())));
                if (httpSession != null) {
                    httpSession.invalidate();
                }
            } else if (httpSession != null && httpSession.isNew()) {
                response.getMetadata().add(SessionUtils.JSESSIONID_HEADER, httpSession.getId());
            }
        }
    }
    sessionHelper.clean();
}
#method_after
@Override
public void postProcess(ServerResponse response) {
    HttpSession httpSession = getCurrentSession(false);
    if (!current.get(MetaData.class).hasKey("async") || (!(Boolean.TRUE.equals((Boolean) current.get(MetaData.class).get("async"))))) {
        DbUser user = current.get(DbUser.class);
        if (user != null) {
            if (!persistentSession) {
                backend.logoff(sessionHelper.sessionize(new LogoutUserParameters(user.getId())));
                if (httpSession != null) {
                    httpSession.invalidate();
                }
            } else if (httpSession != null && httpSession.isNew()) {
                response.getMetadata().add(SessionUtils.JSESSIONID_HEADER, httpSession.getId());
            }
        }
    }
    sessionHelper.clean();
}
#end_block

#method_before
public void setMemberOf(List<String> memberOf) {
    this.memberOf = memberOf;
}
#method_after
public void setMemberOf(Set<String> memberOf) {
    this.memberOf = memberOf;
}
#end_block

#method_before
public List<String> getMemberOf() {
    return memberOf;
}
#method_after
public Set<String> getMemberOf() {
    return memberOf;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + status;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbGroup other = (DbGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && status == other.status);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbGroup other = (DbGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && active == other.active);
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().toHex());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DirectoryUser.class, to = User.class)
public static User map(DirectoryUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getId().getBytes());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getName());
    model.setId(Hex.encodeHexString(entity.getId().getBytes()));
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (DirectoryGroup directoryGroup : entity.getGroups()) {
            Group group = new Group();
            group.setName(directoryGroup.getName());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DirectoryUser.class, to = User.class)
public static User map(DirectoryUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setExternalId(entity.getId().toString());
    model.setUserName(entity.getName());
    model.setId(entity.getId().toHex());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (DirectoryGroup directoryGroup : entity.getGroups()) {
            Group group = new Group();
            group.setName(directoryGroup.getName());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                DirectoryGroup a = (DirectoryGroup) item;
                if (!excludeUsers.contains(a.getId())) {
                    // XXX: This should use DbGroup and not DbUser.
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getId());
                    tempVar3.setFirstName(a.getName());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getDirectory().getName());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<ExternalId> excludeUsers = new HashSet<ExternalId>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getExternalId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                DirectoryGroup a = (DirectoryGroup) item;
                if (!excludeUsers.contains(a.getId())) {
                    // XXX: This should use DbGroup and not DbUser.
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getId());
                    tempVar3.setFirstName(a.getName());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getDirectory().getName());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
protected void addUsersToModel(VdcQueryReturnValue returnValue, Set<ExternalId> excludeUsers) {
    for (IVdcQueryable item : (ArrayList<IVdcQueryable>) returnValue.getReturnValue()) {
        DirectoryUser a = (DirectoryUser) item;
        if (!excludeUsers.contains(a.getId())) {
            EntityModel tempVar2 = new EntityModel();
            tempVar2.setEntity(new DbUser(a));
            getusers().add(tempVar2);
        }
    }
}
#method_after
protected void addUsersToModel(VdcQueryReturnValue returnValue, Set<ExternalId> excludeUsers) {
    for (IVdcQueryable item : (List<IVdcQueryable>) returnValue.getReturnValue()) {
        DirectoryUser a = (DirectoryUser) item;
        if (!excludeUsers.contains(a.getId())) {
            EntityModel tempVar2 = new EntityModel();
            tempVar2.setEntity(new DbUser(a));
            getusers().add(tempVar2);
        }
    }
}
#end_block

#method_before
protected void findGroups(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.RunQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryGroup), query);
}
#method_after
protected void findGroups(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryGroup), query);
}
#end_block

#method_before
protected void findUsers(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.RunQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryUser), query);
}
#method_after
protected void findUsers(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryUser), query);
}
#end_block

#method_before
private boolean handleQueryError(VdcQueryReturnValue returnValue, AdElementListModel model) {
    model.setMessage(null);
    if (!returnValue.getSucceeded()) {
        model.setMessage(Frontend.getAppErrorsTranslator().TranslateErrorTextSingle(returnValue.getExceptionString()));
        getSearchInProgress().setEntity(false);
        return true;
    }
    return false;
}
#method_after
private boolean handleQueryError(VdcQueryReturnValue returnValue, AdElementListModel model) {
    model.setMessage(null);
    if (!returnValue.getSucceeded()) {
        model.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
        getSearchInProgress().setEntity(false);
        return true;
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, ExternalId id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(domain, id);
    if (dbUser == null) {
        Directory directory = DirectoryManager.getInstance().getDirectory(domain);
        if (directory == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        DirectoryUser directoryUser = directory.findUser(id);
        if (directoryUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(directoryUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#method_after
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String directoryName, ExternalId id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(directoryName, id);
    if (dbUser == null) {
        Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
        if (directory == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        DirectoryUser directoryUser = directory.findUser(id);
        if (directoryUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(directoryUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the directory name has been provided:
    String directoryName = getParameters().getDirectory();
    if (directoryName == null) {
        log.error("Can't add user because directory name hasn't been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the idientifier of the directory user has been provided:
    ExternalId id = getParameters().getId();
    if (id == null) {
        log.error("Can't add user from directory \"{}\" because the user identifier hasn't been provided.", directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the directory exists:
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    if (directory == null) {
        log.error("Can't add user with id \"{}\" because directory \"{}\" doesn't exist.", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = directory.findUser(id);
    if (directoryUser == null) {
        log.error("Can't add user with id \"{}\" because it doesn't exist in directory \"{}\".", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the directory name has been provided:
    String directoryName = getParameters().getDirectory();
    if (directoryName == null) {
        log.error("Can't add user because directory name hasn't been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the identifier of the directory user has been provided:
    ExternalId id = getParameters().getId();
    if (id == null) {
        log.errorFormat("Can't add user from directory \"{0}\" because the user identifier hasn't been provided.", directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the directory exists:
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    if (directory == null) {
        log.errorFormat("Can't add user with id \"{0}\" because directory \"{1}\" doesn't exist.", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = directory.findUser(id);
    if (directoryUser == null) {
        log.errorFormat("Can't add user with id \"{0}\" because it doesn't exist in directory \"{1}\".", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getName());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUserDAO dao = getDbUserDAO();
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectory().getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectory().getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#end_block

#method_before
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().toHex());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DirectoryGroup.class, to = Group.class)
public static Group map(DirectoryGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getId().getBytes());
    model.setName(entity.getName());
    model.setId(Hex.encodeHexString(entity.getId().getBytes()));
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DirectoryGroup.class, to = Group.class)
public static Group map(DirectoryGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(entity.getId().toHex());
    model.setExternalId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
private void setUpProfileMock(String name) {
    Directory directoryMock = mock(Directory.class);
    doReturn(name).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(directoryMock);
    Authenticator authenticatorMock = mock(Authenticator.class);
    doReturn(name).when(authenticatorMock).getName();
    AuthenticatorManager.getInstance().registerAuthenticator(authenticatorMock);
    AuthenticationProfile profileMock = mock(AuthenticationProfile.class);
    doReturn(name).when(profileMock).getName();
    doReturn(directoryMock).when(profileMock).getDirectory();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    AuthenticationProfileManager.getInstance().registerProfile(profileMock);
}
#method_after
private void setUpProfileMock(String name) {
    Directory directoryMock = mock(Directory.class);
    doReturn(name).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(name, directoryMock);
    Authenticator authenticatorMock = mock(Authenticator.class);
    AuthenticatorManager.getInstance().registerAuthenticator(name, authenticatorMock);
    AuthenticationProfile profileMock = mock(AuthenticationProfile.class);
    doReturn(name).when(profileMock).getName();
    doReturn(directoryMock).when(profileMock).getDirectory();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    AuthenticationProfileManager.getInstance().registerProfile(name, profileMock);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final String domain = getParameters().getDomain();
    final ExternalId id = getParameters().getId();
    final Directory directory = DirectoryManager.getInstance().getDirectory(domain);
    final DirectoryGroup group = directory.findGroup(id);
    getQueryReturnValue().setReturnValue(group);
}
#method_after
@Override
protected void executeQueryCommand() {
    final String directoryName = getParameters().getDomain();
    final ExternalId id = getParameters().getId();
    final Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    final DirectoryGroup group = directory.findGroup(id);
    getQueryReturnValue().setReturnValue(group);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Load authentication profiles:
    File etcDir = EngineLocalConfig.getInstance().getEtcDir();
    File authDir = new File(etcDir, "auth.d");
    if (authDir.exists() && authDir.isDirectory()) {
        AuthenticationProfileManager.getInstance().loadConfiguration(authDir);
    }
    // If no authentication profiles have been configured then create one for each of the old style domains:
    if (AuthenticationProfileManager.getInstance().getProfiles().isEmpty()) {
        for (String domain : LdapBrokerUtils.getDomainsList()) {
            Authenticator authenticator = new ProvisionalAuthenticator(domain);
            AuthenticatorManager.getInstance().registerAuthenticator(authenticator);
            Directory directory = new ProvisionalDirectory(domain);
            DirectoryManager.getInstance().registerDirectory(directory);
            AuthenticationProfile profile = new AuthenticationProfile(domain, authenticator, directory);
            AuthenticationProfileManager.getInstance().registerProfile(profile);
        }
    }
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    for (String domain : LdapBrokerUtils.getDomainsList()) {
        LdapBroker broker = LdapFactory.getInstance(domain);
        Authenticator authenticator = new ProvisionalAuthenticator(domain, broker);
        Directory directory = new ProvisionalDirectory(domain, broker);
        AuthenticationProfile profile = new AuthenticationProfile(domain, authenticator, directory);
        AuthenticatorManager.getInstance().registerAuthenticator(domain, authenticator);
        DirectoryManager.getInstance().registerDirectory(domain, directory);
        AuthenticationProfileManager.getInstance().registerProfile(domain, profile);
    }
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#end_block

#method_before
@Override
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#method_after
@Override
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#end_block

#method_before
public String getVdcObjectName() {
    permissions perms = getParameters().getPermission();
    return getDbFacade().getEntityNameByIdAndType(perms.getObjectId(), perms.getObjectType());
}
#method_after
public String getVdcObjectName() {
    Permissions perms = getParameters().getPermission();
    return getDbFacade().getEntityNameByIdAndType(perms.getObjectId(), perms.getObjectType());
}
#end_block

#method_before
protected boolean isSystemSuperUser() {
    permissions superUserPermission = getPermissionDAO().getForRoleAndAdElementAndObjectWithGroupCheck(PredefinedRoles.SUPER_USER.getId(), getCurrentUser().getId(), MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID);
    return superUserPermission != null;
}
#method_after
protected boolean isSystemSuperUser() {
    Permissions superUserPermission = getPermissionDAO().getForRoleAndAdElementAndObjectWithGroupCheck(PredefinedRoles.SUPER_USER.getId(), getCurrentUser().getId(), MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID);
    return superUserPermission != null;
}
#end_block

#method_before
// TODO - this code is shared with addPermissionCommand - check if
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissions permission = getParameters().getPermission();
    permissionList.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    return permissionList;
}
#method_after
// TODO - this code is shared with addPermissionCommand - check if
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    Permissions permission = getParameters().getPermission();
    permissionList.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String domain = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(domain);
    directoryGroup = directory.findGroup(id);
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String directoryName = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    directoryGroup = directory.findGroup(id);
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getName());
    return true;
}
#end_block

#method_before
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String domain = getDomain(group);
    DirectoryGroup directoryGroup = getEntity(DirectoryGroup.class, SearchType.DirectoryGroup, getDirectoryGroupSearchPattern(group.getName(), domain));
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in domain " + domain).build();
    }
    DirectoryIdParameters parameters = new DirectoryIdParameters();
    parameters.setDirectory(directoryGroup.getDirectory().getName());
    parameters.setId(directoryGroup.getId());
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#method_after
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getDirectoryName(group);
    DirectoryGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    DirectoryIdParameters parameters = new DirectoryIdParameters();
    parameters.setDirectory(directoryName);
    parameters.setId(directoryGroup.getId());
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#end_block

#method_before
@Override
public SyntaxContainer analyzeSyntaxState(String searchText, boolean final2) {
    SyntaxContainer retval = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter AdConditionFieldAC;
    if (searchText.toUpperCase().contains("ADUSER")) {
        AdConditionFieldAC = new AdUserConditionFieldAutoCompleter();
    } else {
        AdConditionFieldAC = new AdGroupConditionFieldAutoCompleter();
    }
    IAutoCompleter conditionRelationAC;
    char[] searchCharArr = searchText.toCharArray();
    boolean betweenDoubleQuotes = false;
    int curStartPos = 0;
    String curConditionField = "";
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        SyntaxObjectType curState = retval.getState();
        char curChar = searchCharArr[idx];
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        // ERROR INVALID-SEARCH OBJECT
                        retval.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return retval;
                    }
                } else {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    retval.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    retval.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            case COLON:
            case CONDITION_VALUE:
                if (AdConditionFieldAC.validate(nextObject)) {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curConditionField = nextObject;
                    curStartPos = idx + 1;
                } else if (// &&
                !AdConditionFieldAC.validateCompletion(nextObject)) // (!mSortbyAC.validateCompletion(nextObject)))
                {
                    retval.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                    return retval;
                }
                retval.setvalid(false);
                break;
            case CONDITION_FIELD:
                conditionRelationAC = AdConditionFieldAC.getFieldRelationshipAutoCompleter(curConditionField);
                if (conditionRelationAC == null) {
                    retval.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return retval;
                }
                if (idx + 1 < searchCharArr.length) {
                    String tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (conditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!conditionRelationAC.validate(nextObject)) {
                    if (!conditionRelationAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                retval.setvalid(false);
                break;
            case CONDITION_RELATION:
                boolean addObjFlag = false;
                if (curChar == '"') {
                    betweenDoubleQuotes = (!betweenDoubleQuotes);
                    if (betweenDoubleQuotes) {
                        if (!mFirstDQRegexp.IsMatch(strRealObj)) {
                            retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx + 1);
                            return retval;
                        }
                    } else {
                        strRealObj = StringHelper.trim(strRealObj, new char[] { '\"' });
                        addObjFlag = true;
                    }
                }
                // searchObject and no space is predicted !!
                if (final2) {
                    if (((curChar == ' ') || (idx + 1 == searchCharArr.length)) && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                } else {
                    if ((curChar == ' ') && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                }
                if (addObjFlag) {
                    if (!AdConditionFieldAC.validateFieldValue(curConditionField, strRealObj)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx);
                        return retval;
                    } else {
                        retval.addSyntaxObject(SyntaxObjectType.CONDITION_VALUE, strRealObj, curStartPos, idx + 1);
                        curConditionField = "";
                    }
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            default:
                retval.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return retval;
        }
    }
    return retval;
}
#method_after
@Override
public SyntaxContainer analyzeSyntaxState(String searchText, boolean final2) {
    SyntaxContainer retval = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter AdConditionFieldAC;
    if (searchText.toUpperCase().contains("ADUSER")) {
        AdConditionFieldAC = new AdUserConditionFieldAutoCompleter();
    } else {
        AdConditionFieldAC = new AdGroupConditionFieldAutoCompleter();
    }
    IAutoCompleter conditionRelationAC;
    char[] searchCharArr = searchText.toCharArray();
    boolean betweenDoubleQuotes = false;
    int curStartPos = 0;
    String curConditionField = "";
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        SyntaxObjectType curState = retval.getState();
        char curChar = searchCharArr[idx];
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        // ERROR INVALID-SEARCH OBJECT
                        retval.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return retval;
                    }
                } else {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    retval.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    retval.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            case COLON:
            case CONDITION_VALUE:
                if (AdConditionFieldAC.validate(nextObject)) {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curConditionField = nextObject;
                    curStartPos = idx + 1;
                } else if (// &&
                !AdConditionFieldAC.validateCompletion(nextObject)) // (!mSortbyAC.validateCompletion(nextObject)))
                {
                    retval.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                    return retval;
                }
                retval.setvalid(false);
                break;
            case CONDITION_FIELD:
                conditionRelationAC = AdConditionFieldAC.getFieldRelationshipAutoCompleter(curConditionField);
                if (conditionRelationAC == null) {
                    retval.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return retval;
                }
                if (idx + 1 < searchCharArr.length) {
                    String tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (conditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!conditionRelationAC.validate(nextObject)) {
                    if (!conditionRelationAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                retval.setvalid(false);
                break;
            case CONDITION_RELATION:
                boolean addObjFlag = false;
                if (curChar == '"') {
                    betweenDoubleQuotes = (!betweenDoubleQuotes);
                    if (betweenDoubleQuotes) {
                        if (!mFirstDQRegexp.IsMatch(strRealObj)) {
                            retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx + 1);
                            return retval;
                        }
                    } else {
                        strRealObj = StringHelper.trim(strRealObj, new char[] { '\"' });
                        addObjFlag = true;
                    }
                }
                // searchObject and no space is predicted !!
                if (final2) {
                    if (((curChar == ' ') || (idx + 1 == searchCharArr.length)) && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                } else {
                    if ((curChar == ' ') && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                }
                if (addObjFlag) {
                    if (!AdConditionFieldAC.validateFieldValue(curConditionField, strRealObj)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx);
                        return retval;
                    } else {
                        retval.addSyntaxObject(SyntaxObjectType.CONDITION_VALUE, strRealObj, curStartPos, idx + 1);
                        curConditionField = "";
                    }
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            default:
                retval.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return retval;
        }
    }
    return retval;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String domain = getParameters().getDomain();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(domain);
    DirectoryUser user = directory.findUser(id);
    getQueryReturnValue().setReturnValue(user);
}
#method_after
@Override
protected void executeQueryCommand() {
    String directoryName = getParameters().getDomain();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    DirectoryUser user = directory.findUser(id);
    getQueryReturnValue().setReturnValue(user);
}
#end_block

#method_before
public void init() {
    if (!initialized) {
        log.info("Start initializing " + getClass().getSimpleName());
        int mRefreshRate = Config.<Integer>GetValue(ConfigValues.UserRefreshRate);
        jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "refreshAllUsers", new Class[] {}, new Object[] {}, 0, mRefreshRate, TimeUnit.SECONDS);
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#method_after
public void init() {
    if (!initialized) {
        log.info("Start initializing " + getClass().getSimpleName());
        int mRefreshRate = Config.<Integer>getValue(ConfigValues.UserRefreshRate);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "refreshAllUsers", new Class[] {}, new Object[] {}, 0, mRefreshRate, TimeUnit.SECONDS);
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshAllUsers")
private void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    // Classify the users by directory:
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        Directory key = DirectoryManager.getInstance().getDirectory(dbUser.getDomain());
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#method_after
@OnTimerMethodAnnotation("refreshAllUsers")
public void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    List<DbGroup> dbGroups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : dbGroups) {
        groupsMap.put(group.getExternalId(), group);
    }
    // Classify the users by directory. Note that the resulting map may have an entry with a null key, that
    // corresponds to the users whose directory has been removed from the configuration.
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        Directory key = DirectoryManager.getInstance().getDirectory(dbUser.getDomain());
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#end_block

#method_before
private List<DbUser> refreshUsers(List<DbUser> dbUsers, Directory directory) {
    // Find all the users in the directory using a batch operation to improve performance:
    List<ExternalId> ids = new ArrayList<>(dbUsers.size());
    for (DbUser dbUser : dbUsers) {
        ids.add(dbUser.getExternalId());
    }
    List<DirectoryUser> directoryUsers = directory.findUsers(ids);
    // Build a map of users indexed by directory id to simplify the next step where we want to find the directory
    // user corresponding to each database user:
    Map<ExternalId, DirectoryUser> index = new HashMap<>();
    for (DirectoryUser directoryUser : directoryUsers) {
        index.put(directoryUser.getId(), directoryUser);
    }
    // For each database user refresh it using the corresponding directory user and collect those users that need to
    // be updated:
    List<DbUser> refreshed = new ArrayList<>();
    for (DbUser dbUser : dbUsers) {
        DirectoryUser directoryUser = index.get(dbUser.getId());
        dbUser = refreshUser(dbUser, directoryUser);
        if (dbUser != null) {
            refreshed.add(dbUser);
        }
    }
    return refreshed;
}
#method_after
private List<DbUser> refreshUsers(List<DbUser> dbUsers, Directory directory) {
    // Find all the users in the directory using a batch operation to improve performance:
    List<ExternalId> ids = new ArrayList<>(dbUsers.size());
    for (DbUser dbUser : dbUsers) {
        ids.add(dbUser.getExternalId());
    }
    List<DirectoryUser> directoryUsers = null;
    if (directory != null) {
        directoryUsers = directory.findUsers(ids);
    } else {
        directoryUsers = Collections.emptyList();
    }
    // Build a map of users indexed by directory id to simplify the next step where we want to find the directory
    // user corresponding to each database user:
    Map<ExternalId, DirectoryUser> index = new HashMap<>();
    for (DirectoryUser directoryUser : directoryUsers) {
        index.put(directoryUser.getId(), directoryUser);
    }
    // For each database user refresh it using the corresponding directory user and collect those users that need to
    // be updated:
    List<DbUser> refreshed = new ArrayList<>();
    for (DbUser dbUser : dbUsers) {
        DirectoryUser directoryUser = index.get(dbUser.getExternalId());
        dbUser = refreshUser(dbUser, directoryUser);
        if (dbUser != null) {
            refreshed.add(dbUser);
        }
    }
    return refreshed;
}
#end_block

#method_before
private DbUser refreshUser(DbUser dbUser, DirectoryUser directoryUser) {
    // available (if it isn't marked already):
    if (directoryUser == null) {
        if (dbUser.getStatus() != 0) {
            log.warn("User \"{}\" will be marked as unvailable as it wasn't found in directory \"{}\".", directoryUser.getName(), directoryUser.getDirectory().getName());
            dbUser.setStatus(DirectoryEntryStatus.UNAVAILABLE.getValue());
            DbFacade.getInstance().getDbUserDao().update(dbUser);
        }
        return dbUser;
    }
    // This flag indicates if there are any differences and thus if the database update should actuall be performed:
    boolean update = false;
    // If the user was marked as not available in the database then mark it as available:
    if (dbUser.getStatus() == 0) {
        log.info("User \"{}\" will be marked as available as it was found in directory \"{}\".", directoryUser.getName(), directoryUser.getDirectory().getName());
        dbUser.setStatus(DirectoryEntryStatus.AVAILABLE.getValue());
        update = true;
    }
    // the flag that indicates that the database needs to be updated:
    if (!StringUtils.equals(dbUser.getFirstName(), directoryUser.getName())) {
        dbUser.setFirstName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLastName(), directoryUser.getLastName())) {
        dbUser.setLastName(directoryUser.getLastName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDomain(), directoryUser.getDirectory().getName())) {
        dbUser.setDomain(directoryUser.getDirectory().getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLoginName(), directoryUser.getName())) {
        dbUser.setLoginName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDepartment(), directoryUser.getDepartment())) {
        dbUser.setDepartment(directoryUser.getDepartment());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getRole(), directoryUser.getTitle())) {
        dbUser.setRole(directoryUser.getTitle());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getEmail(), directoryUser.getEmail())) {
        dbUser.setEmail(directoryUser.getEmail());
        update = true;
    }
    // Compare the new list of group names and identifiers:
    StringBuilder groupNamesBuffer = new StringBuilder();
    StringBuilder groupIdsBuffer = new StringBuilder();
    boolean first = true;
    for (DirectoryGroup directoryGruop : directoryUser.getGroups()) {
        if (!first) {
            groupNamesBuffer.append(',');
            groupIdsBuffer.append(',');
        }
        groupNamesBuffer.append(directoryGruop.getName());
        groupIdsBuffer.append(directoryGruop.getId());
    }
    String groupNames = groupNamesBuffer.toString();
    String groupIds = groupIdsBuffer.toString();
    if (!StringUtils.equals(dbUser.getGroupNames(), groupNames)) {
        dbUser.setGroupNames(groupNames);
        update = true;
    }
    if (!StringUtils.equals(dbUser.getGroupIds(), groupIds)) {
        dbUser.setGroupIds(groupIds);
        update = true;
    }
    return update ? dbUser : null;
}
#method_after
private DbUser refreshUser(DbUser dbUser, DirectoryUser directoryUser) {
    // if it isn't marked already:
    if (directoryUser == null) {
        if (dbUser.isActive()) {
            log.warnFormat("User \"{0}\" will be marked as not active as it wasn't found in the directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
            dbUser.setActive(false);
        }
        return dbUser;
    }
    // This flag indicates if there are any differences and thus if the database update should actually be
    // performed:
    boolean update = false;
    // If the user was marked as not active in the database then mark it as active:
    if (!dbUser.isActive()) {
        log.infoFormat("User \"{0}\" will be marked as active as it was found in directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
        dbUser.setActive(true);
        update = true;
    }
    // the flag that indicates that the database needs to be updated:
    if (!StringUtils.equals(dbUser.getFirstName(), directoryUser.getName())) {
        dbUser.setFirstName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLastName(), directoryUser.getLastName())) {
        dbUser.setLastName(directoryUser.getLastName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDomain(), directoryUser.getDirectory().getName())) {
        dbUser.setDomain(directoryUser.getDirectory().getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLoginName(), directoryUser.getName())) {
        dbUser.setLoginName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDepartment(), directoryUser.getDepartment())) {
        dbUser.setDepartment(directoryUser.getDepartment());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getRole(), directoryUser.getTitle())) {
        dbUser.setRole(directoryUser.getTitle());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getEmail(), directoryUser.getEmail())) {
        dbUser.setEmail(directoryUser.getEmail());
        update = true;
    }
    // Compare the new list of group names and identifiers:
    StringBuilder groupNamesBuffer = new StringBuilder();
    StringBuilder groupIdsBuffer = new StringBuilder();
    boolean first = true;
    for (DirectoryGroup directoryGroup : directoryUser.getGroups()) {
        DbGroup dbGroup = groupsMap.get(directoryGroup.getId());
        if (!first) {
            groupNamesBuffer.append(',');
            groupIdsBuffer.append(dbGroup.getId());
        }
        groupNamesBuffer.append(directoryGroup.getName());
        groupIdsBuffer.append(directoryGroup.getId());
        first = false;
    }
    String groupNames = groupNamesBuffer.toString();
    String groupIds = groupIdsBuffer.toString();
    if (!StringUtils.equals(dbUser.getGroupNames(), groupNames)) {
        dbUser.setGroupNames(groupNames);
        update = true;
    }
    if (!StringUtils.equals(dbUser.getGroupIds(), groupIds)) {
        dbUser.setGroupIds(groupIds);
        update = true;
    }
    return update ? dbUser : null;
}
#end_block

#method_before
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.UpdateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#method_after
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.updateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().Subtract(data.getDate());
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.CreateADSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.CreateBackendSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Config.<Integer>GetValue(ConfigValues.SearchResultsLimit) : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), searchObj.getSearchObjectStr(), new Date(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + status;
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && status == other.status && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && active == other.active && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#end_block

#method_before
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(GROUP_NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    verifyLinks(model);
}
#method_after
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(GROUP_NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    verifyLinks(model);
}
#end_block

#method_before
@Override
protected void verifyModel(Group model, int index) {
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#method_after
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Get the name of the internal domain:
    String internal = Config.<String>GetValue(ConfigValues.AdminDomain);
    // Get the list of authentication profile names:
    List<AuthenticationProfile> profiles = AuthenticationProfileManager.getInstance().getProfiles();
    List<String> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(profile.getName());
    }
    if (getParameters().getFilterInternalDomain()) {
        names.remove(internal);
    }
    // Sort it so that the internal profile is always the last:
    sort(names, new LoginDomainComparator(internal));
    // Return the sorted list:
    getQueryReturnValue().setReturnValue(names);
}
#method_after
@Override
protected void executeQueryCommand() {
    // Get the name of the internal domain:
    String internal = Config.<String>getValue(ConfigValues.AdminDomain);
    // Get the list of authentication profile names:
    List<AuthenticationProfile> profiles = AuthenticationProfileManager.getInstance().getProfiles();
    List<String> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(profile.getName());
    }
    if (getParameters().getFilterInternalDomain()) {
        names.remove(internal);
    }
    // Sort it so that the internal profile is always the last:
    sort(names, new LoginDomainComparator(internal));
    // Return the sorted list:
    getQueryReturnValue().setReturnValue(names);
}
#end_block

#method_before
@Override
protected void verifyModel(User model, int index) {
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
}
#method_after
@Override
protected void verifyModel(User model, int index) {
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
}
#end_block

#method_before
@Before
public void setUp() {
    initMocks(this);
    doReturn(DIRECTORY).when(authenticatorMock).getName();
    AuthenticatorManager.getInstance().registerAuthenticator(authenticatorMock);
    doReturn(DIRECTORY).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(directoryMock);
    doReturn(DIRECTORY).when(profileMock).getName();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    doReturn(directoryMock).when(profileMock).getDirectory();
    AuthenticationProfileManager.getInstance().registerProfile(profileMock);
}
#method_after
@Before
public void setUp() {
    initMocks(this);
    AuthenticatorManager.getInstance().registerAuthenticator(NAME, authenticatorMock);
    doReturn(NAME).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(NAME, directoryMock);
    doReturn(NAME).when(profileMock).getName();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    doReturn(directoryMock).when(profileMock).getDirectory();
    AuthenticationProfileManager.getInstance().registerProfile(NAME, profileMock);
}
#end_block

#method_before
protected DirectoryGroup getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        DbGroup dbGroup = DbFacade.getInstance().getDbGroupDao().get(getGroupId());
        Directory directory = DirectoryManager.getInstance().getDirectory(dbGroup.getDomain());
        // XXX: Should check for null directory.
        mGroup = directory.findGroup(dbGroup.getExternalId());
    }
    return mGroup;
}
#method_after
protected DirectoryGroup getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        DbGroup dbGroup = DbFacade.getInstance().getDbGroupDao().get(getGroupId());
        Directory directory = DirectoryManager.getInstance().getDirectory(dbGroup.getDomain());
        mGroup = directory.findGroup(dbGroup.getExternalId());
    }
    return mGroup;
}
#end_block

#method_before
private Principal setUpLoginExpectations(boolean canDo, boolean success) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    expect(backend.Login((LoginUserParameters) eqActionParams(LoginUserParameters.class, new String[] { "LoginName", "Password", "ProfileName", "ActionType", "SessionId" }, new Object[] { USER, SECRET, DOMAIN, VdcActionType.LoginUser, session.getSessionId() }))).andReturn(result);
    expect(result.getCanDoAction()).andReturn(canDo);
    expect(result.getSucceeded()).andReturn(success).anyTimes();
    DbUser user = control.createMock(DbUser.class);
    if (canDo && success) {
        expect(result.getActionReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.RunPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#method_after
private Principal setUpLoginExpectations(boolean canDo, boolean success) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    expect(backend.login((LoginUserParameters) eqActionParams(LoginUserParameters.class, new String[] { "LoginName", "Password", "ProfileName", "ActionType", "SessionId" }, new Object[] { USER, SECRET, DOMAIN, VdcActionType.LoginUser, session.getSessionId() }))).andReturn(result);
    expect(result.getCanDoAction()).andReturn(canDo);
    expect(result.getSucceeded()).andReturn(success).anyTimes();
    DbUser user = control.createMock(DbUser.class);
    if (canDo && success) {
        expect(result.getActionReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#end_block

#method_before
private Principal setUpValidateSession(boolean success) {
    VdcQueryReturnValue queryReturnValue = control.createMock(VdcQueryReturnValue.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    DbUser user = control.createMock(DbUser.class);
    expect(backend.RunPublicQuery(eq(VdcQueryType.ValidateSession), eqQueryParams(VdcQueryParametersBase.class, new String[] { "SessionId" }, new Object[] { sessionId }))).andReturn(queryReturnValue);
    expect(queryReturnValue.getSucceeded()).andReturn(success).anyTimes();
    if (success) {
        expect(queryReturnValue.getReturnValue()).andReturn(user);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#method_after
private Principal setUpValidateSession(boolean success) {
    VdcQueryReturnValue queryReturnValue = control.createMock(VdcQueryReturnValue.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    DbUser user = control.createMock(DbUser.class);
    expect(backend.runPublicQuery(eq(VdcQueryType.ValidateSession), eqQueryParams(VdcQueryParametersBase.class, new String[] { "SessionId" }, new Object[] { sessionId }))).andReturn(queryReturnValue);
    expect(queryReturnValue.getSucceeded()).andReturn(success).anyTimes();
    if (success) {
        expect(queryReturnValue.getReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#end_block

#method_before
private ServerResponse setUpLogoutExpectations() {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    DbUser user = control.createMock(DbUser.class);
    expect(current.get(DbUser.class)).andReturn(user);
    expect(user.getId()).andReturn(GUID);
    expect(backend.Logoff((LogoutUserParameters) eqActionParams(LogoutUserParameters.class, new String[] { "UserId", "SessionId" }, new Object[] { GUID, session.getSessionId() }))).andReturn(result);
    ServerResponse response = control.createMock(ServerResponse.class);
    control.replay();
    return response;
}
#method_after
private ServerResponse setUpLogoutExpectations() {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    DbUser user = control.createMock(DbUser.class);
    expect(current.get(DbUser.class)).andReturn(user);
    expect(user.getId()).andReturn(GUID);
    expect(backend.logoff((LogoutUserParameters) eqActionParams(LogoutUserParameters.class, new String[] { "UserId", "SessionId" }, new Object[] { GUID, session.getSessionId() }))).andReturn(result);
    ServerResponse response = control.createMock(ServerResponse.class);
    control.replay();
    return response;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    // The identifier of the owner of the permission can come from the
    // parameters directly or from the user/group objects:
    Guid ownerId = parameters.getPermission().getad_element_id();
    if (ownerId == null) {
        if (user != null) {
            ownerId = user.getId();
        }
        if (ownerId == null) {
            if (group != null) {
                ownerId = group.getId();
            }
        }
    }
    final permissions paramPermission = parameters.getPermission();
    permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), ownerId, paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        paramPermission.setad_element_id(ownerId);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    // The identifier of the owner of the permission can come from the parameters directly or from the user/group
    // objects:
    Guid ownerId = parameters.getPermission().getad_element_id();
    if (ownerId == null) {
        if (user != null) {
            ownerId = user.getId();
        }
        if (ownerId == null) {
            if (group != null) {
                ownerId = group.getId();
            }
        }
    }
    final Permissions paramPermission = parameters.getPermission();
    Permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), ownerId, paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        paramPermission.setad_element_id(ownerId);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateAdminStatus(permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#method_after
private void updateAdminStatus(Permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getSessionId());
    return getBackend().RunQuery(search, searchParameters);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getSessionId());
    return getBackend().runQuery(search, searchParameters);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunPublicQuery invoked! " + queryType);
    debugQuery(queryType, params);
    return getBackend().RunPublicQuery(queryType, params);
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: runPublicQuery invoked! " + queryType);
    debugQuery(queryType, params);
    return getBackend().runPublicQuery(queryType, params);
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllCanDoPass) {
    // $NON-NLS-1$ //$NON-NLS-2$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: " + multipleParams.size() + "]");
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getSessionId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().RunMultipleActions(actionType, multipleParams, isRunOnlyIfAllCanDoPass);
    return returnValues;
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllCanDoPass) {
    // $NON-NLS-1$ //$NON-NLS-2$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: " + multipleParams.size() + "]");
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getSessionId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllCanDoPass);
    return returnValues;
}
#end_block

#method_before
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getSessionId());
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().RunAction(actionType, params);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getSessionId());
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().runAction(actionType, params);
}
#end_block

#method_before
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().Logoff(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().logoff(params);
    return returnValue;
}
#end_block

#method_before
@Override
public VdcReturnValueBase Login(String userName, String password, String domain) {
    LoginUserParameters params = new LoginUserParameters(domain, userName, password);
    params.setSessionId(getSessionId());
    params.setActionType(VdcActionType.LoginAdminUser);
    VdcReturnValueBase returnValue = getBackend().Login(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    params.setSessionId(getSessionId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    return returnValue;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, Guid id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().get(id);
    if (dbUser == null) {
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(sessionId, domain, id)).getReturnValue();
        if (adUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(adUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#method_after
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, Guid id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().get(id);
    if (dbUser == null) {
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(sessionId, domain, id)).getReturnValue();
        if (adUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(adUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    directoryGroup = (LdapGroup) LdapFactory.getInstance(directory).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getname());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    directoryGroup = (LdapGroup) LdapFactory.getInstance(directory).runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getname());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the identifier of the user to be removed from the parameters:
    Guid id = getParameters().getId();
    // Delete all the permissions of the user:
    for (permissions permission : DbFacade.getInstance().getPermissionDao().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters(permission);
        tempVar.setShouldBeLogged(false);
        Backend.getInstance().runInternalAction(VdcActionType.RemovePermission, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Delete the user itself:
    getDbUserDAO().remove(id);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the identifier of the user to be removed from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permissions permission : DbFacade.getInstance().getPermissionDao().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters(permission);
        tempVar.setShouldBeLogged(false);
        Backend.getInstance().runInternalAction(VdcActionType.RemovePermission, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Delete the user itself:
    getDbUserDAO().remove(id);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Get the identifier of the user to be removed from the parameters:
    Guid id = getParameters().getId();
    // Check that we are not trying to remove the builting admin user:
    if (PredefinedUsers.ADMIN_USER.getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_ADMIN_USER);
        return false;
    }
    // Check that the current user isn't trying to remove himself:
    if (getCurrentUser().getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_HIMSELF);
        return false;
    }
    // Check that the user exists in the database:
    DbUser dbUser = getDbUserDAO().get(id);
    if (dbUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Get the identifier of the user to be removed:
    Guid id = getParameters().getId();
    // Check that we are not trying to remove the built-in admin user:
    if (PredefinedUsers.ADMIN_USER.getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_ADMIN_USER);
        return false;
    }
    // Check that the current user isn't trying to remove himself:
    if (getCurrentUser().getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_HIMSELF);
        return false;
    }
    // Check that the user exists in the database:
    DbUser dbUser = getDbUserDAO().get(id);
    if (dbUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
        return false;
    }
    return true;
}
#end_block

#method_before
private void getAttachedTagsToSelectedUsers(TagListModel model) {
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<org.ovirt.engine.core.common.businessentities.tags>();
    selectedItemsCounter = 0;
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (!user.isGroup()) {
            userIds.add(user.getId());
        } else {
            grpIds.add(user.getId());
        }
    }
    for (Guid userId : userIds) {
        AsyncDataProvider.getAttachedTagsToUser(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), userId);
    }
    for (Guid grpId : grpIds) {
        AsyncDataProvider.getAttachedTagsToUserGroup(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), grpId);
    }
}
#method_after
private void getAttachedTagsToSelectedUsers(TagListModel model) {
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (!user.isGroup()) {
            userIds.add(user.getId());
        } else {
            grpIds.add(user.getId());
        }
    }
    for (Guid userId : userIds) {
        AsyncDataProvider.getAttachedTagsToUser(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), userId);
    }
    for (Guid grpId : grpIds) {
        AsyncDataProvider.getAttachedTagsToUserGroup(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), grpId);
    }
}
#end_block

#method_before
private void postGetAttachedTags(UserListModel userListModel, TagListModel tagListModel) {
    if (userListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<org.ovirt.engine.core.common.businessentities.tags> attachedTags = Linq.distinct(userListModel.allAttachedTags, new TagsEqualityComparer());
        for (org.ovirt.engine.core.common.businessentities.tags a : attachedTags) {
            int count = 0;
            for (org.ovirt.engine.core.common.businessentities.tags b : allAttachedTags) {
                if (b.gettag_id().equals(a.gettag_id())) {
                    count++;
                }
            }
            userListModel.attachedTagsToEntities.put(a.gettag_id(), count == userListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(userListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(userListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        userListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(UserListModel userListModel, TagListModel tagListModel) {
    if (userListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(userListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags a : attachedTags) {
            int count = 0;
            for (Tags b : allAttachedTags) {
                if (b.gettag_id().equals(a.gettag_id())) {
                    count++;
                }
            }
            userListModel.attachedTagsToEntities.put(a.gettag_id(), count == userListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(userListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(userListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        userListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_user");
    model.setMessage(ConstantsManager.getInstance().getConstants().usersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (DbUser item : Linq.<DbUser>cast(getSelectedItems())) {
        list.add(item.getFirstName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_user");
    ArrayList<String> list = new ArrayList<String>();
    for (DbUser item : Linq.<DbUser>cast(getSelectedItems())) {
        list.add(item.getFirstName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser);
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getId());
        parametersList.add(parameters);
        callbacksList.add(null);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    if (callbacksList.size() > 0) {
        callbacksList.set(callbacksList.size() - 1, lastCallback);
    }
    Frontend.RunMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#method_after
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getId());
        parametersList.add(parameters);
        callbacksList.add(null);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    if (callbacksList.size() > 0) {
        callbacksList.set(callbacksList.size() - 1, lastCallback);
    }
    Frontend.getInstance().runMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#end_block

#method_before
public void onRemove() {
    ArrayList<DbUser> items = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    if (userPrms.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.RemoveUser, userPrms);
    }
    if (groupPrms.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.RemoveGroup, groupPrms);
    }
    cancel();
}
#method_after
public void onRemove() {
    ArrayList<DbUser> items = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    if (userPrms.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveUser, userPrms);
    }
    if (groupPrms.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGroup, groupPrms);
    }
    cancel();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Get the name of the directory and the identifier of the user from
    // the parameters:
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    // Check that the user is available in the directory (and save the
    // reference to avoid looking it up later when actually adding the
    // user to the database):
    directoryUser = (LdapUser) LdapFactory.getInstance(directory).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getUserName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Get the name of the directory and the identifier of the user from the parameters:
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = (LdapUser) LdapFactory.getInstance(directory).runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getUserName());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we
    // need to update, if not we need to insert:
    DbUser dbUser = dao.get(directoryUser.getUserId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.get(directoryUser.getUserId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // Remove the permissions of the group:
    for (permissions permission : getPermissionDAO().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.RemovePermission, param, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Remove the group itself:
    getAdGroupDAO().remove(getAdGroup().getid());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permissions permission : getPermissionDAO().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.RemovePermission, param, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Remove the group itself:
    getAdGroupDAO().remove(getAdGroup().getid());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String domain = getDomain(group);
    LdapGroup directoryGroup = getEntity(LdapGroup.class, SearchType.AdGroup, getDirectoryGroupSearchPattern(group.getName(), domain));
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in domain " + domain).build();
    }
    DirectoryIdParameters addGroup = new DirectoryIdParameters();
    addGroup.setDirectory(directoryGroup.getdomain());
    addGroup.setId(directoryGroup.getid());
    return performCreate(VdcActionType.AddGroup, addGroup, new GroupIdResolver(directoryGroup.getid()), BaseResource.class);
}
#method_after
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getDirectoryName(group);
    LdapGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    DirectoryIdParameters addGroup = new DirectoryIdParameters();
    addGroup.setDirectory(directoryName);
    addGroup.setId(directoryGroup.getid());
    return performCreate(VdcActionType.AddGroup, addGroup, new GroupIdResolver(directoryGroup.getid()), BaseResource.class);
}
#end_block

#method_before
@Override
public void init(FilterConfig filterConfig) throws ServletException {
// Nothing.
}
#method_after
@Override
public void init(FilterConfig filterConfig) throws ServletException {
}
#end_block

#method_before
@Override
public void destroy() {
// Nothing.
}
#method_after
@Override
public void destroy() {
}
#end_block

#method_before
private void doFilter(HttpServletRequest req, HttpServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    // In order to perform the automatic login the principal needs to be populated, if it isn't then we just forward
    // the request to the next filter:
    Principal principal = req.getUserPrincipal();
    if (principal == null) {
        chain.doFilter(req, rsp);
        return;
    }
    // If the user is already logged in then this filter doesn't need to do anything else:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(req.getSession().getId(), false);
    if (dbUser != null) {
        chain.doFilter(req, rsp);
        return;
    }
    // Extract the login name and the authentication profile name from the principal:
    String principalName = principal.getName();
    int index = principalName.lastIndexOf('@');
    if (index == -1) {
        log.error("Can't login user because the principal name \"{}\" doesn't contain the name of the authentication " + "profile.", principalName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    String loginName = principalName.substring(0, index);
    String profileName = principalName.substring(index + 1);
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.error("Can't login user \"{}\" because authentication profile \"{}\" doesn't exist.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUserDAO dbUserDao = DbFacade.getInstance().getDbUserDao();
    dbUser = dbUserDao.getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dbUserDao.save(dbUser);
    }
    // Check if the user has permission to log in:
    PermissionDAO permissionDao = DbFacade.getInstance().getPermissionDao();
    Guid permissionId = permissionDao.getEntityPermissionsForUserAndGroups(dbUser.getId(), dbUser.getGroupIds(), VdcActionType.LoginUser.getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true);
    if (permissionId == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't have the " + "required permission.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Retrieve the MLA admin status of the user, this may be redundant in some use-cases, but looking forward to
    // single sign on we will want this informatin:
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    dbUser.setAdmin(isAdmin);
    // Attach the user to the session:
    SessionDataContainer.getInstance().setUser(req.getSession().getId(), dbUser);
    // Forward the request to the next filter in the chain:
    chain.doFilter(req, rsp);
}
#method_after
private void doFilter(HttpServletRequest req, HttpServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    // In order to perform the automatic login the principal needs to be populated, if it isn't then we just forward
    // the request to the next filter:
    Principal principal = req.getUserPrincipal();
    if (principal == null) {
        chain.doFilter(req, rsp);
        return;
    }
    // If the user is already logged in then this filter doesn't need to do anything else:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(req.getSession().getId(), false);
    if (dbUser != null) {
        chain.doFilter(req, rsp);
        return;
    }
    // Extract the login name and the authentication profile name from the principal:
    String principalName = principal.getName();
    int index = principalName.lastIndexOf('@');
    if (index == -1) {
        log.error("Can't login user because the principal name \"{}\" doesn't contain the name of the authentication " + "profile.", principalName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    String loginName = principalName.substring(0, index);
    String profileName = principalName.substring(index + 1);
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.error("Can't login user \"{}\" because authentication profile \"{}\" doesn't exist.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    if (directory == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the directory doesn't exist.", profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUserDAO dbUserDao = DbFacade.getInstance().getDbUserDao();
    dbUser = dbUserDao.getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dbUserDao.save(dbUser);
    }
    // Check if the user has permission to log in:
    PermissionDAO permissionDao = DbFacade.getInstance().getPermissionDao();
    Guid permissionId = permissionDao.getEntityPermissionsForUserAndGroups(dbUser.getId(), dbUser.getGroupIds(), VdcActionType.LoginUser.getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true);
    if (permissionId == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't have the " + "required permission.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Retrieve the MLA admin status of the user, this may be redundant in some use-cases, but looking forward to
    // single sign on we will want this information:
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    dbUser.setAdmin(isAdmin);
    // Attach the user to the session:
    SessionDataContainer.getInstance().setUser(req.getSession().getId(), dbUser);
    // Forward the request to the next filter in the chain:
    chain.doFilter(req, rsp);
}
#end_block

#method_before
@Override
public Directory create(File file, Configuration config) {
    // Get the name of the directory:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        log.error("The configuration file \"{}\" doesn't contain the name of the directory.", file.getAbsolutePath());
        return null;
    }
    // We are good, create the directory:
    return new InternalDirectory(name);
}
#method_after
@Override
public Directory create(Configuration config) throws ConfigurationException {
    // Get the name of the directory:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        throw new ConfigurationException("The configuration file \"" + config.getFile().getAbsolutePath() + "\" doesn't contain the name of " + "the directory.");
    }
    // We are good, create the directory:
    return new InternalDirectory(name);
}
#end_block

#method_before
@Override
public boolean authenticate(String name, char[] password) {
    String adminName = Config.<String>GetValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>GetValue(ConfigValues.AdminPassword);
    return ObjectUtils.equals(name, adminName) && Arrays.equals(password, adminPassword.toCharArray());
}
#method_after
@Override
public AuthenticationResult<?> authenticate(String user, String password) {
    String adminName = Config.<String>getValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword);
    return new BooleanAuthenticationResult(ObjectUtils.equals(user, adminName) && ObjectUtils.equals(password, adminPassword));
}
#end_block

#method_before
@Override
public Authenticator create(File file, Configuration config) {
    // Get the name of the authenticator:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        log.error("The configuration file \"{}\" doesn't contain the name of the authenticator.", file.getAbsolutePath());
        return null;
    }
    // We are good, create the authenticator:
    return new InternalAuthenticator(name);
}
#method_after
@Override
public Authenticator create(Configuration config) throws ConfigurationException {
    return new InternalAuthenticator();
}
#end_block

#method_before
@Override
public boolean authenticate(String name, String password) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(domain, name, password));
    UserAuthenticationResult authResult = (UserAuthenticationResult) ldapResult.getReturnValue();
    return authResult.isSuccessful();
}
#method_after
@Override
public AuthenticationResult<?> authenticate(String name, String password) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(domain, name, password));
    UserAuthenticationResult authResult = (UserAuthenticationResult) ldapResult.getReturnValue();
    return new ProvisionalAuthenticationResult(authResult);
}
#end_block

#method_before
@Override
public DirectoryUser findUser(String name) {
    // Find the user with the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserName, new LdapSearchByUserNameParameters(null, domain, name + "@" + domain));
    LdapUser ldapUser = (LdapUser) ldapResult.getReturnValue();
    // Map the user:
    return mapUser(ldapUser);
}
#method_after
@Override
public DirectoryUser findUser(String name) {
    // Find the user with the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserName, new LdapSearchByUserNameParameters(null, domain, name));
    LdapUser ldapUser = (LdapUser) ldapResult.getReturnValue();
    if (ldapUser == null) {
        return null;
    }
    // Map the user:
    return mapUser(ldapUser);
}
#end_block

#method_before
public static Object populate(Object model, Class<?> clz, List<Class<?>> seen, int level) throws Exception {
    for (Method method : clz.getMethods()) {
        if (isSetter(method)) {
            if (takesPrimitive(method)) {
                random(method, model);
            } else if (takesEnum(method)) {
                shuffle(method, model);
            } else if (takesBigDecimal(method)) {
                populateBigDecimal(method, model);
            } else if (takesXmlGregorianCalendar(method)) {
                populateXmlGregorianCalendar(method, model);
            } else if (takesBytes(method)) {
                populateBytes(method, model);
            } else {
                descend(method, model, scope(seen), level);
            }
        } else if (isGetter(method) && returnsList(method)) {
            fill(method, model, seen, level);
        }
    }
    return model;
}
#method_after
public static Object populate(Object model, Class<?> clz, List<Class<?>> seen, int level) throws Exception {
    for (Method method : clz.getMethods()) {
        if (isSetter(method)) {
            if (takesPrimitive(method)) {
                random(method, model);
            } else if (takesEnum(method)) {
                shuffle(method, model);
            } else if (takesBigDecimal(method)) {
                populateBigDecimal(method, model);
            } else if (takesXmlGregorianCalendar(method)) {
                populateXmlGregorianCalendar(method, model);
            } else {
                descend(method, model, scope(seen), level);
            }
        } else if (isGetter(method) && returnsList(method)) {
            fill(method, model, seen, level);
        }
    }
    return model;
}
#end_block

#method_before
@Test
public void testAddGroupWithExplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddDirectoryGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    Group model = new Group();
    model.setName(NAMES[0]);
    model.setDomain(domain);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupWithExplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    Group model = new Group();
    model.setName(NAMES[0]);
    model.setDomain(domain);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testAddGroupWithImplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + GROUP_NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddDirectoryGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupWithImplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + GROUP_NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().toString());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = LdapUser.class, to = User.class)
public static User map(LdapUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getUserId().toByteArray());
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (String name : entity.getGroups().keySet()) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapUser.class, to = User.class)
public static User map(LdapUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (String name : entity.getGroups().keySet()) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().toString());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = LdapGroup.class, to = Group.class)
public static Group map(LdapGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getid().toByteArray());
    model.setName(entity.getname());
    model.setId(entity.getid().toString());
    if (!StringUtils.isEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapGroup.class, to = Group.class)
public static Group map(LdapGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getname());
    model.setId(entity.getid().toString());
    if (!StringUtils.isEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Before
public void setUp() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(0, Version.v3_0)).thenReturn(0);
    when(osRepository.getMinimumRam(0, null)).thenReturn(0);
    when(osRepository.getMaximumRam(0, Version.v3_0)).thenReturn(256);
    when(osRepository.getMaximumRam(0, null)).thenReturn(256);
    when(osRepository.isWindows(0)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(0)).thenReturn(ArchitectureType.x86_64);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(Version.v3_0);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#end_block

#method_before
@Override
protected void beforeUiCommonInitEvent(LoginModel loginModel) {
    CommonModelManager.init(eventBus, user, loginModel, frontendFailureEventListener);
}
#method_after
@Override
protected void beforeUiCommonInitEvent(LoginModel loginModel) {
    CommonModelManager.init(eventBus);
}
#end_block

#method_before
@Override
public void onLogout() {
    // Logout operation happens within the CommonModel SignOut event handler
    CommonModelManager.instance().signOut();
    AsyncDataProvider.clearCache();
}
#method_after
@Override
public void onLogout() {
    // Logout operation happens within the CommonModel SignOut event handler
    CommonModelManager.instance().signOut();
    performLogout();
}
#end_block

#method_before
@Override
protected void initFrontend() {
    super.initFrontend();
    // Configure REST API integration for UI plugin infrastructure
    Frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#method_after
@Override
protected void initFrontend() {
    super.initFrontend();
    // Configure REST API integration for UI plugin infrastructure
    frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(request.getSession().getId());
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout();
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    super.doGet(request, response);
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(request.getSession().getId());
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(request.getSession().getId());
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    super.doGet(request, response);
}
#end_block

#method_before
protected Integer getEngineSessionTimeout() {
    // TODO retrieve actual config value
    return 30;
}
#method_after
protected Integer getEngineSessionTimeout(String sessionId) {
    return (Integer) runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserSessionTimeOutInterval, ConfigCommon.defaultConfigurationVersion), sessionId);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        // is this a physical nic?
        boolean isPhysicalInterface = vlanId == null;
        if (isPhysicalInterface) {
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                NetworkLabelModel labelModel = labelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    Set<LogicalNetworkModel> nicNetworks = nicToNetwork.get(ifName);
                    if (nicNetworks == null) {
                        nicNetworks = new HashSet<LogicalNetworkModel>();
                        nicToNetwork.put(nicName, nicNetworks);
                    }
                    for (LogicalNetworkModel networkModel : labelModel.getNetworks()) {
                        nicNetworks.add(networkModel);
                        networkModel.attachViaLabel();
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                NetworkLabelModel labelModel = labelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (LogicalNetworkModel networkModel : labelModel.getNetworks()) {
                        nicToNetwork.get(ifName).add(networkModel);
                        networkModel.attachViaLabel();
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, List<LogicalNetworkModel>> nicToNetwork = new HashMap<String, List<LogicalNetworkModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        // is this a physical nic?
        boolean isPhysicalInterface = vlanId == null;
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        if (isPhysicalInterface) {
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new ArrayList<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        List<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, List<LogicalNetworkModel>> nicToNetwork = new HashMap<String, List<LogicalNetworkModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new ArrayList<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        List<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
public Response performRemove(String id) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = lookupNetwork(asGuidOr404(id));
    if (entity == null) {
        notFound();
        return null;
    }
    return performAction(removeAction, getActionParameters(null, entity, true));
}
#method_after
@Override
public Response performRemove(String id) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = lookupNetwork(asGuidOr404(id));
    if (entity == null) {
        notFound();
        return null;
    }
    return performAction(removeAction, getRemoveParameters(entity));
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, "id|name");
    String networkName = null;
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getNetworks(clusterId);
    if (network.isSetId()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkById(network.getId(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkName = net.getName();
        }
    }
    String networkId = null;
    if (network.isSetName()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkByName(network.getName(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkId = net.getId().toString();
        }
    }
    if (!network.isSetId()) {
        network.setId(networkId);
    } else if (network.isSetName() && !network.getId().equals(networkId)) {
        badRequest("Network ID provided does not match the ID for network with name: " + network.getName());
    }
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    return performCreate(addAction, getActionParameters(network, entity), new NetworkIdResolver(StringUtils.defaultIfEmpty(network.getName(), networkName)));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, "id|name");
    String networkName = null;
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getNetworks(clusterId);
    if (network.isSetId()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkById(network.getId(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkName = net.getName();
        }
    }
    String networkId = null;
    if (network.isSetName()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkByName(network.getName(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkId = net.getId().toString();
        }
    }
    if (!network.isSetId()) {
        network.setId(networkId);
    } else if (network.isSetName() && !network.getId().equals(networkId)) {
        badRequest("Network ID provided does not match the ID for network with name: " + network.getName());
    }
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    return performCreate(addAction, getAddParameters(network, entity), new NetworkIdResolver(StringUtils.defaultIfEmpty(network.getName(), networkName)));
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = (AddNetworkStoragePoolParameters) getActionParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getAddParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    DataCenter dataCenter = new DataCenter();
    dataCenter.setId(dataCenterId.toString());
    network.setDataCenter(dataCenter);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = (AddNetworkStoragePoolParameters) getActionParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    DataCenter dataCenter = new DataCenter();
    dataCenter.setId(dataCenterId.toString());
    network.setDataCenter(dataCenter);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getAddParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(AffinityGroup entity) {
    return createIdParameterMapper(entity.getId()).addValue("name", entity.getName()).addValue("description", entity.getDescription()).addValue("cluster_id", entity.getClusterId()).addValue("polarity", entity.getPolarity()).addValue("enforcement_type", entity.getEnforcementType()).addValue("vm_ids", entity.getVmIds() == null ? StringUtils.EMPTY : StringUtils.join(entity.getVmIds(), SEPARATOR));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(AffinityGroup entity) {
    return createIdParameterMapper(entity.getId()).addValue("name", entity.getName()).addValue("description", entity.getDescription()).addValue("cluster_id", entity.getClusterId()).addValue("positive", entity.isPositive()).addValue("enforcing", entity.isEnforcing()).addValue("vm_ids", entity.getEntityIds() == null ? StringUtils.EMPTY : StringUtils.join(entity.getEntityIds(), SEPARATOR));
}
#end_block

#method_before
@Override
protected RowMapper<AffinityGroup> createEntityRowMapper() {
    return new RowMapper<AffinityGroup>() {

        @Override
        public AffinityGroup mapRow(ResultSet rs, int arg1) throws SQLException {
            AffinityGroup affinityGroup = new AffinityGroup();
            affinityGroup.setId(getGuid(rs, "id"));
            affinityGroup.setName(rs.getString("name"));
            affinityGroup.setDescription(rs.getString("description"));
            affinityGroup.setClusterId(getGuid(rs, "cluster_id"));
            affinityGroup.setPolarity(AffinityPolarity.forValue(rs.getInt("polarity")));
            affinityGroup.setEnforcementType(AffinityEnforcementType.forValue(rs.getInt("enforcement_type")));
            affinityGroup.setVmIds(GuidUtils.getGuidListFromString(rs.getString("vm_ids")));
            affinityGroup.setVmNames(split(rs.getString("vm_names")));
            return affinityGroup;
        }
    };
}
#method_after
@Override
protected RowMapper<AffinityGroup> createEntityRowMapper() {
    return AffinityGropupRowMapper.instance;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
    }
    return validateParameters();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
    }
    return validateParameters();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getAffinityGroup().setId(Guid.newGuid());
    getAffinityGroupDao().save(getAffinityGroup());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getAffinityGroup().setId(Guid.newGuid());
    getAffinityGroupDao().save(getAffinityGroup());
    getReturnValue().setActionReturnValue(getAffinityGroup().getId());
    setSucceeded(true);
}
#end_block

#method_before
public String getName() {
    return name;
}
#method_after
@Override
public String getName() {
    return name;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((enforcementType == null) ? 0 : enforcementType.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((polarity == null) ? 0 : polarity.hashCode());
    result = prime * result + ((vmIds == null) ? 0 : vmIds.hashCode());
    result = prime * result + ((vmNames == null) ? 0 : vmNames.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (enforcing ? 1231 : 1237);
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (positive ? 1231 : 1237);
    result = prime * result + ((entityIds == null) ? 0 : entityIds.hashCode());
    result = prime * result + ((entityNames == null) ? 0 : entityNames.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AffinityGroup other = (AffinityGroup) obj;
    if (clusterId == null) {
        if (other.clusterId != null)
            return false;
    } else if (!clusterId.equals(other.clusterId))
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (enforcementType != other.enforcementType)
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (polarity != other.polarity)
        return false;
    if (vmIds == null) {
        if (other.vmIds != null)
            return false;
    } else if (!vmIds.equals(other.vmIds))
        return false;
    if (vmNames == null) {
        if (other.vmNames != null)
            return false;
    } else if (!vmNames.equals(other.vmNames))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AffinityGroup other = (AffinityGroup) obj;
    if (clusterId == null) {
        if (other.clusterId != null)
            return false;
    } else if (!clusterId.equals(other.clusterId))
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (enforcing != other.enforcing)
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (positive != other.positive)
        return false;
    if (entityIds == null) {
        if (other.entityIds != null)
            return false;
    } else if (!entityIds.equals(other.entityIds))
        return false;
    if (entityNames == null) {
        if (other.entityNames != null)
            return false;
    } else if (!entityNames.equals(other.entityNames))
        return false;
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getAffinityGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_AFFINITY_GROUP_ID);
    }
    if (!getParameters().getAffinityGroup().getClusterId().equals(getClusterId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_CLUSTER_ID);
    }
    if (!getAffinityGroup().getName().equals(getParameters().getAffinityGroup().getName()) && getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
    }
    return validateParameters();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getAffinityGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_AFFINITY_GROUP_ID);
    }
    if (!getParameters().getAffinityGroup().getClusterId().equals(getClusterId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_CLUSTER_ID);
    }
    if (!getAffinityGroup().getName().equals(getParameters().getAffinityGroup().getName()) && getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
    }
    return validateParameters();
}
#end_block

#method_before
@Test
public void canDoAction_testNameChange_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(affinityGroup.getName());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
}
#method_after
@Test
public void canDoAction_testNameChange_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(affinityGroup.getName());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
}
#end_block

#method_before
@Test
public void canDoAction_vmNameExists_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(anyString());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
}
#method_after
@Test
public void canDoAction_vmNameExists_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(anyString());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
}
#end_block

#method_before
@Test
public void canDoAction_duplicateVm_Test() {
    affinityGroup.getVmIds().add(vmId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
}
#method_after
@Test
public void canDoAction_duplicateVm_Test() {
    affinityGroup.getEntityIds().add(vmId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
}
#end_block

#method_before
private AffinityGroup createAffinityGroup() {
    affinityGroup = new AffinityGroup();
    affinityGroup.setVmIds(new ArrayList<Guid>());
    affinityGroup.getVmIds().add(vmId);
    return affinityGroup;
}
#method_after
private AffinityGroup createAffinityGroup() {
    affinityGroup = new AffinityGroup();
    affinityGroup.setEntityIds(new ArrayList<Guid>());
    affinityGroup.getEntityIds().add(vmId);
    return affinityGroup;
}
#end_block

#method_before
protected boolean validateParameters() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CLUSTER_FOR_AFFINITY_GROUP);
    }
    if (getParameters().getAffinityGroup().getVmIds() != null) {
        VmStatic vmStatic = null;
        Set<Guid> vmSet = new HashSet<Guid>();
        for (Guid vmId : getParameters().getAffinityGroup().getVmIds()) {
            vmStatic = getVmStaticDAO().get(vmId);
            if (vmStatic == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VM_FOR_AFFINITY_GROUP);
            }
            if (!vmStatic.getVdsGroupId().equals(getVdsGroupId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_IN_AFFINITY_GROUP_CLUSTER);
            }
            if (vmSet.contains(vmStatic.getId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
            } else {
                vmSet.add(vmStatic.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean validateParameters() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CLUSTER_FOR_AFFINITY_GROUP);
    }
    if (getParameters().getAffinityGroup().getEntityIds() != null) {
        VmStatic vmStatic = null;
        Set<Guid> vmSet = new HashSet<Guid>();
        for (Guid vmId : getParameters().getAffinityGroup().getEntityIds()) {
            vmStatic = getVmStaticDAO().get(vmId);
            if (vmStatic == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VM_FOR_AFFINITY_GROUP);
            }
            if (!vmStatic.getVdsGroupId().equals(getVdsGroupId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_IN_AFFINITY_GROUP_CLUSTER);
            }
            if (vmSet.contains(vmStatic.getId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
            } else {
                vmSet.add(vmStatic.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
private void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<AffinityGroup> nameColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> descColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> polarityColumn = new EnumColumn<AffinityGroup, AffinityPolarity>() {

        @Override
        protected AffinityPolarity getRawValue(AffinityGroup object) {
            return object.getPolarity();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(polarityColumn, constants.polarityAffinityGroup(), "100px");
    TextColumnWithTooltip<AffinityGroup> enforceColumn = new EnumColumn<AffinityGroup, AffinityEnforcementType>() {

        @Override
        protected AffinityEnforcementType getRawValue(AffinityGroup object) {
            return object.getEnforcementType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(enforceColumn, constants.enforceAffinityGroup(), "100px");
    addMembersColumn(constants);
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.newAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.editAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.removeAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
private void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<AffinityGroup> nameColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> descColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionAffinityGroup(), "150px");
    BooleanColumn<AffinityGroup> polarityColumn = new BooleanColumn<AffinityGroup>(constants.positiveAffinity(), constants.negativeAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isPositive();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(polarityColumn, constants.polarityAffinityGroup(), "100px");
    BooleanColumn<AffinityGroup> enforceColumn = new BooleanColumn<AffinityGroup>(constants.hardEnforcingAffinity(), constants.softEnforcingAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isEnforcing();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(enforceColumn, constants.enforceAffinityGroup(), "100px");
    getTable().addColumn(new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            // $NON-NLS-1$
            String join = join(getEntityNames(object), ", ");
            if (join.isEmpty()) {
                return constants.noMembersAffinityGroup();
            }
            return join;
        }
    }, constants.membersAffinityGroup(), // $NON-NLS-1$
    "500px");
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.newAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.editAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.removeAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getParentEntity() != null) {
        super.syncSearch();
        AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                AffinityGroupListModel<?> affinityGroupListModel = (AffinityGroupListModel<?>) model;
                ArrayList<AffinityGroup> list = (ArrayList<AffinityGroup>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                affinityGroupListModel.setItems(list);
            }
        });
        VdcQueryParametersBase parameters = new IdQueryParameters(getParentEntity().getId());
        parameters.setRefresh(getIsQueryFirstTime());
        Frontend.getInstance().runQuery(getQueryType(), parameters, asyncQuery);
        setIsQueryFirstTime(false);
    }
}
#method_after
@Override
protected void syncSearch() {
    if (getParentEntity() != null) {
        super.syncSearch(queryType, new IdQueryParameters(getParentEntity().getId()));
    }
}
#end_block

#method_before
public void setNewCommand(UICommand newCommand) {
    this.newCommand = newCommand;
}
#method_after
private void setNewCommand(UICommand newCommand) {
    this.newCommand = newCommand;
}
#end_block

#method_before
public void setEditCommand(UICommand editCommand) {
    this.editCommand = editCommand;
}
#method_after
private void setEditCommand(UICommand editCommand) {
    this.editCommand = editCommand;
}
#end_block

#method_before
public void setRemoveCommand(UICommand removeCommand) {
    this.removeCommand = removeCommand;
}
#method_after
private void setRemoveCommand(UICommand removeCommand) {
    this.removeCommand = removeCommand;
}
#end_block

#method_before
public void setParentEntity(T parentEntity) {
    this.parentEntity = parentEntity;
}
#method_after
private void setParentEntity(T parentEntity) {
    this.parentEntity = parentEntity;
}
#end_block

#method_before
private void newEntity() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroupModel model = getNewAffinityGroupModel();
    model.init();
    setWindow(model);
}
#method_after
private void newEntity() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroupModel model = new NewAffinityGroupModel(getNewAffinityGroup(), this, getClusterId(), getClusterName());
    model.init();
    setWindow(model);
}
#end_block

#method_before
private void edit() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroup affinityGroup = getSelectedItem();
    if (affinityGroup == null) {
        return;
    }
    sortVms(affinityGroup);
    AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver());
    model.init();
    setWindow(model);
}
#method_after
private void edit() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroup affinityGroup = getSelectedItem();
    if (affinityGroup == null) {
        return;
    }
    AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterId(), getClusterName());
    model.init();
    setWindow(model);
}
#end_block

#method_before
public void setName(EntityModel<String> name) {
    this.name = name;
}
#method_after
private void setName(EntityModel<String> name) {
    this.name = name;
}
#end_block

#method_before
public void setDescription(EntityModel<String> description) {
    this.description = description;
}
#method_after
private void setDescription(EntityModel<String> description) {
    this.description = description;
}
#end_block

#method_before
public void setVmsSelectionModel(VmsSelectionModel vmsSelectionModel) {
    this.vmsSelectionModel = vmsSelectionModel;
}
#method_after
private void setVmsSelectionModel(VmsSelectionModel vmsSelectionModel) {
    this.vmsSelectionModel = vmsSelectionModel;
}
#end_block

#method_before
void onSave() {
    if (!validate()) {
        return;
    }
    if (getProgress() != null) {
        return;
    }
    AffinityGroup group = getAffinityGroup();
    group.setName(getName().getEntity());
    group.setDescription(getDescription().getEntity());
    group.setClusterId(clusterResolver.getClusterId());
    group.setEnforcementType(getEnforcementType().getSelectedItem());
    group.setPolarity(getPolarity().getSelectedItem());
    group.setEntityIds(getVmsSelectionModel().getSelectedVmIds());
    startProgress(null);
    Frontend.getInstance().runAction(getSaveActionType(), new AffinityGroupCRUDParameters(group.getId(), group), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            if (result != null && result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#method_after
void onSave() {
    if (!validate()) {
        return;
    }
    if (getProgress() != null) {
        return;
    }
    AffinityGroup group = getAffinityGroup();
    group.setName(getName().getEntity());
    group.setDescription(getDescription().getEntity());
    group.setClusterId(clusterId);
    group.setEnforcing(getEnforcing().getEntity());
    group.setPositive(getPositive().getEntity());
    group.setEntityIds(getVmsSelectionModel().getSelectedVmIds());
    startProgress(null);
    Frontend.getInstance().runAction(saveActionType, new AffinityGroupCRUDParameters(group.getId(), group), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            if (result != null && result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    setAffinityGroupListModel(new VmAffinityGroupListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(getAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateCache(value);
    super.setItems(value);
}
#method_after
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateVmCache(value);
    super.setItems(value);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVm(((VM) getSelectedItem()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setDefaultVncKeyboardLayout(vm.getDefaultVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setDefaultVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.PropertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider) {
    return new SearchableDetailTabModelProvider<Snapshot, VmListModel, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider, VmListModel.class, VmSnapshotListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider) {
    return new SearchableDetailTabModelProvider<Snapshot, VmListModel, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider, VmListModel.class, VmSnapshotListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
public void init(List<VM> vms, List<Guid> usedVms) {
    if (vms == null || usedVms == null) {
        return;
    }
    allVmMap = new HashMap<Guid, VM>();
    for (VM vm : vms) {
        allVmMap.put(vm.getId(), vm);
    }
    for (Guid guid : usedVms) {
        usedVmMap.put(guid, allVmMap.get(guid));
    }
    disableEvent = true;
    VmSelectionModel selectionModel;
    List<VmSelectionModel> list = new ArrayList<VmSelectionModel>();
    for (Entry<Guid, VM> entry : usedVmMap.entrySet()) {
        Pair<String, VM> pair = new Pair<String, VM>(entry.getValue().getName(), entry.getValue());
        selectionModel = createNewLineModel(pair);
        selectionModel.getVms().setSelectedItem(pair);
        list.add(selectionModel);
    }
    disableEvent = false;
    setItems(list);
}
#method_after
public void init(List<VM> vms, List<Guid> usedVms) {
    if (vms == null || usedVms == null) {
        return;
    }
    allVmNameMap = new HashMap<String, VM>();
    Map<Guid, VM> vmmMap = new HashMap<Guid, VM>();
    for (VM vm : vms) {
        allVmNameMap.put(vm.getName(), vm);
        vmmMap.put(vm.getId(), vm);
    }
    Set<String> usedVmNames = new HashSet<String>();
    for (Guid guid : usedVms) {
        usedVmNames.add(vmmMap.get(guid).getName());
    }
    init(allVmNameMap.keySet(), usedVmNames);
}
#end_block

#method_before
public VmSelectionModel createNewLineModel() {
    return createNewLineModel(null);
}
#method_after
@Override
public KeyValueLineModel createNewLineModel(String key) {
    KeyValueLineModel keyValueLineModel = super.createNewLineModel(key);
    keyValueLineModel.getValue().setIsAvailable(false);
    keyValueLineModel.getValues().setIsAvailable(false);
    return keyValueLineModel;
}
#end_block

#method_before
public List<Guid> getSelectedVmIds() {
    List<Guid> list = new ArrayList<Guid>();
    for (VmSelectionModel vmSelectionModel : getItems()) {
        Pair<String, VM> selectedItem = vmSelectionModel.getVms().getSelectedItem();
        if (isKeyValid(selectedItem)) {
            list.add(selectedItem.getSecond().getId());
        }
    }
    return list;
}
#method_after
public List<Guid> getSelectedVmIds() {
    List<Guid> list = new ArrayList<Guid>();
    for (KeyValueLineModel keyModel : getItems()) {
        String selectedItem = keyModel.getKeys().getSelectedItem();
        if (isKeyValid(selectedItem)) {
            list.add(allVmNameMap.get(selectedItem).getId());
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.affinityGroupNameLabel());
    descriptionEditor.setLabel(constants.affinityDescriptionLabel());
    polarityEditor.setLabel(constants.affinityGroupPolarityLabel());
    enforcementTypeEditor.setLabel(constants.affinityGroupEnforceTypeLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.affinityGroupNameLabel());
    descriptionEditor.setLabel(constants.affinityDescriptionLabel());
    positiveEditor.setLabel(constants.affinityGroupPolarityLabel());
    enforcingEditor.setLabel(constants.affinityGroupEnforceTypeLabel());
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(getDownHosts(allHosts, parameters), getMaintenanceHosts(allHosts, parameters), getEmptyHosts(allHosts, parameters), parameters);
    if (action != null)
        processPmAction(action);
    return migrationRule;
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    List<VDS> emptyHosts = new ArrayList<>();
    List<VDS> maintenanceHosts = new ArrayList<>();
    List<VDS> downHosts = new ArrayList<>();
    getHostLists(allHosts, parameters, emptyHosts, maintenanceHosts, downHosts);
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(cluster, downHosts, maintenanceHosts, emptyHosts, parameters);
    if (action != null) {
        processPmAction(action);
    }
    return migrationRule;
}
#end_block

#method_before
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        List<Guid> vdsList = new ArrayList<>(1);
        vdsList.add(vds.getId());
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(vdsList, true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start, true);
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
    /* Should not ever happen... */
    }
}
#method_after
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        Guid[] vdsList = new Guid[] { vds.getId() };
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(Arrays.asList(vdsList), true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Stop, true);
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
        /* Should not ever happen... */
        log.errorFormat("Unknown host power management transition {0} -> {1}", currentStatus.toString(), targetStatus.toString());
    }
}
#end_block

#method_before
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    final int enableAutoPM = tryParseWithDefault(parameters.get("EnableAutomaticHostPowerManagement"), Config.<Integer>getValue(ConfigValues.EnableAutomaticHostPowerManagement));
    /* Automatic power management is disabled */
    if (enableAutoPM == 0)
        return null;
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty())
        return null;
    else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        return hostsWithAutoPM.isEmpty() ? null : new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    return null;
}
#method_after
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(VDSGroup cluster, List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    String enableAutoPMParameter = parameters.get("EnableAutomaticHostPowerManagement");
    Boolean enableAutoPM = enableAutoPMParameter == null ? null : Boolean.valueOf(enableAutoPMParameter);
    if (enableAutoPM == null) {
        enableAutoPM = Config.<Boolean>getValue(ConfigValues.EnableAutomaticHostPowerManagement);
    }
    /* Automatic power management is disabled */
    if (!enableAutoPM.booleanValue()) {
        log.infoFormat("Automatic power management is disabled for cluster {0}.", cluster.getName());
        return null;
    }
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, but no additional host is available.", cluster.getName());
        return null;
    } else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        if (hostsWithAutoPM.isEmpty()) {
            log.infoFormat("Cluster {0} does have too many spare hosts, but none can be put to maintenance.", cluster.getName());
            return null;
        } else {
            return new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
        }
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, reactivating one.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, trying to start one up.", cluster.getName());
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    /* All power management constraints were satisfied, no need to do anything */
    return null;
}
#end_block

#method_before
public boolean getKeepPolicyPMEnabled() {
    return _keepPolicyPMEnabled;
}
#method_after
public boolean getKeepPolicyPMEnabled() {
    return keepPolicyPMEnabled;
}
#end_block

#method_before
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this._keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#method_after
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this.keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#end_block

#method_before
public boolean getKeepPolicyPMEnabled() {
    return _keepPolicyPMEnabled;
}
#method_after
public boolean getKeepPolicyPMEnabled() {
    return keepPolicyPMEnabled;
}
#end_block

#method_before
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this._keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#method_after
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this.keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#end_block

#method_before
private void MoveVdssToGoingToMaintenanceMode() {
    List<VDS> spms = new ArrayList<VDS>();
    for (VDS vds : vdssToMaintenance.values()) {
        if (vds.getSpmStatus() != VdsSpmStatus.SPM) {
            setVdsStatusToPrepareForMaintaice(vds);
        } else {
            spms.add(vds);
        }
    }
    for (VDS vds : spms) {
        setVdsStatusToPrepareForMaintaice(vds);
    }
    cancelIncommingMigrations();
    freeLock();
}
#method_after
private void MoveVdssToGoingToMaintenanceMode() {
    List<VDS> spms = new ArrayList<VDS>();
    Iterator<VDS> it = vdssToMaintenance.values().iterator();
    while (it.hasNext()) {
        VDS vds = it.next();
        // SPMs will move to Prepare For Maintenance later after standard hosts
        if (vds.getSpmStatus() != VdsSpmStatus.SPM) {
            if (!setVdsStatusToPrepareForMaintenance(vds)) {
                it.remove();
            }
        } else {
            spms.add(vds);
        }
    }
    for (VDS vds : spms) {
        if (!setVdsStatusToPrepareForMaintenance(vds)) {
            vdssToMaintenance.remove(vds.getId());
        }
    }
    cancelIncommingMigrations();
    freeLock();
}
#end_block

#method_before
private void MigrateAllVdss() {
    for (Guid vdsId : getParameters().getVdsIdList()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext());
        if (!result.getCanDoAction()) {
            getReturnValue().getCanDoActionMessages().addAll(result.getCanDoActionMessages());
            getReturnValue().setCanDoAction(false);
        }
    }
}
#method_after
private void MigrateAllVdss() {
    for (Guid vdsId : vdssToMaintenance.keySet()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext());
        if (!result.getCanDoAction()) {
            getReturnValue().getCanDoActionMessages().addAll(result.getCanDoActionMessages());
            getReturnValue().setCanDoAction(false);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    MoveVdssToGoingToMaintenanceMode();
    MigrateAllVdss();
    // set network to operational / non-operational
    for (Guid id : _vdsGroupIds) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(id);
        for (Network net : networks) {
            NetworkClusterHelper.setStatus(id, net);
        }
    }
    // clear the automatic PM flag unless instructed otherwise
    if (!getParameters().getKeepPolicyPMEnabled()) {
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            vds.setPowerManagementControlledByPolicy(false);
            DbFacade.getInstance().getVdsDynamicDao().update(vds.getDynamicData());
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    MoveVdssToGoingToMaintenanceMode();
    MigrateAllVdss();
    // find clusters for hosts that should move to maintenance
    Set<Guid> clusters = new HashSet<>();
    for (VDS vds : vdssToMaintenance.values()) {
        if (!clusters.contains(vds.getVdsGroupId())) {
            clusters.add(vds.getVdsGroupId());
            // set network to operational / non-operational
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
            for (Network net : networks) {
                NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
            }
        }
    }
    // clear the automatic PM flag unless instructed otherwise
    if (!getParameters().getKeepPolicyPMEnabled()) {
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            vds.setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    _vdsGroupIds = new ArrayList<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    _vdsGroupIds.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            Set<Guid> clustersAsSet = new HashSet<Guid>();
            clustersAsSet.addAll(_vdsGroupIds);
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    VDSReturnValue vdsReturnValue = null;
    try {
        // Set status immediately to prevent a race (BZ 636950/656224)
        setStatus();
        // Regular (no secondary agent) , multiple sequential agents or multiple concurrent agents
        if (StringUtils.isEmpty(getVds().getPmSecondaryIp())) {
            handleSingleAgent(lastStatus, vdsReturnValue);
        } else {
            if (getVds().isPmSecondaryConcurrent()) {
                handleMultipleConcurrentAgents(lastStatus, vdsReturnValue);
            } else {
                handleMultipleSequentialAgents(lastStatus, vdsReturnValue);
            }
        }
        setSucceeded(getFenceSucceeded());
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        } else // Successful fencing with reboot or shutdown op. Clear the power management policy flag
        if (EnumSet.of(FenceActionType.Restart, FenceActionType.Stop).contains(getParameters().getAction()) && getParameters().getKeepPolicyPMEnabled() == false) {
            getVds().setPowerManagementControlledByPolicy(false);
            DbFacade.getInstance().getVdsDynamicDao().update(getVds().getDynamicData());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    VDSReturnValue vdsReturnValue = null;
    try {
        // Set status immediately to prevent a race (BZ 636950/656224)
        setStatus();
        // Regular (no secondary agent) , multiple sequential agents or multiple concurrent agents
        if (StringUtils.isEmpty(getVds().getPmSecondaryIp())) {
            handleSingleAgent(lastStatus, vdsReturnValue);
        } else {
            if (getVds().isPmSecondaryConcurrent()) {
                handleMultipleConcurrentAgents(lastStatus, vdsReturnValue);
            } else {
                handleMultipleSequentialAgents(lastStatus, vdsReturnValue);
            }
        }
        setSucceeded(getFenceSucceeded());
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        } else // Successful fencing with reboot or shutdown op. Clear the power management policy flag
        if ((getParameters().getAction() == FenceActionType.Restart || getParameters().getAction() == FenceActionType.Stop) && getParameters().getKeepPolicyPMEnabled() == false) {
            getVds().setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    }
}
#end_block

#method_before
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    int i = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    while (!statusReached && i <= getRerties()) {
        log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
        if (executor.findProxyHost()) {
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // No need to retry , agent definitions are corrupted
                    log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                    break;
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        } else {
            break;
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#method_after
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    int i = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    while (!statusReached && i <= getRerties()) {
        log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
        if (executor.findProxyHost()) {
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // No need to retry , agent definitions are corrupted
                    log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                    break;
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        } else {
            break;
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(getDownHosts(allHosts, parameters), getMaintenanceHosts(allHosts, parameters), getEmptyHosts(allHosts, parameters), parameters);
    if (action != null)
        processPmAction(action);
    return migrationRule;
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    List<VDS> emptyHosts = new ArrayList<>();
    List<VDS> maintenanceHosts = new ArrayList<>();
    List<VDS> downHosts = new ArrayList<>();
    getHostLists(allHosts, parameters, emptyHosts, maintenanceHosts, downHosts);
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(cluster, downHosts, maintenanceHosts, emptyHosts, parameters);
    if (action != null) {
        processPmAction(action);
    }
    return migrationRule;
}
#end_block

#method_before
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        List<Guid> vdsList = new ArrayList<>(1);
        vdsList.add(vds.getId());
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(vdsList, true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        VdsPowerDownParameters parameters = new VdsPowerDownParameters(vds.getId());
        parameters.setKeepPolicyPMEnabled(true);
        Backend.getInstance().runInternalAction(VdcActionType.VdsPowerDown, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
    /* Should not ever happen... */
    }
}
#method_after
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        Guid[] vdsList = new Guid[] { vds.getId() };
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(Arrays.asList(vdsList), true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        VdsPowerDownParameters parameters = new VdsPowerDownParameters(vds.getId());
        parameters.setKeepPolicyPMEnabled(true);
        Backend.getInstance().runInternalAction(VdcActionType.VdsPowerDown, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
        /* Should not ever happen... */
        log.errorFormat("Unknown host power management transition {0} -> {1}", currentStatus.toString(), targetStatus.toString());
    }
}
#end_block

#method_before
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    final int enableAutoPM = tryParseWithDefault(parameters.get("EnableAutomaticHostPowerManagement"), Config.<Integer>getValue(ConfigValues.EnableAutomaticHostPowerManagement));
    /* Automatic power management is disabled */
    if (enableAutoPM == 0)
        return null;
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty())
        return null;
    else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        return hostsWithAutoPM.isEmpty() ? null : new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    return null;
}
#method_after
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(VDSGroup cluster, List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    String enableAutoPMParameter = parameters.get("EnableAutomaticHostPowerManagement");
    Boolean enableAutoPM = enableAutoPMParameter == null ? null : Boolean.valueOf(enableAutoPMParameter);
    if (enableAutoPM == null) {
        enableAutoPM = Config.<Boolean>getValue(ConfigValues.EnableAutomaticHostPowerManagement);
    }
    /* Automatic power management is disabled */
    if (!enableAutoPM.booleanValue()) {
        log.infoFormat("Automatic power management is disabled for cluster {0}.", cluster.getName());
        return null;
    }
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, but no additional host is available.", cluster.getName());
        return null;
    } else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        if (hostsWithAutoPM.isEmpty()) {
            log.infoFormat("Cluster {0} does have too many spare hosts, but none can be put to maintenance.", cluster.getName());
            return null;
        } else {
            return new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
        }
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, reactivating one.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, trying to start one up.", cluster.getName());
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    /* All power management constraints were satisfied, no need to do anything */
    return null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("SSH powerdown will not be executed on host {0}({1}) since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    /* Try this only when the Host is in maintenance state */
    if (getVds().getStatus() != VDSStatus.Maintenance) {
        setCommandShouldBeLogged(false);
        log.infoFormat("SSH powerdown will not be executed on host {0}({1}) since it is not in Maintenance.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString());
    if (result) {
        // SSH powerdown executed without errors set the status to down
        getVds().setStatus(VDSStatus.Down);
        // clear the automatic PM flag unless instructed otherwise
        if (!getParameters().getKeepPolicyPMEnabled()) {
            getVds().setPowerManagementControlledByPolicy(false);
        }
        getDbFacade().getVdsDynamicDao().update(getVds().getDynamicData());
    } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) {
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop);
        parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled());
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    }
    getReturnValue().setSucceeded(result);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        handleError("SSH power down will not be executed on host {0} ({1}) since it doesn't exist anymore.");
        return;
    }
    /* Try this only when the Host is in maintenance state */
    if (getVds().getStatus() != VDSStatus.Maintenance) {
        handleError("SSH power down will not be executed on host {0} ({1}) since it is not in Maintenance.");
        return;
    }
    boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString());
    if (result) {
        // SSH powerdown executed without errors set the status to down
        getVds().setStatus(VDSStatus.Down);
        // clear the automatic PM flag unless instructed otherwise
        if (!getParameters().getKeepPolicyPMEnabled()) {
            getVds().setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) {
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop);
        parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled());
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    }
    getReturnValue().setSucceeded(result);
}
#end_block

#method_before
private boolean executeSshPowerdown(String version) {
    boolean ret = false;
    try (final EngineSSHClient sshClient = new EngineSSHClient();
        final ByteArrayOutputStream cmdOut = new ByteArrayOutputStream();
        final ByteArrayOutputStream cmdErr = new ByteArrayOutputStream()) {
        try {
            log.infoFormat("Opening SSH powerdown session on host {0}", getVds().getHostName());
            sshClient.setVds(getVds());
            sshClient.useDefaultKeyPair();
            sshClient.connect();
            sshClient.authenticate();
            log.infoFormat("Executing SSH powerdown command on host {0}", getVds().getHostName());
            sshClient.executeCommand(Config.<String>getValue(ConfigValues.SshVdsPowerdownCommand, version), null, cmdOut, cmdErr);
            ret = true;
        } catch (Exception ex) {
            log.errorFormat("SSH powerdown command failed on host {0}: {1}\nStdout: {2}\nStderr: {3}\nStacktrace: {4}", getVds().getHostName(), ex.getMessage(), cmdOut.toString(), cmdErr.toString(), ex);
        }
    } catch (IOException e) {
        log.error("IOException", e);
    }
    return ret;
}
#method_after
private boolean executeSshPowerdown(String version) {
    boolean ret = false;
    try (final EngineSSHClient sshClient = new EngineSSHClient();
        final ByteArrayOutputStream cmdOut = new ByteArrayOutputStream();
        final ByteArrayOutputStream cmdErr = new ByteArrayOutputStream()) {
        try {
            log.infoFormat("Opening SSH power down session on host {0}", getVds().getHostName());
            sshClient.setVds(getVds());
            sshClient.useDefaultKeyPair();
            sshClient.connect();
            sshClient.authenticate();
            log.infoFormat("Executing SSH power down command on host {0}", getVds().getHostName());
            sshClient.executeCommand(Config.<String>getValue(ConfigValues.SshVdsPowerdownCommand, version), null, cmdOut, cmdErr);
            ret = true;
        } catch (Exception ex) {
            log.errorFormat("SSH power down command failed on host {0}: {1}\nStdout: {2}\nStderr: {3}\nStacktrace: {4}", getVds().getHostName(), ex.getMessage(), cmdOut.toString(), cmdErr.toString(), ex);
        }
    } catch (IOException e) {
        log.error("IOException", e);
    }
    return ret;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + cpuOverCommitDurationMinutes;
    result = prime * result + highUtilization;
    result = prime * result + lowUtilization;
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && cpuOverCommitDurationMinutes == other.cpuOverCommitDurationMinutes && highUtilization == other.highUtilization && lowUtilization == other.lowUtilization && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#end_block

#method_before
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#method_after
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setId(instance.getId());
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy((Boolean) model.getDisableAutomaticPowerManagement().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort((Integer) model.getPort().getEntity());
    host.setSshPort(Integer.valueOf((String) model.getAuthSshPort().getEntity()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy((Boolean) model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters vdsActionParams = new AddVdsActionParameters();
    vdsActionParams.setvds(host);
    vdsActionParams.setVdsId(host.getId());
    if (model.getUserPassword().getEntity() != null) {
        vdsActionParams.setPassword((String) model.getUserPassword().getEntity());
    }
    vdsActionParams.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    vdsActionParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, vdsActionParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterGuideModel localModel = (ClusterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort((Integer) model.getPort().getEntity());
    host.setSshPort(Integer.valueOf((String) model.getAuthSshPort().getEntity()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters vdsActionParams = new AddVdsActionParameters();
    vdsActionParams.setvds(host);
    vdsActionParams.setVdsId(host.getId());
    if (model.getUserPassword().getEntity() != null) {
        vdsActionParams.setPassword((String) model.getUserPassword().getEntity());
    }
    vdsActionParams.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    vdsActionParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, vdsActionParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterGuideModel localModel = (ClusterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("controlled_by_pm_policy", vds.isPowerManagementControlledByPolicy());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#method_after
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(hostName, other.hostName) && ObjectUtils.objectsEqual(consoleAddress, other.consoleAddress) && ObjectUtils.objectsEqual(managementIp, other.managementIp) && ObjectUtils.objectsEqual(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && ObjectUtils.objectsEqual(pmOptions, other.pmOptions) && ObjectUtils.objectsEqual(pmOptionsMap, other.pmOptionsMap) && ObjectUtils.objectsEqual(pmPassword, other.pmPassword) && ObjectUtils.objectsEqual(pmPort, other.pmPort) && ObjectUtils.objectsEqual(pmType, other.pmType) && ObjectUtils.objectsEqual(pmUser, other.pmUser) && ObjectUtils.objectsEqual(pmSecondaryIp, other.pmSecondaryIp) && pmSecondaryConcurrent == other.pmSecondaryConcurrent && ObjectUtils.objectsEqual(pmSecondaryOptions, other.pmSecondaryOptions) && ObjectUtils.objectsEqual(pmSecondaryOptionsMap, other.pmSecondaryOptionsMap) && ObjectUtils.objectsEqual(pmSecondaryPassword, other.pmSecondaryPassword) && ObjectUtils.objectsEqual(pmSecondaryPort, other.pmSecondaryPort) && ObjectUtils.objectsEqual(pmSecondaryType, other.pmSecondaryType) && ObjectUtils.objectsEqual(pmSecondaryUser, other.pmSecondaryUser) && port == other.port && sshPort == other.sshPort && ObjectUtils.objectsEqual(sshUsername, other.sshUsername) && ObjectUtils.objectsEqual(serverSslEnabled, other.serverSslEnabled) && ObjectUtils.objectsEqual(uniqueId, other.uniqueId) && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && ObjectUtils.objectsEqual(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && ObjectUtils.objectsEqual(sshKeyFingerprint, other.sshKeyFingerprint)) && ObjectUtils.objectsEqual(disablePowerManagementPolicy, other.disablePowerManagementPolicy);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(hostName, other.hostName) && ObjectUtils.objectsEqual(consoleAddress, other.consoleAddress) && ObjectUtils.objectsEqual(managementIp, other.managementIp) && ObjectUtils.objectsEqual(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && ObjectUtils.objectsEqual(pmOptions, other.pmOptions) && ObjectUtils.objectsEqual(pmOptionsMap, other.pmOptionsMap) && ObjectUtils.objectsEqual(pmPassword, other.pmPassword) && ObjectUtils.objectsEqual(pmPort, other.pmPort) && ObjectUtils.objectsEqual(pmType, other.pmType) && ObjectUtils.objectsEqual(pmUser, other.pmUser) && ObjectUtils.objectsEqual(pmSecondaryIp, other.pmSecondaryIp) && pmSecondaryConcurrent == other.pmSecondaryConcurrent && ObjectUtils.objectsEqual(pmSecondaryOptions, other.pmSecondaryOptions) && ObjectUtils.objectsEqual(pmSecondaryOptionsMap, other.pmSecondaryOptionsMap) && ObjectUtils.objectsEqual(pmSecondaryPassword, other.pmSecondaryPassword) && ObjectUtils.objectsEqual(pmSecondaryPort, other.pmSecondaryPort) && ObjectUtils.objectsEqual(pmSecondaryType, other.pmSecondaryType) && ObjectUtils.objectsEqual(pmSecondaryUser, other.pmSecondaryUser) && port == other.port && sshPort == other.sshPort && ObjectUtils.objectsEqual(sshUsername, other.sshUsername) && ObjectUtils.objectsEqual(serverSslEnabled, other.serverSslEnabled) && ObjectUtils.objectsEqual(uniqueId, other.uniqueId) && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && ObjectUtils.objectsEqual(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && ObjectUtils.objectsEqual(sshKeyFingerprint, other.sshKeyFingerprint)) && disablePowerManagementPolicy == other.disablePowerManagementPolicy;
}
#end_block

#method_before
private void updateOptionsNonLocalFS() {
    if (clusters == null || allStorageDomains == null || attachedStorageDomains == null || isoStorageDomains == null || allHosts == null) {
        return;
    }
    // Add cluster action.
    // $NON-NLS-1$
    UICommand addClusterAction = new UICommand("AddCluster", this);
    if (clusters.isEmpty()) {
        addClusterAction.setTitle(DataCenterConfigureClustersAction);
        getCompulsoryActions().add(addClusterAction);
    } else {
        addClusterAction.setTitle(DataCenterAddAnotherClusterAction);
        getOptionalActions().add(addClusterAction);
    }
    ArrayList<VDS> hosts = new ArrayList<VDS>();
    ArrayList<VDS> availableHosts = new ArrayList<VDS>();
    ArrayList<VDS> upHosts = new ArrayList<VDS>();
    for (VDS vds : allHosts) {
        if (Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            hosts.add(vds);
        }
        if ((vds.getStatus() == VDSStatus.Maintenance || vds.getStatus() == VDSStatus.PendingApproval) && doesHostSupportAnyCluster(clusters, vds)) {
            availableHosts.add(vds);
        }
        if (vds.getStatus() == VDSStatus.Up && Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            upHosts.add(vds);
        }
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("AddHost", this);
    tempVar.setIsExecutionAllowed(clusters.size() > 0);
    UICommand addHostAction = tempVar;
    addHostAction.setTitle(DataCenterConfigureHostsAction);
    getCompulsoryActions().add(addHostAction);
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    // If now compatible hosts are found - disable the select host button
    selectHostAction.setIsChangable(availableHosts.size() > 0);
    selectHostAction.setIsExecutionAllowed(availableHosts.size() > 0);
    if (clusters.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
    ArrayList<StorageDomain> unattachedStorage = new ArrayList<StorageDomain>();
    boolean addToList;
    Version version3_0 = new Version(3, 0);
    for (StorageDomain item : allStorageDomains) {
        addToList = false;
        if (item.getStorageDomainType() == StorageDomainType.Data && item.getStorageType() == getEntity().getStorageType() && item.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            if (getEntity().getStoragePoolFormatType() == null) {
                // compat logic: in case its not v1 and the version is less than 3.0 break.
                if (item.getStorageStaticData().getStorageFormat() != StorageFormatType.V1 && getEntity().getcompatibility_version().compareTo(version3_0) < 0) {
                    continue;
                }
                addToList = true;
            } else if (getEntity().getStoragePoolFormatType() == item.getStorageStaticData().getStorageFormat()) {
                addToList = true;
            }
        }
        if (addToList) {
            unattachedStorage.add(item);
        }
    }
    ArrayList<StorageDomain> attachedDataStorages = new ArrayList<StorageDomain>();
    for (StorageDomain a : attachedStorageDomains) {
        if (a.getStorageDomainType() == StorageDomainType.Data || a.getStorageDomainType() == StorageDomainType.Master) {
            attachedDataStorages.add(a);
        }
    }
    // $NON-NLS-1$
    UICommand addDataStorageAction = new UICommand("AddDataStorage", this);
    addDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    addDataStorageAction.setIsExecutionAllowed(upHosts.size() > 0);
    if (unattachedStorage.isEmpty() && attachedDataStorages.isEmpty()) {
        addDataStorageAction.setTitle(DataCenterConfigureStorageAction);
        getCompulsoryActions().add(addDataStorageAction);
    } else {
        addDataStorageAction.setTitle(DataCenterAddMoreStorageAction);
        getOptionalActions().add(addDataStorageAction);
    }
    // Attach data storage action.
    // $NON-NLS-1$
    UICommand attachDataStorageAction = new UICommand("AttachDataStorage", this);
    if (upHosts.isEmpty()) {
        attachDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachDataStorageAction.setIsExecutionAllowed(unattachedStorage.size() > 0 && upHosts.size() > 0);
    if (attachedDataStorages.isEmpty()) {
        attachDataStorageAction.setTitle(DataCenterAttachStorageAction);
        getCompulsoryActions().add(attachDataStorageAction);
    } else {
        attachDataStorageAction.setTitle(DataCenterAttachMoreStorageAction);
        getOptionalActions().add(attachDataStorageAction);
    }
    // $NON-NLS-1$
    UICommand addIsoStorageAction = new UICommand("AddIsoStorage", this);
    addIsoStorageAction.getExecuteProhibitionReasons().add(NoDataDomainAttachedReason);
    addIsoStorageAction.setIsExecutionAllowed(getEntity().getStatus() == StoragePoolStatus.Up);
    if (isoStorageDomains.isEmpty()) {
        addIsoStorageAction.setTitle(DataCenterConfigureISOLibraryAction);
        getOptionalActions().add(addIsoStorageAction);
    }
    // Attach ISO storage action.
    // Allow to attach ISO domain only when there are Data storages attached
    // and there ISO storages to attach and ther are no ISO storages actually
    // attached.
    ArrayList<StorageDomain> attachedIsoStorages = new ArrayList<StorageDomain>();
    for (StorageDomain sd : attachedStorageDomains) {
        if (sd.getStorageDomainType() == StorageDomainType.ISO) {
            attachedIsoStorages.add(sd);
        }
    }
    boolean attachIsoAllowed = (attachedDataStorages.size() > 0 && Linq.isAnyStorageDomainIsMatserAndActive(attachedDataStorages) && isoStorageDomains.size() > 0 && attachedIsoStorages.isEmpty() && upHosts.size() > 0);
    // The action is available if there are no storages attached to the
    // Data Center. It will not always be allowed.
    boolean attachIsoAvailable = attachedIsoStorages.isEmpty();
    // $NON-NLS-1$
    UICommand attachIsoStorageAction = new UICommand("AttachIsoStorage", this);
    attachIsoStorageAction.setIsAvailable(attachIsoAvailable);
    if (upHosts.isEmpty()) {
        attachIsoStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachIsoStorageAction.setIsExecutionAllowed(attachIsoAllowed);
    if (attachIsoAvailable) {
        attachIsoStorageAction.setTitle(DataCenterAttachISOLibraryAction);
        getOptionalActions().add(attachIsoStorageAction);
    }
    stopProgress();
}
#method_after
private void updateOptionsNonLocalFS() {
    if (clusters == null || allStorageDomains == null || attachedStorageDomains == null || isoStorageDomains == null || allHosts == null) {
        return;
    }
    // Add cluster action.
    // $NON-NLS-1$
    UICommand addClusterAction = new UICommand("AddCluster", this);
    if (clusters.isEmpty()) {
        addClusterAction.setTitle(DataCenterConfigureClustersAction);
        getCompulsoryActions().add(addClusterAction);
    } else {
        addClusterAction.setTitle(DataCenterAddAnotherClusterAction);
        getOptionalActions().add(addClusterAction);
    }
    ArrayList<VDS> hosts = new ArrayList<VDS>();
    ArrayList<VDS> availableHosts = new ArrayList<VDS>();
    ArrayList<VDS> upHosts = new ArrayList<VDS>();
    for (VDS vds : allHosts) {
        if (Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            hosts.add(vds);
        }
        if ((vds.getStatus() == VDSStatus.Maintenance || vds.getStatus() == VDSStatus.PendingApproval) && doesHostSupportAnyCluster(clusters, vds)) {
            availableHosts.add(vds);
        }
        if (vds.getStatus() == VDSStatus.Up && Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            upHosts.add(vds);
        }
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("AddHost", this);
    tempVar.setIsExecutionAllowed(clusters.size() > 0);
    UICommand addHostAction = tempVar;
    addHostAction.setTitle(DataCenterConfigureHostsAction);
    getCompulsoryActions().add(addHostAction);
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    // If now compatible hosts are found - disable the select host button
    selectHostAction.setIsChangable(availableHosts.size() > 0);
    selectHostAction.setIsExecutionAllowed(availableHosts.size() > 0);
    if (clusters.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
    ArrayList<StorageDomain> unattachedStorage = new ArrayList<StorageDomain>();
    boolean addToList;
    Version version3_0 = new Version(3, 0);
    for (StorageDomain item : allStorageDomains) {
        addToList = false;
        if (item.getStorageDomainType() == StorageDomainType.Data && item.getStorageType() == getEntity().getStorageType() && item.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            if (getEntity().getStoragePoolFormatType() == null) {
                // compat logic: in case its not v1 and the version is less than 3.0 break.
                if (item.getStorageStaticData().getStorageFormat() != StorageFormatType.V1 && getEntity().getcompatibility_version().compareTo(version3_0) < 0) {
                    continue;
                }
                addToList = true;
            } else if (getEntity().getStoragePoolFormatType() == item.getStorageStaticData().getStorageFormat()) {
                addToList = true;
            }
        }
        if (addToList) {
            unattachedStorage.add(item);
        }
    }
    ArrayList<StorageDomain> attachedDataStorages = new ArrayList<StorageDomain>();
    for (StorageDomain a : attachedStorageDomains) {
        if (a.getStorageDomainType() == StorageDomainType.Data || a.getStorageDomainType() == StorageDomainType.Master) {
            attachedDataStorages.add(a);
        }
    }
    // $NON-NLS-1$
    UICommand addDataStorageAction = new UICommand("AddDataStorage", this);
    addDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    addDataStorageAction.setIsExecutionAllowed(upHosts.size() > 0);
    if (unattachedStorage.isEmpty() && attachedDataStorages.isEmpty()) {
        addDataStorageAction.setTitle(DataCenterConfigureStorageAction);
        getCompulsoryActions().add(addDataStorageAction);
    } else {
        addDataStorageAction.setTitle(DataCenterAddMoreStorageAction);
        getOptionalActions().add(addDataStorageAction);
    }
    // Attach data storage action.
    // $NON-NLS-1$
    UICommand attachDataStorageAction = new UICommand("AttachDataStorage", this);
    if (upHosts.isEmpty()) {
        attachDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachDataStorageAction.setIsExecutionAllowed(unattachedStorage.size() > 0 && upHosts.size() > 0);
    if (attachedDataStorages.isEmpty()) {
        attachDataStorageAction.setTitle(DataCenterAttachStorageAction);
        getCompulsoryActions().add(attachDataStorageAction);
    } else {
        attachDataStorageAction.setTitle(DataCenterAttachMoreStorageAction);
        getOptionalActions().add(attachDataStorageAction);
    }
    // $NON-NLS-1$
    UICommand addIsoStorageAction = new UICommand("AddIsoStorage", this);
    addIsoStorageAction.getExecuteProhibitionReasons().add(NoDataDomainAttachedReason);
    addIsoStorageAction.setIsExecutionAllowed(getEntity().getStatus() == StoragePoolStatus.Up);
    if (isoStorageDomains.isEmpty()) {
        addIsoStorageAction.setTitle(DataCenterConfigureISOLibraryAction);
        getOptionalActions().add(addIsoStorageAction);
    }
    // Attach ISO storage action.
    // Allow to attach ISO domain only when there are Data storages attached
    // and there ISO storages to attach and ther are no ISO storages actually
    // attached.
    ArrayList<StorageDomain> attachedIsoStorages = new ArrayList<StorageDomain>();
    for (StorageDomain sd : attachedStorageDomains) {
        if (sd.getStorageDomainType() == StorageDomainType.ISO) {
            attachedIsoStorages.add(sd);
        }
    }
    boolean attachIsoAllowed = (attachedDataStorages.size() > 0 && Linq.isAnyStorageDomainIsMasterAndActive(attachedDataStorages) && isoStorageDomains.size() > 0 && attachedIsoStorages.isEmpty() && upHosts.size() > 0);
    // The action is available if there are no storages attached to the
    // Data Center. It will not always be allowed.
    boolean attachIsoAvailable = attachedIsoStorages.isEmpty();
    // $NON-NLS-1$
    UICommand attachIsoStorageAction = new UICommand("AttachIsoStorage", this);
    attachIsoStorageAction.setIsAvailable(attachIsoAvailable);
    if (upHosts.isEmpty()) {
        attachIsoStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachIsoStorageAction.setIsExecutionAllowed(attachIsoAllowed);
    if (attachIsoAvailable) {
        attachIsoStorageAction.setTitle(DataCenterAttachISOLibraryAction);
        getOptionalActions().add(attachIsoStorageAction);
    }
    stopProgress();
}
#end_block

#method_before
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy((Boolean) model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters addVdsParams = new AddVdsActionParameters();
    addVdsParams.setVdsId(host.getId());
    addVdsParams.setvds(host);
    if (model.getUserPassword().getEntity() != null) {
        addVdsParams.setPassword((String) model.getUserPassword().getEntity());
    }
    addVdsParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, addVdsParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters addVdsParams = new AddVdsActionParameters();
    addVdsParams.setVdsId(host.getId());
    addVdsParams.setvds(host);
    if (model.getUserPassword().getEntity() != null) {
        addVdsParams.setPassword((String) model.getUserPassword().getEntity());
    }
    addVdsParams.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    addVdsParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, addVdsParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
public EntityModel getDisableAutomaticPowerManagement() {
    return disableAutomaticPowerManagement;
}
#method_after
public EntityModel<Boolean> getDisableAutomaticPowerManagement() {
    return disableAutomaticPowerManagement;
}
#end_block

#method_before
private void setDisableAutomaticPowerManagement(EntityModel value) {
    disableAutomaticPowerManagement = value;
}
#method_after
private void setDisableAutomaticPowerManagement(EntityModel<Boolean> value) {
    disableAutomaticPowerManagement = value;
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                VDSGroup oldCluster = (VDSGroup) hostModel.getCluster().getSelectedItem();
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    hostModel.getCluster().setItems(clusters);
                    if (oldCluster != null) {
                        VDSGroup newSelectedItem = Linq.firstOrDefault(clusters, new Linq.ClusterPredicate(oldCluster.getId()));
                        if (newSelectedItem != null) {
                            hostModel.getCluster().setSelectedItem(newSelectedItem);
                        }
                    }
                    if (hostModel.getCluster().getSelectedItem() == null) {
                        hostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines)) && ObjectUtils.objectsEqual(powerManagementControlledByPolicy, other.powerManagementControlledByPolicy);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines)) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().update(getVds().getDynamicData());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
}
#method_after
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!hostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetDisableAutomaticPm()) {
        entity.setDisablePowerManagementPolicy(model.isDisableAutomaticPm());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    model.setDisableAutomaticPm(entity.isDisablePowerManagementPolicy());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(entity.isPmSecondaryConcurrent());
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    model.setAutomaticPmEnabled(!entity.isDisablePowerManagementPolicy());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(entity.isPmSecondaryConcurrent());
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    // get vds that over committed for the time defined
    /* returns list of Hosts with
         *    cpuUtilization >= highUtilization
         *    && cpuOverCommitMinutes >= CpuOverCommitDurationMinutes
         */
    List<VDS> overUtilizedHosts = getOverUtilizedHosts(hosts, parameters);
    // if no hosts is overutilized, then there is nothing to balance...
    if (overUtilizedHosts == null || overUtilizedHosts.size() == 0) {
        return null;
    }
    // returns hosts with utilization lower then the specified threshold
    List<VDS> underUtilizedHosts = getUnderUtilizedHosts(cluster, hosts, parameters);
    // if no host has a spare power, then there is nothing we can do to balance it..
    if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
        return null;
    }
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId());
    if (migrableVmsOnRandomHost.isEmpty()) {
        return null;
    }
    VM vm = getBestVmToMigrate(randomHost.getId(), migrableVmsOnRandomHost);
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    // get vds that over committed for the time defined
    /* returns list of Hosts with
         *    cpuUtilization >= highUtilization
         *    && cpuOverCommitMinutes >= CpuOverCommitDurationMinutes
         */
    List<VDS> overUtilizedHosts = getOverUtilizedHosts(hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if (overUtilizedHosts == null || overUtilizedHosts.size() == 0) {
        log.infoFormat("There is no over-utilized host in cluster '{0}'", cluster.getName());
        return null;
    }
    // returns hosts with utilization lower than the specified threshold
    List<VDS> underUtilizedHosts = getUnderUtilizedHosts(cluster, hosts, parameters);
    // if no host has a spare power, then there is nothing we can do to balance it..
    if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
        log.warnFormat("All hosts are over-utilized, can't balance the cluster '{0}'", cluster.getName());
        return null;
    }
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId());
    if (migrableVmsOnRandomHost.isEmpty()) {
        return null;
    }
    VM vm = getBestVmToMigrate(randomHost.getId(), migrableVmsOnRandomHost);
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#end_block

#method_before
private VDS getWorstVDS(List<VDS> relevantHosts, Map<String, String> parameters) {
    VDS worstVDS = relevantHosts.get(0);
    for (VDS vds : relevantHosts) {
        if (getOccupiedVMSLots(vds, parameters) > getOccupiedVMSLots(worstVDS, parameters))
            worstVDS = vds;
    }
    return worstVDS;
}
#method_after
private VDS getWorstVDS(List<VDS> relevantHosts, Map<String, String> parameters) {
    VDS worstVds = relevantHosts.get(0);
    int worstVdsSlots = 0;
    for (VDS vds : relevantHosts) {
        if (getOccupiedVmSlots(vds, parameters) > worstVdsSlots) {
            worstVds = vds;
            worstVdsSlots = getOccupiedVmSlots(worstVds, parameters);
        }
    }
    return worstVds;
}
#end_block

#method_before
@Override
protected List<VDS> getOverUtilizedHosts(List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int highVmCountUtilization = tryParseWithDefault(parameters.get("HighVMCount"), getHighVMCountDefaultValue());
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    if (getOccupiedVMSLots(worstVDS, parameters) < highVmCountUtilization) {
        log.debugFormat("No host is overutilized, the worst is {1} with {2} occupied VM slots", worstVDS.getName(), getOccupiedVMSLots(worstVDS, parameters));
        return null;
    }
    return LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return getOccupiedVMSLots(p, parameters) >= getOccupiedVMSLots(worstVDS, parameters);
        }
    });
}
#method_after
@Override
protected List<VDS> getOverUtilizedHosts(List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int highVmCountUtilization = NumberUtils.toInt(parameters.get("HighVmCount"), highVmCountDefault);
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    final int worstVdsOccupiedVmSlots = getOccupiedVmSlots(worstVDS, parameters);
    if (worstVdsOccupiedVmSlots < highVmCountUtilization) {
        log.infoFormat("There is no host with more than {0} running guests, no balancing is needed", highVmCountUtilization);
        return null;
    }
    return LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return getOccupiedVmSlots(p, parameters) >= worstVdsOccupiedVmSlots;
        }
    });
}
#end_block

#method_before
@Override
protected List<VDS> getUnderUtilizedHosts(VDSGroup cluster, List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int migrationThreshold = tryParseWithDefault(parameters.get("MigrationThreshold"), getMigrationThresholdDefault());
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    return LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            int distance = getOccupiedVMSLots(worstVDS, parameters) - getOccupiedVMSLots(p, parameters);
            return distance < migrationThreshold;
        }
    });
}
#method_after
@Override
protected List<VDS> getUnderUtilizedHosts(VDSGroup cluster, List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int migrationThreshold = NumberUtils.toInt(parameters.get("MigrationThreshold"), migrationThresholdDefault);
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    final int worstVdsOccupiedVmSlots = getOccupiedVmSlots(worstVDS, parameters);
    List<VDS> underUtilizedHosts = LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            int distance = worstVdsOccupiedVmSlots - getOccupiedVmSlots(p, parameters);
            return distance >= migrationThreshold;
        }
    });
    if (underUtilizedHosts.size() == 0) {
        log.warnFormat("There is no host with less than {0} running guests", worstVdsOccupiedVmSlots - migrationThreshold);
    }
    return underUtilizedHosts;
}
#end_block

#method_before
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#method_after
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
        case "OptimalForHaReservation":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HaReservationWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new HaReservationBalancePolicyUnit(policyUnit);
            }
            break;
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#end_block

#method_before
private int calcEvenGuestDistributionScore(VDS vds) {
    return Math.max(0, vds.getVmCount());
}
#method_after
private int calcEvenGuestDistributionScore(VDS vds, Map<String, String> parameters) {
    return Math.max(0, getOccupiedVmSlots(vds, parameters));
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    for (VDS vds : hosts) {
        scores.add(new Pair<Guid, Integer>(vds.getId(), calcEvenGuestDistributionScore(vds)));
    }
    return scores;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    for (VDS vds : hosts) {
        scores.add(new Pair<Guid, Integer>(vds.getId(), calcEvenGuestDistributionScore(vds, parameters)));
    }
    return scores;
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), clusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateCache(value);
    super.setItems(value);
}
#method_after
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateVmCache(value);
    super.setItems(value);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVm(((VM) getSelectedItem()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.PropertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ChangeCDModel.executedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setVncKeyboardLayout(instance.getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#end_block

#method_before
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#method_after
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setId(instance.getId());
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    if (items != value) {
        itemsChanging(value, items);
        items = value;
        getItemsChangedEvent().raise(this, EventArgs.Empty);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        if (items != null && selectedItem != null) {
            for (Object object : items) {
                UserPortalItemModel itemModel = (UserPortalItemModel) object;
                if (itemModel.getEntity().equals(selectedItem.getEntity())) {
                    this.selectedItem = itemModel;
                    break;
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Iterable value) {
    if (items != value) {
        itemsChanging(value, items);
        items = value;
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        if (items != null && selectedItem != null) {
            for (Object object : items) {
                UserPortalItemModel itemModel = (UserPortalItemModel) object;
                if (itemModel.getEntity().equals(selectedItem.getEntity())) {
                    this.selectedItem = itemModel;
                    break;
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    UnitVmModel model = (UnitVmModel) getWindow();
    if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getDataCenterWithClustersList()) {
        updateDataCenterWithCluster();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getDefaultHost()) {
        vmModel_DefaultHost_ItemsChanged();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getDisplayProtocol()) {
        vmModel_DisplayProtocol_ItemsChanged();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getPriority()) {
        vmModel_Priority_ItemsChanged();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getTimeZone()) {
        vmModel_TimeZone_ItemsChanged();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    UnitVmModel model = (UnitVmModel) getWindow();
    if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getDataCenterWithClustersList()) {
        updateDataCenterWithCluster();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getDefaultHost()) {
        vmModel_DefaultHost_ItemsChanged();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getDisplayProtocol()) {
        vmModel_DisplayProtocol_ItemsChanged();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getPriority()) {
        vmModel_Priority_ItemsChanged();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getTimeZone()) {
        vmModel_TimeZone_ItemsChanged();
    }
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        poolMap = new HashMap<Guid, VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            poolMap.put(pool.getVmPoolId(), pool);
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        List all = Linq.concat(getvms(), filteredPools);
        Collections.sort(all, new NameableComparator());
        consoleModelsCache.updateCache(filterVms(all));
        ArrayList<Model> items = new ArrayList<Model>();
        for (Object item : all) {
            VmConsoles consoles = null;
            if (item instanceof VM) {
                consoles = consoleModelsCache.getVmConsolesForVm((VM) item);
            }
            UserPortalItemModel model = new UserPortalItemModel(item, consoles);
            model.setEntity(item);
            items.add(model);
        }
        setItems(items);
        setCanConnectAutomatically(getAutoConnectableConsoles().size() == 1);
        setvms(null);
        setpools(null);
        getSearchCompletedEvent().raise(this, EventArgs.Empty);
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, DbFacade.getInstance().getVdsGroupDao().get(vm.getVdsGroupId()).getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, DbFacade.getInstance().getVdsGroupDao().get(vm.getVdsGroupId()).getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#end_block

#method_before
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#method_after
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurUserName == null) ? 0 : consoleCurUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurUserName == null) ? 0 : consoleCurUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurUserName, other.consoleCurUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(mExitMessage, other.mExitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurUserName, other.consoleCurUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(mExitMessage, other.mExitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName));
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            params.setUseVnc(displayType == DisplayType.VNC);
        }
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetKeyboardLayout()) {
        String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
        if (vncKeyboardLayout != null) {
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                params.setUseVnc(displayType == DisplayType.VNC);
            }
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#method_after
private void initVncKeyboardLayout() {
    List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    List<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#end_block

#method_before
void initListBoxEditors() {
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new AbstractRenderer<String>() {

        final String globalLayout = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(String object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object;
            }
        }
    });
}
#method_after
void initListBoxEditors() {
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
}
#end_block

#method_before
@Override
public void edit(final RunOnceModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    runOnceModel = object;
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isLinux = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(isLinux);
        }
    });
    object.getIsCloudInitEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsCloudInitEnabled().getEntity();
            cloudInitWidget.setVisible(selected);
        }
    });
    object.getIsSysprepEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsSysprepEnabled().getEntity();
            sysprepOptions.setVisible(selected);
            sysprepToEnableLabel.setVisible(!selected);
        }
    });
    object.getIsCloudInitPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cloudInitSubPanel.setVisible((Boolean) object.getIsCloudInitPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    object.getIsSysprepPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            sysprepSubPanel.setVisible((Boolean) object.getIsSysprepPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            } else if ("IsCustomPropertiesSheetVisible".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesPanel.setVisible(object.getIsCustomPropertiesSheetVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
    cloudInitWidget.edit(object.getCloudInit());
}
#method_after
@Override
public void edit(final RunOnceModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    runOnceModel = object;
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isLinux = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(isLinux);
        }
    });
    object.getIsCloudInitEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsCloudInitEnabled().getEntity();
            cloudInitWidget.setVisible(selected);
        }
    });
    object.getIsSysprepEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsSysprepEnabled().getEntity();
            sysprepOptions.setVisible(selected);
            sysprepToEnableLabel.setVisible(!selected);
        }
    });
    object.getIsCloudInitPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cloudInitSubPanel.setVisible((Boolean) object.getIsCloudInitPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    object.getIsSysprepPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            sysprepSubPanel.setVisible((Boolean) object.getIsSysprepPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            } else if ("IsCustomPropertiesSheetVisible".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesPanel.setVisible(object.getIsCustomPropertiesSheetVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
    cloudInitWidget.edit(object.getCloudInit());
}
#end_block

#method_before
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.getInstance().runAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        model.getCommands().add(// $NON-NLS-1$
        new UICommand("OnPreview", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        UICommand cancelCommand = // $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true);
        model.getCommands().add(cancelCommand);
        model.setCancelCommand(cancelCommand);
        model.setCloseCommand(// $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsCancel(true));
    }
}
#method_after
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.getInstance().runAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        // $NON-NLS-1$
        addCommands(model, "OnPreview");
    }
}
#end_block

#method_before
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    model.setCancelCommand(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#method_after
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        OnPreview();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCustomPreviewCommand()) {
        customPreview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        onPreview();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCustomPreview")) {
        onCustomPreview();
    }
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    return entity;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
public SetupNetworksParameters buildParameters(Guid hostId, Guid sourceClusterId, Guid targetClusterId) {
    List<Network> targetClusterNetworks = getNetworkDAO().getAllForCluster(targetClusterId);
    Map<String, Network> targetClusterNetworksByName = Entities.entitiesByName(targetClusterNetworks);
    SetupNetworksParameters params = createSetupNetworksParameters(hostId);
    Map<String, VdsNetworkInterface> nicsByNetwork = Entities.hostInterfacesByNetworkName(params.getInterfaces());
    Map<String, List<Network>> networksByLabel = getClusterNetworksByLabel(targetClusterNetworks);
    List<VdsNetworkInterface> hostNics = new ArrayList<>(params.getInterfaces());
    // Detect which networks should be added and which should be removed
    for (VdsNetworkInterface nic : hostNics) {
        adjustNetworksByLabel(targetClusterNetworksByName, params, nicsByNetwork, networksByLabel, nic);
    }
    return params;
}
#method_after
public SetupNetworksParameters buildParameters(Guid hostId, Guid sourceClusterId, Guid targetClusterId) {
    List<Network> targetClusterNetworks = getNetworkDAO().getAllForCluster(targetClusterId);
    Map<String, Network> targetClusterNetworksByName = Entities.entitiesByName(targetClusterNetworks);
    SetupNetworksParameters params = createSetupNetworksParameters(hostId);
    Map<String, VdsNetworkInterface> nicsByNetwork = Entities.hostInterfacesByNetworkName(params.getInterfaces());
    Map<String, List<Network>> targetNetworksByLabel = getClusterNetworksByLabel(targetClusterNetworks);
    Map<String, List<Network>> sourceNetworksByLabel = getClusterNetworksByLabel(getNetworkDAO().getAllForCluster(sourceClusterId));
    List<VdsNetworkInterface> hostNics = new ArrayList<>(params.getInterfaces());
    // Detect which networks should be added and which should be removed
    for (VdsNetworkInterface nic : hostNics) {
        adjustNetworksByLabel(sourceNetworksByLabel, targetClusterNetworksByName, targetNetworksByLabel, params, nicsByNetwork, nic);
    }
    return params;
}
#end_block

#method_before
public void adjustNetworksByLabel(Map<String, Network> targetClusterNetworksByName, SetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, Map<String, List<Network>> networksByLabel, VdsNetworkInterface nic) {
    if (nic.getLabels() == null) {
        return;
    }
    for (String label : nic.getLabels()) {
        for (Network net : networksByLabel.get(label)) {
            if (targetClusterNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                configureNetwork(nic, params.getInterfaces(), net);
            } else if (!targetClusterNetworksByName.containsKey(net.getName()) && nicsByNetwork.containsKey(net.getName())) {
                removeNetworkFromParameters(params, nic, net);
            }
        }
    }
}
#method_after
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, SetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (nic.getLabels() == null) {
        return;
    }
    for (String label : nic.getLabels()) {
        // configure networks by target cluster assignment
        List<Network> targetLabeledNetworks = targetNetworksByLabel.get(label);
        if (targetLabeledNetworks != null) {
            for (Network net : targetLabeledNetworks) {
                if (targetNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                    configureNetwork(nic, params.getInterfaces(), net);
                } else if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
        // remove labeled networks originated in source cluster but not assigned to target cluster
        List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
        if (sourceLabeledNetworks != null) {
            for (Network net : sourceLabeledNetworks) {
                if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
    }
}
#end_block

#method_before
public void removeNetworkFromParameters(SetupNetworksParameters params, VdsNetworkInterface nic, Network net) {
    if (NetworkUtils.isVlan(net)) {
        VdsNetworkInterface vlan = getVlanDevice(params.getInterfaces(), nic, net);
        if (vlan == null) {
            throw new VdcBLLException(VdcBllErrors.NETWORK_LABEL_CONFLICT);
        } else {
            params.getInterfaces().remove(vlan);
        }
    }
}
#method_after
public void removeNetworkFromParameters(SetupNetworksParameters params, VdsNetworkInterface nic, Network net) {
    if (NetworkUtils.isVlan(net)) {
        VdsNetworkInterface vlan = getVlanDevice(params.getInterfaces(), nic, net);
        if (vlan == null) {
            throw new VdcBLLException(VdcBllErrors.NETWORK_LABEL_CONFLICT);
        } else {
            params.getInterfaces().remove(vlan);
        }
    } else if (StringUtils.equals(net.getName(), nic.getNetworkName())) {
        nic.setNetworkName(null);
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#end_block

#method_before
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.Model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.Model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.Model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.Model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                VDSGroup oldCluster = (VDSGroup) hostModel.getCluster().getSelectedItem();
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    hostModel.getCluster().setItems(clusters);
                    if (oldCluster != null) {
                        VDSGroup newSelectedItem = Linq.firstOrDefault(clusters, new Linq.ClusterPredicate(oldCluster.getId()));
                        if (newSelectedItem != null) {
                            hostModel.getCluster().setSelectedItem(newSelectedItem);
                        }
                    }
                    if (hostModel.getCluster().getSelectedItem() == null) {
                        hostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
                    }
                }
            }
        };
        if (getIsNew()) {
            AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
        } else {
            AsyncDataProvider.getClusterListByFlags(_asyncQuery, dataCenter.getId(), getVdsFlags());
        }
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    setVdsFlags(vds.getCpuFlags());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
            clusterModel.getCPU().setItems(cpus);
            clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
            if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
                initCPU();
            }
            if (getIsEdit()) {
                if (StringHelper.isNullOrEmpty(getEntity().getcpu_name())) {
                    List<ArchitectureType> architectures = new ArrayList<ArchitectureType>();
                    if (getEntity().getArchitecture().equals(ArchitectureType.undefined)) {
                        architectures.add(ArchitectureType.undefined);
                    }
                    for (ServerCpu cpu : cpus) {
                        ArchitectureType cpuArch = cpu.getArchitecture();
                        if (!architectures.contains(cpuArch)) {
                            architectures.add(cpuArch);
                        }
                    }
                    ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
                    getArchitecture().setItems(architectures);
                    if (oldSelectedArch != null) {
                        getArchitecture().setSelectedItem(oldSelectedArch);
                    } else {
                        getArchitecture().setSelectedItem(getEntity().getArchitecture());
                    }
                }
            } else {
                getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
                getArchitecture().setSelectedItem(ArchitectureType.undefined);
            }
        }
    };
    if (getIsEdit()) {
        AsyncDataProvider.getAllowedCPUList(_asyncQuery, getEntity().getId(), version);
    } else {
        AsyncDataProvider.getCPUList(_asyncQuery, version);
    }
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
}
#end_block

#method_before
private void clusterPolicyChanged() {
    ClusterPolicy clusterPolicy = getClusterPolicy().getSelectedItem();
    ArrayList<String> lines = new ArrayList<String>();
    Map<Guid, PolicyUnit> allPolicyUnits = new HashMap<Guid, PolicyUnit>();
    if (clusterPolicy.getFilters() != null) {
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            allPolicyUnits.put(policyUnitId, policyUnitMap.get(policyUnitId));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            allPolicyUnits.put(pair.getFirst(), policyUnitMap.get(pair.getFirst()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        allPolicyUnits.put(clusterPolicy.getBalance(), policyUnitMap.get(clusterPolicy.getBalance()));
    }
    for (PolicyUnit policyUnit : allPolicyUnits.values()) {
        if (policyUnit.getParameterRegExMap() != null) {
            for (Map.Entry<String, String> keyValue : policyUnit.getParameterRegExMap().entrySet()) {
                lines.add(keyValue.getKey() + '=' + keyValue.getValue());
            }
        }
    }
    getCustomPropertySheet().setKeyValueString(lines);
    if (getIsEdit() && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
        getCustomPropertySheet().setEntity(KeyValueModel.convertProperties(getEntity().getClusterPolicyProperties()));
    } else {
        getCustomPropertySheet().setEntity(KeyValueModel.convertProperties(clusterPolicy.getParameterMap()));
    }
}
#method_after
private void clusterPolicyChanged() {
    ClusterPolicy clusterPolicy = getClusterPolicy().getSelectedItem();
    ArrayList<String> lines = new ArrayList<String>();
    Map<Guid, PolicyUnit> allPolicyUnits = new HashMap<Guid, PolicyUnit>();
    if (clusterPolicy.getFilters() != null) {
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            allPolicyUnits.put(policyUnitId, policyUnitMap.get(policyUnitId));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            allPolicyUnits.put(pair.getFirst(), policyUnitMap.get(pair.getFirst()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        allPolicyUnits.put(clusterPolicy.getBalance(), policyUnitMap.get(clusterPolicy.getBalance()));
    }
    for (PolicyUnit policyUnit : allPolicyUnits.values()) {
        if (policyUnit.getParameterRegExMap() != null) {
            for (Map.Entry<String, String> keyValue : policyUnit.getParameterRegExMap().entrySet()) {
                lines.add(keyValue.getKey() + '=' + keyValue.getValue());
            }
        }
    }
    getCustomPropertySheet().setKeyValueString(lines);
    if (getIsEdit() && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(getEntity().getClusterPolicyProperties()));
    } else {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(clusterPolicy.getParameterMap()));
    }
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#end_block

#method_before
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#method_after
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#end_block

#method_before
public boolean checkHaReservationStatusForCluster(VDSGroup cluster, List<VDS> failedHosts) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    // No hosts, return true
    if (hosts == null) {
        return true;
    }
    // HA Reservation is not possible with less the 2 hosts
    if (hosts.size() < 2) {
        return false;
    }
    // List of host id and cpu/ram free resources
    // for the outer Pair, first is host id second is a Pair of cpu and ram
    // for the inner Pair, first is cpu second is ram
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = getUnutilizedResources(hosts);
    List<VM> vmInCluster = DbFacade.getInstance().getVmDao().getAllForVdsGroup(cluster.getId());
    if (vmInCluster == null) {
        return true;
    }
    // Filter non HA Vms
    vmInCluster = LinqUtils.filter(vmInCluster, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.isAutoStartup();
        }
    });
    Map<Guid, List<VM>> hostToHaVmsMapping = mapVmToHost(vmInCluster);
    for (VDS host : hosts) {
        boolean isHaSafe = findReplacementForHost(cluster, host, hostToHaVmsMapping.get(host.getId()), hostsUnutilizedResources);
        if (!isHaSafe) {
            failedHosts.add(host);
        }
    }
    if (failedHosts.size() == 0) {
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean checkHaReservationStatusForCluster(VDSGroup cluster, List<VDS> failedHosts) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    // No hosts, return true
    if (hosts == null || hosts.isEmpty()) {
        return true;
    }
    // HA Reservation is not possible with less than 2 hosts
    if (hosts.size() < 2) {
        log.debugFormat("Cluster: {0} failed HA reservation check because there is only one host in the cluster", cluster.getName());
        failedHosts.addAll(hosts);
        return false;
    }
    // List of host id and cpu/ram free resources
    // for the outer Pair, first is host id second is a Pair of cpu and ram
    // for the inner Pair, first is cpu second is ram
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = getUnutilizedResources(hosts);
    Map<Guid, List<VM>> hostToHaVmsMapping = mapHaVmToHostByCluster(cluster.getId());
    for (VDS host : hosts) {
        if (hostToHaVmsMapping.get(host.getId()) != null) {
            boolean isHaSafe = findReplacementForHost(cluster, host, hostToHaVmsMapping.get(host.getId()), hostsUnutilizedResources);
            if (!isHaSafe) {
                failedHosts.add(host);
            }
        }
    }
    log.infoFormat("HA reservation status for cluster {0} is {1}", cluster.getName(), failedHosts.isEmpty() ? "OK" : "Failed");
    return failedHosts.isEmpty();
}
#end_block

#method_before
private boolean findReplacementForHost(VDSGroup cluster, VDS host, List<VM> vmList, List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources) {
    Map<Guid, Pair<Integer, Integer>> additionalHostsUtilizedResources = new HashMap<Guid, Pair<Integer, Integer>>();
    for (VM vm : vmList) {
        int curVmMemSize = (int) Math.round(vm.getMemSizeMb() * (vm.getUsageMemPercent() / 100.0));
        int curVmCpuPercent = vm.getUsageCpuPercent() * vm.getNumOfCpus() / SlaValidator.getEffectiveCpuCores(host, cluster.getCountThreadsAsCores());
        boolean foundForCurVm = false;
        for (Pair<Guid, Pair<Integer, Integer>> hostData : hostsUnutilizedResources) {
            // Make sure not to run on the same Host as the Host we are testing
            if (hostData.getFirst().equals(host.getId())) {
                continue;
            }
            // Check Memory and CPU
            if (hostData.getSecond() != null && hostData.getSecond().getSecond() != null && hostData.getSecond().getFirst() != null) {
                int memoryFree = hostData.getSecond().getSecond();
                int cpuFree = hostData.getSecond().getFirst();
                long additionalMemory = 0;
                int additionalCpu = 0;
                if (additionalHostsUtilizedResources.get(hostData.getFirst()) != null) {
                    additionalCpu = additionalHostsUtilizedResources.get(hostData.getFirst()).getFirst();
                    additionalMemory = additionalHostsUtilizedResources.get(hostData.getFirst()).getSecond();
                }
                if ((memoryFree - additionalMemory) >= curVmMemSize && (cpuFree - additionalCpu) >= curVmCpuPercent) {
                    // Found a place for current vm, add the RAM and CPU size to additionalHostsUtilizedResources
                    if (!additionalHostsUtilizedResources.containsKey(hostData.getFirst())) {
                        Pair<Integer, Long> cpuRamPair = new Pair<Integer, Long>();
                        cpuRamPair.setSecond(new Long(curVmMemSize));
                        cpuRamPair.setFirst(curVmCpuPercent);
                    } else {
                        Pair<Integer, Integer> cpuRamPair = additionalHostsUtilizedResources.get(hostData.getFirst());
                        cpuRamPair.setSecond(cpuRamPair.getSecond() + curVmMemSize);
                        cpuRamPair.setFirst(cpuRamPair.getFirst() + curVmCpuPercent);
                    }
                    foundForCurVm = true;
                    break;
                }
            }
        }
        if (!foundForCurVm) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean findReplacementForHost(VDSGroup cluster, VDS host, List<VM> vmList, List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources) {
    Map<Guid, Pair<Integer, Integer>> additionalHostsUtilizedResources = new HashMap<Guid, Pair<Integer, Integer>>();
    for (VM vm : vmList) {
        int curVmMemSize = 0;
        if (vm.getUsageMemPercent() != null) {
            curVmMemSize = (int) Math.round(vm.getMemSizeMb() * (vm.getUsageMemPercent() / 100.0));
        }
        int curVmCpuPercent = 0;
        if (vm.getUsageCpuPercent() != null) {
            curVmCpuPercent = vm.getUsageCpuPercent() * vm.getNumOfCpus() / SlaValidator.getEffectiveCpuCores(host, cluster.getCountThreadsAsCores());
        }
        log.debugFormat("VM {0}. CPU usage:{1}%, RAM usage:{2}MB", vm.getName(), curVmCpuPercent, curVmMemSize);
        boolean foundForCurVm = false;
        for (Pair<Guid, Pair<Integer, Integer>> hostData : hostsUnutilizedResources) {
            // Make sure not to run on the same Host as the Host we are testing
            if (hostData.getFirst().equals(host.getId())) {
                continue;
            }
            // Check Memory and CPU
            if (hostData.getSecond() != null && hostData.getSecond().getSecond() != null && hostData.getSecond().getFirst() != null) {
                int memoryFree = hostData.getSecond().getSecond();
                int cpuFree = hostData.getSecond().getFirst();
                long additionalMemory = 0;
                int additionalCpu = 0;
                if (additionalHostsUtilizedResources.get(hostData.getFirst()) != null) {
                    additionalCpu = additionalHostsUtilizedResources.get(hostData.getFirst()).getFirst();
                    additionalMemory = additionalHostsUtilizedResources.get(hostData.getFirst()).getSecond();
                }
                if ((memoryFree - additionalMemory) >= curVmMemSize && (cpuFree - additionalCpu) >= curVmCpuPercent) {
                    // Found a place for current vm, add the RAM and CPU size to additionalHostsUtilizedResources
                    Pair<Integer, Integer> cpuRamPair = additionalHostsUtilizedResources.get(hostData.getFirst());
                    if (cpuRamPair != null) {
                        cpuRamPair.setFirst(cpuRamPair.getFirst() + curVmCpuPercent);
                        cpuRamPair.setSecond(cpuRamPair.getSecond() + curVmMemSize);
                    } else {
                        cpuRamPair = new Pair<>(curVmCpuPercent, curVmMemSize);
                        additionalHostsUtilizedResources.put(hostData.getFirst(), cpuRamPair);
                    }
                    foundForCurVm = true;
                    break;
                }
            }
        }
        if (!foundForCurVm) {
            log.infoFormat("Did not found a replacement host for VM:{0}", vm.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private Map<Guid, List<VM>> mapVmToHost(List<VM> vms) {
    Map<Guid, List<VM>> hostToHaVmsMapping = new HashMap<Guid, List<VM>>();
    for (VM vm : vms) {
        if (vm.getRunOnVds() != null) {
            if (!hostToHaVmsMapping.containsKey(vm.getRunOnVds())) {
                List<VM> vmsOfHost = new ArrayList<VM>();
                vmsOfHost.add(vm);
                hostToHaVmsMapping.put(vm.getRunOnVds(), vmsOfHost);
            } else {
                hostToHaVmsMapping.get(vm.getRunOnVds()).add(vm);
            }
        }
    }
    return hostToHaVmsMapping;
}
#method_after
public static Map<Guid, List<VM>> mapVmToHost(List<VM> vms) {
    Map<Guid, List<VM>> hostToHaVmsMapping = new HashMap<>();
    for (VM vm : vms) {
        if (!Guid.isNullOrEmpty(vm.getRunOnVds())) {
            if (!hostToHaVmsMapping.containsKey(vm.getRunOnVds())) {
                List<VM> vmsOfHost = new ArrayList<VM>();
                vmsOfHost.add(vm);
                hostToHaVmsMapping.put(vm.getRunOnVds(), vmsOfHost);
            } else {
                hostToHaVmsMapping.get(vm.getRunOnVds()).add(vm);
            }
        }
    }
    return hostToHaVmsMapping;
}
#end_block

#method_before
private List<Pair<Guid, Pair<Integer, Integer>>> getUnutilizedResources(List<VDS> hosts) {
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = new ArrayList<Pair<Guid, Pair<Integer, Integer>>>();
    for (VDS host : hosts) {
        Pair<Integer, Integer> innerUnutilizedCpuRamPair = new Pair<Integer, Integer>();
        innerUnutilizedCpuRamPair.setFirst(100 - host.getUsageCpuPercent());
        int hostFreeMem = 0;
        if (host.getPhysicalMemMb() != null && host.getUsageMemPercent() != null) {
            int usedMem = (int) Math.round(host.getPhysicalMemMb() * (host.getUsageMemPercent() / 100.0));
            hostFreeMem = host.getPhysicalMemMb() - usedMem;
        }
        innerUnutilizedCpuRamPair.setSecond(hostFreeMem);
        Pair<Guid, Pair<Integer, Integer>> outerUnutilizedCpuRamPair = new Pair<Guid, Pair<Integer, Integer>>();
        outerUnutilizedCpuRamPair.setFirst(host.getId());
        outerUnutilizedCpuRamPair.setSecond(innerUnutilizedCpuRamPair);
        hostsUnutilizedResources.add(outerUnutilizedCpuRamPair);
    }
    return hostsUnutilizedResources;
}
#method_after
private List<Pair<Guid, Pair<Integer, Integer>>> getUnutilizedResources(List<VDS> hosts) {
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = new ArrayList<>();
    for (VDS host : hosts) {
        Pair<Integer, Integer> innerUnutilizedCpuRamPair = new Pair<>();
        int hostFreeCpu = 0;
        if (host.getUsageCpuPercent() != null) {
            hostFreeCpu = 100 - host.getUsageCpuPercent();
        }
        innerUnutilizedCpuRamPair.setFirst(hostFreeCpu);
        // Get available memory for the Host, round down to int
        int hostFreeMem = (int) host.getMaxSchedulingMemory();
        innerUnutilizedCpuRamPair.setSecond(hostFreeMem);
        Pair<Guid, Pair<Integer, Integer>> outerUnutilizedCpuRamPair = new Pair<>(host.getId(), innerUnutilizedCpuRamPair);
        hostsUnutilizedResources.add(outerUnutilizedCpuRamPair);
    }
    return hostsUnutilizedResources;
}
#end_block

#method_before
public static void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "performHaResevationCheck", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#method_after
public static void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debugFormat("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = new HaReservationHandling().checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    StringBuilder failedHostsStr = new StringBuilder();
                    int commaCount = returnedFailedHosts.size() - 1;
                    for (VDS host : returnedFailedHosts) {
                        failedHostsStr.append(host.getName());
                        if (commaCount > 0) {
                            failedHostsStr.append(", ");
                            commaCount--;
                        }
                    }
                    logable.addCustomValue("Hosts", failedHostsStr.toString());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                }
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(returnedFailedHosts, ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    Map<Guid, Integer> hostsHaVmCount = new HashMap<Guid, Integer>();
    // If the vm is not HA or the cluster is not marked as HA Reservation set default score.
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    if (!vm.isAutoStartup() || !vdsGroup.supportsHaReservation()) {
        fillDefaultScores(hosts, scores);
    } else {
        // Use a single call to the DB to retrieve all VM in the Cluster and map them by Host id
        Map<Guid, List<VM>> hostId2HaVmMapping = mapHaVmToHostByCluster(vdsGroup.getId());
        int maxCount = 0;
        for (VDS host : hosts) {
            int count = 0;
            if (hostId2HaVmMapping.containsKey(host.getId())) {
                count = hostId2HaVmMapping.get(host.getId()).size();
            }
            maxCount = (maxCount < count) ? count : maxCount;
            hostsHaVmCount.put(host.getId(), count);
        }
        // Fit count to scale of 0 to RATIO_FACTOR
        if (maxCount > 0) {
            for (VDS host : hosts) {
                int fittedCount = Math.round(hostsHaVmCount.get(host.getId()).floatValue() / maxCount * RATIO_FACTOR);
                hostsHaVmCount.put(host.getId(), fittedCount);
            }
        }
        // Get scale down param
        Integer scaleDownParameter = 1;
        if (parameters.get("ScaleDown") != null) {
            scaleDownParameter = Integer.parseInt(parameters.get("ScaleDown"));
        } else {
            scaleDownParameter = Config.<Integer>getValue(ConfigValues.ScaleDownForHaReservation);
        }
        // Set the score pairs
        for (VDS host : hosts) {
            // Scale down if needed
            int haCount = hostsHaVmCount.get(host.getId());
            haCount = (int) Math.ceil(haCount / scaleDownParameter.floatValue());
            scores.add(new Pair<Guid, Integer>(host.getId(), haCount));
        }
    }
    return scores;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.info("Started HA reservation scoring method");
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    Map<Guid, Integer> hostsHaVmCount = new HashMap<Guid, Integer>();
    // If the vm is not HA or the cluster is not marked as HA Reservation set default score.
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    if (!vm.isAutoStartup() || !vdsGroup.supportsHaReservation()) {
        fillDefaultScores(hosts, scores);
    } else {
        // Use a single call to the DB to retrieve all VM in the Cluster and map them by Host id
        Map<Guid, List<VM>> hostId2HaVmMapping = HaReservationHandling.mapHaVmToHostByCluster(vdsGroup.getId());
        int maxCount = 0;
        for (VDS host : hosts) {
            int count = 0;
            if (hostId2HaVmMapping.containsKey(host.getId())) {
                count = hostId2HaVmMapping.get(host.getId()).size();
            }
            maxCount = (maxCount < count) ? count : maxCount;
            hostsHaVmCount.put(host.getId(), count);
        }
        // Fit count to scale of 0 to RATIO_FACTOR
        if (maxCount > 0) {
            for (VDS host : hosts) {
                int fittedCount = Math.round(hostsHaVmCount.get(host.getId()).floatValue() / maxCount * RATIO_FACTOR);
                hostsHaVmCount.put(host.getId(), fittedCount);
            }
        }
        // Get scale down param
        Integer scaleDownParameter = 1;
        if (parameters.get("ScaleDown") != null) {
            scaleDownParameter = Integer.parseInt(parameters.get("ScaleDown"));
        } else {
            scaleDownParameter = Config.<Integer>getValue(ConfigValues.ScaleDownForHaReservation);
        }
        // Set the score pairs
        for (VDS host : hosts) {
            // Scale down if needed
            int haCount = hostsHaVmCount.get(host.getId());
            haCount = (int) Math.ceil(haCount / scaleDownParameter.floatValue());
            scores.add(new Pair<Guid, Integer>(host.getId(), haCount));
            log.infoFormat("Score for host:{0} is {1}", host.getName(), haCount);
        }
    }
    return scores;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    if (!cluster.supportsHaReservation()) {
        return null;
    }
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    int haVmsInCluster = 0;
    Map<Guid, List<VM>> hostId2HaVmMapping = mapHaVmToHostByCluster(cluster.getId());
    haVmsInCluster = countHaVmsInCluster(hostId2HaVmMapping);
    int optimalHaDistribution = (int) Math.ceil(((double) haVmsInCluster / hosts.size()));
    int overUtilizationParam = 100;
    if (parameters.get("OverUtilization") != null) {
        overUtilizationParam = Integer.parseInt(parameters.get("OverUtilization"));
    } else {
        overUtilizationParam = Config.<Integer>getValue(ConfigValues.OverUtilizationForHaReservation);
    }
    int overUtilizationThreshold = (int) Math.ceil(optimalHaDistribution * (overUtilizationParam / 100));
    List<VDS> overUtilizedHosts = getOverUtilizedHosts(hosts, hostId2HaVmMapping, optimalHaDistribution);
    if (overUtilizedHosts.size() == 0) {
        return null;
    }
    List<VDS> underUtilizedHosts = getUnderUtilizedHosts(hosts, hostId2HaVmMapping, overUtilizationParam);
    if (underUtilizedHosts.size() == 0) {
        return null;
    }
    // Get random host from the over utilized hosts
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId(), hostId2HaVmMapping);
    if (migrableVmsOnRandomHost.isEmpty()) {
        return null;
    }
    // Get random vm to migrate
    VM vm = migrableVmsOnRandomHost.get(new Random().nextInt(migrableVmsOnRandomHost.size()));
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.debugFormat("Started HA reservation balancing method for cluster: {0}", cluster.getName());
    if (!cluster.supportsHaReservation()) {
        return null;
    }
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    int haVmsInCluster = 0;
    Map<Guid, List<VM>> hostId2HaVmMapping = HaReservationHandling.mapHaVmToHostByCluster(cluster.getId());
    haVmsInCluster = countHaVmsInCluster(hostId2HaVmMapping);
    int optimalHaDistribution = (int) Math.ceil(((double) haVmsInCluster / hosts.size()));
    int overUtilizationParam = DEFAULT_OVER_UTILIZATION_VALUE;
    if (parameters.get("OverUtilization") != null) {
        overUtilizationParam = NumberUtils.toInt(parameters.get("OverUtilization"));
    } else {
        overUtilizationParam = Config.<Integer>getValue(ConfigValues.OverUtilizationForHaReservation);
    }
    log.debugFormat("optimalHaDistribution value:{0}", optimalHaDistribution);
    int overUtilizationThreshold = (int) Math.ceil(optimalHaDistribution * (overUtilizationParam / 100.0));
    log.debugFormat("overUtilizationThreshold value: {0}", overUtilizationThreshold);
    List<VDS> overUtilizedHosts = getHostUtilizedByCondition(hosts, hostId2HaVmMapping, overUtilizationThreshold, Condition.MORE_THAN);
    if (overUtilizedHosts.isEmpty()) {
        log.debugFormat("No over utilized hosts for cluster: {0}", cluster.getName());
        return null;
    }
    List<VDS> underUtilizedHosts = getHostUtilizedByCondition(hosts, hostId2HaVmMapping, overUtilizationParam, Condition.LESS_THAN);
    if (underUtilizedHosts.size() == 0) {
        log.debugFormat("No under utilized hosts for cluster: {0}", cluster.getName());
        return null;
    }
    // Get random host from the over utilized hosts
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId(), hostId2HaVmMapping);
    if (migrableVmsOnRandomHost.isEmpty()) {
        log.debugFormat("No migratable hosts were found for cluster: {0} ", cluster.getName());
        return null;
    }
    // Get random vm to migrate
    VM vm = migrableVmsOnRandomHost.get(new Random().nextInt(migrableVmsOnRandomHost.size()));
    log.infoFormat("VM to be migrated:{0}", vm.getName());
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#end_block

#method_before
private List<VM> getMigrableVmsRunningOnVds(final Guid hostId, Map<Guid, List<VM>> hostId2HaVmMapping) {
    List<VM> vms = hostId2HaVmMapping.get(hostId);
    vms = LinqUtils.filter(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.getMigrationSupport() == MigrationSupport.MIGRATABLE && !hostId.equals(v.getDedicatedVmForVds());
        }
    });
    return vms;
}
#method_after
private List<VM> getMigrableVmsRunningOnVds(final Guid hostId, Map<Guid, List<VM>> hostId2HaVmMapping) {
    List<VM> vms = hostId2HaVmMapping.get(hostId);
    vms = LinqUtils.filter(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.getMigrationSupport() == MigrationSupport.MIGRATABLE;
        }
    });
    return vms;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    ExtendedVmDynamic other = (ExtendedVmDynamic) obj;
    return ObjectUtils.objectsEqual(host, other.host);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    ExtendedVmDynamic other = (ExtendedVmDynamic) obj;
    return Objects.equals(host, other.host);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (host != null ? host.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + Objects.hashCode(host);
    return result;
}
#end_block

#method_before
public static void main(String[] args) {
    NotificationProperties prop = null;
    initLogging();
    try {
        prop = NotificationProperties.getInstance();
        prop.validate();
    } catch (Exception ex) {
        log.error("Failed to parse configuration.", ex);
        System.exit(1);
    }
    if (args != null && args.length > 0 && ARG_VALIDATE.equals(args[0])) {
        // command line argument to validate only entered
        System.exit(0);
    }
    NotifierSignalHandler handler = new NotifierSignalHandler();
    handler.addScheduledExecutorService(notifyScheduler);
    handler.addScheduledExecutorService(monitorScheduler);
    Runtime.getRuntime().addShutdownHook(handler);
    NotificationService notificationService = null;
    EngineMonitorService engineMonitorService = null;
    try {
        notificationService = new NotificationService(prop);
        engineMonitorService = new EngineMonitorService(prop);
        // add notification service to scheduler with its configurable interval
        handler.addServiceHandler(notifyScheduler.scheduleWithFixedDelay(notificationService, 1, prop.getLong(NotificationProperties.INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
        // add engine monitor service to scheduler with its configurable interval
        handler.addServiceHandler(monitorScheduler.scheduleWithFixedDelay(engineMonitorService, 1, prop.getLong(NotificationProperties.ENGINE_INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
    } catch (Exception e) {
        log.error("Failed to run the event notification service. ", e);
        // flag exit code to calling script after threads shut down.
        System.exit(1);
    }
}
#method_after
public static void main(String[] args) {
    NotificationProperties prop = null;
    initLogging();
    try {
        prop = NotificationProperties.getInstance();
        prop.validate();
    } catch (Exception ex) {
        log.error("Failed to parse configuration.", ex);
        // print error also to stderr to be seen in console during service startup
        System.err.println(ex.getMessage());
        System.exit(1);
    }
    if (args != null && args.length > 0 && ARG_VALIDATE.equals(args[0])) {
        // command line argument to validate only entered
        System.exit(0);
    }
    NotifierSignalHandler handler = new NotifierSignalHandler();
    handler.addScheduledExecutorService(notifyScheduler);
    handler.addScheduledExecutorService(monitorScheduler);
    Runtime.getRuntime().addShutdownHook(handler);
    try {
        NotificationService notificationService = new NotificationService(prop);
        EngineMonitorService engineMonitorService = new EngineMonitorService(prop);
        // add notification service to scheduler with its configurable interval
        handler.addServiceHandler(notifyScheduler.scheduleWithFixedDelay(notificationService, 1, prop.getLong(NotificationProperties.INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
        // add engine monitor service to scheduler with its configurable interval
        handler.addServiceHandler(monitorScheduler.scheduleWithFixedDelay(engineMonitorService, 1, prop.getLong(NotificationProperties.ENGINE_INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
    } catch (Exception e) {
        log.error("Failed to run the event notification service. ", e);
        // flag exit code to calling script after threads shut down.
        System.exit(1);
    }
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (cluster.getArchitecture() == ArchitectureType.undefined) {
                throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("The selected cluster does not have architecture, please set it before adding vms.").build());
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                replaceDefaultOs(staticVm, cluster);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetDisplay()) {
                staticVm.setDefaultDisplayType(null);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = (item instanceof VM) ? consoleModelsCache.getVmConsolesForVmId(((VM) item).getId()) : consoleModelsCache.getVmConsolesForPoolId(((VmPool) item).getVmPoolId());
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = (item instanceof VM) ? consoleModelsCache.getVmConsolesForVmId(((VM) item).getId()) : consoleModelsCache.getVmConsolesForPoolId(((VmPool) item).getVmPoolId());
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#end_block

#method_before
private void storeConsolesInternal(VmConsoles consoles, boolean isPool) {
    ConsoleProtocol selectedProtocol = consoles.getSelectedProcotol();
    ConsoleContext context = consoles.getConsoleContext();
    String id = isPool ? consoles.getVm().getVmPoolId().toString() : consoles.getVm().getId().toString();
    KeyMaker keyMaker = new KeyMaker(id, isPool, context);
    clientStorage.setLocalItem(keyMaker.make(SELECTED_PROTOCOL), selectedProtocol.toString());
    if (selectedProtocol == ConsoleProtocol.SPICE) {
        storeSpiceData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.VNC) {
        storeVncData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.RDP) {
        storeRdpData(consoles, keyMaker);
    }
}
#method_after
private void storeConsolesInternal(VmConsoles consoles, boolean isPool) {
    ConsoleProtocol selectedProtocol = consoles.getSelectedProcotol();
    ConsoleContext context = consoles.getConsoleContext();
    String id = consoles.getEntityId().toString();
    KeyMaker keyMaker = new KeyMaker(id, isPool, context);
    clientStorage.setLocalItem(keyMaker.make(SELECTED_PROTOCOL), selectedProtocol.toString());
    if (selectedProtocol == ConsoleProtocol.SPICE) {
        storeSpiceData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.VNC) {
        storeVncData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.RDP) {
        storeRdpData(consoles, keyMaker);
    }
}
#end_block

#method_before
@Override
public void loadFromLocalStorage(VmConsoles consoles) {
    String vmId = guidToStringNullSafe(consoles.getVm().getId());
    String poolId = guidToStringNullSafe(consoles.getVm().getVmPoolId());
    ConsoleContext context = consoles.getConsoleContext();
    KeyMaker poolKeyMaker = new KeyMaker(poolId, true, context);
    // load pool defaults
    loadConsolesWithKeymaker(consoles, poolKeyMaker);
    if (consoles instanceof VmConsolesImpl) {
        KeyMaker vmKeyMaker = new KeyMaker(vmId, false, context);
        // load vm
        loadConsolesWithKeymaker(consoles, vmKeyMaker);
    }
}
#method_after
@Override
public void loadFromLocalStorage(VmConsoles consoles) {
    String vmId = guidToStringNullSafe(consoles.getVm().getId());
    String poolId = guidToStringNullSafe(consoles.getVm().getVmPoolId());
    ConsoleContext context = consoles.getConsoleContext();
    if (poolId != null) {
        KeyMaker poolKeyMaker = new KeyMaker(poolId, true, context);
        // load pool defaults
        loadConsolesWithKeymaker(consoles, poolKeyMaker);
    }
    if (consoles instanceof VmConsolesImpl) {
        KeyMaker vmKeyMaker = new KeyMaker(vmId, false, context);
        // load vm
        loadConsolesWithKeymaker(consoles, vmKeyMaker);
    }
}
#end_block

#method_before
public String make(String key) {
    return vmOrPoolId + isPool + context + key;
}
#method_after
public String make(String key) {
    return id + isPool + context + key;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    // todo revisit this, connectAutomatically flag may not be needed
    if (connectAutomatically.readConnectAutomatically() && model.getCanConnectAutomatically() && !alreadyOpened) {
        try {
            model.getAutoConnectableConsoles().get(0).connect();
            alreadyOpened = true;
        } catch (VmConsoles.ConsoleConnectException e) {
            errorPopupManager.show(e.getLocalizedErrorMessage());
        }
    }
    unregisterModels();
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    if (connectAutomatically.readConnectAutomatically() && model.getCanConnectAutomatically() && !alreadyOpened) {
        try {
            model.getAutoConnectableConsoles().get(0).connect();
            alreadyOpened = true;
        } catch (VmConsoles.ConsoleConnectException e) {
            errorPopupManager.show(e.getLocalizedErrorMessage());
        }
    }
    unregisterModels();
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVmId((((VM) getSelectedItem()).getId()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVmId(vm.getId()).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVmId(vm.getId()).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
@Override
protected boolean shouldRenderCell(UserPortalItemModel model) {
    return model.isPool() || model.getVM().isRunningOrPaused();
}
#method_after
@Override
protected boolean shouldRenderCell(UserPortalItemModel model) {
    return model.isPool() || (model.getVM() != null) && model.getVM().isRunningOrPaused();
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/watchDogModels").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/displayProtocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Test
public void testLoadOverridingFiles() throws Exception {
    Assert.assertEquals("qxl/qxl", OsInfoPreferencesLoader.INSTANCE.getPreferences().node("/os/default/displayProtocols").get("value", "qxl/qxl"));
}
#method_after
@Test
public void testLoadOverridingFiles() throws Exception {
    Assert.assertEquals("qxl/qxl", OsInfoPreferencesLoader.INSTANCE.getPreferences().node("/os/default/devices/display/protocols").get("value", "qxl/qxl"));
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.ImageLocked);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setAppList(getParameters().getVm().getDynamicData().getAppList());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#method_after
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.ImageLocked);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setLastStopTime(new Date());
    tempVar.setAppList(getParameters().getVm().getDynamicData().getAppList());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), false);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
@Before
public void setUp() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    final Version version = Version.v3_0;
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<Integer, Map<Version, List<DisplayType>>>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    vm.setVdsGroupId(group.getId());
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<Integer, Map<Version, List<DisplayType>>>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
}
#method_after
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(getVmId());
}
#method_after
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
public static boolean isDisplayTypeSupported(int osId, DisplayType defaultDisplayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isDisplayTypeSupported(osId, clusterVersion, defaultDisplayType);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.toString());
    }
    return result;
}
#method_after
public static boolean isDisplayTypeSupported(int osId, DisplayType defaultDisplayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isDisplayTypeSupported(osId, clusterVersion, defaultDisplayType);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
            // Check if the display type is supported
            if (!VmHandler.isDisplayTypeSupported(vm.getOs(), vm.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
                return false;
            }
            if (VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()) && !FeatureSupported.virtIoScsi(targetCluster.getcompatibility_version())) {
                return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
            // Check if the display type is supported
            if (!VmHandler.isDisplayTypeSupported(vm.getOs(), vm.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
                return false;
            }
            if (VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()) && !FeatureSupported.virtIoScsi(targetCluster.getcompatibility_version())) {
                return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
            }
            // A existing VM cannot be changed into a cluster without a defined architecture
            if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
            } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName()) && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    } else {
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CLUSTER_IS_NOT_VALID);
        } else if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && isDomainLegal(getParameters().getVmTemplateData().getDomain(), getReturnValue().getCanDoActionMessages())) {
            returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
            if (!returnValue) {
                addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
            }
        }
    }
    // Check that the USB policy is legal
    if (returnValue) {
        returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isDisplayTypeSupported(getParameters().getVmTemplateData().getOsId(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName()) && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    } else {
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CLUSTER_IS_NOT_VALID);
        } else if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && isDomainLegal(getParameters().getVmTemplateData().getDomain(), getReturnValue().getCanDoActionMessages())) {
            returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
            if (!returnValue) {
                addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
            }
        }
    }
    // Check that the USB policy is legal
    if (returnValue) {
        returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isDisplayTypeSupported(getParameters().getVmTemplateData().getOsId(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean hasWatchdog(Guid templateId) {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(templateId);
}
#method_after
protected boolean hasWatchdog(Guid templateId) {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
public Map<String, Action> loadParametersMetaData() {
    parametersMetaData = new HashMap<String, Action>();
    try {
        InputStream stream = FileUtils.get(RESOURCES_PACKAGE, PARAMS_METADATA);
        if (stream != null) {
            Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
            Object result = new Yaml(constructor).load(stream);
            for (Action action : ((MetaData) result).getActions()) {
                parametersMetaData.put(uriInfo.getBaseUri().getPath() + action.getName(), action);
            }
        } else {
            LOG.error("Parameters metatdata file not found.");
        }
    } catch (Exception e) {
        LOG.error("Loading parameters metatdata failed.", e);
    }
    return parametersMetaData;
}
#method_after
public Map<String, Action> loadParametersMetaData() {
    parametersMetaData = new HashMap<String, Action>();
    try {
        InputStream stream = FileUtils.get(RESOURCES_PACKAGE, PARAMS_METADATA);
        if (stream != null) {
            Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
            Object result = new Yaml(constructor).load(stream);
            /**
             * uriInfo.getBaseUri().getPath() might be: /ovirt-engine/api/ (with trailing '/') or: /ovirt-engine/api
             * (without trailing '/') - depending on the context of the request. The reason for this variability is
             * not clear. In any case - we assume no trailing '/' when creating the action name, so we add a check
             * and eliminate the trailing slash if necessary.
             */
            String baseUri = uriInfo.getBaseUri().getPath();
            if (baseUri.endsWith("/")) {
                baseUri = baseUri.substring(0, baseUri.length() - 1);
            }
            for (Action action : ((MetaData) result).getActions()) {
                parametersMetaData.put(baseUri + action.getName(), action);
            }
        } else {
            LOG.error("Parameters metatdata file not found.");
        }
    } catch (Exception e) {
        LOG.error("Loading parameters metatdata failed.", e);
    }
    return parametersMetaData;
}
#end_block

#method_before
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    List<String> paths = applicationMode == ApplicationMode.GlusterOnly ? ApiUtils.getGlusterRels(uriInfo) : ApiUtils.getAllRels(uriInfo);
    for (String path : paths) {
        Class<?> resource = findResource(path, classes);
        String entryPointPath = uriInfo.getBaseUri().getPath();
        String prefix = entryPointPath.endsWith("/") ? entryPointPath + path : entryPointPath + "/" + path;
        results.addAll(describe(resource, prefix, new HashMap<String, Type>()));
    }
    return results;
}
#method_after
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    String entryPointPath = uriInfo.getBaseUri().getPath();
    for (String path : rels) {
        Class<?> resource = findResource(path, classes);
        String prefix = entryPointPath.endsWith("/") ? entryPointPath + path : entryPointPath + "/" + path;
        results.addAll(describe(resource, prefix, new HashMap<String, Type>()));
    }
    return results;
}
#end_block

#method_before
private DetailedLink findUsage(RSDL rsdl, UriInfo uriInfo, String httpMethod) {
    for (DetailedLink link : rsdl.getLinks().getLinks()) {
        if (isMatch(link, uriInfo, httpMethod)) {
            return link;
        }
    }
    // should never happen
    return null;
}
#method_after
private DetailedLink findUsage(RSDL rsdl, UriInfo uriInfo, String httpMethod) {
    DetailedLink link = null;
    for (DetailedLink currentLink : rsdl.getLinks().getLinks()) {
        if (isMatch(currentLink, uriInfo, httpMethod)) {
            link = currentLink;
            break;
        }
    }
    assert (link != null) : "Corresponding link not found (this should not happen)";
    return link;
}
#end_block

#method_before
private RSDL getRSDL(Application application) {
    for (Object obj : application.getSingletons()) {
        if (obj instanceof BackendApiResource) {
            BackendApiResource resource = (BackendApiResource) obj;
            return resource.getRSDL();
        }
    }
    // should never happen
    return null;
}
#method_after
private RSDL getRSDL(Application application) {
    RSDL rsdl = null;
    for (Object obj : application.getSingletons()) {
        if (obj instanceof BackendApiResource) {
            BackendApiResource resource = (BackendApiResource) obj;
            rsdl = resource.getRSDL();
            break;
        }
    }
    assert (rsdl != null) : "Resource that generates RSDL, BackendApiResource, not found (this should never happen)";
    return rsdl;
}
#end_block

#method_before
private boolean isMatch(DetailedLink link, UriInfo uriInfo, String httpMethod) {
    int baseUriLength = uriInfo.getBaseUri().getPath().length();
    // e.g: [vms, {vm:id}, start]
    String[] linkPathSegments = link.getHref().substring(baseUriLength).split("/");
    // e.g: [vms, f26b0918-8e16-4915-b1c2-7f39e568de23, start]
    List<PathSegment> uriPathSegments = uriInfo.getPathSegments();
    return isMatchLength(linkPathSegments, uriPathSegments) && isMatchePath(linkPathSegments, uriPathSegments) && isMatchRel(link.getRel(), httpMethod);
}
#method_after
private boolean isMatch(DetailedLink link, UriInfo uriInfo, String httpMethod) {
    int baseUriLength = uriInfo.getBaseUri().getPath().length();
    // e.g: [vms, {vm:id}, start]
    String[] linkPathSegments = link.getHref().substring(baseUriLength).split("/");
    // e.g: [vms, f26b0918-8e16-4915-b1c2-7f39e568de23, start]
    List<PathSegment> uriPathSegments = uriInfo.getPathSegments();
    return isMatchLength(linkPathSegments, uriPathSegments) && isMatchPath(linkPathSegments, uriPathSegments) && isMatchRel(link.getRel(), httpMethod);
}
#end_block

#method_before
private Collection<DetailedLink> getLinks() {
    return ApiUtils.getLinks(getUriInfo());
}
#method_after
private Collection<DetailedLink> getLinks() {
    return ApiRootLinksCreator.getLinks(getUriInfo());
}
#end_block

#method_before
private Collection<DetailedLink> getGlusterLinks() {
    return ApiUtils.getGlusterLinks(getUriInfo());
}
#method_after
private Collection<DetailedLink> getGlusterLinks() {
    return ApiRootLinksCreator.getGlusterLinks(getUriInfo());
}
#end_block

#method_before
public synchronized RSDL getRSDL() {
    if (rsdl == null) {
        rsdl = new RsdlBuilder(getUriInfo(), getCurrent().get(ApplicationMode.class)).description(RSDL_DESCRIPTION).rel(RSDL_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).schema(new SchemaBuilder().rel(SCHEMA_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + SCHEMA_CONSTRAINT_PARAMETER).name(SCHEMA_NAME).description(SCHEMA_DESCRIPTION).build()).generalMetadata(new GeneralMetadataBuilder().rel(GENERAL_METADATA_REL).href(getUriInfo().getBaseUri().getPath().replace("api", "*")).name(GENERAL_METADATA_NAME).description(GENERAL_METADATA_DESCRIPTION).build()).build();
    }
    return rsdl;
}
#method_after
public synchronized RSDL getRSDL() {
    if (rsdl == null) {
        List<String> rels = getCurrent().get(ApplicationMode.class) == ApplicationMode.GlusterOnly ? ApiRootLinksCreator.getGlusterRels(uriInfo) : ApiRootLinksCreator.getAllRels(uriInfo);
        rsdl = new RsdlBuilder(getUriInfo(), rels).description(RSDL_DESCRIPTION).rel(RSDL_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).schema(new SchemaBuilder().rel(SCHEMA_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + SCHEMA_CONSTRAINT_PARAMETER).name(SCHEMA_NAME).description(SCHEMA_DESCRIPTION).build()).generalMetadata(new GeneralMetadataBuilder().rel(GENERAL_METADATA_REL).href(getUriInfo().getBaseUri().getPath().replace("api", "*")).name(GENERAL_METADATA_NAME).description(GENERAL_METADATA_DESCRIPTION).build()).build();
    }
    return rsdl;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.ILLEGAL) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
    }
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
        return false;
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = new DiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isOsSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (disk.isAllowSnapshot()) {
        updateDiskVmSnapshotId();
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!isOperationPerformedOnDiskSnapshot()) {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
    }
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (!isOperationPerformedOnDiskSnapshot()) {
        if (disk.isAllowSnapshot()) {
            updateDiskVmSnapshotId();
        }
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#end_block

#method_before
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), false, "", null);
}
#method_after
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), getParameters().isReadOnly(), "", null, getParameters().getSnapshotId());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<Disk> diskList = DbFacade.getInstance().getDiskDao().getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    ArrayList<Disk> filteredDiskList = new ArrayList<Disk>();
    VM vm = DbFacade.getInstance().getVmDao().get(getParameters().getVmId());
    List<String> supportedDiskInterfaceNames = getOsRepository().getDiskInterfaces(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    List<DiskInterface> supportedDiskInterfaces = new ArrayList<DiskInterface>();
    for (String interfaceName : supportedDiskInterfaceNames) {
        try {
            supportedDiskInterfaces.add(DiskInterface.valueOf(interfaceName));
        } catch (IllegalArgumentException e) {
        // ignore if we can't find the enum value.
        }
    }
    for (Disk disk : diskList) {
        if (supportedDiskInterfaces.contains(disk.getDiskInterface())) {
            filteredDiskList.add(disk);
        }
    }
    setReturnValue(filteredDiskList);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<Disk> diskList = DbFacade.getInstance().getDiskDao().getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (CollectionUtils.isEmpty(diskList)) {
        setReturnValue(new ArrayList<>());
        return;
    }
    VM vm = DbFacade.getInstance().getVmDao().get(getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (vm == null) {
        setReturnValue(new ArrayList<>());
        return;
    }
    List<Disk> filteredDiskList = new ArrayList<>();
    for (Disk disk : diskList) {
        if (VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), disk.getDiskInterface())) {
            filteredDiskList.add(disk);
        }
    }
    setReturnValue(filteredDiskList);
}
#end_block

#method_before
public OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
protected OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
public ValidationResult isVirtIoScsiValid(VM vm) {
    if (DiskInterface.VirtIO_SCSI != disk.getDiskInterface()) {
        return ValidationResult.VALID;
    }
    if (disk.getSgio() != null) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            return new ValidationResult(VdcBllMessages.SCSI_GENERIC_IO_IS_NOT_SUPPORTED_FOR_IMAGE_DISK);
        }
    }
    if (vm != null) {
        if (!FeatureSupported.virtIoScsi(vm.getVdsGroupCompatibilityVersion())) {
            return new ValidationResult(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        return isOsSupportedForVirtIoScsi(vm);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isVirtIoScsiValid(VM vm) {
    if (DiskInterface.VirtIO_SCSI != disk.getDiskInterface()) {
        return ValidationResult.VALID;
    }
    if (disk.getSgio() != null) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            return new ValidationResult(VdcBllMessages.SCSI_GENERIC_IO_IS_NOT_SUPPORTED_FOR_IMAGE_DISK);
        }
    }
    if (vm != null) {
        if (!FeatureSupported.virtIoScsi(vm.getVdsGroupCompatibilityVersion())) {
            return new ValidationResult(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        if (!isVirtioScsiControllerAttached(vm.getId())) {
            return new ValidationResult(VdcBllMessages.CANNOT_PERFORM_ACTION_VIRTIO_SCSI_IS_DISABLED);
        }
        return isOsSupportedForVirtIoScsi(vm);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isOsSupportedForVirtIoScsi(VM vm) {
    // TODO move this config val to osinfo
    final List<String> unsupportedOSs = Config.<List<String>>GetValue(ConfigValues.VirtIoScsiUnsupportedOsList);
    String vmOs = SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(vm.getVmOsId());
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isOsSupportedForVirtIoScsi(VM vm) {
    if (!VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), DiskInterface.VirtIO_SCSI)) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isDiskInterfaceSupported(int osId, Version version) {
    List<String> supportedDiskInterfaceNames = getOsRepository().getDiskInterfaces(osId, version);
    List<DiskInterface> supportedDiskInterfaces = new ArrayList<DiskInterface>();
    for (String interfaceName : supportedDiskInterfaceNames) {
        try {
            supportedDiskInterfaces.add(DiskInterface.valueOf(interfaceName));
        } catch (IllegalArgumentException e) {
        // ignore if we can't find the enum value.
        }
    }
    return (!supportedDiskInterfaces.contains(disk.getDiskInterface())) ? new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED) : ValidationResult.VALID;
}
#method_after
public ValidationResult isDiskInterfaceSupported(VM vm) {
    if (vm != null) {
        if (!VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), disk.getDiskInterface())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED, String.format("$osName %s", getOsRepository().getOsName(vm.getOs())));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
private void addVideoCardByDisplayType(DisplayType displayType, int numOfMonitors, boolean singleQxlPci) {
    Map<String, Object> struct = new HashMap<String, Object>();
    VmDeviceType vmDeviceType = getOsRepository().getDisplayDevice(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), displayType);
    // create a monitor as an unmanaged device
    struct.put(VdsProperties.Type, VmDeviceGeneralType.VIDEO.getValue());
    struct.put(VdsProperties.Device, vmDeviceType);
    struct.put(VdsProperties.SpecParams, getNewMonitorSpecParams(displayType, numOfMonitors, singleQxlPci));
    struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
    devices.add(struct);
}
#method_after
private void addVideoCardByDisplayType(DisplayType displayType, int numOfMonitors, boolean singleQxlPci) {
    Map<String, Object> struct = new HashMap<String, Object>();
    VmDeviceType vmDeviceType = getOsRepository().getDisplayDevice(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), displayType);
    // create a monitor as an unmanaged device
    struct.put(VdsProperties.Type, VmDeviceGeneralType.VIDEO.getValue());
    struct.put(VdsProperties.Device, vmDeviceType.getName());
    struct.put(VdsProperties.SpecParams, getNewMonitorSpecParams(displayType, numOfMonitors, singleQxlPci));
    struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
    devices.add(struct);
}
#end_block

#method_before
private OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForVirtioScsiDisk(unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    if (vnicProfile.getNetworkQosId() != null) {
        if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
            return false;
        }
        NetworkQoS networkQoS = DbFacade.getInstance().getQosDao().get(vnicProfile.getNetworkQosId());
        if (networkQoS != null) {
            Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
            if (specParams == null) {
                specParams = new HashMap<>();
                struct.put(VdsProperties.SpecParams, specParams);
            }
            addQosData(specParams, VdsProperties.QOS_INBOUND, networkQoS.getInboundAverage(), networkQoS.getInboundPeak(), networkQoS.getInboundBurst());
            addQosData(specParams, VdsProperties.QOS_OUTBOUND, networkQoS.getOutboundAverage(), networkQoS.getOutboundPeak(), networkQoS.getOutboundBurst());
        }
    }
    return true;
}
#method_after
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (qosId != null) {
        if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
            return false;
        }
        Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
        if (specParams == null) {
            specParams = new HashMap<>();
            struct.put(VdsProperties.SpecParams, specParams);
        }
        NetworkQoS networkQoS = DbFacade.getInstance().getQosDao().get(qosId);
        NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
        qosMapper.serialize(networkQoS);
    }
    return true;
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    // IDE slot 2 is reserved by VDSM to CDROM
    struct.put(VdsProperties.Index, "2");
    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    List<Disk> disks = new ArrayList<Disk>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForVirtioScsiDisk(vmDeviceUnitMap);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
}
#end_block

#method_before
private static List<VmDevice> getPluggedInterfaces(List<VmDevice> devices) {
    ArrayList<VmDevice> result = new ArrayList<VmDevice>();
    for (VmDevice device : devices) {
        if (isBridge(device) && device.getIsPlugged()) {
            result.add(device);
        }
    }
    return result;
}
#method_after
private static List<VmDevice> getPluggedInterfaces(List<VmDevice> devices) {
    List<VmDevice> result = new ArrayList<VmDevice>();
    for (VmDevice device : devices) {
        if (isBridge(device) && device.getIsPlugged()) {
            result.add(device);
        }
    }
    return result;
}
#end_block

#method_before
private static List<VmDevice> sortInterfacesByName(VM vm, List<VmDevice> pluggedInterfaces) {
    if (pluggedInterfaces.size() < 2) {
        return pluggedInterfaces;
    }
    final HashMap<Guid, String> deviceIdToIfaceName = new HashMap<Guid, String>();
    for (VmNetworkInterface iface : vm.getInterfaces()) {
        deviceIdToIfaceName.put(iface.getId(), iface.getName());
    }
    Collections.sort(pluggedInterfaces, new Comparator<VmDevice>() {

        @Override
        public int compare(VmDevice first, VmDevice second) {
            Guid firstDeviceId = first.getId().getDeviceId();
            Guid secondDeviceId = second.getId().getDeviceId();
            String firstIfaceName = deviceIdToIfaceName.get(firstDeviceId);
            String secondIfaceName = deviceIdToIfaceName.get(secondDeviceId);
            return firstIfaceName.compareTo(secondIfaceName);
        }
    });
    return pluggedInterfaces;
}
#method_after
private static List<VmDevice> sortInterfacesByName(VM vm, List<VmDevice> pluggedInterfaces) {
    if (pluggedInterfaces.size() < 2) {
        return pluggedInterfaces;
    }
    final Map<Guid, String> deviceIdToIfaceName = new HashMap<Guid, String>();
    for (VmNetworkInterface iface : vm.getInterfaces()) {
        deviceIdToIfaceName.put(iface.getId(), iface.getName());
    }
    Collections.sort(pluggedInterfaces, new Comparator<VmDevice>() {

        @Override
        public int compare(VmDevice first, VmDevice second) {
            Guid firstDeviceId = first.getId().getDeviceId();
            Guid secondDeviceId = second.getId().getDeviceId();
            String firstIfaceName = deviceIdToIfaceName.get(firstDeviceId);
            String secondIfaceName = deviceIdToIfaceName.get(secondDeviceId);
            return firstIfaceName.compareTo(secondIfaceName);
        }
    });
    return pluggedInterfaces;
}
#end_block

#method_before
public void setName(EntityModel<String> name) {
    this.name = name;
}
#method_after
private void setName(EntityModel<String> name) {
    this.name = name;
}
#end_block

#method_before
public void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#method_after
private void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#end_block

#method_before
public ListModel<NetworkView> getNetwork() {
    return network;
}
#method_after
public EntityModel<NetworkView> getNetwork() {
    return network;
}
#end_block

#method_before
public void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#method_after
private void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#end_block

#method_before
public void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#method_after
private void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getSelectedItem().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getEntity().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#end_block

#method_before
public void flush() {
    if (subnet == null) {
        subnet = new ExternalSubnet();
    }
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getSelectedItem();
    subnet.setExternalNetwork(network != null ? network.getProvidedBy() : null);
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#method_after
public void flush() {
    subnet = new ExternalSubnet();
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getEntity();
    subnet.setExternalNetwork(network.getProvidedBy());
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    List<IValidation> cidrValidations = new ArrayList<IValidation>();
    cidrValidations.add(new NotEmptyValidation());
    if (getIpVersion().getSelectedItem() == IpVersion.IPV4) {
        cidrValidations.add(new CidrValidation());
    }
    getCidr().validateEntity(cidrValidations.toArray(new IValidation[0]));
    getIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return getName().getIsValid() && getCidr().getIsValid() && getIpVersion().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    getCidr().validateEntity(new IValidation[] { getIpVersion().getSelectedItem() == IpVersion.IPV4 ? new CidrValidation() : new NotEmptyValidation() });
    getIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return getName().getIsValid() && getCidr().getIsValid() && getIpVersion().getIsValid();
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    getSubnetCidr().setIsValid(true);
    getSubnetIpVersion().setIsValid(true);
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        List<IValidation> cidrValidations = new ArrayList<IValidation>();
        cidrValidations.add(new NotEmptyValidation());
        if (getSubnetIpVersion().getSelectedItem() == IpVersion.IPV4) {
            cidrValidations.add(new CidrValidation());
        }
        getSubnetCidr().validateEntity(cidrValidations.toArray(new IValidation[0]));
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#method_after
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        getSubnetCidr().validateEntity(new IValidation[] { getSubnetIpVersion().getSelectedItem() == IpVersion.IPV4 ? new CidrValidation() : new NotEmptyValidation() });
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#end_block

#method_before
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#method_after
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    AsyncQuery query = new AsyncQuery();
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Iterable<NetworkQoS> qos = (Iterable<NetworkQoS>) returnValue;
            getQos().setItems(qos);
            getQos().setSelectedItem(Linq.findNetworkQosById(qos, getNetwork().getQosId()));
        }
    };
    AsyncDataProvider.getAllNetworkQos(dc.getId(), query);
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#end_block

#method_before
protected void addCommands() {
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("OnSave", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar2.setIsDefault(true);
    getCommands().add(tempVar2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    getCommands().add(tempVar3);
}
#method_after
private void addCommands() {
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("OnSave", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar2.setIsDefault(true);
    getCommands().add(tempVar2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    getCommands().add(tempVar3);
    // $NON-NLS-1$
    addQosCommand = new UICommand("AddQos", this);
    addQosCommand.setTitle(ConstantsManager.getInstance().getConstants().newNetworkQosButton());
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setLabel((String) getNetworkLabel().getEntity());
    network.setComment((String) getComment().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    network.setMtu(0);
    if ((Boolean) getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setLabel((String) getNetworkLabel().getEntity());
    network.setComment((String) getComment().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    network.setMtu(0);
    if ((Boolean) getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (StringHelper.stringsEqual(command.getName(), "OnSave")) {
        // $NON-NLS-1$
        onSave();
    } else if (StringHelper.stringsEqual(command.getName(), "Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command == getAddQosCommand()) {
        addQos();
    }
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_DETECTED_FROM_CLI, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_DETECTED_FROM_CLI, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_NOT_FOUND_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REMOVE_GLUSTER_VOLUME_BRICKS_NOT_FOUND_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#method_after
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_SYSTEM_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_SYSTEM_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SYSTEM_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SYSTEM_PERMISSION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String vdsGroupCpuName = getVds().getVdsGroupCpuName();
    VDSGroup grp = DbFacade.getInstance().getVdsGroupDao().get(getVds().getVdsGroupId());
    ServerCpu sc = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
    if (sc == null) {
        // operational
        if (!StringUtils.isEmpty(getVds().getCpuFlags())) {
            foundCPU = false;
        } else {
            _hasFlags = false;
        }
        log.errorFormat("Could not find server cpu for server {0}:{1}, flags: {2}", getVdsId(), getVds().getName(), getVds().getCpuFlags());
    }
    // Checks whether the host and the cluster have the same architecture
    if (_hasFlags && foundCPU && !grp.getArchitecture().equals(ArchitectureType.undefined) && !sc.getArchitecture().equals(grp.getArchitecture())) {
        _architectureMismatch = true;
        addCustomValue("VdsArchitecture", sc.getArchitecture().name());
        addCustomValue("VdsGroupArchitecture", grp.getArchitecture().name());
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.ARCHITECTURE_INCOMPATIBLE_WITH_CLUSTER);
        tempVar.setSaveToDb(true);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
    }
    // if cluster doesn't have cpu then get the cpu from the vds
    if (_hasFlags && foundCPU && !_architectureMismatch && StringUtils.isEmpty(vdsGroupCpuName)) {
        // update group with the cpu name
        grp.setcpu_name(sc.getCpuName());
        grp.setArchitecture(null);
        // use suppress in order to update group even if action fails
        // (out of the transaction)
        VdsGroupOperationParameters tempVar = new VdsGroupOperationParameters(grp);
        tempVar.setTransactionScopeOption(TransactionScopeOption.Suppress);
        tempVar.setIsInternalCommand(true);
        Backend.getInstance().runInternalAction(VdcActionType.UpdateVdsGroup, tempVar);
        vdsGroupCpuName = sc.getCpuName();
    }
    // If the host CPU name is not found by the CpuFlagsManagerHandler class, report an error
    if (!foundCPU) {
        SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_UNSUPPORTED);
        tempVar2.setSaveToDb(true);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext());
    } else if (!_architectureMismatch) {
        List<String> missingFlags = CpuFlagsManagerHandler.missingServerCpuFlags(vdsGroupCpuName, getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
        if (!StringUtils.isEmpty(getVds().getCpuFlags()) && (!foundCPU || missingFlags != null)) {
            if (missingFlags != null) {
                addCustomValue("CpuFlags", StringUtils.join(missingFlags, ", "));
                if (missingFlags.contains("nx")) {
                    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
                    AuditLogDirector.log(logable, AuditLogType.CPU_FLAGS_NX_IS_MISSING);
                }
            }
            SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_INCOMPATIBLE_WITH_CLUSTER);
            tempVar2.setSaveToDb(true);
            Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext());
        } else {
            // if no need to change to non operational then don't log the command
            setCommandShouldBeLogged(false);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    String vdsGroupCpuName = getVds().getVdsGroupCpuName();
    VDSGroup grp = DbFacade.getInstance().getVdsGroupDao().get(getVds().getVdsGroupId());
    ServerCpu sc = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
    if (sc == null) {
        // operational
        if (!StringUtils.isEmpty(getVds().getCpuFlags())) {
            foundCPU = false;
        } else {
            _hasFlags = false;
        }
        log.errorFormat("Could not find server cpu for server {0}:{1}, flags: {2}", getVdsId(), getVds().getName(), getVds().getCpuFlags());
    }
    // Checks whether the host and the cluster have the same architecture
    if (_hasFlags && foundCPU) {
        if (grp.getArchitecture() != ArchitectureType.undefined && sc.getArchitecture() != grp.getArchitecture()) {
            architectureMatch = false;
            addCustomValue("VdsArchitecture", sc.getArchitecture().name());
            addCustomValue("VdsGroupArchitecture", grp.getArchitecture().name());
            SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.ARCHITECTURE_INCOMPATIBLE_WITH_CLUSTER);
            tempVar.setSaveToDb(true);
            Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
        } else {
            // if cluster doesn't have cpu then get the cpu from the vds
            if (StringUtils.isEmpty(vdsGroupCpuName)) {
                // update group with the cpu name
                grp.setcpu_name(sc.getCpuName());
                grp.setArchitecture(ArchitectureType.undefined);
                // use suppress in order to update group even if action fails
                // (out of the transaction)
                VdsGroupOperationParameters tempVar = new VdsGroupOperationParameters(grp);
                tempVar.setTransactionScopeOption(TransactionScopeOption.Suppress);
                tempVar.setIsInternalCommand(true);
                Backend.getInstance().runInternalAction(VdcActionType.UpdateVdsGroup, tempVar);
                vdsGroupCpuName = sc.getCpuName();
            }
        }
    }
    // If the host CPU name is not found by the CpuFlagsManagerHandler class, report an error
    if (architectureMatch) {
        List<String> missingFlags = CpuFlagsManagerHandler.missingServerCpuFlags(vdsGroupCpuName, getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
        if (!StringUtils.isEmpty(getVds().getCpuFlags()) && (!foundCPU || missingFlags != null)) {
            if (missingFlags != null) {
                addCustomValue("CpuFlags", StringUtils.join(missingFlags, ", "));
                if (missingFlags.contains("nx")) {
                    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
                    AuditLogDirector.log(logable, AuditLogType.CPU_FLAGS_NX_IS_MISSING);
                }
            }
            SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_INCOMPATIBLE_WITH_CLUSTER);
            tempVar2.setSaveToDb(true);
            Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext());
        } else {
            // if no need to change to non operational then don't log the command
            setCommandShouldBeLogged(false);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (!foundCPU) {
        return AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION;
    } else if (_architectureMismatch) {
        return AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER;
    } else if (!_hasFlags) {
        return AuditLogType.VDS_CPU_RETRIEVE_FAILED;
    } else {
        return AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (!foundCPU) {
        return AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION;
    } else if (!architectureMatch) {
        return AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER;
    } else if (!_hasFlags) {
        return AuditLogType.VDS_CPU_RETRIEVE_FAILED;
    } else {
        return AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER;
    }
}
#end_block

#method_before
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (iface.getVlanId() != null) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#method_after
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (isVlan(iface)) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (i.getVlanId() != null && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (isVlan(i) && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (Objects.equals(iface.getQos(), qos) || iface.isQosOverridden());
}
#method_after
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (isQosInSync(iface, qos) || iface.isQosOverridden());
}
#end_block

#method_before
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && network.getVlanId() == null;
}
#method_after
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && !isVlan(network);
}
#end_block

#method_before
private void assertInterfaceModified(SetupNetworksHelper helper, VdsNetworkInterface iface) {
    assertTrue(MessageFormat.format("Expected interface ''{0}'' to be modified but it wasn''t. Modified interfaces: {1}", iface, helper.getModifiedInterfaces()), helper.getModifiedInterfaces().contains(iface));
}
#method_after
private void assertInterfaceModified(SetupNetworksHelper helper, VdsNetworkInterface iface) {
    Set<String> modifiedNames = new HashSet<String>();
    for (VdsNetworkInterface modifiedIface : helper.getModifiedInterfaces()) {
        modifiedNames.add(modifiedIface.getName());
    }
    assertTrue(MessageFormat.format("Expected interface ''{0}'' to be modified but it wasn''t. Modified interfaces: {1}", iface, helper.getModifiedInterfaces()), modifiedNames.contains(iface.getName()));
}
#end_block

#method_before
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address, boolean qosOverridden) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setQosOverridden(qosOverridden);
    return iface;
}
#method_after
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address, boolean qosOverridden, Set<String> labels) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setQosOverridden(qosOverridden);
    iface.setLabels(labels);
    return iface;
}
#end_block

#method_before
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null, false);
}
#method_after
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null, false, null);
}
#end_block

#method_before
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), false);
    return nic;
}
#method_after
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), false, null);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null, false);
}
#method_after
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null, false, null);
}
#end_block

#method_before
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null, false);
}
#method_after
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null, false, null);
}
#end_block

#method_before
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null, false);
}
#method_after
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null, false, null);
}
#end_block

#method_before
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].isQosOverridden()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#method_after
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].isQosOverridden(), nics[i].getLabels()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#end_block

#method_before
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    detectSlaveChanges();
    validateMTU();
    validateNetworkQos();
    return translateViolations();
}
#method_after
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    extractModifiedInterfaces();
    detectSlaveChanges();
    validateMTU();
    validateNetworkQos();
    validateNotRemovingLabeledNetworks();
    return translateViolations();
}
#end_block

#method_before
private void validateNetworkQos() {
    boolean featureSupported = FeatureSupported.HostNetworkQos(vds.getVdsGroupCompatibilityVersion());
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.isQosOverridden()) {
            if (!featureSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, iface.getNetworkName());
            }
            NetworkQosValidator qosValidator = new NetworkQosValidator(iface.getQos());
            if (qosValidator.allValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_MISSING_VALUES, iface.getNetworkName());
            }
            if (qosValidator.peakConsistentWithAverage() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_PEAK_LOWER_THAN_AVERAGE, iface.getNetworkName());
            }
        }
    }
}
#method_after
private void validateNetworkQos() {
    boolean featureSupported = FeatureSupported.hostNetworkQos(vds.getVdsGroupCompatibilityVersion());
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.isQosOverridden()) {
            if (!featureSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, iface.getNetworkName());
            }
            NetworkQosValidator qosValidator = new NetworkQosValidator(iface.getQos());
            if (qosValidator.allValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_MISSING_VALUES, iface.getNetworkName());
            }
            if (qosValidator.peakConsistentWithAverage() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_PEAK_LOWER_THAN_AVERAGE, iface.getNetworkName());
            }
        }
    }
}
#end_block

#method_before
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else {
                if (networkWasModified(iface)) {
                    if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                    }
                    modifiedNetworks.add(network);
                }
                if ((existingIface == null && iface.isQosOverridden()) || existingIface != null && (iface.isQosOverridden() != existingIface.isQosOverridden())) {
                    modifiedInterfaces.add(iface);
                }
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                }
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#end_block

#method_before
public Collection<VdsNetworkInterface> getModifiedInterfaces() {
    return modifiedInterfaces;
}
#method_after
public List<VdsNetworkInterface> getModifiedInterfaces() {
    return modifiedInterfaces;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVdsId(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                setSucceeded(TransactionSupport.executeInNewTransaction(updateVdsNetworksInTx()));
            }
        }
    } catch (TimeoutException e) {
        log.debugFormat("Setup networks command timed out for {0} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        setSucceeded(true);
        return;
    }
    if (!getRemovedBonds().isEmpty()) {
        unlabelRemovedBonds();
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVdsId(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                setSucceeded(TransactionSupport.executeInNewTransaction(updateVdsNetworksInTx()));
            }
        }
    } catch (TimeoutException e) {
        log.debugFormat("Setup networks command timed out for {0} seconds", timeout);
    }
}
#end_block

#method_before
private Collection<VdsNetworkInterface> getModifiedInterfaces() {
    return helper.getModifiedInterfaces();
}
#method_after
private List<VdsNetworkInterface> getModifiedInterfaces() {
    return helper.getModifiedInterfaces();
}
#end_block

#method_before
private TransactionMethod<Boolean> updateVdsNetworksInTx() {
    return new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            // update the interfaces whose qosOverridden field has changed
            getDbFacade().getInterfaceDao().updateQosOverridden(getModifiedInterfaces());
            // save the new network topology to DB
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return Boolean.TRUE;
        }
    };
}
#method_after
private TransactionMethod<Boolean> updateVdsNetworksInTx() {
    return new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            // save the new network topology to DB
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds(), getInterfaces()));
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return Boolean.TRUE;
        }
    };
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), new NetworkQoS());
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    NetworkQoS qos = createQos();
    qos.setOutboundAverage(30);
    qos.setOutboundPeak(30);
    qos.setOutboundBurst(30);
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), qos);
}
#end_block

#method_before
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    return iface;
}
#method_after
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    iface.setQos(createQos());
    return iface;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (FeatureSupported.HostNetworkQos(getVds().getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(getDbFacade().getVdsDao().get(getParameters().getVdsId()).getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, Version clusterCompatibilityVersion) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, Version.v3_3, false);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, new Version(3, 4), true);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(clusterCompatibilityVersion);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(qosMapper.deserialize(), expectedQos);
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    Version version = mock(Version.class);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(expectedQos, qosMapper.deserialize());
}
#end_block

#method_before
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, Version.v3_3);
}
#method_after
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, false);
}
#end_block

#method_before
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    when(qosDao.get(any(Guid.class))).thenReturn(qos);
    qos(network, iface, qos, new Version(3, 4));
}
#method_after
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    Guid qosId = Guid.newGuid();
    network.setQosId(qosId);
    NetworkQoS qos = createQos();
    qos.setId(qosId);
    when(qosDao.get(qosId)).thenReturn(qos);
    qos(network, iface, qos, true);
}
#end_block

#method_before
@Test
public void qosOnInterface() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    when(qosDao.get(any(Guid.class))).thenReturn(qos);
    iface.setQosOverridden(true);
    qos(network, iface, null, new Version(3, 4));
}
#method_after
@Test
public void qosOnInterface() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    iface.setQos(qos);
    iface.setQosOverridden(true);
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, qos, true);
}
#end_block

#method_before
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDAO vdsStaticDao = mock(VdsStaticDAO.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(dbFacade.getQosDao()).thenReturn(qosDao);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    return new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected VDS getVds() {
            return host;
        }
    };
}
#method_after
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDAO vdsStaticDao = mock(VdsStaticDAO.class);
    final VdsDAO vdsDao = mock(VdsDAO.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(dbFacade.getVdsDao()).thenReturn(vdsDao);
    when(dbFacade.getQosDao()).thenReturn(qosDao);
    when(vdsDao.get(any(Guid.class))).thenReturn(host);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    return new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }
    };
}
#end_block

#method_before
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(30);
    qos.setInboundPeak(30);
    qos.setInboundBurst(30);
    return qos;
}
#method_after
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    return qos;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    vmStatic.setOriginalTemplateGuid(vmStatic.getVmtGuid());
    vmStatic.setOriginalTemplateName(getVmTemplate().getName());
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    return entity;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<VmDynamic> getBatchMapper() {
    return new MapSqlParameterMapper<VmDynamic>() {

        @Override
        public MapSqlParameterSource map(VmDynamic entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("guest_cur_user_name", entity.getGuestCurrentUserName()).addValue("console_cur_user_name", entity.getConsoleCurrentUserName()).addValue("guest_last_login_time", entity.getGuestLastLoginTime()).addValue("guest_last_logout_time", entity.getGuestLastLogoutTime()).addValue("console_user_id", entity.getConsoleUserId()).addValue("guest_os", entity.getGuestOs()).addValue("migrating_to_vds", entity.getMigratingToVds()).addValue("run_on_vds", entity.getRunOnVds()).addValue("status", entity.getStatus()).addValue("vm_guid", entity.getId()).addValue("vm_host", entity.getVmHost()).addValue("vm_ip", entity.getVmIp()).addValue("last_start_time", entity.getLastStartTime()).addValue("last_stop_time", entity.getLastStopTime()).addValue("vm_pid", entity.getVmPid()).addValue("vm_fqdn", entity.getVmFQDN()).addValue("app_list", entity.getAppList()).addValue("display", entity.getDisplay()).addValue("acpi_enable", entity.getAcpiEnable()).addValue("session", entity.getSession()).addValue("display_ip", entity.getDisplayIp()).addValue("display_type", entity.getDisplayType()).addValue("kvm_enable", entity.getKvmEnable()).addValue("boot_sequence", entity.getBootSequence()).addValue("display_secure_port", entity.getDisplaySecurePort()).addValue("utc_diff", entity.getUtcDiff()).addValue("last_vds_run_on", entity.getLastVdsRunOn()).addValue("client_ip", entity.getClientIp()).addValue("guest_requested_memory", entity.getGuestRequestedMemory()).addValue("hibernation_vol_handle", entity.getHibernationVolHandle()).addValue("exit_status", entity.getExitStatus()).addValue("pause_status", entity.getPauseStatus()).addValue("exit_message", entity.getExitMessage()).addValue("hash", entity.getHash()).addValue("guest_agent_nics_hash", entity.getGuestAgentNicsHash()).addValue("last_watchdog_event", entity.getLastWatchdogEvent()).addValue("last_watchdog_action", entity.getLastWatchdogAction()).addValue("cpu_name", entity.getCpuName());
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<VmDynamic> getBatchMapper() {
    return new MapSqlParameterMapper<VmDynamic>() {

        @Override
        public MapSqlParameterSource map(VmDynamic entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("guest_cur_user_name", entity.getGuestCurrentUserName()).addValue("console_cur_user_name", entity.getConsoleCurrentUserName()).addValue("guest_last_login_time", entity.getGuestLastLoginTime()).addValue("guest_last_logout_time", entity.getGuestLastLogoutTime()).addValue("console_user_id", entity.getConsoleUserId()).addValue("guest_os", entity.getGuestOs()).addValue("migrating_to_vds", entity.getMigratingToVds()).addValue("run_on_vds", entity.getRunOnVds()).addValue("status", entity.getStatus()).addValue("vm_guid", entity.getId()).addValue("vm_host", entity.getVmHost()).addValue("vm_ip", entity.getVmIp()).addValue("last_start_time", entity.getLastStartTime()).addValue("last_stop_time", entity.getLastStopTime()).addValue("vm_pid", entity.getVmPid()).addValue("vm_fqdn", entity.getVmFQDN()).addValue("app_list", entity.getAppList()).addValue("display", entity.getDisplay()).addValue("acpi_enable", entity.getAcpiEnable()).addValue("session", entity.getSession()).addValue("display_ip", entity.getDisplayIp()).addValue("display_type", entity.getDisplayType()).addValue("kvm_enable", entity.getKvmEnable()).addValue("boot_sequence", entity.getBootSequence()).addValue("display_secure_port", entity.getDisplaySecurePort()).addValue("utc_diff", entity.getUtcDiff()).addValue("last_vds_run_on", entity.getLastVdsRunOn()).addValue("client_ip", entity.getClientIp()).addValue("guest_requested_memory", entity.getGuestRequestedMemory()).addValue("hibernation_vol_handle", entity.getHibernationVolHandle()).addValue("exit_status", entity.getExitStatus()).addValue("pause_status", entity.getPauseStatus()).addValue("exit_message", entity.getExitMessage()).addValue("hash", entity.getHash()).addValue("guest_agent_nics_hash", entity.getGuestAgentNicsHash()).addValue("last_watchdog_event", entity.getLastWatchdogEvent()).addValue("last_watchdog_action", entity.getLastWatchdogAction()).addValue("is_run_once", entity.isRunOnce()).addValue("cpu_name", entity.getCpuName());
            return paramValue;
        }
    };
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (getNic().getLabels() != null && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && nic.getLabels() != null && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks.toArray(new String[assignedNetworks.size()]), ", "));
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (getNic().getLabels() != null && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && nic.getLabels() != null && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks, ", "));
    }
    return true;
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    return iface;
}
#method_after
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address, Set<String> labels) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setLabels(labels);
    return iface;
}
#end_block

#method_before
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null);
}
#method_after
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null, null);
}
#end_block

#method_before
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr());
    return nic;
}
#method_after
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), null);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null);
}
#method_after
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null, null);
}
#end_block

#method_before
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null);
}
#method_after
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null, null);
}
#end_block

#method_before
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null);
}
#method_after
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null, null);
}
#end_block

#method_before
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#method_after
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].getLabels()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), new NetworkQoS());
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    NetworkQoS qos = createQos();
    qos.setOutboundAverage(30);
    qos.setOutboundPeak(30);
    qos.setOutboundBurst(30);
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), qos);
}
#end_block

#method_before
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    return iface;
}
#method_after
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    iface.setQos(createQos());
    return iface;
}
#end_block

#method_before
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    detectSlaveChanges();
    validateMTU();
    return translateViolations();
}
#method_after
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    extractModifiedLabeledInterfaces();
    detectSlaveChanges();
    validateMTU();
    validateNotRemovingLabeledNetworks();
    return translateViolations();
}
#end_block

#method_before
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (iface.getVlanId() != null) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#method_after
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (isVlan(iface)) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (i.getVlanId() != null && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (isVlan(i) && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && Objects.equals(iface.getQos(), qos);
}
#method_after
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && isQosInSync(iface, qos);
}
#end_block

#method_before
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && network.getVlanId() == null;
}
#method_after
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && !isVlan(network);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    // call getVdsCapabilities verb
    super.executeVdsBrokerCommand();
    updateNetConfigDirtyFlag();
    // update to db
    persistAndEnforceNetworkCompliance(getVds(), skipManagementNetwork());
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    // call getVdsCapabilities verb
    super.executeVdsBrokerCommand();
    updateNetConfigDirtyFlag();
    // update to db
    persistAndEnforceNetworkCompliance(getVds(), skipManagementNetwork(), Entities.entitiesByName(getParameters().getInterfaces()));
    proceedProxyReturnValue();
}
#end_block

#method_before
public static NonOperationalReason persistAndEnforceNetworkCompliance(VDS vds, boolean skipManagementNetwork) {
    persistTopology(vds);
    if (vds.getStatus() != VDSStatus.Maintenance) {
        List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(vds.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the vds networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
        logUnsynchronizedNetworks(vds, Entities.entitiesByName(clusterNetworks));
    }
    return NonOperationalReason.NONE;
}
#method_after
public static NonOperationalReason persistAndEnforceNetworkCompliance(VDS vds, boolean skipManagementNetwork, Map<String, VdsNetworkInterface> nicsByName) {
    persistTopology(vds, nicsByName);
    if (vds.getStatus() != VDSStatus.Maintenance) {
        List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(vds.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the vds networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
        logUnsynchronizedNetworks(vds, Entities.entitiesByName(clusterNetworks));
    }
    return NonOperationalReason.NONE;
}
#end_block

#method_before
private static void persistTopology(VDS vds) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<VdsNetworkInterface> dbIfaces = interfaceDAO.getAllInterfacesForVds(vds.getId());
    List<String> updatedIfaces = new ArrayList<String>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbIfaces) {
        boolean found = false;
        for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
            if (dbIface.getName().equals(vdsIface.getName())) {
                // we preserve only the ID from the Database
                // everything else is what we got from getVdsCapabilities
                vdsIface.setId(dbIface.getId());
                dbIfacesToBatch.add(vdsIface);
                updatedIfaces.add(vdsIface.getName());
                found = true;
                break;
            }
        }
        if (!found) {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#method_after
private static void persistTopology(VDS vds, Map<String, VdsNetworkInterface> nicsByName) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<VdsNetworkInterface> dbIfaces = interfaceDAO.getAllInterfacesForVds(vds.getId());
    List<String> updatedIfaces = new ArrayList<String>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    Map<String, VdsNetworkInterface> hostNicsByNames = Entities.entitiesByName(vds.getInterfaces());
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbIfaces) {
        if (hostNicsByNames.containsKey(dbIface.getName())) {
            VdsNetworkInterface vdsIface = hostNicsByNames.get(dbIface.getName());
            // we preserve only the ID and the labels from the Database
            // everything else is what we got from getVdsCapabilities
            vdsIface.setId(dbIface.getId());
            vdsIface.setLabels(dbIface.getLabels());
            dbIfacesToBatch.add(vdsIface);
            updatedIfaces.add(vdsIface.getName());
        } else {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (nicsByName != null) {
        updateInterfacesWithUserConfiguration(dbIfacesToBatch, nicsByName);
        updateInterfacesWithUserConfiguration(vds.getInterfaces(), nicsByName);
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        if (!NetworkUtils.isNetworkInSync(nic, getNetwork(), getDbFacade().getQosDao().get(getNetwork().getQosId()))) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (FeatureSupported.HostNetworkQos(getVds().getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (network.getQosId() != null && FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, Version clusterCompatibilityVersion) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, Version.v3_3, false);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, new Version(3, 4), true);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(clusterCompatibilityVersion);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(qosMapper.deserialize(), expectedQos);
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    Version version = mock(Version.class);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(expectedQos, qosMapper.deserialize());
}
#end_block

#method_before
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, Version.v3_3);
}
#method_after
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, false);
}
#end_block

#method_before
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    when(qosDao.get(any(Guid.class))).thenReturn(qos);
    qos(network, iface, qos, new Version(3, 4));
}
#method_after
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    Guid qosId = Guid.newGuid();
    network.setQosId(qosId);
    NetworkQoS qos = createQos();
    qos.setId(qosId);
    when(qosDao.get(qosId)).thenReturn(qos);
    qos(network, iface, qos, true);
}
#end_block

#method_before
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(30);
    qos.setInboundPeak(30);
    qos.setInboundBurst(30);
    return qos;
}
#method_after
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    return qos;
}
#end_block

#method_before
protected NetworkQoS getOldQos() {
    if (!oldQosRetrieved) {
        oldQos = DbFacade.getInstance().getQosDao().get(qos.getId());
        oldQosRetrieved = true;
    }
    return oldQos;
}
#method_after
protected NetworkQoS getOldQos() {
    if (oldQos == null) {
        oldQos = DbFacade.getInstance().getQosDao().get(qos.getId());
    }
    return oldQos;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (validateParameters()) {
        NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
        if (!validate(validator.qosExists()) || !validate(validator.consistentDataCenter())) {
            return false;
        } else {
            NetworkQoS oldNetworkQoS = getNetworkQoSDao().get(getNetworkQoS().getId());
            if (validateValues()) {
                if (!oldNetworkQoS.getName().equals(getNetworkQoS().getName())) {
                    return validateNameNotExistInDC();
                }
            } else {
                return false;
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
    return (validateParameters() && validate(validator.qosExists()) && validate(validator.consistentDataCenter()) && validateValues() && validate(validator.nameNotChangedOrNotTaken()));
}
#end_block

#method_before
@Before
public void setup() {
    qos = new NetworkQoS();
    oldQos = new NetworkQoS();
    validator = spy(new NetworkQosValidator(qos));
    doReturn(oldQos).when(validator).getOldQos();
    nullValidator = spy(new NetworkQosValidator(null));
    doReturn(oldQos).when(nullValidator).getOldQos();
}
#method_after
@Before
public void setup() {
    qos = new NetworkQoS();
    oldQos = new NetworkQoS();
    allQos = new ArrayList<NetworkQoS>();
    validator = spy(new NetworkQosValidator(qos));
    doReturn(oldQos).when(validator).getOldQos();
    doReturn(allQos).when(validator).getAllQosInDc();
    nullValidator = spy(new NetworkQosValidator(null));
    doReturn(oldQos).when(nullValidator).getOldQos();
}
#end_block

#method_before
@Override
public void saveStatisticsForVds(VdsNetworkStatistics stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", stats.getId()).addValue("rx_drop", stats.getReceiveDropRate()).addValue("rx_rate", stats.getReceiveRate()).addValue("tx_drop", stats.getTransmitDropRate()).addValue("tx_rate", stats.getTransmitRate()).addValue("iface_status", stats.getStatus()).addValue("vds_id", stats.getVdsId());
    getCallsHandler().executeModification("Insertvds_interface_statistics", parameterSource);
}
#method_after
@Override
public void saveStatisticsForVds(VdsNetworkStatistics stats) {
    MapSqlParameterSource parameterSource = createStatisticsParametersMapper(stats);
    getCallsHandler().executeModification("Insertvds_interface_statistics", parameterSource);
}
#end_block

#method_before
@Override
public void massUpdateInterfacesForVds(List<VdsNetworkInterface> dbIfacesToBatch) {
    updateAllInBatch("Updatevds_interface", dbIfacesToBatch, new MapSqlParameterMapper<VdsNetworkInterface>() {

        @Override
        public MapSqlParameterSource map(VdsNetworkInterface entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("addr", entity.getAddress()).addValue("bond_name", entity.getBondName()).addValue("bond_type", entity.getBondType()).addValue("gateway", entity.getGateway()).addValue("id", entity.getId()).addValue("is_bond", entity.getBonded()).addValue("bond_opts", entity.getBondOptions()).addValue("mac_addr", entity.getMacAddress()).addValue("name", entity.getName()).addValue("network_name", entity.getNetworkName()).addValue("speed", entity.getSpeed()).addValue("subnet", entity.getSubnet()).addValue("boot_protocol", entity.getBootProtocol()).addValue("type", entity.getType()).addValue("vds_id", entity.getVdsId()).addValue("vlan_id", entity.getVlanId()).addValue("mtu", entity.getMtu()).addValue("bridged", entity.isBridged()).addValue("qos_id", entity.getQos() == null ? null : entity.getQos().getId());
            return paramValue;
        }
    });
}
#method_after
@Override
public void massUpdateInterfacesForVds(List<VdsNetworkInterface> dbIfacesToBatch) {
    updateAllInBatch("Updatevds_interface", dbIfacesToBatch, new MapSqlParameterMapper<VdsNetworkInterface>() {

        @Override
        public MapSqlParameterSource map(VdsNetworkInterface nic) {
            return createInterfaceParametersMapper(nic);
        }
    });
}
#end_block

#method_before
public void updateAllInBatch(String procedureName, Collection<VdsNetworkInterface> paramValues, MapSqlParameterMapper<VdsNetworkInterface> mapper) {
    getCallsHandler().executeStoredProcAsBatch(procedureName, paramValues, mapper);
}
#method_after
public void updateAllInBatch(String procedureName, Collection<VdsNetworkInterface> paramValues, MapSqlParameterMapper<VdsNetworkInterface> mapper) {
    for (VdsNetworkInterface entity : paramValues) {
        persistQosChanges(entity);
    }
    getCallsHandler().executeStoredProcAsBatch(procedureName, paramValues, mapper);
}
#end_block

#method_before
@Override
public void saveInterfaceForVds(VdsNetworkInterface entity) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", entity.getAddress()).addValue("bond_name", entity.getBondName()).addValue("bond_type", entity.getBondType()).addValue("gateway", entity.getGateway()).addValue("id", entity.getId()).addValue("is_bond", entity.getBonded()).addValue("bond_opts", entity.getBondOptions()).addValue("mac_addr", entity.getMacAddress()).addValue("name", entity.getName()).addValue("network_name", entity.getNetworkName()).addValue("speed", entity.getSpeed()).addValue("subnet", entity.getSubnet()).addValue("boot_protocol", entity.getBootProtocol()).addValue("type", entity.getType()).addValue("vds_id", entity.getVdsId()).addValue("vlan_id", entity.getVlanId()).addValue("mtu", entity.getMtu()).addValue("bridged", entity.isBridged()).addValue("qos_id", entity.getQos() == null ? null : entity.getQos().getId());
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#method_after
@Override
public void saveInterfaceForVds(VdsNetworkInterface nic) {
    persistQosChanges(nic);
    MapSqlParameterSource parameterSource = createInterfaceParametersMapper(nic);
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#end_block

#method_before
@Override
public void massUpdateStatisticsForVds(Collection<VdsNetworkStatistics> statistics) {
    List<MapSqlParameterSource> executions = new ArrayList<>(statistics.size());
    for (VdsNetworkStatistics stats : statistics) {
        executions.add(getCustomMapSqlParameterSource().addValue("id", stats.getId()).addValue("rx_drop", stats.getReceiveDropRate()).addValue("rx_rate", stats.getReceiveRate()).addValue("tx_drop", stats.getTransmitDropRate()).addValue("tx_rate", stats.getTransmitRate()).addValue("iface_status", stats.getStatus()).addValue("vds_id", stats.getVdsId()));
    }
    getCallsHandler().executeStoredProcAsBatch("Updatevds_interface_statistics", executions);
}
#method_after
@Override
public void massUpdateStatisticsForVds(Collection<VdsNetworkStatistics> statistics) {
    List<MapSqlParameterSource> executions = new ArrayList<>(statistics.size());
    for (VdsNetworkStatistics stats : statistics) {
        executions.add(createStatisticsParametersMapper(stats));
    }
    getCallsHandler().executeStoredProcAsBatch("Updatevds_interface_statistics", executions);
}
#end_block

#method_before
private void update(VdsNetworkStatistics stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", stats.getId()).addValue("rx_drop", stats.getReceiveDropRate()).addValue("rx_rate", stats.getReceiveRate()).addValue("tx_drop", stats.getTransmitDropRate()).addValue("tx_rate", stats.getTransmitRate()).addValue("iface_status", stats.getStatus()).addValue("vds_id", stats.getVdsId());
    getCallsHandler().executeModification("Updatevds_interface_statistics", parameterSource);
}
#method_after
private void update(VdsNetworkStatistics stats) {
    getCallsHandler().executeModification("Updatevds_interface_statistics", createStatisticsParametersMapper(stats));
}
#end_block

#method_before
@Override
public void updateInterfaceForVds(VdsNetworkInterface entity) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", entity.getAddress()).addValue("bond_name", entity.getBondName()).addValue("bond_type", entity.getBondType()).addValue("gateway", entity.getGateway()).addValue("id", entity.getId()).addValue("is_bond", entity.getBonded()).addValue("bond_opts", entity.getBondOptions()).addValue("mac_addr", entity.getMacAddress()).addValue("name", entity.getName()).addValue("network_name", entity.getNetworkName()).addValue("speed", entity.getSpeed()).addValue("subnet", entity.getSubnet()).addValue("boot_protocol", entity.getBootProtocol()).addValue("type", entity.getType()).addValue("vds_id", entity.getVdsId()).addValue("vlan_id", entity.getVlanId()).addValue("mtu", entity.getMtu()).addValue("bridged", entity.isBridged()).addValue("qos_id", entity.getQos() == null ? null : entity.getQos().getId());
    getCallsHandler().executeModification("Updatevds_interface", parameterSource);
}
#method_after
@Override
public void updateInterfaceForVds(VdsNetworkInterface nic) {
    persistQosChanges(nic);
    getCallsHandler().executeModification("Updatevds_interface", createInterfaceParametersMapper(nic));
}
#end_block

#method_before
@Override
public void removeInterfaceFromVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    getCallsHandler().executeModification("Deletevds_interface", parameterSource);
}
#method_after
@Override
public void removeInterfaceFromVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    DbFacade.getInstance().getQosDao().remove(id);
    getCallsHandler().executeModification("Deletevds_interface", parameterSource);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("qos_id", network.getQos() == null ? null : network.getQos().getId());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel());
}
#end_block

#method_before
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    entity.setQos(DbFacade.getInstance().getQosDao().get(getGuid(rs, "qos_id")));
    return entity;
}
#method_after
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    return entity;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", qos=").append(getQos()).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", qos=").append(getQos()).append(", labels=").append(getLabels()).append("}");
    return builder.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((address == null) ? 0 : address.hashCode());
    result = prime * result + ((bondName == null) ? 0 : bondName.hashCode());
    result = prime * result + ((bondOptions == null) ? 0 : bondOptions.hashCode());
    result = prime * result + ((bondType == null) ? 0 : bondType.hashCode());
    result = prime * result + ((bonded == null) ? 0 : bonded.hashCode());
    result = prime * result + ((bootProtocol == null) ? 0 : bootProtocol.hashCode());
    result = prime * result + ((networkName == null) ? 0 : networkName.hashCode());
    result = prime * result + (bridged ? 1231 : 1237);
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + mtu;
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + ((qos == null) ? 0 : qos.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((address == null) ? 0 : address.hashCode());
    result = prime * result + ((bondName == null) ? 0 : bondName.hashCode());
    result = prime * result + ((bondOptions == null) ? 0 : bondOptions.hashCode());
    result = prime * result + ((bondType == null) ? 0 : bondType.hashCode());
    result = prime * result + ((bonded == null) ? 0 : bonded.hashCode());
    result = prime * result + ((bootProtocol == null) ? 0 : bootProtocol.hashCode());
    result = prime * result + ((networkName == null) ? 0 : networkName.hashCode());
    result = prime * result + (bridged ? 1231 : 1237);
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + mtu;
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + ((qos == null) ? 0 : qos.hashCode());
    result = prime * result + ((labels == null) ? 0 : labels.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VdsNetworkInterface)) {
        return false;
    }
    VdsNetworkInterface other = (VdsNetworkInterface) obj;
    if (address == null) {
        if (other.address != null) {
            return false;
        }
    } else if (!address.equals(other.address)) {
        return false;
    }
    if (bondName == null) {
        if (other.bondName != null) {
            return false;
        }
    } else if (!bondName.equals(other.bondName)) {
        return false;
    }
    if (bondOptions == null) {
        if (other.bondOptions != null) {
            return false;
        }
    } else if (!bondOptions.equals(other.bondOptions)) {
        return false;
    }
    if (bondType == null) {
        if (other.bondType != null) {
            return false;
        }
    } else if (!bondType.equals(other.bondType)) {
        return false;
    }
    if (bonded == null) {
        if (other.bonded != null) {
            return false;
        }
    } else if (!bonded.equals(other.bonded)) {
        return false;
    }
    if (bootProtocol != other.bootProtocol) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(networkName, other.networkName)) {
        return false;
    }
    if (bridged != other.bridged) {
        return false;
    }
    if (gateway == null) {
        if (other.gateway != null) {
            return false;
        }
    } else if (!gateway.equals(other.gateway)) {
        return false;
    }
    if (mtu != other.mtu) {
        return false;
    }
    if (subnet == null) {
        if (other.subnet != null) {
            return false;
        }
    } else if (!subnet.equals(other.subnet)) {
        return false;
    }
    if (vdsId == null) {
        if (other.vdsId != null) {
            return false;
        }
    } else if (!vdsId.equals(other.vdsId)) {
        return false;
    }
    if (vlanId == null) {
        if (other.vlanId != null) {
            return false;
        }
    } else if (!vlanId.equals(other.vlanId)) {
        return false;
    }
    if (!Objects.equals(qos, other.qos)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VdsNetworkInterface)) {
        return false;
    }
    VdsNetworkInterface other = (VdsNetworkInterface) obj;
    if (address == null) {
        if (other.address != null) {
            return false;
        }
    } else if (!address.equals(other.address)) {
        return false;
    }
    if (bondName == null) {
        if (other.bondName != null) {
            return false;
        }
    } else if (!bondName.equals(other.bondName)) {
        return false;
    }
    if (bondOptions == null) {
        if (other.bondOptions != null) {
            return false;
        }
    } else if (!bondOptions.equals(other.bondOptions)) {
        return false;
    }
    if (bondType == null) {
        if (other.bondType != null) {
            return false;
        }
    } else if (!bondType.equals(other.bondType)) {
        return false;
    }
    if (bonded == null) {
        if (other.bonded != null) {
            return false;
        }
    } else if (!bonded.equals(other.bonded)) {
        return false;
    }
    if (bootProtocol != other.bootProtocol) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(networkName, other.networkName)) {
        return false;
    }
    if (bridged != other.bridged) {
        return false;
    }
    if (gateway == null) {
        if (other.gateway != null) {
            return false;
        }
    } else if (!gateway.equals(other.gateway)) {
        return false;
    }
    if (mtu != other.mtu) {
        return false;
    }
    if (subnet == null) {
        if (other.subnet != null) {
            return false;
        }
    } else if (!subnet.equals(other.subnet)) {
        return false;
    }
    if (vdsId == null) {
        if (other.vdsId != null) {
            return false;
        }
    } else if (!vdsId.equals(other.vdsId)) {
        return false;
    }
    if (vlanId == null) {
        if (other.vlanId != null) {
            return false;
        }
    } else if (!vlanId.equals(other.vlanId)) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(qos, other.qos)) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(labels, other.labels)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", description=").append(getDescription()).append(", comment=").append(getComment()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", type=").append(getType()).append(", vlanId=").append(getVlanId()).append(", stp=").append(getStp()).append(", dataCenterId=").append(getDataCenterId()).append(", mtu=").append(getMtu()).append(", vmNetwork=").append(isVmNetwork()).append(", cluster=").append(getCluster()).append(", providedBy=").append(getProvidedBy()).append(", label=").append(getLabel()).append(", qos=").append(getQos()).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", description=").append(getDescription()).append(", comment=").append(getComment()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", type=").append(getType()).append(", vlanId=").append(getVlanId()).append(", stp=").append(getStp()).append(", dataCenterId=").append(getDataCenterId()).append(", mtu=").append(getMtu()).append(", vmNetwork=").append(isVmNetwork()).append(", cluster=").append(getCluster()).append(", providedBy=").append(getProvidedBy()).append(", label=").append(getLabel()).append(", qosId=").append(getQosId()).append("}");
    return builder.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((dataCenterId == null) ? 0 : dataCenterId.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + (mtu);
    result = prime * result + ((vmNetwork) ? 11 : 13);
    result = prime * result + ((providedBy == null) ? 0 : providedBy.hashCode());
    result = prime * result + ((label == null) ? 0 : label.hashCode());
    result = prime * result + ((qos == null) ? 0 : qos.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((dataCenterId == null) ? 0 : dataCenterId.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + (mtu);
    result = prime * result + ((vmNetwork) ? 11 : 13);
    result = prime * result + ((providedBy == null) ? 0 : providedBy.hashCode());
    result = prime * result + ((label == null) ? 0 : label.hashCode());
    result = prime * result + ((qosId == null) ? 0 : qosId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Network other = (Network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (dataCenterId == null) {
        if (other.dataCenterId != null)
            return false;
    } else if (!dataCenterId.equals(other.dataCenterId))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlanId == null) {
        if (other.vlanId != null)
            return false;
    } else if (!vlanId.equals(other.vlanId))
        return false;
    if (mtu != other.mtu)
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    if (providedBy == null) {
        if (other.providedBy != null)
            return false;
    } else if (!providedBy.equals(other.providedBy))
        return false;
    if (label == null) {
        if (other.label != null)
            return false;
    } else if (!label.equals(other.label))
        return false;
    if (!Objects.equals(qos, other.qos)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Network other = (Network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (dataCenterId == null) {
        if (other.dataCenterId != null)
            return false;
    } else if (!dataCenterId.equals(other.dataCenterId))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlanId == null) {
        if (other.vlanId != null)
            return false;
    } else if (!vlanId.equals(other.vlanId))
        return false;
    if (mtu != other.mtu)
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    if (providedBy == null) {
        if (other.providedBy != null)
            return false;
    } else if (!providedBy.equals(other.providedBy))
        return false;
    if (label == null) {
        if (other.label != null)
            return false;
    } else if (!label.equals(other.label))
        return false;
    if (!ObjectUtils.objectsEqual(qosId, other.qosId)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private Provider<?> getProvider() {
    if (provider == null) {
        provider = getDbFacade().getProviderDao().get(getExternalNetwork().getProviderId());
    }
    return provider;
}
#method_after
private Provider<?> getProvider() {
    if (provider == null && getExternalNetwork() != null) {
        provider = getDbFacade().getProviderDao().get(getExternalNetwork().getProviderId());
    }
    return provider;
}
#end_block

#method_before
private ProviderNetwork getExternalNetwork() {
    if (externalNetwork == null) {
        Network network = getNetworkDAO().get(getParameters().getNetworkId());
        externalNetwork = network.getProvidedBy();
    }
    return externalNetwork;
}
#method_after
private ProviderNetwork getExternalNetwork() {
    if (externalNetwork == null) {
        Network network = getNetworkDAO().get(getParameters().getNetworkId());
        if (network != null) {
            externalNetwork = network.getProvidedBy();
        }
    }
    return externalNetwork;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet()) && super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet());
}
#end_block

#method_before
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (network.getVlanId() == null) {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        } else {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
@Override
public void edit(final NewExternalSubnetModel subnet) {
    driver.edit(subnet);
}
#method_after
@Override
public void edit(final NewExternalSubnetModel subnet) {
    driver.edit(subnet);
    networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName());
}
#end_block

#method_before
public void setName(EntityModel<String> name) {
    this.name = name;
}
#method_after
private void setName(EntityModel<String> name) {
    this.name = name;
}
#end_block

#method_before
public void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#method_after
private void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#end_block

#method_before
public ListModel<NetworkView> getNetwork() {
    return network;
}
#method_after
public EntityModel<NetworkView> getNetwork() {
    return network;
}
#end_block

#method_before
public void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#method_after
private void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#end_block

#method_before
public void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#method_after
private void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getSelectedItem().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getEntity().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#end_block

#method_before
public void flush() {
    if (subnet == null) {
        subnet = new ExternalSubnet();
    }
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getSelectedItem();
    subnet.setExternalNetwork(network != null ? network.getProvidedBy() : null);
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#method_after
public void flush() {
    subnet = new ExternalSubnet();
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getEntity();
    subnet.setExternalNetwork(network.getProvidedBy());
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
public void newSubnet() {
    if (getWindow() != null) {
        return;
    }
    NewExternalSubnetModel model = new NewExternalSubnetModel(this);
    setWindow(model);
    initNetworkInModel(model);
}
#method_after
public void newSubnet() {
    if (getWindow() != null) {
        return;
    }
    NewExternalSubnetModel model = new NewExternalSubnetModel(getEntity(), this);
    setWindow(model);
}
#end_block

#method_before
@Override
public NetworkView getEntity() {
    return (NetworkView) ((super.getEntity() instanceof NetworkView) ? super.getEntity() : null);
}
#method_after
@Override
public NetworkView getEntity() {
    return (NetworkView) super.getEntity();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        @SuppressWarnings("unchecked")
        public void onSuccess(Object model, Object returnValue) {
            NetworkExternalSubnetListModel.this.setItems((List<ExternalSubnet>) returnValue);
        }
    };
    AsyncDataProvider.getExternalSubnetsByNetworkId(asyncQuery, getEntity().getId());
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch(VdcQueryType.GetExternalSubnetsOnProviderByNetwork, new IdQueryParameters(getEntity().getId()));
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.PropertyName.equals("name")) {
        // $NON-NLS-1$
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.propertyName.equals("name")) {
        // $NON-NLS-1$
        getSearchCommand().execute();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    NetworkView network = getEntity();
    getNewCommand().setIsExecutionAllowed(network != null && network.isExternal());
    getRemoveCommand().setIsExecutionAllowed((getSelectedItems() != null && getSelectedItems().size() > 0));
}
#method_after
private void updateActionAvailability() {
    getRemoveCommand().setIsExecutionAllowed((getSelectedItems() != null && getSelectedItems().size() > 0));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newSubnet();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newSubnet();
    } else if (command == getRemoveCommand()) {
        remove();
    }
}
#end_block

#method_before
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (network.getVlanId() == null) {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        } else {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet()) && super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet());
}
#end_block

#method_before
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (NetworkClusterModel networkClusterModel : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(networkClusterModel.isRequired());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(networkClusterModel.getEntity(), tempVar));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
    if ((Boolean) getExport().getEntity() && !getSubnetName().getEntity().isEmpty()) {
        ExternalSubnet subnet = new ExternalSubnet();
        subnet.setName(getSubnetName().getEntity());
        subnet.setCidr(getSubnetCidr().getEntity());
        subnet.setIpVersion(getSubnetIpVersion().getSelectedItem());
        actionParameters1 = new ArrayList<VdcActionParametersBase>();
        actionParameters1.add(new AddExternalSubnetParameters(subnet, networkId));
        Frontend.getInstance().runMultipleAction(VdcActionType.AddSubnetToProvider, actionParameters1);
    }
}
#method_after
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (NetworkClusterModel networkClusterModel : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(networkClusterModel.isRequired());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(networkClusterModel.getEntity(), tempVar));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
    if ((Boolean) getExport().getEntity() && getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        ExternalSubnet subnet = new ExternalSubnet();
        subnet.setName(getSubnetName().getEntity());
        subnet.setCidr(getSubnetCidr().getEntity());
        subnet.setIpVersion(getSubnetIpVersion().getSelectedItem());
        Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, networkId));
    }
}
#end_block

#method_before
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            }
        }
    });
    getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
}
#method_after
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            }
        }
    });
    getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    getSubnetCidr().setIsValid(true);
    getSubnetIpVersion().setIsValid(true);
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        getSubnetCidr().validateEntity(new IValidation[] { new NotEmptyValidation() });
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#method_after
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        getSubnetCidr().validateEntity(new IValidation[] { new NotEmptyValidation() });
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#end_block

