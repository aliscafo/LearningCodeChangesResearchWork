2052
#method_before
@Override
protected void configure() {
    factory(LfsGetLocksAction.Factory.class);
    factory(LfsPutLocksAction.Factory.class);
    factory(LfsProjectLocks.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(LfsGetLocksAction.Factory.class);
    factory(LfsPutLocksAction.Factory.class);
    factory(LfsProjectLocks.Factory.class);
    install(LfsLocksHandler.module());
}
#end_block

#method_before
LfsLockResponse createLock(String project, CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    LfsLock lock = locks.createLock(user, input);
    return new LfsLockResponse(lock);
}
#method_after
LfsLockResponse createLock(Project.NameKey project, CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    LfsLock lock = locks.createLock(user, input);
    return new LfsLockResponse(lock);
}
#end_block

#method_before
LfsLockResponse deleteLock(String project, CurrentUser user, String lockId, LfsDeleteLockInput input) throws LfsException {
    log.debug("Delete (-f {}) lock for {} in project {}", Boolean.TRUE.equals(input.force), lockId, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Optional<LfsLock> hasLock = locks.getLock(lockId);
    if (!hasLock.isPresent()) {
        throw new LfsException(String.format("there is no lock id %s in project %s", lockId, project));
    }
    LfsLock lock = hasLock.get();
    if (lock.owner.name.equals(user.getUserName())) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    } else if (input.force) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    }
    throw new LfsException(String.format("Lock %s is owned by different user %s", lockId, lock.owner.name));
}
#method_after
LfsLockResponse deleteLock(Project.NameKey project, CurrentUser user, String lockId, LfsDeleteLockInput input) throws LfsException {
    log.debug("Delete (-f {}) lock for {} in project {}", Boolean.TRUE.equals(input.force), lockId, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Optional<LfsLock> hasLock = locks.getLock(lockId);
    if (!hasLock.isPresent()) {
        throw new LfsException(String.format("there is no lock id %s in project %s", lockId, project));
    }
    LfsLock lock = hasLock.get();
    if (lock.owner.name.equals(user.getUserName())) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    } else if (input.force) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    }
    throw new LfsException(String.format("Lock %s is owned by different user %s", lockId, lock.owner.name));
}
#end_block

#method_before
LfsVerifyLocksResponse verifyLocks(String project, final CurrentUser user) {
    log.debug("Verify list of locks for {} project and user {}", project, user);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() {

        @Override
        public Boolean apply(LfsLock input) {
            return input.owner.name.equals(user.getUserName());
        }
    };
    Map<Boolean, List<LfsLock>> groupByOurs = locks.getLocks().stream().collect(Collectors.groupingBy(isOurs));
    return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
}
#method_after
LfsVerifyLocksResponse verifyLocks(Project.NameKey project, final CurrentUser user) {
    log.debug("Verify list of locks for {} project and user {}", project, user);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() {

        @Override
        public Boolean apply(LfsLock input) {
            return input.owner.name.equals(user.getUserName());
        }
    };
    Map<Boolean, List<LfsLock>> groupByOurs = locks.getLocks().stream().collect(Collectors.groupingBy(isOurs));
    return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
}
#end_block

#method_before
LfsGetLocksResponse listLocksByPath(String project, String path) {
    log.debug("Get lock for {} path in {} project", path, project);
    String lockId = toLockId.apply(path);
    return listLocksById(project, lockId);
}
#method_after
LfsGetLocksResponse listLocksByPath(Project.NameKey project, String path) {
    log.debug("Get lock for {} path in {} project", path, project);
    String lockId = toLockId.apply(path);
    return listLocksById(project, lockId);
}
#end_block

#method_before
LfsGetLocksResponse listLocksById(String project, String id) {
    log.debug("Get lock for {} id in {} project", id, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Optional<LfsLock> lock = locks.getLock(id);
    List<LfsLock> locksById = (lock.isPresent() ? Lists.newArrayList(lock.get()) : Collections.emptyList());
    return new LfsGetLocksResponse(locksById, null);
}
#method_after
LfsGetLocksResponse listLocksById(Project.NameKey project, String id) {
    log.debug("Get lock for {} id in {} project", id, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Optional<LfsLock> lock = locks.getLock(id);
    List<LfsLock> locksById = (lock.isPresent() ? ImmutableList.of(lock.get()) : Collections.emptyList());
    return new LfsGetLocksResponse(locksById, null);
}
#end_block

#method_before
LfsGetLocksResponse listLocks(String project) {
    log.debug("Get locks for {} project", project);
    return new LfsGetLocksResponse(projects.getUnchecked(project).getLocks(), null);
}
#method_after
LfsGetLocksResponse listLocks(Project.NameKey project) {
    log.debug("Get locks for {} project", project);
    return new LfsGetLocksResponse(projectLocks.getUnchecked(project).getLocks(), null);
}
#end_block

#method_before
@Override
public LfsProjectLocks load(String project) throws Exception {
    LfsProjectLocks locks = factory.create(project);
    locks.load();
    return locks;
}
#method_after
@Override
public LfsProjectLocks load(Project.NameKey project) throws Exception {
    LfsProjectLocks locks = factory.create(project);
    locks.load();
    return locks;
}
#end_block

#method_before
Optional<LfsLock> getLock(String lockId) {
    return Optional.fromNullable(locks.getIfPresent(lockId));
}
#method_after
Optional<LfsLock> getLock(String lockId) {
    return Optional.ofNullable(locks.getIfPresent(lockId));
}
#end_block

#method_before
LfsLock createLock(CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    String lockId = toLockId.apply(input.path);
    LfsLock lock = locks.getIfPresent(lockId);
    if (lock != null) {
        throw new LfsLockExistsException(lock);
    }
    lock = new LfsLock(lockId, input.path, now(), new LfsLockOwner(user.getUserName()));
    LockFile fileLock = new LockFile(locksPath.resolve(lockId).toFile());
    try {
        if (!fileLock.lock()) {
            log.warn("Cannot lock path [{}] in project {}", input.path, project);
            throw new LfsLockExistsException(lock);
        }
    } catch (IOException e) {
        String error = String.format("Locking path [%s] in project %s failed with error %s", input.path, project, e.getMessage());
        log.warn(error);
        throw new LfsException(error);
    }
    try {
        try (OutputStreamWriter out = new OutputStreamWriter(fileLock.getOutputStream())) {
            gson.toJson(lock, out);
        } catch (IOException e) {
            String error = String.format("Locking path [%s] in project %s failed during write with error %s", input.path, project, e.getMessage());
            log.warn(error);
            throw new LfsException(error);
        }
        if (!fileLock.commit()) {
            String error = String.format("Committing locking to path [%s] in project %s failed", input.path, project);
            log.warn(error);
            throw new LfsException(error);
        }
    } finally {
        fileLock.unlock();
    }
    locks.put(lockId, lock);
    return lock;
}
#method_after
LfsLock createLock(CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    String lockId = toLockId.apply(input.path);
    LfsLock lock = locks.getIfPresent(lockId);
    if (lock != null) {
        throw new LfsLockExistsException(lock);
    }
    lock = new LfsLock(lockId, input.path, now(), new LfsLockOwner(user.getUserName()));
    LockFile fileLock = new LockFile(locksPath.resolve(lockId).toFile());
    try {
        if (!fileLock.lock()) {
            log.warn("Cannot lock path [{}] in project {}", input.path, project);
            throw new LfsLockExistsException(lock);
        }
    } catch (IOException e) {
        String error = String.format("Locking path [%s] in project %s failed with error %s", input.path, project, e.getMessage());
        log.warn(error);
        throw new LfsException(error);
    }
    try {
        try (OutputStreamWriter out = new OutputStreamWriter(fileLock.getOutputStream())) {
            gson.toJson(lock, out);
        } catch (IOException e) {
            String error = String.format("Locking path [%s] in project %s failed during write with error %s", input.path, project, e.getMessage());
            log.warn(error);
            throw new LfsException(error);
        }
        if (!fileLock.commit()) {
            String error = String.format("Committing lock to path [%s] in project %s failed", input.path, project);
            log.warn(error);
            throw new LfsException(error);
        }
        // put lock object to cache while file lock is being hold so that
        // there is no chance that other process performs lock operation
        // in the meantime (either cache returns with existing object or
        // LockFile.lock fails on locking attempt)
        locks.put(lockId, lock);
    } finally {
        fileLock.unlock();
    }
    return lock;
}
#end_block

#method_before
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, context);
        } else {
            deleteLock(project, lockId, context);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL.matcher(context.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), context);
        return;
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#method_after
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, context);
        } else {
            deleteLock(project, lockId, context);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), context);
        return;
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#end_block

#method_before
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project);
    }
    throw new LfsException("no repository at " + context.path);
}
#method_after
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project);
    }
    throw new LfsException("no repository at " + context.path);
}
#end_block

#method_before
static Map<String, Config> parse(GerritPluginConfigs annotation) {
    if (annotation == null || annotation.value().length < 1) {
        return null;
    }
    HashMap<String, Config> result = new HashMap<>();
    for (GerritPluginConfig c : annotation.value()) {
        String pluginName = c.pluginName();
        Config config;
        if (result.containsKey(pluginName)) {
            config = result.get(pluginName);
        } else {
            config = new Config();
            result.put(pluginName, config);
        }
        parseAnnotation(config, new GerritPluginConfigToGerritConfig(c));
    }
    return result;
}
#method_after
static Map<String, Config> parse(GlobalPluginConfig annotation) {
    if (annotation == null) {
        return null;
    }
    Map<String, Config> result = new HashMap<>();
    Config cfg = new Config();
    parseAnnotation(cfg, new GlobalPluginConfigToGerritConfig(annotation));
    result.put(annotation.pluginName(), cfg);
    return result;
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null, // @GerritPluginConfig is only valid on methods.
    null, // @GerritPluginConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null, // @GlobalPluginConfig is only valid on methods.
    null, // @GlobalPluginConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class), testDesc.getAnnotation(GerritPluginConfig.class), testDesc.getAnnotation(GerritPluginConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class), testDesc.getAnnotation(GlobalPluginConfig.class), testDesc.getAnnotation(GlobalPluginConfigs.class));
}
#end_block

#method_before
private Config buildConfig(Config baseConfig) {
    if (configs() != null && config() != null) {
        throw new IllegalStateException("Use either @GerritConfigs or @GerritConfig not both");
    }
    if (configs() != null) {
        return ConfigAnnotationParser.parse(baseConfig, configs());
    } else if (config() != null) {
        return ConfigAnnotationParser.parse(baseConfig, config());
    } else {
        return baseConfig;
    }
}
#method_after
private Config buildConfig(Config baseConfig) {
    if (configs() != null) {
        return ConfigAnnotationParser.parse(baseConfig, configs());
    } else if (config() != null) {
        return ConfigAnnotationParser.parse(baseConfig, config());
    } else {
        return baseConfig;
    }
}
#end_block

#method_before
private Map<String, Config> buildPluginConfigs() {
    if (pluginConfigs() != null && pluginConfig() != null) {
        throw new IllegalStateException("Use either @GerritPluginConfig or @GerritPluginConfigs not both");
    }
    if ((pluginConfigs() != null || pluginConfig() != null) && memory()) {
        throw new IllegalStateException("Must use @UseLocalDisk with @GerritPluginConfig(s)");
    }
    if (pluginConfigs() != null) {
        return ConfigAnnotationParser.parse(pluginConfigs());
    } else if (pluginConfig() != null) {
        return ConfigAnnotationParser.parse(pluginConfig());
    }
    return new HashMap<>();
}
#method_after
private Map<String, Config> buildPluginConfigs() {
    if (pluginConfigs() != null) {
        return ConfigAnnotationParser.parse(pluginConfigs());
    } else if (pluginConfig() != null) {
        return ConfigAnnotationParser.parse(pluginConfig());
    }
    return new HashMap<>();
}
#end_block

#method_before
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg, desc.buildPluginConfigs());
        daemonService = Executors.newSingleThreadExecutor();
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#method_after
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    desc.checkValidAnnotations();
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg, desc.buildPluginConfigs());
        daemonService = Executors.newSingleThreadExecutor();
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#end_block

#method_before
private static List<Runner> runnersFor(Class<?> clazz) {
    Method defaultConfig = getDefaultConfig(clazz);
    List<Method> configs = getConfigs(clazz);
    Method configMap = getConfigMap(clazz);
    Field parameterField = getOnlyField(clazz, Parameter.class);
    checkArgument(parameterField != null, "No @ConfigSuite.Field found");
    Field nameField = getOnlyField(clazz, Name.class);
    List<Runner> result = Lists.newArrayListWithCapacity(configs.size() + 1);
    try {
        result.add(new ConfigRunner(clazz, parameterField, nameField, null, callConfigMethod(defaultConfig)));
        for (Method m : configs) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, m.getName(), callConfigMethod(m)));
        }
        for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : callConfigMapMethod(configMap).entrySet()) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, e.getKey(), e.getValue()));
        }
        return result;
    } catch (InitializationError e) {
        System.err.println("Errors initializing runners:");
        for (Throwable t : e.getCauses()) {
            t.printStackTrace();
        }
        throw new RuntimeException(e);
    }
}
#method_after
private static List<Runner> runnersFor(Class<?> clazz) {
    Method defaultConfig = getDefaultConfig(clazz);
    List<Method> configs = getConfigs(clazz);
    Map<String, org.eclipse.jgit.lib.Config> configMap = callConfigMapMethod(getConfigMap(clazz), configs);
    Field parameterField = getOnlyField(clazz, Parameter.class);
    checkArgument(parameterField != null, "No @ConfigSuite.Field found");
    Field nameField = getOnlyField(clazz, Name.class);
    List<Runner> result = Lists.newArrayListWithCapacity(configs.size() + 1);
    try {
        result.add(new ConfigRunner(clazz, parameterField, nameField, null, callConfigMethod(defaultConfig)));
        for (Method m : configs) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, m.getName(), callConfigMethod(m)));
        }
        for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : configMap.entrySet()) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, e.getKey(), e.getValue()));
        }
        return result;
    } catch (InitializationError e) {
        System.err.println("Errors initializing runners:");
        for (Throwable t : e.getCauses()) {
            t.printStackTrace();
        }
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m) {
    if (m == null) {
        return ImmutableMap.of();
    }
    checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m);
    Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments();
    checkArgument(String.class.getTypeName().equals(types[0].getTypeName()), "The map returned by %s must have String as key", m);
    checkArgument(org.eclipse.jgit.lib.Config.class.getTypeName().equals(types[1].getTypeName()), "The map returned by %s must have Config as value", m);
    checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m);
    checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m);
    try {
        @SuppressWarnings("unchecked")
        Map<String, org.eclipse.jgit.lib.Config> configMap = (Map<String, org.eclipse.jgit.lib.Config>) m.invoke(null);
        return configMap;
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m, List<Method> configs) {
    if (m == null) {
        return ImmutableMap.of();
    }
    checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m);
    Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments();
    checkArgument(String.class.isAssignableFrom((Class<?>) types[0]), "The map returned by %s must have String as key", m);
    checkArgument(org.eclipse.jgit.lib.Config.class.isAssignableFrom((Class<?>) types[1]), "The map returned by %s must have Config as value", m);
    checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m);
    checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m);
    try {
        @SuppressWarnings("unchecked")
        Map<String, org.eclipse.jgit.lib.Config> configMap = (Map<String, org.eclipse.jgit.lib.Config>) m.invoke(null);
        checkArgument(!configMap.containsKey(DEFAULT), "The map returned by %s cannot contain key %s (duplicate test suite name)", m, DEFAULT);
        for (String name : configs.stream().map(cm -> cm.getName()).collect(toSet())) {
            checkArgument(!configMap.containsKey(name), "The map returned by %s cannot contain key %s (duplicate test suite name)", m, name);
        }
        return configMap;
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<AccountState>> schemas = SchemaUtil.schemasFromClass(AccountSchemaDefinitions.class, AccountState.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", AccountSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<AccountState> prevSchema = AccountSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", AccountSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<ChangeData>> schemas = SchemaUtil.schemasFromClass(ChangeSchemaDefinitions.class, ChangeData.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", ChangeSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<ChangeData> prevSchema = ChangeSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", ChangeSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Test
public void byInname() throws Exception {
    String namePart = testName.getMethodName();
    namePart = namePart.replaceAll("[\\[\\]]", "");
    GroupInfo group1 = createGroup("group-" + namePart);
    GroupInfo group2 = createGroup("group-" + namePart + "-2");
    GroupInfo group3 = createGroup("group-" + namePart + "3");
    assertQuery("inname:" + namePart, group1, group2, group3);
    assertQuery("inname:" + namePart.toUpperCase(Locale.US), group1, group2, group3);
    assertQuery("inname:" + namePart.toLowerCase(Locale.US), group1, group2, group3);
}
#method_after
@Test
public void byInname() throws Exception {
    String namePart = getSanitizedMethodName();
    namePart = CharMatcher.is('_').removeFrom(namePart);
    GroupInfo group1 = createGroup("group-" + namePart);
    GroupInfo group2 = createGroup("group-" + namePart + "-2");
    GroupInfo group3 = createGroup("group-" + namePart + "3");
    assertQuery("inname:" + namePart, group1, group2, group3);
    assertQuery("inname:" + namePart.toUpperCase(Locale.US), group1, group2, group3);
    assertQuery("inname:" + namePart.toLowerCase(Locale.US), group1, group2, group3);
}
#end_block

#method_before
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = testName.getMethodName().toLowerCase();
    suffix = suffix.replaceAll("[\\[\\]]", "_");
    if (suffix.endsWith("_")) {
        suffix = suffix.substring(0, suffix.length() - 1);
    }
    return name + "_" + suffix;
}
#method_after
protected String name(String name) {
    if (name == null) {
        return null;
    }
    return name + "_" + getSanitizedMethodName();
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<AccountGroup>> schemas = SchemaUtil.schemasFromClass(GroupSchemaDefinitions.class, AccountGroup.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", GroupSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<AccountGroup> prevSchema = GroupSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", GroupSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Test
public void byName() throws Exception {
    AccountInfo user1 = newAccountWithFullName("jdoe", "John Doe");
    AccountInfo user2 = newAccountWithFullName("jroe", "Jane Roe");
    AccountInfo user3 = newAccountWithFullName("user3", "Mr Selfish");
    assertQuery("notexisting");
    assertQuery("Not Existing");
    assertQuery(quote(user1.name), user1);
    assertQuery("name:" + quote(user1.name), user1);
    assertQuery("John", user1);
    assertQuery("john", user1);
    assertQuery("Doe", user1);
    assertQuery("doe", user1);
    assertQuery("DOE", user1);
    assertQuery("Jo Do", user1);
    assertQuery("jo do", user1);
    assertQuery("self", currentUserInfo, user3);
    assertQuery("name:John", user1);
    assertQuery("name:john", user1);
    assertQuery("name:Doe", user1);
    assertQuery("name:doe", user1);
    assertQuery("name:DOE", user1);
    assertQuery("name:self", user3);
    assertQuery(quote(user2.name), user2);
    assertQuery("name:" + quote(user2.name), user2);
}
#method_after
@Test
public void byName() throws Exception {
    AccountInfo user1 = newAccountWithFullName("jdoe", "John Doe");
    AccountInfo user2 = newAccountWithFullName("jroe", "Jane Roe");
    AccountInfo user3 = newAccountWithFullName("user3", "Mr Selfish");
    assertQuery("notexisting");
    assertQuery("Not Existing");
    assertQuery(quote(user1.name), user1);
    assertQuery("name:" + quote(user1.name), user1);
    assertQuery("John", user1);
    assertQuery("john", user1);
    assertQuery("Doe", user1);
    assertQuery("doe", user1);
    assertQuery("DOE", user1);
    assertQuery("Jo Do", user1);
    assertQuery("jo do", user1);
    assertQuery("self", currentUserInfo, user3);
    assertQuery("me", currentUserInfo);
    assertQuery("name:John", user1);
    assertQuery("name:john", user1);
    assertQuery("name:Doe", user1);
    assertQuery("name:doe", user1);
    assertQuery("name:DOE", user1);
    assertQuery("name:self", user3);
    assertQuery(quote(user2.name), user2);
    assertQuery("name:" + quote(user2.name), user2);
}
#end_block

#method_before
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = testName.getMethodName().toLowerCase();
    suffix = suffix.replaceAll("[\\[\\]]", "_");
    if (suffix.endsWith("_")) {
        suffix = suffix.substring(0, suffix.length() - 1);
    }
    if (name.contains("@")) {
        return name + "." + suffix;
    }
    return name + "_" + suffix;
}
#method_after
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = getSanitizedMethodName();
    if (name.contains("@")) {
        return name + "." + suffix;
    }
    return name + "_" + suffix;
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#method_after
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true, null);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#end_block

#method_before
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertThat(getSchema().hasField(ChangeField.WIP)).isFalse();
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#method_after
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < 42) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#end_block

#method_before
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertThat(getSchema().hasField(ChangeField.WIP)).isFalse();
        return;
    }
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    assertQuery("reviewer:" + user1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
}
#method_after
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 42) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
@Override
public ChangeApi id(String project, int id) throws RestApiException {
    return id(project + "/+/" + id);
}
#method_after
@Override
public ChangeApi id(String project, int id) throws RestApiException {
    return id(Joiner.on('~').join(ImmutableList.of(Url.encode(project), Url.encode(String.valueOf(id)))));
}
#end_block

#method_before
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    // Try project/+/numericChangeId
    if (id.contains(PROJECT_CHANGE_DELIMITER)) {
        int lastDel = id.lastIndexOf(PROJECT_CHANGE_DELIMITER);
        if (lastDel > 0) {
            String project = id.substring(0, lastDel);
            Integer n = Ints.tryParse(id.substring(lastDel + PROJECT_CHANGE_DELIMITER.length()));
            if (n != null) {
                try {
                    return ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), new Change.Id(n), user));
                } catch (NoSuchChangeException e) {
                    return Collections.emptyList();
                } catch (IllegalArgumentException e) {
                    // Change or Project unknown. This exception is thrown in checkArgument calls in NoteDb.
                    return Collections.emptyList();
                } catch (OrmException e) {
                    // other OrmExceptions (failure in the persistence layer).
                    if (Throwables.getRootCause(e) instanceof RepositoryNotFoundException) {
                        return Collections.emptyList();
                    }
                    throw e;
                }
            }
        }
    }
    // Try legacy id
    if (id.charAt(0) != '0') {
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return asChangeControls(query.byLegacyChangeId(new Change.Id(n)), user);
        }
    }
    // Try isolated changeId
    if (!id.contains("~")) {
        return asChangeControls(query.byKeyPrefix(id), user);
    }
    // Try change triplet
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id);
    if (triplet.isPresent()) {
        return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user);
    }
    return Collections.emptyList();
}
#method_after
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    int numTwiddles = 0;
    for (char c : id.toCharArray()) {
        if (c == '~') {
            numTwiddles++;
        }
    }
    if (numTwiddles == 1) {
        // Try project~numericChangeId
        String project = id.substring(0, id.indexOf('~'));
        Integer n = Ints.tryParse(id.substring(project.length() + 1));
        if (n != null) {
            Change.Id changeId = new Change.Id(n);
            try {
                return ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), changeId, user));
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            } catch (IllegalArgumentException e) {
                String changeNotFound = String.format("change %s not found in ReviewDb", changeId);
                String projectNotFound = String.format("passed project %s when creating ChangeNotes for %s, but actual project is", project, changeId);
                if (e.getMessage().equals(changeNotFound) || e.getMessage().startsWith(projectNotFound)) {
                    return Collections.emptyList();
                }
                throw e;
            } catch (OrmException e) {
                // other OrmExceptions (failure in the persistence layer).
                if (Throwables.getRootCause(e) instanceof RepositoryNotFoundException) {
                    return Collections.emptyList();
                }
                throw e;
            }
        }
    } else if (numTwiddles == 2) {
        // Try change triplet
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id);
        if (triplet.isPresent()) {
            return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user);
        }
    }
    // Try numeric changeId
    if (id.charAt(0) != '0') {
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return asChangeControls(query.byLegacyChangeId(new Change.Id(n)), user);
        }
    }
    // Try isolated changeId
    return asChangeControls(query.byKeyPrefix(id), user);
}
#end_block

#method_before
@Override
public CommitInfo commit(boolean addLinks) throws RestApiException {
    try {
        return getCommit.setAddLinks(addLinks).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public CommitInfo commit(boolean addLinks) throws RestApiException {
    try {
        return getCommit.setAddLinks(addLinks).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve commit", e);
    }
}
#end_block

#method_before
public GetCommit setAddLinks(boolean addLinks) {
    this.addLinks = addLinks;
    return this;
}
#method_after
@Option(name = "--links", usage = "Include weblinks")
public GetCommit setAddLinks(boolean addLinks) {
    this.addLinks = addLinks;
    return this;
}
#end_block

#method_before
@Test
public void commit() throws Exception {
    WebLinkInfo expectedWebLinkInfo = new WebLinkInfo("foo", "imageUrl", "url");
    patchSetLinks.add(new PatchSetWebLink() {

        @Override
        public WebLinkInfo getPatchSetWebLink(String projectName, String commit) {
            return expectedWebLinkInfo;
        }
    });
    Result r = createChange();
    RevCommit c = r.getCommit();
    CommitInfo commitInfo = gApi.changes().id(r.getChangeId()).current().commit(false);
    assertThat(commitInfo.commit).isEqualTo(c.name());
    assertPersonIdent(commitInfo.author, c.getAuthorIdent());
    assertPersonIdent(commitInfo.committer, c.getCommitterIdent());
    assertThat(commitInfo.message).isEqualTo(c.getFullMessage());
    assertThat(commitInfo.subject).isEqualTo(c.getShortMessage());
    assertThat(commitInfo.parents).hasSize(1);
    assertThat(Iterables.getOnlyElement(commitInfo.parents).commit).isEqualTo(c.getParent(0).name());
    assertThat(commitInfo.webLinks).isNull();
    commitInfo = gApi.changes().id(r.getChangeId()).current().commit(true);
    assertThat(commitInfo.webLinks).hasSize(1);
    WebLinkInfo webLinkInfo = Iterables.getOnlyElement(commitInfo.webLinks);
    assertThat(webLinkInfo.name).isEqualTo(expectedWebLinkInfo.name);
    assertThat(webLinkInfo.imageUrl).isEqualTo(expectedWebLinkInfo.imageUrl);
    assertThat(webLinkInfo.url).isEqualTo(expectedWebLinkInfo.url);
    assertThat(webLinkInfo.target).isEqualTo(expectedWebLinkInfo.target);
}
#method_after
@Test
public void commit() throws Exception {
    WebLinkInfo expectedWebLinkInfo = new WebLinkInfo("foo", "imageUrl", "url");
    patchSetLinks.add(new PatchSetWebLink() {

        @Override
        public WebLinkInfo getPatchSetWebLink(String projectName, String commit) {
            return expectedWebLinkInfo;
        }
    });
    PushOneCommit.Result r = createChange();
    RevCommit c = r.getCommit();
    CommitInfo commitInfo = gApi.changes().id(r.getChangeId()).current().commit(false);
    assertThat(commitInfo.commit).isEqualTo(c.name());
    assertPersonIdent(commitInfo.author, c.getAuthorIdent());
    assertPersonIdent(commitInfo.committer, c.getCommitterIdent());
    assertThat(commitInfo.message).isEqualTo(c.getFullMessage());
    assertThat(commitInfo.subject).isEqualTo(c.getShortMessage());
    assertThat(commitInfo.parents).hasSize(1);
    assertThat(Iterables.getOnlyElement(commitInfo.parents).commit).isEqualTo(c.getParent(0).name());
    assertThat(commitInfo.webLinks).isNull();
    commitInfo = gApi.changes().id(r.getChangeId()).current().commit(true);
    assertThat(commitInfo.webLinks).hasSize(1);
    WebLinkInfo webLinkInfo = Iterables.getOnlyElement(commitInfo.webLinks);
    assertThat(webLinkInfo.name).isEqualTo(expectedWebLinkInfo.name);
    assertThat(webLinkInfo.imageUrl).isEqualTo(expectedWebLinkInfo.imageUrl);
    assertThat(webLinkInfo.url).isEqualTo(expectedWebLinkInfo.url);
    assertThat(webLinkInfo.target).isEqualTo(expectedWebLinkInfo.target);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (byState == Predicate.<ChangeData>any()) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    String email = parseEmail(who);
    if (email.isEmpty()) {
        return new AuthorPredicate(who);
    }
    return Predicate.or(Arrays.asList(new AuthorPredicate(email), new AuthorPredicate(who)));
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    String email = parseEmail(who);
    if (email.isEmpty()) {
        return new CommitterPredicate(who);
    }
    return Predicate.or(Arrays.asList(new CommitterPredicate(email), new CommitterPredicate(who)));
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(inMemoryDatabase);
}
#end_block

#method_before
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessage("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#method_after
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessageThat().isEqualTo("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessage("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessage("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessage("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#method_after
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessageThat().isEqualTo("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#end_block

#method_before
@Test
public void byDraftByExcludesZombieDrafts() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    Change change = insert(repo, newChange(repo));
    Change.Id id = change.getId();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = Patch.COMMIT_MSG;
    gApi.changes().id(id.get()).current().createDraft(in);
    assertQuery("draftby:" + userId, change);
    assertQuery("commentby:" + userId);
    TestRepository<Repo> allUsers = new TestRepository<>(repoManager.openRepository(allUsersName));
    Ref draftsRef = allUsers.getRepository().exactRef(RefNames.refsDraftComments(id, userId));
    assertThat(draftsRef).isNotNull();
    ReviewInput rin = ReviewInput.dislike();
    rin.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    gApi.changes().id(id.get()).current().review(rin);
    assertQuery("draftby:" + userId);
    assertQuery("commentby:" + userId, change);
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNull();
    // Re-add drafts ref and ensure it gets filtered out during indexing.
    allUsers.update(draftsRef.getName(), draftsRef.getObjectId());
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNotNull();
    if (PrimaryStorage.of(change) == PrimaryStorage.REVIEW_DB) {
        // Record draft ref in noteDbState as well.
        ReviewDb db = ReviewDbUtil.unwrapDb(this.db);
        change = db.changes().get(id);
        NoteDbChangeState.applyDelta(change, NoteDbChangeState.Delta.create(id, Optional.empty(), ImmutableMap.of(userId, draftsRef.getObjectId())));
        db.changes().update(Collections.singleton(change));
    }
    indexer.index(db, project, id);
    assertQuery("draftby:" + userId);
}
#method_after
@Test
public void byDraftByExcludesZombieDrafts() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    Change change = insert(repo, newChange(repo));
    Change.Id id = change.getId();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = Patch.COMMIT_MSG;
    gApi.changes().id(id.get()).current().createDraft(in);
    assertQuery("draftby:" + userId, change);
    assertQuery("commentby:" + userId);
    TestRepository<Repo> allUsers = new TestRepository<>(repoManager.openRepository(allUsersName));
    Ref draftsRef = allUsers.getRepository().exactRef(RefNames.refsDraftComments(id, userId));
    assertThat(draftsRef).isNotNull();
    ReviewInput rin = ReviewInput.dislike();
    rin.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    gApi.changes().id(id.get()).current().review(rin);
    assertQuery("draftby:" + userId);
    assertQuery("commentby:" + userId, change);
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNull();
    // Re-add drafts ref and ensure it gets filtered out during indexing.
    allUsers.update(draftsRef.getName(), draftsRef.getObjectId());
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNotNull();
    if (PrimaryStorage.of(change) == PrimaryStorage.REVIEW_DB && !notesMigration.disableChangeReviewDb()) {
        // Record draft ref in noteDbState as well.
        ReviewDb db = ReviewDbUtil.unwrapDb(this.db);
        change = db.changes().get(id);
        NoteDbChangeState.applyDelta(change, NoteDbChangeState.Delta.create(id, Optional.empty(), ImmutableMap.of(userId, draftsRef.getObjectId())));
        db.changes().update(Collections.singleton(change));
    }
    indexer.index(db, project, id);
    assertQuery("draftby:" + userId);
}
#end_block

#method_before
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
}
#method_after
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change3 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change4 = insert(repo, newChange(repo));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    gApi.accounts().self().setStars(change4.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("ignore"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change4, change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
    // check ignored
    assertQuery("is:ignored", change4);
    assertQuery("-is:ignored", change3, change2, change1);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidatePolicy(CommitValidators.Policy.NONE).setStatus(status).setTopic(topic);
    return ins;
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidate(false).setStatus(status).setTopic(topic);
    return ins;
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter()) {
        bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false));
        c.setReuseAddress(reuseAddress);
        c.setIdleTimeout(cfg.getTimeUnit("httpd", null, "idleTimeout", 30000L, TimeUnit.MILLISECONDS));
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false));
        c.setReuseAddress(reuseAddress);
        c.setIdleTimeout(cfg.getTimeUnit("httpd", null, "idleTimeout", 30000L, MILLISECONDS));
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
@Override
public void setPrivate(boolean value, String message) {
    throw new NotImplementedException();
}
#method_after
@Override
public void setPrivate(boolean value, @Nullable String message) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains(msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains(msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true, null);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false, null);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#method_after
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isNull();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
}
#end_block

#method_before
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#method_after
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#end_block

#method_before
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#method_after
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#end_block

#method_before
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#method_after
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#end_block

#method_before
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange();
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    changeAbandoner.batchAbandon(controlA.get(0).getProject().getNameKey(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#method_after
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange();
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    changeAbandoner.batchAbandon(batchUpdateFactory, controlA.get(0).getProject().getNameKey(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#end_block

#method_before
@Test
public void batchAbandonChangeProject() throws Exception {
    String project1Name = name("Project1");
    String project2Name = name("Project2");
    gApi.projects().create(project1Name);
    gApi.projects().create(project2Name);
    TestRepository<InMemoryRepository> project1 = cloneProject(new Project.NameKey(project1Name));
    TestRepository<InMemoryRepository> project2 = cloneProject(new Project.NameKey(project2Name));
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange(project1, "master", "x", "x", "x", "");
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange(project2, "master", "x", "x", "x", "");
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Project name \"%s\" doesn't match \"%s\"", project2Name, project1Name));
    changeAbandoner.batchAbandon(new Project.NameKey(project1Name), user, list);
}
#method_after
@Test
public void batchAbandonChangeProject() throws Exception {
    String project1Name = name("Project1");
    String project2Name = name("Project2");
    gApi.projects().create(project1Name);
    gApi.projects().create(project2Name);
    TestRepository<InMemoryRepository> project1 = cloneProject(new Project.NameKey(project1Name));
    TestRepository<InMemoryRepository> project2 = cloneProject(new Project.NameKey(project2Name));
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange(project1, "master", "x", "x", "x", "");
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange(project2, "master", "x", "x", "x", "");
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Project name \"%s\" doesn't match \"%s\"", project2Name, project1Name));
    changeAbandoner.batchAbandon(batchUpdateFactory, new Project.NameKey(project1Name), user, list);
}
#end_block

#method_before
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#method_after
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = batchUpdateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PutPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public void setPrivate(boolean value, String message) throws RestApiException {
    try {
        SetPrivateOp.Input input = new SetPrivateOp.Input(message);
        if (value) {
            putPrivate.apply(change, input);
        } else {
            deletePrivate.apply(change, input);
        }
    } catch (UpdateException e) {
        throw new RestApiException("Cannot change private status", e);
    }
}
#method_after
@Override
public void setPrivate(boolean value, @Nullable String message) throws RestApiException {
    try {
        SetPrivateOp.Input input = new SetPrivateOp.Input(message);
        if (value) {
            postPrivate.apply(change, input);
        } else {
            deletePrivate.apply(change, input);
        }
    } catch (Exception e) {
        throw asRestApiException("Cannot change private status", e);
    }
}
#end_block

#method_before
@Override
public void setWorkInProgress(String message) throws RestApiException {
    try {
        setWip.apply(change, new WorkInProgressOp.Input(message));
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set work in progress state", e);
    }
}
#method_after
@Override
public void setWorkInProgress(String message) throws RestApiException {
    try {
        setWip.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throw asRestApiException("Cannot set work in progress state", e);
    }
}
#end_block

#method_before
@Override
public void setReadyForReview(String message) throws RestApiException {
    try {
        setReady.apply(change, new WorkInProgressOp.Input(message));
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set ready for review state", e);
    }
}
#method_after
@Override
public void setReadyForReview(String message) throws RestApiException {
    try {
        setReady.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throw asRestApiException("Cannot set ready for review state", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (IOException | UpdateException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot update change by merge", e);
    }
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot publish change", e);
    }
}
#method_after
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot publish change", e);
    }
}
#end_block

#method_before
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (EmailException | OrmException | UpdateException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot rebase change", e);
    }
}
#method_after
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot rebase change", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Could not extract IncludedIn data", e);
    }
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Could not extract IncludedIn data", e);
    }
}
#end_block

#method_before
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot get hashtags", e);
    }
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get drafts", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        return check.apply(change, fix).value();
    } catch (OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        // ConsistencyChecker.
        return check.apply(change, fix).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Override
public void ignore(boolean ignore) throws RestApiException {
    if (ignore) {
        this.ignore.apply(change, new Ignore.Input());
    } else {
        unignore.apply(change, new Unignore.Input());
    }
}
#method_after
@Override
public void ignore(boolean ignore) throws RestApiException {
    // StarredChangesUtil.
    if (ignore) {
        this.ignore.apply(change, new Ignore.Input());
    } else {
        unignore.apply(change, new Unignore.Input());
    }
}
#end_block

#method_before
@Override
public void mute(boolean mute) throws RestApiException {
    if (mute) {
        this.mute.apply(change, new Mute.Input());
    } else {
        unmute.apply(change, new Unmute.Input());
    }
}
#method_after
@Override
public void mute(boolean mute) throws RestApiException {
    // StarredChangesUtil.
    if (mute) {
        this.mute.apply(change, new Mute.Input());
    } else {
        unmute.apply(change, new Unmute.Input());
    }
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            // Workaround for JDK-6518827 - zero-length argument ignored on Win32
            String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
            if (!exists(site.ssh_rsa)) {
                System.err.print(" rsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_dsa)) {
                System.err.print(" dsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_ed25519)) {
                System.err.print(" ed25519...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue as since older hosts wont be able to generate ed25519 keys.
                    System.err.print(" Failed to generate ed25519 key, continuing...");
                    System.err.flush();
                }
            }
            if (!exists(site.ssh_ecdsa)) {
                System.err.print(" ecdsa...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ecdsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue as since older hosts wont be able to generate ecdsa keys.
                    System.err.print(" Failed to generate ecdsa key, continuing...");
                    System.err.flush();
                }
            }
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (!exists(site.ssh_key) && !exists(site.ssh_rsa) && !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            // Workaround for JDK-6518827 - zero-length argument ignored on Win32
            String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
            if (!exists(site.ssh_rsa)) {
                System.err.print(" rsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_dsa)) {
                System.err.print(" dsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_ed25519)) {
                System.err.print(" ed25519...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue since older hosts won't be able to generate ed25519 keys.
                    System.err.print(" Failed to generate ed25519 key, continuing...");
                    System.err.flush();
                }
            }
            if (!exists(site.ssh_ecdsa)) {
                System.err.print(" ecdsa...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ecdsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue since older hosts won't be able to generate ecdsa keys.
                    System.err.print(" Failed to generate ecdsa key, continuing...");
                    System.err.flush();
                }
            }
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
@Override
public KeyPairProvider get() {
    Path objKey = site.ssh_key;
    Path rsaKey = site.ssh_rsa;
    Path dsaKey = site.ssh_dsa;
    Path ecdsaKey = site.ssh_ecdsa;
    Path ed25519Key = site.ssh_ed25519;
    final List<File> stdKeys = new ArrayList<>(2);
    if (Files.exists(rsaKey)) {
        stdKeys.add(rsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(dsaKey)) {
        stdKeys.add(dsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ecdsaKey)) {
        stdKeys.add(ecdsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ed25519Key)) {
        stdKeys.add(ed25519Key.toAbsolutePath().toFile());
    }
    if (Files.exists(objKey)) {
        if (stdKeys.isEmpty()) {
            SimpleGeneratorHostKeyProvider p = new SimpleGeneratorHostKeyProvider();
            p.setPath(objKey.toAbsolutePath());
            return p;
        }
        // Both formats of host key exist, we don't know which format
        // should be authoritative. Complain and abort.
        // 
        stdKeys.add(objKey.toAbsolutePath().toFile());
        throw new ProvisionException("Multiple host keys exist: " + stdKeys);
    }
    if (stdKeys.isEmpty()) {
        throw new ProvisionException("No SSH keys under " + site.etc_dir);
    }
    if (!SecurityUtils.isBouncyCastleRegistered()) {
        throw new ProvisionException("Bouncy Castle Crypto not installed;" + " needed to read server host keys: " + stdKeys + "");
    }
    FileKeyPairProvider kp = new FileKeyPairProvider();
    kp.setFiles(stdKeys);
    return kp;
}
#method_after
@Override
public KeyPairProvider get() {
    Path objKey = site.ssh_key;
    Path rsaKey = site.ssh_rsa;
    Path dsaKey = site.ssh_dsa;
    Path ecdsaKey = site.ssh_ecdsa;
    Path ed25519Key = site.ssh_ed25519;
    final List<File> stdKeys = new ArrayList<>(4);
    if (Files.exists(rsaKey)) {
        stdKeys.add(rsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(dsaKey)) {
        stdKeys.add(dsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ecdsaKey)) {
        stdKeys.add(ecdsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ed25519Key)) {
        stdKeys.add(ed25519Key.toAbsolutePath().toFile());
    }
    if (Files.exists(objKey)) {
        if (stdKeys.isEmpty()) {
            SimpleGeneratorHostKeyProvider p = new SimpleGeneratorHostKeyProvider();
            p.setPath(objKey.toAbsolutePath());
            return p;
        }
        // Both formats of host key exist, we don't know which format
        // should be authoritative. Complain and abort.
        // 
        stdKeys.add(objKey.toAbsolutePath().toFile());
        throw new ProvisionException("Multiple host keys exist: " + stdKeys);
    }
    if (stdKeys.isEmpty()) {
        throw new ProvisionException("No SSH keys under " + site.etc_dir);
    }
    if (!SecurityUtils.isBouncyCastleRegistered()) {
        throw new ProvisionException("Bouncy Castle Crypto not installed;" + " needed to read server host keys: " + stdKeys + "");
    }
    FileKeyPairProvider kp = new FileKeyPairProvider();
    kp.setFiles(stdKeys);
    return kp;
}
#end_block

#method_before
private String getUrl(@GerritServerConfig Config cfg, SitePaths sitePaths) {
    String url = cfg.getString("accountPatchReviewDb", null, "url");
    if (url == null) {
        return H2.createUrl(sitePaths.db_dir.resolve("account_patch_reviews"));
    }
    return url;
}
#method_after
private static String getUrl(@GerritServerConfig Config cfg, SitePaths sitePaths) {
    String url = cfg.getString("accountPatchReviewDb", null, "url");
    if (url == null) {
        return H2.createUrl(sitePaths.db_dir.resolve("account_patch_reviews"));
    }
    return url;
}
#end_block

#method_before
private static DataSource createDataSource(String url) {
    BasicDataSource datasource = new BasicDataSource();
    if (url.contains("postgresql")) {
        datasource.setDriverClassName("org.postgresql.Driver");
    } else if (url.contains("h2")) {
        datasource.setDriverClassName("org.h2.Driver");
    } else if (url.contains("mysql")) {
        datasource.setDriverClassName("com.mysql.jdbc.Driver");
    }
    datasource.setUrl(url);
    datasource.setMaxActive(50);
    datasource.setMinIdle(4);
    datasource.setMaxIdle(16);
    long evictIdleTimeMs = 1000 * 60;
    datasource.setMinEvictableIdleTimeMillis(evictIdleTimeMs);
    datasource.setTimeBetweenEvictionRunsMillis(evictIdleTimeMs / 2);
    return datasource;
}
#method_after
protected static DataSource createDataSource(String url) {
    BasicDataSource datasource = new BasicDataSource();
    if (url.contains("postgresql")) {
        datasource.setDriverClassName("org.postgresql.Driver");
    } else if (url.contains("h2")) {
        datasource.setDriverClassName("org.h2.Driver");
    } else if (url.contains("mysql")) {
        datasource.setDriverClassName("com.mysql.jdbc.Driver");
    }
    datasource.setUrl(url);
    datasource.setMaxActive(50);
    datasource.setMinIdle(4);
    datasource.setMaxIdle(16);
    long evictIdleTimeMs = 1000 * 60;
    datasource.setMinEvictableIdleTimeMillis(evictIdleTimeMs);
    datasource.setTimeBetweenEvictionRunsMillis(evictIdleTimeMs / 2);
    return datasource;
}
#end_block

#method_before
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS ACCOUNT_PATCH_REVIEWS (" + "ACCOUNT_ID INTEGER DEFAULT 0 NOT NULL, " + "CHANGE_ID INTEGER DEFAULT 0 NOT NULL, " + "PATCH_SET_ID INTEGER DEFAULT 0 NOT NULL, " + "FILE_NAME VARCHAR(255) DEFAULT '' NOT NULL, " + "CONSTRAINT PRIMARY_KEY_ACCOUNT_PATCH_REVIEWS " + "PRIMARY KEY (ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME)" + ")");
}
#method_after
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + "account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, " + "patch_set_id INTEGER DEFAULT 0 NOT NULL, " + "file_name VARCHAR(4096) DEFAULT '' NOT NULL, " + "CONSTRAINT primary_key_account_patch_reviews " + "PRIMARY KEY (account_id, change_id, patch_set_id, file_name)" + ")");
}
#end_block

#method_before
public void dropTableIfExists() throws OrmException {
    try (Connection con = ds.getConnection();
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS ACCOUNT_PATCH_REVIEWS");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#method_after
public void dropTableIfExists() throws OrmException {
    try (Connection con = ds.getConnection();
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS account_patch_reviews");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#end_block

#method_before
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#method_after
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#method_after
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND " + "PATCH_SET_ID = ? AND FILE_NAME = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE account_id = ? AND change_id = ? AND " + "patch_set_id = ? AND file_name = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID = ? AND PATCH_SET_ID = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE change_id = ? AND patch_set_id = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT PATCH_SET_ID, FILE_NAME FROM ACCOUNT_PATCH_REVIEWS APR1 " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND PATCH_SET_ID = " + "(SELECT MAX(PATCH_SET_ID) FROM ACCOUNT_PATCH_REVIEWS APR2 WHERE " + "APR1.ACCOUNT_ID = APR2.ACCOUNT_ID " + "AND APR1.CHANGE_ID = APR2.CHANGE_ID " + "AND PATCH_SET_ID <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSetWithReviewedFiles r = new PatchSetWithReviewedFiles();
                r.files = new ArrayList<>();
                r.patchSetId = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                do {
                    r.files.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(r);
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#method_after
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT patch_set_id, file_name FROM account_patch_reviews APR1 " + "WHERE account_id = ? AND change_id = ? AND patch_set_id = " + "(SELECT MAX(patch_set_id) FROM account_patch_reviews APR2 WHERE " + "APR1.account_id = APR2.account_id " + "AND APR1.change_id = APR2.change_id " + "AND patch_set_id <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("patch_set_id"));
                ImmutableSet.Builder<String> builder = ImmutableSet.builder();
                do {
                    builder.add(rs.getString("file_name"));
                } while (rs.next());
                return Optional.of(AccountPatchReviewStore.PatchSetWithReviewedFiles.create(id, builder.build()));
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#end_block

#method_before
public OrmException convertError(String op, SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return new OrmException(op + " failure on ACCOUNT_PATCH_REVIEWS", err);
}
#method_after
public OrmException convertError(String op, SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return new OrmException(op + " failure on account_patch_reviews", err);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    JdbcAccountPatchReviewStore jdbcAccountPatchReviewStore = new JdbcAccountPatchReviewStore(cfg, sitePaths);
    jdbcAccountPatchReviewStore.dropTableIfExists();
    jdbcAccountPatchReviewStore.createTableIfNotExists();
    try (Connection con = jdbcAccountPatchReviewStore.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        int batchCount = 0;
        try (Statement s = newStatement(db);
            ResultSet rs = s.executeQuery("SELECT * from account_patch_reviews")) {
            while (rs.next()) {
                stmt.setInt(1, rs.getInt("account_id"));
                stmt.setInt(2, rs.getInt("change_id"));
                stmt.setInt(3, rs.getInt("patch_set_id"));
                stmt.setString(4, rs.getString("file_name"));
                stmt.addBatch();
                batchCount++;
                if (batchCount >= MAX_BATCH_SIZE) {
                    stmt.executeBatch();
                    batchCount = 0;
                }
            }
        }
        if (batchCount > 0) {
            stmt.executeBatch();
        }
    } catch (SQLException e) {
        throw jdbcAccountPatchReviewStore.convertError("insert", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    JdbcAccountPatchReviewStore jdbcAccountPatchReviewStore = JdbcAccountPatchReviewStore.createAccountPatchReviewStore(cfg, sitePaths);
    jdbcAccountPatchReviewStore.dropTableIfExists();
    jdbcAccountPatchReviewStore.createTableIfNotExists();
    try (Connection con = jdbcAccountPatchReviewStore.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        int batchCount = 0;
        try (Statement s = newStatement(db);
            ResultSet rs = s.executeQuery("SELECT * from account_patch_reviews")) {
            while (rs.next()) {
                stmt.setInt(1, rs.getInt("account_id"));
                stmt.setInt(2, rs.getInt("change_id"));
                stmt.setInt(3, rs.getInt("patch_set_id"));
                stmt.setString(4, rs.getString("file_name"));
                stmt.addBatch();
                batchCount++;
                if (batchCount >= MAX_BATCH_SIZE) {
                    stmt.executeBatch();
                    batchCount = 0;
                }
            }
        }
        if (batchCount > 0) {
            stmt.executeBatch();
        }
    } catch (SQLException e) {
        throw jdbcAccountPatchReviewStore.convertError("insert", e);
    }
}
#end_block

#method_before
@Override
public OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("ACCOUNT_PATCH_REVIEWS", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on ACCOUNT_PATCH_REVIEWS", err);
    }
}
#method_after
@Override
public OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("account_patch_reviews", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on account_patch_reviews", err);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(test ? new JdbcAccountPatchReviewStore.InMemoryModule() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(test ? new H2AccountPatchReviewStore.InMemoryModule() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public static PatchSet.Id nextPatchSetId(Repository git, PatchSet.Id id) throws IOException {
    return nextPatchSetId(git.getRefDatabase().getRefs(RefDatabase.ALL), id);
}
#method_after
public static PatchSet.Id nextPatchSetId(Repository git, PatchSet.Id id) throws IOException {
    return nextPatchSetIdFromChangeRefsMap(Maps.transformValues(git.getRefDatabase().getRefs(id.getParentKey().toRefPrefix()), Ref::getObjectId), id);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate();
        info.wip = c.isWip();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate();
        info.workInProgress = c.isWorkInProgress();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate();
    out.wip = in.isWip();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate();
    out.workInProgress = in.isWorkInProgress();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
            if (state == ReviewerStateInternal.REMOVED) {
                continue;
            }
            Collection<AccountInfo> reviewers = toAccountInfo(cd.reviewers().byState(state));
            reviewers.addAll(toAccountInfoByEmail(cd.reviewersByEmail().byState(state)));
            if (!reviewers.isEmpty()) {
                out.reviewers.put(state.asReviewerState(), reviewers);
            }
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(PermissionBackend.ForChange perm, ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(perm, cd, labelTypes, standard, detailed) : labelsForClosedChange(perm, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForOpenChange(ChangeControl ctl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Map<String, LabelWithStatus> labels = initLabels(cd, labelTypes, standard);
    if (detailed) {
        setAllApprovals(ctl, cd, labels);
    }
    for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
        LabelType type = labelTypes.byLabel(e.getKey());
        if (type == null) {
            continue;
        }
        if (standard) {
            for (PatchSetApproval psa : cd.currentApprovals()) {
                if (type.matches(psa)) {
                    short val = psa.getValue();
                    Account.Id accountId = psa.getAccountId();
                    setLabelScores(type, e.getValue(), val, accountId);
                }
            }
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForOpenChange(PermissionBackend.ForChange perm, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    Map<String, LabelWithStatus> labels = initLabels(cd, labelTypes, standard);
    if (detailed) {
        setAllApprovals(perm, cd, labels);
    }
    for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
        LabelType type = labelTypes.byLabel(e.getKey());
        if (type == null) {
            continue;
        }
        if (standard) {
            for (PatchSetApproval psa : cd.currentApprovals()) {
                if (type.matches(psa)) {
                    short val = psa.getValue();
                    Account.Id accountId = psa.getAccountId();
                    setLabelScores(type, e.getValue(), val, accountId);
                }
            }
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(PermissionBackend.ForChange basePerm, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException, PermissionBackendException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), cd.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    for (Account.Id accountId : allUsers) {
        PermissionBackend.ForChange perm = basePerm.user(userFactory.create(accountId));
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(perm, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = labelTypes.byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = perm.test(new LabelPermission(lt)) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = perm.test(new LabelPermission(lt)) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    SetMultimap<Account.Id, PatchSetApproval> current = MultimapBuilder.hashKeys().hashSetValues().build();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(PermissionBackend.ForChange basePerm, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    SetMultimap<Account.Id, PatchSetApproval> current = MultimapBuilder.hashKeys().hashSetValues().build();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            PermissionBackend.ForChange perm = basePerm.user(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(perm, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    boolean isMerged = cd.change().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelType> toCheck = new HashMap<>();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels != null) {
            for (SubmitRecord.Label r : rec.labels) {
                LabelType type = labelTypes.byLabel(r.label);
                if (type != null && (!isMerged || type.allowPostSubmit())) {
                    toCheck.put(type.getName(), type);
                }
            }
        }
    }
    Map<String, Short> labels = null;
    Set<LabelPermission.WithValue> can = perm.testLabels(toCheck.values());
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            for (LabelValue v : type.getValues()) {
                boolean ok = can.contains(new LabelPermission.WithValue(type, v));
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(perm, cd);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, Short> currentLabels(ChangeControl ctl) throws OrmException {
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), ctl, ctl.getChange().currentPatchSetId(), ctl.getUser().getAccountId())) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    ChangeControl ctl = cd.changeControl().forUser(user);
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), ctl, cd.change().currentPatchSetId(), user.getAccountId())) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        if (patchNum == null || ctl.isPatchVisible(db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (ctl.canRemoveReviewer(id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, rw, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(ctl.getChange().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWip(wip);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWip(wip);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWip() ? "Ready For Review" : "Work In Progress");
    String m = Strings.nullToEmpty(in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), !m.isEmpty() ? null : c.isWip() ? ChangeMessagesUtil.TAG_SET_READY : ChangeMessagesUtil.TAG_SET_WIP);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review");
    String m = Strings.nullToEmpty(in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), c.isWorkInProgress() ? ChangeMessagesUtil.TAG_SET_WIP : ChangeMessagesUtil.TAG_SET_READY);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
public static ChangeMessage newMessage(PatchSet.Id psId, CurrentUser user, Timestamp when, String body, @Nullable String tag) {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUuid()), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#method_after
public static ChangeMessage newMessage(ChangeContext ctx, String body, @Nullable String tag) {
    return newMessage(ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWip()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, false, input));
        bu.execute();
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set ready for review");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWorkInProgress()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, false, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("Ready").setTitle("Set Ready For Review").setVisible(rsrc.getControl().isOwner() && rsrc.getChange().getStatus() == Status.NEW && rsrc.getChange().isWip());
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("Ready").setTitle("Set Ready For Review").setVisible(rsrc.isUserOwner() && rsrc.getChange().getStatus() == Status.NEW && rsrc.getChange().isWorkInProgress());
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWip()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, true, input));
        bu.execute();
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set work in progress");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWorkInProgress()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, true, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible(rsrc.getControl().isOwner() && rsrc.getChange().getStatus() == Status.NEW && !rsrc.getChange().isWip());
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible(rsrc.isUserOwner() && rsrc.getChange().getStatus() == Status.NEW && !rsrc.getChange().isWorkInProgress());
}
#end_block

#method_before
public static Change readOneReviewDbChange(ReviewDb db, Change.Id id) throws OrmException {
    return ReviewDbUtil.unwrapDb(db).changes().get(id);
}
#method_after
@Nullable
public static Change readOneReviewDbChange(ReviewDb db, Change.Id id) throws OrmException {
    return ReviewDbUtil.unwrapDb(db).changes().get(id);
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            ChangeNotes cn = create(db, project, cid);
            if (cn.getChange() != null && predicate.test(cn)) {
                notes.add(cn);
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            try {
                ChangeNotes cn = create(db, project, cid);
                if (cn.getChange() != null && predicate.test(cn)) {
                    notes.add(cn);
                }
            } catch (NoSuchChangeException e) {
                // a dangling patch set ref or something.
                continue;
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null);
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean wip) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, wip), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, wip);
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean workInProgress) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, workInProgress), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, workInProgress);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWip(c.isWip() == null ? false : c.isWip());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWorkInProgress(c.isWorkInProgress() == null ? false : c.isWorkInProgress());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        // Label names/values are safe to append without sanitizing.
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    // Label names/values are safe to append without sanitizing.
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    if (readOnlyUntil != null) {
        addFooter(msg, FOOTER_READ_ONLY_UNTIL, ChangeNoteUtil.formatTime(serverIdent, readOnlyUntil));
    }
    if (isPrivate != null) {
        addFooter(msg, FOOTER_PRIVATE, isPrivate);
    }
    if (wip != null) {
        addFooter(msg, FOOTER_WIP, wip);
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Map.Entry<Address, ReviewerStateInternal> e : reviewersByEmail.entrySet()) {
        addFooter(msg, e.getValue().getByEmailFooterKey(), e.getKey().toString());
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        // Label names/values are safe to append without sanitizing.
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    // Label names/values are safe to append without sanitizing.
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    if (readOnlyUntil != null) {
        addFooter(msg, FOOTER_READ_ONLY_UNTIL, ChangeNoteUtil.formatTime(serverIdent, readOnlyUntil));
    }
    if (isPrivate != null) {
        addFooter(msg, FOOTER_PRIVATE, isPrivate);
    }
    if (workInProgress != null) {
        addFooter(msg, FOOTER_WORK_IN_PROGRESS, workInProgress);
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null && isPrivate == null && wip == null;
}
#method_after
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && reviewersByEmail.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null && isPrivate == null && workInProgress == null;
}
#end_block

#method_before
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    change.setPrivate(isPrivate);
    change.setWip(wip);
    return change;
}
#method_after
@Override
public Change createChange(Context ctx) throws IOException {
    change = new Change(getChangeKey(ctx.getRevWalk(), commitId), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    change.setPrivate(isPrivate);
    change.setWorkInProgress(workInProgress);
    return change;
}
#end_block

#method_before
private static Change.Key getChangeKey(RevCommit commit) {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId id = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeId = new StringBuilder();
    changeId.append("I").append(ObjectId.toString(id));
    return new Change.Key(changeId.toString());
}
#method_after
private static Change.Key getChangeKey(RevWalk rw, ObjectId id) throws IOException {
    RevCommit commit = rw.parseCommit(id);
    rw.parseBody(commit);
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId changeId = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeIdStr = new StringBuilder();
    changeIdStr.append("I").append(ObjectId.toString(changeId));
    return new Change.Key(changeIdStr.toString());
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(ObjectId.zeroId(), commitId, psId.toRefName());
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    if (isPrivate) {
        update.setPrivate(isPrivate);
    }
    if (wip) {
        update.setWip(wip);
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getIdentifiedUser());
        commitValidatorsFactory.create(validatePolicy, refControl, new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        String refName = psId.toRefName();
        try (CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commitId, refName), refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#method_after
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        pruneReviewersByEmail();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, wip);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (wip == null) {
        parseWip(commit);
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
        for (String line : commit.getFooterLineValues(state.getByEmailFooterKey())) {
            parseReviewerByEmail(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (workInProgress == null) {
        parseWorkInProgress(commit);
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#end_block

#method_before
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#method_after
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#end_block

#method_before
static void executeRemoteSsh(CredentialsProvider credentialsProvider, ReplicationSshSessionFactory sshSessionFactory, URIish uri, String cmd, OutputStream errStream) throws IOException {
    RemoteSession ssh = connect(credentialsProvider, sshSessionFactory, uri);
    Process proc = ssh.exec(cmd, 0);
    proc.getOutputStream().close();
    StreamCopyThread out = new StreamCopyThread(proc.getInputStream(), errStream);
    StreamCopyThread err = new StreamCopyThread(proc.getErrorStream(), errStream);
    out.start();
    err.start();
    try {
        proc.waitFor();
        out.halt();
        err.halt();
    } catch (InterruptedException interrupted) {
    // Don't wait, drop out immediately.
    }
    ssh.disconnect();
}
#method_after
int executeRemoteSsh(URIish uri, String cmd, OutputStream errStream) throws IOException {
    RemoteSession ssh = connect(uri);
    Process proc = ssh.exec(cmd, 0);
    proc.getOutputStream().close();
    StreamCopyThread out = new StreamCopyThread(proc.getInputStream(), errStream);
    StreamCopyThread err = new StreamCopyThread(proc.getErrorStream(), errStream);
    out.start();
    err.start();
    try {
        proc.waitFor();
        out.halt();
        err.halt();
    } catch (InterruptedException interrupted) {
    // Don't wait, drop out immediately.
    }
    ssh.disconnect();
    return proc.exitValue();
}
#end_block

#method_before
static OutputStream newErrorBufferStream() {
    return new OutputStream() {

        private final StringBuilder out = new StringBuilder();

        private final StringBuilder line = new StringBuilder();

        @Override
        public synchronized String toString() {
            while (out.length() > 0 && out.charAt(out.length() - 1) == '\n') {
                out.setLength(out.length() - 1);
            }
            return out.toString();
        }

        @Override
        public synchronized void write(final int b) {
            if (b == '\r') {
                return;
            }
            line.append((char) b);
            if (b == '\n') {
                out.append(line);
                line.setLength(0);
            }
        }
    };
}
#method_after
OutputStream newErrorBufferStream() {
    return new OutputStream() {

        private final StringBuilder out = new StringBuilder();

        private final StringBuilder line = new StringBuilder();

        @Override
        public synchronized String toString() {
            while (out.length() > 0 && out.charAt(out.length() - 1) == '\n') {
                out.setLength(out.length() - 1);
            }
            return out.toString();
        }

        @Override
        public synchronized void write(final int b) {
            if (b == '\r') {
                return;
            }
            line.append((char) b);
            if (b == '\n') {
                out.append(line);
                line.setLength(0);
            }
        }
    };
}
#end_block

#method_before
private static RemoteSession connect(CredentialsProvider credentialsProvider, ReplicationSshSessionFactory sshSessionFactory, URIish uri) throws TransportException {
    return sshSessionFactory.create().getSession(uri, credentialsProvider, FS.DETECTED, ReplicationQueue.SSH_REMOTE_TIMEOUT);
}
#method_after
RemoteSession connect(URIish uri) throws TransportException {
    return sshSessionFactoryProvider.get().getSession(uri, null, FS.DETECTED, SSH_REMOTE_TIMEOUT);
}
#end_block

#method_before
public void createProject(CredentialsProvider credentialsProvider, URIish uri, String projectName, String head) {
    OutputStream errStream = newErrorBufferStream();
    String cmd = "gerrit create-project --branch " + head + " " + projectName;
    try {
        execute(credentialsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
protected boolean createProject(URIish uri, Project.NameKey projectName, String head) {
    OutputStream errStream = sshHelper.newErrorBufferStream();
    String cmd = "gerrit create-project --branch " + head + " " + projectName.get();
    try {
        execute(uri, cmd, errStream);
    } catch (IOException e) {
        logError("creating", uri, errStream, cmd, e);
        return false;
    }
    return true;
}
#end_block

#method_before
public void deleteProject(SecureCredentialsProvider credsProvider, URIish uri, String projectName) {
    OutputStream errStream = newErrorBufferStream();
    String cmd = "deleteproject delete --yes-really-delete --force " + projectName;
    try {
        execute(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error deleting remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
protected boolean deleteProject(URIish uri, Project.NameKey projectName) {
    if (!withoutDeleteProjectPlugin.contains(uri)) {
        OutputStream errStream = sshHelper.newErrorBufferStream();
        String cmd = "deleteproject delete --yes-really-delete --force " + projectName.get();
        int exitCode = -1;
        try {
            exitCode = execute(uri, cmd, errStream);
        } catch (IOException e) {
            logError("deleting", uri, errStream, cmd, e);
            return false;
        }
        if (exitCode == 1) {
            log.info("DeleteProject plugin is not installed on {}; will not try to forward this operation to that host");
            withoutDeleteProjectPlugin.add(uri);
            return true;
        }
    }
    return true;
}
#end_block

#method_before
public void updateHead(CredentialsProvider credsProvider, URIish uri, String projectName, String newHead) {
    OutputStream errStream = newErrorBufferStream();
    String cmd = "gerrit set-head " + projectName + " --new-head " + newHead;
    try {
        execute(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, newHead, e, cmd, errStream), e);
    }
}
#method_after
protected boolean updateHead(URIish uri, Project.NameKey projectName, String newHead) {
    OutputStream errStream = sshHelper.newErrorBufferStream();
    String cmd = "gerrit set-head " + projectName.get() + " --new-head " + newHead;
    try {
        execute(uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n  Command: %s\n  Output: %s", uri, newHead, e, cmd, errStream), e);
        return false;
    }
    return true;
}
#end_block

#method_before
private URIish toSshUri(URIish uri) throws URISyntaxException {
    if (uri.getHost() != null) {
        return new URIish(uri.toString().replace("gerrit://", "ssh://"));
    } else {
        String rawPath = uri.getRawPath();
        if (!rawPath.endsWith("/")) {
            rawPath = rawPath + "/";
        }
        URIish sshUri = new URIish("ssh://" + rawPath);
        if (sshUri.getPort() < 0) {
            sshUri = sshUri.setPort(29418);
        }
        return sshUri;
    }
}
#method_after
private URIish toSshUri(URIish uri) throws URISyntaxException {
    String uriStr = uri.toString();
    if (uri.getHost() != null && uriStr.startsWith(GERRIT_ADMIN_PROTOCOL_PREFIX)) {
        return new URIish(uriStr.substring(0, GERRIT_ADMIN_PROTOCOL_PREFIX.length()));
    }
    String rawPath = uri.getRawPath();
    if (!rawPath.endsWith("/")) {
        rawPath = rawPath + "/";
    }
    URIish sshUri = new URIish("ssh://" + rawPath);
    if (sshUri.getPort() < 0) {
        sshUri = sshUri.setPort(SshAddressesModule.DEFAULT_PORT);
    }
    return sshUri;
}
#end_block

#method_before
private void execute(CredentialsProvider credentialsProvider, URIish uri, String cmd, OutputStream errStream) throws IOException {
    try {
        URIish sshUri = toSshUri(uri);
        executeRemoteSsh(credentialsProvider, sessionFactory, sshUri, cmd, errStream);
    } catch (URISyntaxException e) {
        log.error(String.format("Cannot convert %s to SSH uri", uri), e);
    }
}
#method_after
private int execute(URIish uri, String cmd, OutputStream errStream) throws IOException {
    try {
        URIish sshUri = toSshUri(uri);
        return sshHelper.executeRemoteSsh(sshUri, cmd, errStream);
    } catch (URISyntaxException e) {
        log.error(String.format("Cannot convert %s to SSH uri", uri), e);
    }
    return SSH_COMMAND_FAILED;
}
#end_block

#method_before
@Override
public void stop() {
    running = false;
    int discarded = config.shutdown();
    if (discarded > 0) {
        repLog.warn(String.format("Cancelled %d replication events during shutdown", discarded));
    }
}
#method_after
@Override
public void stop() {
    running = false;
    int discarded = config.shutdown();
    if (discarded > 0) {
        repLog.warn(String.format("Canceled %d replication events during shutdown", discarded));
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#method_after
void scheduleFullSync(Project.NameKey project, String urlMatch, ReplicationState state) {
    scheduleFullSync(project, urlMatch, state, false);
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#method_after
void scheduleFullSync(Project.NameKey project, String urlMatch, ReplicationState state, boolean now) {
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state, now);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher, database));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher.get()));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    String projectName = event.getProjectName();
    for (Map.Entry<String, Set<URIish>> entry : getURIs(new Project.NameKey(projectName), FilterType.PROJECT_CREATION).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            createProject(credsProvider, uri, projectName, event.getHeadName());
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (URIish uri : getURIs(projectName, FilterType.PROJECT_CREATION)) {
        createProject(uri, projectName, event.getHeadName());
    }
}
#end_block

#method_before
@Override
public void onProjectDeleted(ProjectDeletedListener.Event event) {
    String projectName = event.getProjectName();
    for (Map.Entry<String, Set<URIish>> entry : getURIs(new Project.NameKey(projectName), FilterType.PROJECT_DELETION).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            deleteProject(credsProvider, uri, projectName);
        }
    }
}
#method_after
@Override
public void onProjectDeleted(ProjectDeletedListener.Event event) {
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (URIish uri : getURIs(projectName, FilterType.PROJECT_DELETION)) {
        deleteProject(uri, projectName);
    }
}
#end_block

#method_before
@Override
public void onHeadUpdated(HeadUpdatedListener.Event event) {
    String projectName = event.getProjectName();
    for (Map.Entry<String, Set<URIish>> entry : getURIs(new Project.NameKey(projectName), FilterType.ALL).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            updateHead(credsProvider, uri, projectName, event.getNewHeadName());
        }
    }
}
#method_after
@Override
public void onHeadUpdated(HeadUpdatedListener.Event event) {
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (URIish uri : getURIs(project, FilterType.ALL)) {
        updateHead(uri, project, event.getNewHeadName());
    }
}
#end_block

#method_before
private Map<String, Set<URIish>> getURIs(Project.NameKey projectName, FilterType filterType) {
    if (config.getDestinations(filterType).isEmpty()) {
        return Collections.emptyMap();
    }
    if (!running) {
        repLog.error("Replication plugin did not finish startup before event");
        return Collections.emptyMap();
    }
    Map<String, Set<URIish>> result = new HashMap<>();
    for (Destination config : this.config.getDestinations(filterType)) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        Set<URIish> uris = new HashSet<>();
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                repLog.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            if (!isGerrit(uri)) {
                String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
                if (path == null) {
                    repLog.warn(String.format("adminURL %s does not contain ${name}", uri));
                    continue;
                }
                uri = uri.setPath(path);
                if (!isSSH(uri)) {
                    repLog.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                    continue;
                }
            }
            uris.add(uri);
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                uris.add(uri);
            }
        }
        result.put(config.getName(), uris);
    }
    return result;
}
#method_after
private Set<URIish> getURIs(Project.NameKey projectName, FilterType filterType) {
    if (config.getDestinations(filterType).isEmpty()) {
        return Collections.emptySet();
    }
    if (!running) {
        repLog.error("Replication plugin did not finish startup before event");
        return Collections.emptySet();
    }
    Set<URIish> uris = new HashSet<>();
    for (Destination config : this.config.getDestinations(filterType)) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        boolean adminURLUsed = false;
        for (String url : config.getAdminUrls()) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                repLog.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            if (!isGerrit(uri)) {
                String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
                if (path == null) {
                    repLog.warn(String.format("adminURL %s does not contain ${name}", uri));
                    continue;
                }
                uri = uri.setPath(path);
                if (!isSSH(uri)) {
                    repLog.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                    continue;
                }
            }
            uris.add(uri);
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : config.getURIs(projectName, "*")) {
                uris.add(uri);
            }
        }
    }
    return uris;
}
#end_block

#method_before
public boolean createProject(Project.NameKey project, String head) {
    boolean success = false;
    for (Map.Entry<String, Set<URIish>> entry : getURIs(project, FilterType.PROJECT_CREATION).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            success &= createProject(credsProvider, uri, project.get(), head);
        }
    }
    return success;
}
#method_after
public boolean createProject(Project.NameKey project, String head) {
    boolean success = true;
    for (URIish uri : getURIs(project, FilterType.PROJECT_CREATION)) {
        success &= createProject(uri, project, head);
    }
    return success;
}
#end_block

#method_before
private boolean createProject(CredentialsProvider credsProvider, URIish replicateURI, String projectName, String head) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.createProject(credsProvider, replicateURI, projectName, head);
        repLog.info("Created remote repository: " + replicateURI);
    } else if (!replicateURI.isRemote()) {
        createLocally(replicateURI, head);
        repLog.info("Created local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        createRemoteSsh(credsProvider, replicateURI, head);
        repLog.info("Created remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot create new project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository creation", replicateURI));
        return false;
    }
    return true;
}
#method_after
private boolean createProject(URIish replicateURI, Project.NameKey projectName, String head) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.createProject(replicateURI, projectName, head);
    } else if (!replicateURI.isRemote()) {
        createLocally(replicateURI, head);
        repLog.info("Created local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        createRemoteSsh(replicateURI, head);
        repLog.info("Created remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot create new project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository creation", replicateURI));
        return false;
    }
    return true;
}
#end_block

#method_before
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            if (head != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.disableRefLog();
                u.link(head);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#method_after
private static void createLocally(URIish uri, String head) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        repo.create(true);
        if (head != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#end_block

#method_before
private void createRemoteSsh(CredentialsProvider credsProvider, URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + " && cd " + quotedPath + " && git init --bare";
    if (head != null) {
        cmd = cmd + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    }
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemoteSsh(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
private void createRemoteSsh(URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + " && cd " + quotedPath + " && git init --bare";
    if (head != null) {
        cmd = cmd + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    }
    OutputStream errStream = sshHelper.newErrorBufferStream();
    try {
        sshHelper.executeRemoteSsh(uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private void deleteProject(SecureCredentialsProvider credsProvider, URIish replicateURI, String projectName) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.deleteProject(credsProvider, replicateURI, projectName);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else if (!replicateURI.isRemote()) {
        deleteLocally(replicateURI);
        repLog.info("Deleted local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        deleteRemoteSsh(credsProvider, replicateURI);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot delete project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository deletion", replicateURI));
    }
}
#method_after
private void deleteProject(URIish replicateURI, Project.NameKey projectName) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.deleteProject(replicateURI, projectName);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else if (!replicateURI.isRemote()) {
        deleteLocally(replicateURI);
        repLog.info("Deleted local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        deleteRemoteSsh(replicateURI);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot delete project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository deletion", replicateURI));
    }
}
#end_block

#method_before
public static void recursivelyDelete(File dir) throws IOException {
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                if (!d.delete()) {
                    throw new IOException("Failed to delete: " + d.getAbsolutePath());
                }
            }
        }
    }
    if (!dir.delete()) {
        throw new IOException("Failed to delete: " + dir.getAbsolutePath());
    }
}
#method_after
private static void recursivelyDelete(File dir) throws IOException {
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                if (!d.delete()) {
                    throw new IOException("Failed to delete: " + d.getAbsolutePath());
                }
            }
        }
    }
    if (!dir.delete()) {
        throw new IOException("Failed to delete: " + dir.getAbsolutePath());
    }
}
#end_block

#method_before
private void deleteRemoteSsh(CredentialsProvider credsProvider, URIish uri) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "rm -rf " + quotedPath;
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemoteSsh(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error deleting remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
private void deleteRemoteSsh(URIish uri) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "rm -rf " + quotedPath;
    OutputStream errStream = sshHelper.newErrorBufferStream();
    try {
        sshHelper.executeRemoteSsh(uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error deleting remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private void updateHead(CredentialsProvider credsProvider, URIish replicateURI, String projectName, String newHead) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.updateHead(credsProvider, replicateURI, projectName, newHead);
    } else if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(credsProvider, replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#method_after
private void updateHead(URIish replicateURI, Project.NameKey projectName, String newHead) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.updateHead(replicateURI, projectName, newHead);
    } else if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#end_block

#method_before
private void updateHeadRemoteSsh(CredentialsProvider credsProvider, URIish uri, String newHead) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "cd " + quotedPath + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(newHead);
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemoteSsh(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, newHead, e, cmd, errStream), e);
    }
}
#method_after
private void updateHeadRemoteSsh(URIish uri, String newHead) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "cd " + quotedPath + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(newHead);
    OutputStream errStream = sshHelper.newErrorBufferStream();
    try {
        sshHelper.executeRemoteSsh(uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, newHead, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private static void updateHeadLocally(URIish uri, String newHead) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            if (newHead != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.link(newHead);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#method_after
private static void updateHeadLocally(URIish uri, String newHead) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        if (newHead != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.link(newHead);
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#end_block

#method_before
private static boolean isGerrit(URIish uri) {
    String scheme = uri.getScheme();
    return scheme != null && scheme.toLowerCase().equals("gerrit");
}
#method_after
private static boolean isGerrit(URIish uri) {
    String scheme = uri.getScheme();
    return scheme != null && scheme.toLowerCase().equals("gerrit+ssh");
}
#end_block

#method_before
@Test
public void testRetryOnErrorThenSuccess() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), any())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(true, "Success"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isTrue();
}
#method_after
@Test
public void testRetryOnErrorThenSuccess() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), anyString())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(true, "Success"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isTrue();
}
#end_block

#method_before
@Test
public void testFailureAfterMaxTries() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), any())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isFalse();
}
#method_after
@Test
public void testFailureAfterMaxTries() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), anyString())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isFalse();
}
#end_block

#method_before
public boolean isRecoverable() {
    return isRecoverable;
}
#method_after
boolean isRecoverable() {
    return isRecoverable;
}
#end_block

#method_before
private String buildIndexEndpoint(int changeId) {
    return Joiner.on("/").join(pluginRelativePath, "index", changeId);
}
#method_after
private String buildIndexEndpoint(int changeId) {
    return Joiner.on("/").join(pluginRelativePath, "index/change", changeId);
}
#end_block

#method_before
boolean execute() {
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            return true;
        } catch (ForwardingException e) {
            if (!e.isRecoverable()) {
                log.error("Failed to " + name, e);
                return false;
            }
            if (execCnt >= cfg.getMaxTries()) {
                log.error("Failed to " + name + ", after " + cfg.getMaxTries() + " tries");
                return false;
            }
            logRetry(e);
            try {
                Thread.sleep(cfg.getRetryInterval());
            } catch (InterruptedException ie) {
                log.error(name + " was interrupted, giving up", ie);
            }
        }
    }
}
#method_after
boolean execute() {
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            return true;
        } catch (ForwardingException e) {
            if (!e.isRecoverable()) {
                log.error("Failed to {}", name, e);
                return false;
            }
            if (execCnt >= cfg.getMaxTries()) {
                log.error("Failed to {}, after {} tries", name, cfg.getMaxTries());
                return false;
            }
            logRetry(e);
            try {
                Thread.sleep(cfg.getRetryInterval());
            } catch (InterruptedException ie) {
                log.error("{} was interrupted, giving up", name, ie);
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
}
#end_block

#method_before
void tryOnce() throws ForwardingException {
    try {
        HttpResult result = send();
        if (!result.isSuccessful()) {
            log.error("Unable to " + name + ": " + result.getMessage());
            throw new ForwardingException(true, "Unable to " + name + ": " + result.getMessage());
        }
    } catch (IOException e) {
        log.error("Error trying to {}", name, e);
        throw new ForwardingException(isRecoverable(e), e.getMessage());
    }
}
#method_after
void tryOnce() throws ForwardingException {
    try {
        HttpResult result = send();
        if (!result.isSuccessful()) {
            throw new ForwardingException(true, "Unable to " + name + ": " + result.getMessage());
        }
    } catch (IOException e) {
        throw new ForwardingException(isRecoverable(e), e.getMessage(), e);
    }
}
#end_block

#method_before
void logRetry(Throwable cause) {
    if (log.isDebugEnabled()) {
        log.debug("Retrying to " + name + " causeed by '" + cause + "'");
    }
}
#method_after
void logRetry(Throwable cause) {
    if (log.isDebugEnabled()) {
        log.debug("Retrying to {} caused by '{}'", name, cause);
    }
}
#end_block

#method_before
protected <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
            reindexers.put(def.getName(), reindexer);
            if (onlineUpgrade && latest != search.version) {
                reindexer.start();
            }
        }
    }
}
#method_after
protected <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.version != search.version) {
            indexes.addWriteIndex(factory.create(v.schema));
        } else {
            indexes.addWriteIndex(searchIndex);
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
            reindexers.put(def.getName(), reindexer);
            if (onlineUpgrade && latest != search.version) {
                reindexer.start();
            }
        }
    }
}
#end_block

#method_before
protected ProvisionException fail(Throwable t) {
    ProvisionException e = new ProvisionException("Error scanning indexes");
    e.initCause(t);
    return e;
}
#method_after
private ProvisionException fail(Throwable t) {
    ProvisionException e = new ProvisionException("Error scanning indexes");
    e.initCause(t);
    return e;
}
#end_block

#method_before
private void initAuthType() {
    AuthType authType = auth.select("Authentication method", "type", flags.dev ? AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT : AuthType.OPENID);
    switch(authType) {
        case HTTP:
        case HTTP_LDAP:
            {
                String hdr = auth.get("httpHeader");
                if (ui.yesno(hdr != null, "Get username from custom HTTP header")) {
                    auth.string("Username HTTP header", "httpHeader", "SM_USER");
                } else if (hdr != null) {
                    auth.unset("httpHeader");
                }
                auth.string("SSO logout URL", "logoutUrl", null);
                break;
            }
        case LDAP:
        case OAUTH:
            {
                auth.select("Git/HTTP authentication", "gitBasicAuthPolicy", GitBasicAuthPolicy.HTTP);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case LDAP_BIND:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    switch(authType) {
        case LDAP:
        case LDAP_BIND:
        case HTTP_LDAP:
            {
                String server = ldap.string("LDAP server", "server", "ldap://localhost");
                if (// 
                server != null && // 
                !server.startsWith("ldap://") && !server.startsWith("ldaps://")) {
                    if (ui.yesno(false, "Use SSL")) {
                        server = "ldaps://" + server;
                    } else {
                        server = "ldap://" + server;
                    }
                    ldap.set("server", server);
                }
                ldap.string("LDAP username", "username", null);
                ldap.password("username", "password");
                String aBase = ldap.string("Account BaseDN", "accountBase", dnOf(server));
                ldap.string("Group BaseDN", "groupBase", aBase);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case HTTP:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
}
#method_after
private void initAuthType() {
    AuthType authType = auth.select("Authentication method", "type", flags.dev ? AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT : AuthType.OPENID);
    switch(authType) {
        case HTTP:
        case HTTP_LDAP:
            {
                String hdr = auth.get("httpHeader");
                if (ui.yesno(hdr != null, "Get username from custom HTTP header")) {
                    auth.string("Username HTTP header", "httpHeader", "SM_USER");
                } else if (hdr != null) {
                    auth.unset("httpHeader");
                }
                auth.string("SSO logout URL", "logoutUrl", null);
                break;
            }
        case LDAP:
            {
                auth.select("Git/HTTP authentication", "gitBasicAuthPolicy", HTTP, EnumSet.of(HTTP, HTTP_LDAP, LDAP));
                break;
            }
        case OAUTH:
            {
                GitBasicAuthPolicy gitBasicAuth = auth.select("Git/HTTP authentication", "gitBasicAuthPolicy", HTTP, EnumSet.of(HTTP, OAUTH));
                if (gitBasicAuth == OAUTH) {
                    ui.message("*WARNING* Please make sure that your chosen OAuth provider\n" + "supports Git token authentication.\n");
                }
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case LDAP_BIND:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    switch(authType) {
        case LDAP:
        case LDAP_BIND:
        case HTTP_LDAP:
            {
                String server = ldap.string("LDAP server", "server", "ldap://localhost");
                if (// 
                server != null && // 
                !server.startsWith("ldap://") && !server.startsWith("ldaps://")) {
                    if (ui.yesno(false, "Use SSL")) {
                        server = "ldaps://" + server;
                    } else {
                        server = "ldap://" + server;
                    }
                    ldap.set("server", server);
                }
                ldap.string("LDAP username", "username", null);
                ldap.password("username", "password");
                String aBase = ldap.string("Account BaseDN", "accountBase", dnOf(server));
                ldap.string("Group BaseDN", "groupBase", aBase);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case HTTP:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
}
#end_block

#method_before
private void addEmail(String email) throws UnloggedFailure, RestApiException, OrmException, IOException, PermissionBackendException {
    EmailInput in = new EmailInput();
    in.email = email;
    in.noConfirmation = true;
    try {
        createEmailFactory.create(email).apply(rsrc, in);
    } catch (EmailException e) {
        throw die(e.getMessage());
    }
}
#method_after
private void addEmail(String email) throws UnloggedFailure, RestApiException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    EmailInput in = new EmailInput();
    in.email = email;
    in.noConfirmation = true;
    try {
        createEmailFactory.create(email).apply(rsrc, in);
    } catch (EmailException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
private void deleteEmail(String email) throws RestApiException, OrmException, IOException, PermissionBackendException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#method_after
private void deleteEmail(String email) throws RestApiException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    a.setStatus(Strings.nullToEmpty(input.status));
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getStatus()) ? Response.none() : Response.ok(a.getStatus());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    String newStatus = input.status;
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            a.setStatus(Strings.nullToEmpty(newStatus));
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getStatus()) ? Response.none() : Response.ok(a.getStatus());
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, OrmException, IOException {
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (email.equals(a.getPreferredEmail())) {
        return Response.ok("");
    }
    a.setPreferredEmail(email);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Response.created("");
}
#method_after
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, OrmException, IOException {
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            if (email.equals(a.getPreferredEmail())) {
                alreadyPreferred.set(true);
            } else {
                a.setPreferredEmail(email);
            }
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#end_block

#method_before
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, PermissionBackendException {
    if (self.get() != rsrc.getUser() || input.noConfirmation) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (!OutgoingEmailValidator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser() || input.noConfirmation) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (!OutgoingEmailValidator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, PermissionBackendException {
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#method_after
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#method_after
@Override
public Response<?> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#end_block

#method_before
public Response<?> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException {
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow deleting emails");
    }
    Set<AccountExternalId> extIds = dbProvider.get().accountExternalIds().byAccount(user.getAccountId()).toList().stream().filter(e -> email.equals(e.getEmailAddress())).collect(toSet());
    if (extIds.isEmpty()) {
        throw new ResourceNotFoundException(email);
    }
    try {
        for (AccountExternalId extId : extIds) {
            AuthRequest authRequest = new AuthRequest(extId.getKey().get());
            authRequest.setEmailAddress(email);
            accountManager.unlink(user.getAccountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
public Response<?> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException {
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow deleting emails");
    }
    Set<ExternalId> extIds = externalIds.byAccount(dbProvider.get(), user.getAccountId()).stream().filter(e -> email.equals(e.email())).collect(toSet());
    if (extIds.isEmpty()) {
        throw new ResourceNotFoundException(email);
    }
    try {
        for (ExternalId extId : extIds) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(email);
            accountManager.unlink(user.getAccountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void addEmail(EmailInput input) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), input.email);
    try {
        createEmailFactory.create(input.email).apply(rsrc, input);
    } catch (EmailException | OrmException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot add email", e);
    }
}
#method_after
@Override
public void addEmail(EmailInput input) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), input.email);
    try {
        createEmailFactory.create(input.email).apply(rsrc, input);
    } catch (EmailException | OrmException | IOException | ConfigInvalidException | PermissionBackendException e) {
        throw new RestApiException("Cannot add email", e);
    }
}
#end_block

#method_before
@Override
public void deleteEmail(String email) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), email);
    try {
        deleteEmail.apply(rsrc, null);
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete email", e);
    }
}
#method_after
@Override
public void deleteEmail(String email) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), email);
    try {
        deleteEmail.apply(rsrc, null);
    } catch (OrmException | IOException | ConfigInvalidException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete email", e);
    }
}
#end_block

#method_before
@Override
public List<AccountExternalIdInfo> getExternalIds() throws RestApiException {
    try {
        return getExternalIds.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get external IDs", e);
    }
}
#method_after
@Override
public List<AccountExternalIdInfo> getExternalIds() throws RestApiException {
    try {
        return getExternalIds.apply(account);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot get external IDs", e);
    }
}
#end_block

#method_before
@Override
public void deleteExternalIds(List<String> externalIds) throws RestApiException {
    try {
        deleteExternalIds.apply(account, externalIds);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot delete external IDs", e);
    }
}
#method_after
@Override
public void deleteExternalIds(List<String> externalIds) throws RestApiException {
    try {
        deleteExternalIds.apply(account, externalIds);
    } catch (IOException | OrmException | ConfigInvalidException e) {
        throw new RestApiException("Cannot delete external IDs", e);
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            a.setFullName(newName);
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
public void execute(Collection<BatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryRun) throws UpdateException, RestApiException {
    checkNotNull(listener);
    checkSameProject(updates);
    // collection.
    if (migration.disableChangeReviewDb()) {
        ImmutableList<NoteDbBatchUpdate> noteDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        NoteDbBatchUpdate.execute(noteDbUpdates, listener, requestId, dryRun);
    } else {
        ImmutableList<ReviewDbBatchUpdate> reviewDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        ReviewDbBatchUpdate.execute(reviewDbUpdates, listener, requestId, dryRun);
    }
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
public void execute(Collection<BatchUpdate> updates, BatchUpdateListener listener, @Nullable RequestId requestId, boolean dryRun) throws UpdateException, RestApiException {
    checkNotNull(listener);
    checkDifferentProject(updates);
    // collection.
    if (migration.disableChangeReviewDb()) {
        ImmutableList<NoteDbBatchUpdate> noteDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        NoteDbBatchUpdate.execute(noteDbUpdates, listener, requestId, dryRun);
    } else {
        ImmutableList<ReviewDbBatchUpdate> reviewDbUpdates = (ImmutableList) ImmutableList.copyOf(updates);
        ReviewDbBatchUpdate.execute(reviewDbUpdates, listener, requestId, dryRun);
    }
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (RawText.isBinary(ol.getBytes())) {
            continue;
        }
        try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) {
            if (doesInputStreanContainCR(isr)) {
                messages.add(new CommitValidationMessage("found carriage return (CR) character in file: " + path, true));
            }
        }
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        try (InputStream in = ol.openStream()) {
            if (RawText.isBinary(in) || contentTypeUtil.isBlacklistedBinaryContentType(ol, path, cfg)) {
                continue;
            }
        }
        try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) {
            if (doesInputStreanContainCR(isr)) {
                messages.add(new CommitValidationMessage("found carriage return (CR) character in file: " + path, true));
            }
        }
    }
    return messages;
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (RawText.isBinary(ol.getBytes())) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        try (InputStream in = ol.openStream()) {
            if (RawText.isBinary(in) || contentTypeUtil.isBlacklistedBinaryContentType(ol, path, cfg)) {
                continue;
            }
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, String[] blockedTypes, boolean whitelist) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        String contentType = contentTypeUtil.getContentType(ol.getBytes(), path);
        if ((contentTypeUtil.matchesAny(contentType, blockedTypes) && !whitelist) || (!contentTypeUtil.matchesAny(contentType, blockedTypes) && whitelist)) {
            messages.add(new CommitValidationMessage("found blocked content type (" + contentType + ") in file: " + path, true));
        }
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, String[] blockedTypes, boolean whitelist) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        String contentType = contentTypeUtil.getContentType(ol, path);
        if ((contentTypeUtil.matchesAny(contentType, blockedTypes) && !whitelist) || (!contentTypeUtil.matchesAny(contentType, blockedTypes) && whitelist)) {
            messages.add(new CommitValidationMessage("found blocked content type (" + contentType + ") in file: " + path, true));
        }
    }
    return messages;
}
#end_block

#method_before
public String getContentType(byte[] bytes, String pathname) throws IOException {
    return mimeUtil.getMimeType(pathname, bytes).toString();
}
#method_after
public String getContentType(ObjectLoader ol, String pathname) throws IOException {
    try (InputStream is = ol.openStream()) {
        return mimeUtil.getMimeType(pathname, is).toString();
    }
}
#end_block

#method_before
private static Iterable<String> getLabels(ChangeData input, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : input.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && input.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#method_after
private static Iterable<String> getLabels(ChangeData cd, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : cd.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && cd.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#end_block

#method_before
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getAuthor());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getAuthor());
}
#end_block

#method_before
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getCommitter());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getCommitter());
}
#end_block

#method_before
private static String getTopic(ChangeData input) throws OrmException {
    Change c = input.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#method_after
private static String getTopic(ChangeData cd) throws OrmException {
    Change c = cd.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    if (!self.get().getAccountId().equals(rsrc.getChange().getOwner()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to set private status");
    }
    if (rsrc.getChange().isPrivate()) {
        return Response.ok("");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(true);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.created("");
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not allowed to mark private");
    }
    if (rsrc.getChange().isPrivate()) {
        return Response.ok("");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(true);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.created("");
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setPrivate(isPrivate);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setPrivate(isPrivate);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setPrivate(isPrivate);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setPrivate(isPrivate);
    return true;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource rsrc, DeletePrivate.Input input) throws RestApiException, UpdateException {
    if (!self.get().getAccountId().equals(rsrc.getChange().getOwner()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete private status");
    }
    if (!rsrc.getChange().isPrivate()) {
        throw new ResourceConflictException("change is not private");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(false);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, DeletePrivate.Input input) throws RestApiException, UpdateException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not allowed to unmark private");
    }
    if (!rsrc.getChange().isPrivate()) {
        throw new ResourceConflictException("change is not private");
    }
    ChangeControl control = rsrc.getControl();
    SetPrivateOp op = new SetPrivateOp(false);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return Response.none();
}
#end_block

#method_before
@Test
public void setPrivateByOtherUser() throws Exception {
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    setApiUser(accounts.user2());
    assertThat(gApi.changes().id(result.getChangeId()).isPrivate()).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to set private status");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#method_after
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self project:{" + project.get() + "}")).isEmpty();
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return (isAdmin() || (isOwner() && getRefControl().canDeleteOwnChanges()));
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#method_after
boolean canRemoveReviewer() {
    return canPerform(Permission.REMOVE_REVIEWER);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate);
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    get(CHANGE_KIND, "private").to(GetPrivate.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate.IsMergeablePredicate(args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate.IsPrivatePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.reviewer(args, id)).collect(toList()));
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private PluginConfigInfo getPluginInfo() {
    PluginConfigInfo info = new PluginConfigInfo();
    info.hasAvatars = toBoolean(avatar.get() != null);
    info.jsResourcePaths = new ArrayList<>();
    info.htmlResourcePaths = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        String path = u.getJavaScriptResourcePath();
        if (path.endsWith(".html")) {
            info.htmlResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), path));
        } else {
            info.jsResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), path));
        }
    }
    return info;
}
#method_after
private PluginConfigInfo getPluginInfo() {
    PluginConfigInfo info = new PluginConfigInfo();
    info.hasAvatars = toBoolean(avatar.get() != null);
    info.jsResourcePaths = new ArrayList<>();
    info.htmlResourcePaths = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        String path = String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath());
        if (path.endsWith(".html")) {
            info.htmlResourcePaths.add(path);
        } else {
            info.jsResourcePaths.add(path);
        }
    }
    return info;
}
#end_block

#method_before
public synchronized void rescan() {
    SetMultimap<String, Path> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, Path> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, Path> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        Path path = entry.getValue();
        String fileName = path.getFileName().toString();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(path)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(path.toFile())) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(path)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", active.getName()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, path, active);
            if (!loadedPlugin.isDisabled()) {
                log.info(String.format("%s plugin %s, version %s", active == null ? "Loaded" : "Reloaded", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    SetMultimap<String, Path> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, Path> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, Path> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        Path path = entry.getValue();
        String fileName = path.getFileName().toString();
        if (!isUiPlugin(fileName) && !serverPluginFactory.handles(path)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(path.toFile())) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(path)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", active.getName()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, path, active);
            if (!loadedPlugin.isDisabled()) {
                log.info(String.format("%s plugin %s, version %s", active == null ? "Loaded" : "Reloaded", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin loadPlugin(String name, Path srcPlugin, FileSnapshot snapshot) throws InvalidPluginException {
    String pluginName = srcPlugin.getFileName().toString();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getFileName()));
    }
}
#method_after
private Plugin loadPlugin(String name, Path srcPlugin, FileSnapshot snapshot) throws InvalidPluginException {
    String pluginName = srcPlugin.getFileName().toString();
    if (isUiPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getFileName()));
    }
}
#end_block

#method_before
public String getGerritPluginName(Path srcPath) {
    String fileName = srcPath.getFileName().toString();
    if (isJsPlugin(fileName)) {
        return fileName.substring(0, fileName.lastIndexOf('.'));
    }
    if (serverPluginFactory.handles(srcPath)) {
        return serverPluginFactory.getPluginName(srcPath);
    }
    return null;
}
#method_after
public String getGerritPluginName(Path srcPath) {
    String fileName = srcPath.getFileName().toString();
    if (isUiPlugin(fileName)) {
        return fileName.substring(0, fileName.lastIndexOf('.'));
    }
    if (serverPluginFactory.handles(srcPath)) {
        return serverPluginFactory.getPluginName(srcPath);
    }
    return null;
}
#end_block

#method_before
public static void load(List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) {
    plugins.removeIf(p -> !p.endsWith(".js"));
    if (plugins == null || plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    } else {
        self = new PluginLoader(loadTimeout, callback);
        self.load(plugins);
        self.startTimers();
        self.center();
    }
}
#method_after
public static void load(List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) {
    if (plugins == null || plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    }
    plugins = plugins.stream().filter(p -> p.endsWith(".js")).collect(Collectors.toList());
    if (plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    } else {
        self = new PluginLoader(loadTimeout, callback);
        self.load(plugins);
        self.startTimers();
        self.center();
    }
}
#end_block

#method_before
public Map<String, Object> getConfig(String fromBranch, String toBranch) {
    return config.getMergeConfig(fromBranch, toBranch);
}
#method_after
private Config getConfig() throws ConfigInvalidException {
    try {
        return cfgFactory.getProjectPluginConfig(allProjectsName, pluginName);
    } catch (NoSuchProjectException e) {
        throw new ConfigInvalidException("Config invalid because " + allProjectsName.get() + " does not exist!");
    }
}
#end_block

#method_before
public boolean isSkipMerge(String fromBranch, String toBranch, String commitMessage) {
    return config.isSkipMerge(fromBranch, toBranch, commitMessage);
}
#method_after
public boolean isSkipMerge(String fromBranch, String toBranch, String commitMessage) throws ConfigInvalidException {
    Pattern alwaysBlankMergePattern = getConfigPattern("alwaysBlankMerge");
    if (alwaysBlankMergePattern.matches(commitMessage)) {
        return true;
    }
    Pattern blankMergePattern = getConfigPattern("blankMerge");
    // If regex matches blank_merge (DO NOT MERGE), skip iff merge_all is false
    if (blankMergePattern.matches(commitMessage)) {
        return !getMergeAll(fromBranch, toBranch);
    }
    return false;
}
#end_block

#method_before
public String getAutomergeLabel() {
    return config.getAutomergeLabel();
}
#method_after
public String getAutomergeLabel() throws ConfigInvalidException {
    String automergeLabel = getConfig().getString("global", null, "automergeLabel");
    return automergeLabel != null ? automergeLabel : "Verified";
}
#end_block

#method_before
public Set<String> getProjectsInScope(String fromBranch, String toBranch) throws RestApiException, IOException {
    try {
        Set<String> projectSet = new HashSet<String>();
        Set<String> fromProjectSet = getManifestProjects(fromBranch);
        projectSet.addAll(fromProjectSet);
        Set<String> toProjectSet = getManifestProjects(fromBranch, toBranch);
        // Take intersection of project sets, unless one is empty.
        if (projectSet.isEmpty()) {
            projectSet = toProjectSet;
        } else if (!toProjectSet.isEmpty()) {
            projectSet.retainAll(toProjectSet);
        }
        // The lower the level a config is applied, the higher priority it has
        // For example, a project ignored in the global config but added in the branch config will
        // be added to the final project set, not ignored
        applyConfig(projectSet, config.getGlobal());
        applyConfig(projectSet, config.getMergeConfig(fromBranch));
        applyConfig(projectSet, config.getMergeConfig(fromBranch, toBranch));
        log.debug("Project set for {} to {} is {}", fromBranch, toBranch, projectSet);
        return projectSet;
    } catch (RestApiException | IOException e) {
        log.error("Error reading manifest for {}!", fromBranch, e);
        throw e;
    }
}
#method_after
public Set<String> getProjectsInScope(String fromBranch, String toBranch) throws RestApiException, IOException, ConfigInvalidException {
    try {
        Set<String> projectSet = getManifestProjects(fromBranch, toBranch);
        projectSet = applyConfig(fromBranch, toBranch, projectSet);
        log.debug("Project set for {} to {} is {}", fromBranch, toBranch, projectSet);
        return projectSet;
    } catch (RestApiException | IOException e) {
        log.error("Error reading manifest for {}!", fromBranch, e);
        throw e;
    }
}
#end_block

#method_before
public Set<String> getDownstreamBranches(String fromBranch, String project) throws RestApiException, IOException {
    Set<String> downstreamBranches = new HashSet<String>();
    Map<String, Map> fromBranchConfig = config.getMergeConfig(fromBranch);
    if (fromBranchConfig != null) {
        for (String key : fromBranchConfig.keySet()) {
            if (!configOptionKeys.contains(key)) {
                // If it's not a config option, then the key is the toBranch
                Set<String> projectsInScope = getProjectsInScope(fromBranch, key);
                if (projectsInScope.contains(project)) {
                    downstreamBranches.add(key);
                }
            }
        }
    }
    return downstreamBranches;
}
#method_after
public Set<String> getDownstreamBranches(String fromBranch, String project) throws RestApiException, IOException, ConfigInvalidException {
    Set<String> downstreamBranches = new HashSet<String>();
    // List all subsections of automerger, split by :
    Set<String> subsections = getConfig().getSubsections(pluginName);
    for (String subsection : subsections) {
        // Subsections are of the form "fromBranch:toBranch"
        String[] branchPair = subsection.split(Pattern.quote(BRANCH_DELIMITER));
        if (branchPair.length != 2) {
            throw new ConfigInvalidException("Automerger config branch pair malformed: " + subsection);
        }
        if (fromBranch.equals(branchPair[0])) {
            // If fromBranches match, check if project is in both their manifests
            Set<String> projectsInScope = getProjectsInScope(branchPair[0], branchPair[1]);
            if (projectsInScope.contains(project)) {
                downstreamBranches.add(branchPair[1]);
            }
        }
    }
    return downstreamBranches;
}
#end_block

#method_before
// Returns contents of manifest file for the given branch pair
private Set<String> getManifestProjects(String fromBranch, String toBranch) throws RestApiException, IOException {
    Map<String, Object> toBranchConfig = config.getMergeConfig(fromBranch, toBranch);
    if (toBranchConfig == null) {
        return new HashSet<>();
    }
    Map<String, String> manifestProjectInfo = getManifestInfoFromConfig(toBranchConfig);
    return getManifestProjectsForBranch(manifestProjectInfo, toBranch);
}
#method_after
// Returns contents of manifest file for the given branch pair
private Set<String> getManifestProjects(String fromBranch, String toBranch) throws RestApiException, IOException, ConfigInvalidException {
    boolean ignoreSourceManifest = getConfig().getBoolean("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "ignoreSourceManifest", false);
    Set<String> toProjects = getProjectsInManifest(getManifestProject(), getManifestFile(), toBranch);
    if (ignoreSourceManifest) {
        return toProjects;
    }
    Set<String> fromProjects = getProjectsInManifest(getManifestProject(), getManifestFile(), fromBranch);
    fromProjects.retainAll(toProjects);
    return fromProjects;
}
#end_block

#method_before
private void applyConfig(Set<String> projects, Map givenConfig) {
    if (givenConfig == null) {
        return;
    }
    if (givenConfig.containsKey("set_projects")) {
        List<String> setProjects = (ArrayList<String>) givenConfig.get("set_projects");
        projects.clear();
        projects.addAll(setProjects);
        // if we set projects we can ignore the rest
        return;
    }
    if (givenConfig.containsKey("add_projects")) {
        List<String> addProjects = (List<String>) givenConfig.get("add_projects");
        projects.addAll(addProjects);
    }
    if (givenConfig.containsKey("ignore_projects")) {
        List<String> ignoreProjects = (List<String>) givenConfig.get("ignore_projects");
        projects.removeAll(ignoreProjects);
    }
}
#method_after
private Set<String> applyConfig(String fromBranch, String toBranch, Set<String> inputProjects) throws ConfigInvalidException {
    Set<String> projects = new HashSet<>(inputProjects);
    List<String> setProjects = Arrays.asList(getConfig().getStringList("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "setProjects"));
    if (!setProjects.isEmpty()) {
        projects.clear();
        projects.addAll(setProjects);
        // if we set projects we can ignore the rest
        return projects;
    }
    List<String> addProjects = Arrays.asList(getConfig().getStringList("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "addProjects"));
    projects.addAll(addProjects);
    List<String> ignoreProjects = Arrays.asList(getConfig().getStringList("automerger", fromBranch + BRANCH_DELIMITER + toBranch, "ignoreProjects"));
    projects.removeAll(ignoreProjects);
    return projects;
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = event.getChange();
    String revision = event.getRevision().commit.commit;
    log.debug("Detected revision {} abandoned on {}.", revision, change.project);
    abandonDownstream(change, revision);
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = event.getChange();
    String revision = event.getRevision().commit.commit;
    log.debug("Detected revision {} abandoned on {}.", revision, change.project);
    try {
        abandonDownstream(change, revision);
    } catch (ConfigInvalidException e) {
        log.error("Automerger plugin failed onChangeAbandoned for {}", change.id, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.debug("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        } catch (RestApiException e) {
            log.error("RestApiException when editing downstream topics of {}", change.id, e);
        }
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.debug("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        } catch (RestApiException e) {
            log.error("RestApiException when editing downstream topics of {}", change.id, e);
        }
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException e) {
            log.error("RestApiException when updating downstream votes of {}", change.id, e);
        }
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException | ConfigInvalidException e) {
            log.error("Exception when updating downstream votes of {}", change.id, e);
        }
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onChangeRestored for {}", change.id, e);
    }
}
#end_block

#method_before
@Override
public void onDraftPublished(DraftPublishedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onDraftPublished for {}", change.id, e);
    }
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onRevisionCreated for {}", change.id, e);
    }
}
#end_block

#method_before
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException {
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    short vote = 0;
    try {
        createDownstreamMerges(mdsMergeInput);
        reviewInput.message = "Automerging to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
    } catch (FailedMergeException e) {
        reviewInput.message = e.displayConflicts();
        reviewInput.notify = NotifyHandling.ALL;
        vote = -1;
    }
    // Zero out automerge label if success, -1 vote if fail.
    labels.put(config.getAutomergeLabel(), vote);
    reviewInput.labels = labels;
    gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput);
}
#method_after
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, ConfigInvalidException {
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    short vote = 0;
    try {
        createDownstreamMerges(mdsMergeInput);
        reviewInput.message = "Automerging to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
    } catch (FailedMergeException e) {
        reviewInput.message = e.getDisplayString();
        reviewInput.notify = NotifyHandling.ALL;
        vote = -1;
    }
    // Zero out automerge label if success, -1 vote if fail.
    labels.put(config.getAutomergeLabel(), vote);
    reviewInput.labels = labels;
    gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput);
}
#end_block

#method_before
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException {
    List<String> failedMerges = new ArrayList<String>();
    List<Integer> existingDownstream;
    for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
        // Otherwise, create them.
        try {
            boolean createDownstreams = true;
            if (mdsMergeInput.obsoleteRevision != null) {
                existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
                if (!existingDownstream.isEmpty()) {
                    log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                    // it's possible to construct it so that it's not
                    for (Integer dsChangeNumber : existingDownstream) {
                        updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                        createDownstreams = false;
                    }
                }
            }
            if (createDownstreams) {
                log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
                sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
                sdsMergeInput.sourceId = mdsMergeInput.sourceId;
                sdsMergeInput.project = mdsMergeInput.project;
                sdsMergeInput.topic = mdsMergeInput.topic;
                sdsMergeInput.subject = mdsMergeInput.subject;
                sdsMergeInput.downstreamBranch = downstreamBranch;
                sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
                createSingleDownstreamMerge(sdsMergeInput);
            }
        } catch (MergeConflictException e) {
            // TODO(stephenli): also put host in the map
            Map<String, String> substitutionMap = new HashMap<>();
            substitutionMap.put("branch", downstreamBranch);
            substitutionMap.put("revision", mdsMergeInput.currentRevision);
            String resolvedString = assembleConflictMessage(substitutionMap, e.getMessage());
            log.debug("Merge conflict from {} to {}", mdsMergeInput.currentRevision, downstreamBranch);
            failedMerges.add(resolvedString);
            log.debug("Abandoning downstream of {}", mdsMergeInput.sourceId);
            abandonDownstream(gApi.changes().id(mdsMergeInput.sourceId).info(), mdsMergeInput.currentRevision);
        }
    }
    if (!failedMerges.isEmpty()) {
        throw new FailedMergeException(failedMerges);
    }
}
#method_after
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException, ConfigInvalidException {
    // Map from branch to error message
    Map<String, String> failedMergeBranchMap = new TreeMap<String, String>();
    List<Integer> existingDownstream;
    for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
        // Otherwise, create them.
        try {
            boolean createDownstreams = true;
            if (mdsMergeInput.obsoleteRevision != null) {
                existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
                if (!existingDownstream.isEmpty()) {
                    log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                    // it's possible to construct it so that it's not
                    for (Integer dsChangeNumber : existingDownstream) {
                        updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                        createDownstreams = false;
                    }
                }
            }
            if (createDownstreams) {
                log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
                sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
                sdsMergeInput.sourceId = mdsMergeInput.sourceId;
                sdsMergeInput.project = mdsMergeInput.project;
                sdsMergeInput.topic = mdsMergeInput.topic;
                sdsMergeInput.subject = mdsMergeInput.subject;
                sdsMergeInput.downstreamBranch = downstreamBranch;
                sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
                createSingleDownstreamMerge(sdsMergeInput);
            }
        } catch (MergeConflictException e) {
            failedMergeBranchMap.put(downstreamBranch, e.getMessage());
            log.debug("Abandoning downstream of {}", mdsMergeInput.sourceId);
            abandonDownstream(gApi.changes().id(mdsMergeInput.sourceId).info(), mdsMergeInput.currentRevision);
        }
    }
    if (!failedMergeBranchMap.isEmpty()) {
        throw new FailedMergeException(failedMergeBranchMap, mdsMergeInput.currentRevision, config.getHostName(), config.getConflictMessage(), mdsMergeInput.topic);
    }
}
#end_block

#method_before
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException {
    String currentTopic = setTopic(sdsMergeInput.sourceId, sdsMergeInput.topic);
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = sdsMergeInput.currentRevision;
    log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
    ChangeInput downstreamChangeInput = new ChangeInput();
    downstreamChangeInput.project = sdsMergeInput.project;
    downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
    downstreamChangeInput.subject = sdsMergeInput.subject + " am: " + sdsMergeInput.currentRevision.substring(0, 10);
    downstreamChangeInput.topic = currentTopic;
    downstreamChangeInput.merge = mergeInput;
    if (!sdsMergeInput.doMerge) {
        mergeInput.strategy = "ours";
        downstreamChangeInput.subject = sdsMergeInput.subject + " skipped: " + sdsMergeInput.currentRevision.substring(0, 10);
        log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
    }
    gApi.changes().create(downstreamChangeInput);
}
#method_after
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException {
    String currentTopic = setTopic(sdsMergeInput.sourceId, sdsMergeInput.topic);
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = sdsMergeInput.currentRevision;
    mergeInput.strategy = "recursive";
    log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
    ChangeInput downstreamChangeInput = new ChangeInput();
    downstreamChangeInput.project = sdsMergeInput.project;
    downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
    downstreamChangeInput.subject = sdsMergeInput.subject + " am: " + sdsMergeInput.currentRevision.substring(0, 10);
    downstreamChangeInput.topic = currentTopic;
    downstreamChangeInput.merge = mergeInput;
    if (!sdsMergeInput.doMerge) {
        mergeInput.strategy = "ours";
        downstreamChangeInput.subject = sdsMergeInput.subject + " skipped: " + sdsMergeInput.currentRevision.substring(0, 10);
        log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
    }
    gApi.changes().create(downstreamChangeInput);
}
#end_block

#method_before
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.sourceId = change.id;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = change.topic;
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#method_after
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException, ConfigInvalidException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.sourceId = change.id;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = change.topic;
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#end_block

#method_before
private void abandonDownstream(ChangeInfo change, String revision) {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#method_after
private void abandonDownstream(ChangeInfo change, String revision) throws ConfigInvalidException {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#end_block

#method_before
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    if (label.equals(config.getAutomergeLabel())) {
        log.debug("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#method_after
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException, ConfigInvalidException {
    if (label.equals(config.getAutomergeLabel())) {
        log.debug("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
    files.add(TestUtils.createEmptyFile(GOOD, repo));
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
    files.add(TestUtils.createEmptyFile(GOOD, repo));
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testAddTooLongPath() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, new RevWalk(repo), getMaxPathLength());
    Set<String> expected = ImmutableSet.of("ERROR: path too long: " + TOO_LONG);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testAddTooLongPath() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, rw, getMaxPathLength());
        Set<String> expected = ImmutableSet.of("ERROR: path too long: " + TOO_LONG);
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
@Test
public void testDeleteTooLongPath() throws Exception {
    RevCommit c = makeCommit();
    try (Git git = new Git(repo)) {
        Set<File> files = new HashSet<>();
        files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
        TestUtils.removeFiles(git, files);
        c = git.commit().setMessage("Delete file which is too long").call();
    }
    List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, new RevWalk(repo), getMaxPathLength());
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testDeleteTooLongPath() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        try (Git git = new Git(repo)) {
            Set<File> files = new HashSet<>();
            files.add(TestUtils.createEmptyFile(TOO_LONG, repo));
            TestUtils.removeFiles(git, files);
            c = git.commit().setMessage("Delete file which is too long").call();
            rw.parseCommit(c);
        }
        List<CommitValidationMessage> m = MaxPathLengthValidator.performValidation(repo, c, rw, getMaxPathLength());
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
private RevCommit makeCommitWithSymlink() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    File link = new File(repo.getDirectory().getParent(), "foo.txt");
    Files.createSymbolicLink(link.toPath(), Paths.get("bar.txt"));
    files.put(link, null);
    link = new File(repo.getDirectory().getParent(), "symbolicFolder");
    Files.createSymbolicLink(link.toPath(), Paths.get("folder"));
    files.put(link, null);
    return TestUtils.makeCommit(repo, "Commit with symlink.", files);
}
#method_after
private RevCommit makeCommitWithSymlink(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    File link = new File(repo.getDirectory().getParent(), "foo.txt");
    Files.createSymbolicLink(link.toPath(), Paths.get("bar.txt"));
    files.put(link, null);
    link = new File(repo.getDirectory().getParent(), "symbolicFolder");
    Files.createSymbolicLink(link.toPath(), Paths.get("folder"));
    files.put(link, null);
    return TestUtils.makeCommit(rw, repo, "Commit with symlink.", files);
}
#end_block

#method_before
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c, new RevWalk(repo));
    Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSymlink() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithSymlink(rw);
        List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, rw.parseCommit(c), rw);
        Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
private RevCommit makeCommitWithoutSymlink() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommitWithoutSymlink(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testWithoutSymlink() throws Exception {
    RevCommit c = makeCommitWithoutSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c, new RevWalk(repo));
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testWithoutSymlink() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithoutSymlink(rw);
        List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, rw.parseCommit(c), rw);
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
private RevCommit makeCommit(List<String> blockedExtensions) throws NoFilepatternException, IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String extension : blockedExtensions) {
        files.add(new File(repo.getDirectory().getParent(), "foo." + extension));
    }
    // valid extensions
    files.add(new File(repo.getDirectory().getParent(), "foo.java"));
    files.add(new File(repo.getDirectory().getParent(), "foo.core.tmp"));
    files.add(new File(repo.getDirectory().getParent(), "foo.c"));
    files.add(new File(repo.getDirectory().getParent(), "foo.txt"));
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw, List<String> blockedExtensions) throws NoFilepatternException, IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String extension : blockedExtensions) {
        files.add(new File(repo.getDirectory().getParent(), "foo." + extension));
    }
    // valid extensions
    files.add(new File(repo.getDirectory().getParent(), "foo.java"));
    files.add(new File(repo.getDirectory().getParent(), "foo.core.tmp"));
    files.add(new File(repo.getDirectory().getParent(), "foo.c"));
    files.add(new File(repo.getDirectory().getParent(), "foo.txt"));
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testBlockedExtensions() throws Exception {
    RevCommit c = makeCommit(BLOCKED_EXTENSIONS_LC);
    List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, new RevWalk(repo), BLOCKED_EXTENSIONS_LC);
    List<String> expected = new ArrayList<>();
    for (String extension : BLOCKED_EXTENSIONS_LC) {
        expected.add("ERROR: blocked file: foo." + extension);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testBlockedExtensions() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, BLOCKED_EXTENSIONS_LC);
        List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, rw, BLOCKED_EXTENSIONS_LC);
        List<String> expected = new ArrayList<>();
        for (String extension : BLOCKED_EXTENSIONS_LC) {
            expected.add("ERROR: blocked file: foo." + extension);
        }
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
@Test
public void testBlockedExtensionsCaseInsensitive() throws Exception {
    RevCommit c = makeCommit(BLOCKED_EXTENSIONS_UC);
    List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, new RevWalk(repo), BLOCKED_EXTENSIONS_LC);
    List<String> expected = new ArrayList<>();
    for (String extension : BLOCKED_EXTENSIONS_UC) {
        expected.add("ERROR: blocked file: foo." + extension);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testBlockedExtensionsCaseInsensitive() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, BLOCKED_EXTENSIONS_UC);
        List<CommitValidationMessage> m = FileExtensionValidator.performValidation(repo, c, rw, BLOCKED_EXTENSIONS_LC);
        List<String> expected = new ArrayList<>();
        for (String extension : BLOCKED_EXTENSIONS_UC) {
            expected.add("ERROR: blocked file: foo." + extension);
        }
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
private RevCommit makeCommitWithSubmodule() throws IOException, GitAPIException {
    try (Git git = new Git(repo)) {
        SubmoduleAddCommand addCommand = git.submoduleAdd();
        addCommand.setURI(repo.getDirectory().getCanonicalPath());
        addCommand.setPath("modules/library");
        addCommand.call().close();
        git.add().addFilepattern(".").call();
        return git.commit().setMessage("Commit with submodule.").call();
    }
}
#method_after
private RevCommit makeCommitWithSubmodule(RevWalk rw) throws IOException, GitAPIException {
    try (Git git = new Git(repo)) {
        SubmoduleAddCommand addCommand = git.submoduleAdd();
        addCommand.setURI(repo.getDirectory().getCanonicalPath());
        addCommand.setPath("modules/library");
        addCommand.call().close();
        git.add().addFilepattern(".").call();
        return rw.parseCommit(git.commit().setMessage("Commit with submodule.").call());
    }
}
#end_block

#method_before
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, new RevWalk(repo));
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: submodules are not allowed: modules/library");
}
#method_after
@Test
public void testWithSubmodule() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithSubmodule(rw);
        List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, rw);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: submodules are not allowed: modules/library");
    }
}
#end_block

#method_before
private RevCommit makeCommitWithoutSubmodule() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommitWithoutSubmodule(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), null);
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void testWithoutSubmodule() throws Exception {
    RevCommit c = makeCommitWithoutSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, new RevWalk(repo));
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testWithoutSubmodule() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommitWithoutSubmodule(rw);
        List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c, rw);
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
public static void visitChangedEntries(Repository repo, RevCommit c, RevWalk revWalk, TreeWalkVisitor visitor) throws IOException {
    try (TreeWalk tw = new TreeWalk(revWalk.getObjectReader())) {
        tw.setRecursive(true);
        tw.setFilter(TreeFilter.ANY_DIFF);
        tw.addTree(revWalk.parseTree(c.getTree()));
        if (c.getParentCount() > 0) {
            for (RevCommit p : c.getParents()) {
                if (p.getTree() == null) {
                    revWalk.parseHeaders(p);
                }
                tw.addTree(p.getTree());
            }
            while (tw.next()) {
                if (isDifferentToAllParents(c, tw)) {
                    visitor.onVisit(tw);
                }
            }
        } else {
            while (tw.next()) {
                visitor.onVisit(tw);
            }
        }
    }
}
#method_after
public static void visitChangedEntries(Repository repo, RevCommit c, RevWalk revWalk, TreeWalkVisitor visitor) throws IOException {
    try (TreeWalk tw = new TreeWalk(revWalk.getObjectReader())) {
        tw.setRecursive(true);
        tw.setFilter(TreeFilter.ANY_DIFF);
        tw.addTree(c.getTree());
        if (c.getParentCount() > 0) {
            for (RevCommit p : c.getParents()) {
                if (p.getTree() == null) {
                    revWalk.parseHeaders(p);
                }
                tw.addTree(p.getTree());
            }
            while (tw.next()) {
                if (isDifferentToAllParents(c, tw)) {
                    visitor.onVisit(tw);
                }
            }
        } else {
            while (tw.next()) {
                visitor.onVisit(tw);
            }
        }
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.user, receiveEvent.getProjectNameKey(), receiveEvent.getRefName(), KEY_CHECK_BLOCKED_KEYWORD)) {
            ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, receiveEvent.revWalk, blockedKeywordPatterns.values(), cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("includes files containing blocked keywords", messages);
                }
            }
        }
    } catch (NoSuchProjectException e) {
        throw new CommitValidationException("Upload validator failed to find project: " + receiveEvent.project.getName(), e);
    } catch (IOException | ExecutionException e) {
        throw new CommitValidationException("Upload validator errored while validating", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.user, receiveEvent.getProjectNameKey(), receiveEvent.getRefName(), KEY_CHECK_BLOCKED_KEYWORD)) {
            ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, receiveEvent.revWalk, blockedKeywordPatterns.values(), cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("includes files containing blocked keywords", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content;
    content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, RevWalk revWalk, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage());
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid line endings
    String content = "Testline1\r\n" + "Testline2\n" + "Testline3\r\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid line endings
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid line endings
    String content = "Testline1\r\n" + "Testline2\n" + "Testline3\r\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid line endings
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(rw, repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    InvalidLineEndingValidator validator = new InvalidLineEndingValidator(null, new ContentTypeUtil(PATTERN_CACHE), null, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, new RevWalk(repo), EMPTY_PLUGIN_CONFIG);
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found carriage return (CR) character in file: foo.txt");
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        InvalidLineEndingValidator validator = new InvalidLineEndingValidator(null, new ContentTypeUtil(PATTERN_CACHE), null, null, null);
        List<CommitValidationMessage> m = validator.performValidation(repo, c, rw, EMPTY_PLUGIN_CONFIG);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found carriage return (CR) character in file: foo.txt");
    }
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit foobar with test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(rw, repo, "Commit foobar with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, new RevWalk(repo), getPatterns().values(), EMPTY_PLUGIN_CONFIG);
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)", "ERROR: blocked keyword(s) found in: " + Patch.COMMIT_MSG + " (Line: 1) (found: foobar)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null, null);
        List<CommitValidationMessage> m = validator.performValidation(repo, c, rw, getPatterns().values(), EMPTY_PLUGIN_CONFIG);
        Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)", "ERROR: blocked keyword(s) found in: " + Patch.COMMIT_MSG + " (Line: 1) (found: foobar)");
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
private void runCheck(List<String> existingTreePaths, Set<String> testPaths, List<CommitValidationMessage> messages, List<String> visitedPaths) throws Exception {
    RevCommit c = makeCommit(createEmptyDirCacheEntries(existingTreePaths, testRepo), testRepo);
    try (TreeWalk tw = new TreeWalk(repo)) {
        tw.setRecursive(false);
        tw.addTree(c.getTree());
        tw.setFilter(new ListVisitedPathsFilter(visitedPaths));
        validator.checkForDuplicatesAgainstTheWholeTree(tw, testPaths, messages);
    }
}
#method_after
private void runCheck(List<String> existingTreePaths, Set<String> testPaths, List<CommitValidationMessage> messages, List<String> visitedPaths) throws Exception {
    RevCommit c = makeCommit(testRepo.getRevWalk(), createEmptyDirCacheEntries(existingTreePaths, testRepo), testRepo);
    try (TreeWalk tw = new TreeWalk(repo)) {
        tw.setRecursive(false);
        tw.addTree(c.getTree());
        tw.setFilter(new ListVisitedPathsFilter(visitedPaths));
        validator.checkForDuplicatesAgainstTheWholeTree(tw, testPaths, messages);
    }
}
#end_block

#method_before
@Test
public void testCheckInsideOfCommit() throws Exception {
    List<String> filenames = Lists.newArrayList(INITIAL_PATHNAMES);
    // add files with conflicting pathnames
    filenames.add("A");
    filenames.add("F1/ab");
    filenames.add("f2/sF1/aB");
    RevCommit c = makeCommit(createEmptyDirCacheEntries(filenames, testRepo), testRepo);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, new RevWalk(repo));
    assertThat(m).hasSize(4);
    // During checking inside of the commit it's unknown which file is checked
    // first, because of that, both capabilities must be checked.
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("A", "a")), transformMessage(conflict("a", "A")));
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1", "f1")), transformMessage(conflict("f1", "F1")));
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1/ab", "f1/ab")), transformMessage(conflict("f1/ab", "F1/ab")));
    assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("f2/sF1/aB", "f2/sF1/ab")), transformMessage(conflict("f2/sF1/ab", "f2/sF1/aB")));
}
#method_after
@Test
public void testCheckInsideOfCommit() throws Exception {
    List<String> filenames = Lists.newArrayList(INITIAL_PATHNAMES);
    // add files with conflicting pathnames
    filenames.add("A");
    filenames.add("F1/ab");
    filenames.add("f2/sF1/aB");
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, createEmptyDirCacheEntries(filenames, testRepo), testRepo);
        List<CommitValidationMessage> m = validator.performValidation(repo, c, rw);
        assertThat(m).hasSize(4);
        // During checking inside of the commit it's unknown which file is checked
        // first, because of that, both capabilities must be checked.
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("A", "a")), transformMessage(conflict("a", "A")));
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1", "f1")), transformMessage(conflict("f1", "F1")));
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("F1/ab", "f1/ab")), transformMessage(conflict("f1/ab", "F1/ab")));
        assertThat(transformMessages(m)).containsAnyOf(transformMessage(conflict("f2/sF1/aB", "f2/sF1/ab")), transformMessage(conflict("f2/sF1/ab", "f2/sF1/aB")));
    }
}
#end_block

#method_before
@Test
public void testCheckRenaming() throws Exception {
    RevCommit c = makeCommit(createEmptyDirCacheEntries(INITIAL_PATHNAMES, testRepo), testRepo);
    DirCacheEntry[] entries = new DirCacheEntry[INITIAL_PATHNAMES.size()];
    for (int x = 0; x < INITIAL_PATHNAMES.size(); x++) {
        // Rename files
        entries[x] = createDirCacheEntry(INITIAL_PATHNAMES.get(x).toUpperCase(), EMPTY_CONTENT, testRepo);
    }
    RevCommit c1 = makeCommit(entries, testRepo, c);
    List<CommitValidationMessage> m = validator.performValidation(repo, c1, new RevWalk(repo));
    assertThat(m).isEmpty();
}
#method_after
@Test
public void testCheckRenaming() throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw, createEmptyDirCacheEntries(INITIAL_PATHNAMES, testRepo), testRepo);
        DirCacheEntry[] entries = new DirCacheEntry[INITIAL_PATHNAMES.size()];
        for (int x = 0; x < INITIAL_PATHNAMES.size(); x++) {
            // Rename files
            entries[x] = createDirCacheEntry(INITIAL_PATHNAMES.get(x).toUpperCase(), EMPTY_CONTENT, testRepo);
        }
        RevCommit c1 = makeCommit(rw, entries, testRepo, c);
        List<CommitValidationMessage> m = validator.performValidation(repo, c1, rw);
        assertThat(m).isEmpty();
    }
}
#end_block

#method_before
@Test
public void testBlocked() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml", "text/html" };
    List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(), new RevWalk(repo), patterns, false);
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (application/pdf) in file: foo.pdf", "ERROR: found blocked content type (application/xml) in file: foo.xml", "ERROR: found blocked content type (text/html) in file: foo.html");
}
#method_after
@Test
public void testBlocked() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml", "text/html" };
    try (RevWalk rw = new RevWalk(repo)) {
        List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(rw), rw, patterns, false);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (application/pdf) in file: foo.pdf", "ERROR: found blocked content type (application/xml) in file: foo.xml", "ERROR: found blocked content type (text/html) in file: foo.html");
    }
}
#end_block

#method_before
@Test
public void testWhitelist() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml" };
    List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(), new RevWalk(repo), patterns, true);
    assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (text/html) in file: foo.html");
}
#method_after
@Test
public void testWhitelist() throws Exception {
    String[] patterns = new String[] { "application/pdf", "application/xml" };
    try (RevWalk rw = new RevWalk(repo)) {
        List<CommitValidationMessage> m = validator.performValidation(repo, makeCommit(rw), rw, patterns, true);
        assertThat(TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (text/html) in file: foo.html");
    }
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    String content = "<?xml version=\"1.0\"?><a><b>c</b></a>";
    files.put(TestUtils.createEmptyFile("foo.xml", repo), content.getBytes(StandardCharsets.UTF_8));
    content = "<html><body><h1>Hello World!</h1></body></html>";
    files.put(TestUtils.createEmptyFile("foo.html", repo), content.getBytes(StandardCharsets.UTF_8));
    files.put(TestUtils.createEmptyFile("foo.pdf", repo), TEST_PDF);
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    String content = "<?xml version=\"1.0\"?><a><b>c</b></a>";
    files.put(TestUtils.createEmptyFile("foo.xml", repo), content.getBytes(StandardCharsets.UTF_8));
    content = "<html><body><h1>Hello World!</h1></body></html>";
    files.put(TestUtils.createEmptyFile("foo.html", repo), content.getBytes(StandardCharsets.UTF_8));
    files.put(TestUtils.createEmptyFile("foo.pdf", repo), TEST_PDF);
    return TestUtils.makeCommit(rw, repo, "Commit with test files.", files);
}
#end_block

#method_before
private RevCommit makeCommit() throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        files.add(new File(repo.getDirectory().getParent(), filenames));
    }
    // valid filename
    files.add(new File(repo.getDirectory().getParent(), "test"));
    return TestUtils.makeCommit(repo, "Commit with empty test files.", files);
}
#method_after
private RevCommit makeCommit(RevWalk rw) throws IOException, GitAPIException {
    Set<File> files = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        files.add(new File(repo.getDirectory().getParent(), filenames));
    }
    // valid filename
    files.add(new File(repo.getDirectory().getParent(), "test"));
    return TestUtils.makeCommit(rw, repo, "Commit with empty test files.", files);
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "\\[|\\]|\\*|#", "[%:@]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, new RevWalk(repo), invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "\\[|\\]|\\*|#", "[%:@]" };
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = makeCommit(rw);
        List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, rw, invalidFilenamePattern);
        Set<String> expected = new HashSet<>();
        for (String filenames : getInvalidFilenames()) {
            expected.add("ERROR: invalid characters found in filename: " + filenames);
        }
        assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
    }
}
#end_block

#method_before
@Test
@GerritConfig(name = "review.robotCommentSizeLimit", value = "10k")
public void maximumAllowedSizeOfRobotCommentCanBeAdjusted() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    int sizeLimit = 10 * 1024;
    fixReplacementInfo.replacement = getStringFor(sizeLimit);
    exception.expect(BadRequestException.class);
    exception.expectMessage("limit");
    addRobotComment(changeId, withFixRobotCommentInput);
}
#method_after
@Test
@GerritConfig(name = "change.robotCommentSizeLimit", value = "10k")
public void maximumAllowedSizeOfRobotCommentCanBeAdjusted() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    int sizeLimit = 10 * 1024;
    fixReplacementInfo.replacement = getStringFor(sizeLimit);
    exception.expect(BadRequestException.class);
    exception.expectMessage("limit");
    addRobotComment(changeId, withFixRobotCommentInput);
}
#end_block

#method_before
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
        }
    }
    postReviewers.emailReviewers(change, to, cc, notify, accountsToNotify);
}
#method_after
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
            toByEmail.addAll(addition.op.reviewersByEmail);
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
            ccByEmail.addAll(addition.op.reviewersByEmail);
        }
    }
    postReviewers.emailReviewers(change, to, cc, toByEmail, ccByEmail, notify, accountsToNotify);
}
#end_block

#method_before
private void ensureSizeOfJsonInputIsWithinBounds(RobotCommentInput robotCommentInput) throws BadRequestException {
    int robotCommentSizeLimit = getRobotCommentSizeLimit();
    byte[] robotCommentBytes = GSON.toJson(robotCommentInput).getBytes(StandardCharsets.UTF_8);
    int robotCommentSize = robotCommentBytes.length;
    if (robotCommentSize > robotCommentSizeLimit) {
        throw new BadRequestException(String.format("Size %d (bytes) of robot comment is greater than limit %d (bytes)", robotCommentSize, robotCommentSizeLimit));
    }
}
#method_after
private void ensureSizeOfJsonInputIsWithinBounds(RobotCommentInput robotCommentInput) throws BadRequestException {
    OptionalInt robotCommentSizeLimit = getRobotCommentSizeLimit();
    if (robotCommentSizeLimit.isPresent()) {
        int sizeLimit = robotCommentSizeLimit.getAsInt();
        byte[] robotCommentBytes = GSON.toJson(robotCommentInput).getBytes(StandardCharsets.UTF_8);
        int robotCommentSize = robotCommentBytes.length;
        if (robotCommentSize > sizeLimit) {
            throw new BadRequestException(String.format("Size %d (bytes) of robot comment is greater than limit %d (bytes)", robotCommentSize, sizeLimit));
        }
    }
}
#end_block

#method_before
private int getRobotCommentSizeLimit() {
    int robotCommentSizeLimit = gerritConfig.getInt("review", "robotCommentSizeLimit", DEFAULT_ROBOT_COMMENT_SIZE_LIMIT_IN_BYTES);
    if (robotCommentSizeLimit < 0) {
        return DEFAULT_ROBOT_COMMENT_SIZE_LIMIT_IN_BYTES;
    }
    return robotCommentSizeLimit;
}
#method_after
private OptionalInt getRobotCommentSizeLimit() {
    int robotCommentSizeLimit = gerritConfig.getInt("change", "robotCommentSizeLimit", DEFAULT_ROBOT_COMMENT_SIZE_LIMIT_IN_BYTES);
    if (robotCommentSizeLimit <= 0) {
        return OptionalInt.empty();
    }
    return OptionalInt.of(robotCommentSizeLimit);
}
#end_block

#method_before
public Change.Id cherryPick(Change.Id sourceChangeId, PatchSet.Id sourcePatchId, Branch.NameKey sourceBranch, String sourceChangeTopic, Project.NameKey project, ObjectId sourceCommit, String message, String targetRef, RefControl targetRefControl, int parent) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(targetRef)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    String destinationBranch = RefNames.shortName(targetRef);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(targetRef);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = targetRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = targetRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, targetRefControl.getRefName(), newTopic, sourceBranch, sourceCommit);
                    if (sourceChangeId != null && sourcePatchId != null)
                        bu.addOp(sourceChangeId, new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(@Nullable Change.Id sourceChangeId, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, Project.NameKey project, ObjectId sourceCommit, String message, String targetRef, RefControl targetRefControl, int parent) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(targetRef)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    String destinationBranch = RefNames.shortName(targetRef);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(targetRef);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = targetRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = targetRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, targetRefControl.getRefName(), newTopic, sourceBranch, sourceCommit);
                    if (sourceChangeId != null && sourcePatchId != null) {
                        bu.addOp(sourceChangeId, new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, destinationBranch, cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#end_block

#method_before
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch, ObjectId sourceCommit) {
    StringBuilder stringBuilder = new StringBuilder("Patch Set ").append(patchSetId.get());
    if (sourceBranch != null) {
        stringBuilder.append(": Cherry Picked from branch ").append(sourceBranch.getShortName());
    } else {
        stringBuilder.append(": Cherry Picked from commit ").append(sourceCommit);
    }
    return stringBuilder.append(".").toString();
}
#method_after
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch, ObjectId sourceCommit) {
    StringBuilder stringBuilder = new StringBuilder("Patch Set ").append(patchSetId.get());
    if (sourceBranch != null) {
        stringBuilder.append(": Cherry Picked from branch ").append(sourceBranch.getShortName());
    } else {
        stringBuilder.append(": Cherry Picked from commit ").append(sourceCommit.getName());
    }
    return stringBuilder.append(".").toString();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(PROJECT_KIND, "cherrypickcommit").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ProjectResource rsrc, CherryPickCommitInput input) throws OrmException, IOException, UpdateException, RestApiException {
    checkAndCleanInput(input);
    // TODO(xchangcheng): do we need to check if the commit is visible?
    ProjectControl projectControl = rsrc.getControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    String refName = RefNames.fullName(destination);
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + commit + " to " + input.destination);
    }
    Project.NameKey project = rsrc.getNameKey();
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(null, null, null, null, project, ObjectId.fromString(commit), input.message, refName, refControl, parent);
        return json.noOptions().format(project, cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public ChangeInfo apply(CommitResource rsrc, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    String message = Strings.nullToEmpty(input.message).trim();
    String destination = Strings.nullToEmpty(input.destination).trim();
    int parent = input.parent == null ? 1 : input.parent;
    if (destination.isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    ProjectControl projectControl = rsrc.getProject();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    RevCommit commit = rsrc.getCommit();
    String refName = RefNames.fullName(destination);
    RefControl refControl = projectControl.controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + commit + " to " + destination);
    }
    Project.NameKey project = projectControl.getProject().getNameKey();
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(null, null, null, null, project, commit, message.isEmpty() ? commit.getFullMessage() : message, refName, refControl, parent);
        return json.noOptions().format(project, cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    if (input.showJobsSummaryPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsSummaryPanel", input.showJobsSummaryPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsSummaryPanel");
    }
    if (input.sortJobsPanel != null) {
        cfg.setString("plugin", pluginName, "sortJobsPanel", input.sortJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "sortJobsPanel");
    }
    if (input.sortJobsDropDownPanel != null) {
        cfg.setString("plugin", pluginName, "sortJobsDropDownPanel", input.sortJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "sortJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    if (input.showJobsSummaryPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsSummaryPanel", input.showJobsSummaryPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsSummaryPanel");
    }
    if (input.sortJobsPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsPanel", JobsSorting.valueOf(input.sortJobsPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsPanel");
    }
    if (input.sortJobsDropDownPanel != null) {
        cfg.setEnum("plugin", pluginName, "sortJobsDropDownPanel", JobsSorting.valueOf(input.sortJobsDropDownPanel));
    } else {
        cfg.unset("plugin", pluginName, "sortJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#end_block

#method_before
@Override
public ConfigInfo apply(ConfigResource resource) {
    ConfigInfo info = new ConfigInfo();
    info.showJobsPanel = cfg.getBoolean("showJobsPanel", true);
    info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true);
    info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true);
    info.sortJobsPanel = cfg.getString("sortJobsPanel", "REPORTER");
    info.sortJobsDropDownPanel = cfg.getString("sortJobsDropDownPanel", "REPORTER");
    return info;
}
#method_after
@Override
public ConfigInfo apply(ConfigResource resource) {
    ConfigInfo info = new ConfigInfo();
    info.showJobsPanel = cfg.getBoolean("showJobsPanel", true);
    info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true);
    info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true);
    info.sortJobsPanel = cfg.getEnum(JobsSorting.values(), "sortJobsPanel", JobsSorting.REPORTER);
    info.sortJobsDropDownPanel = cfg.getEnum(JobsSorting.values(), "sortJobsDropDownPanel", JobsSorting.REPORTER);
    return info;
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(db, key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(to);
            }
        }
        return new AuthResult(to, key, false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(db, key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
            }
            byIdCache.evict(to);
        }
        return new AuthResult(to, key, false);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
        }
        AuthResult link = link(to, who);
        byIdCache.evict(to);
        return link;
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        final boolean inheritChannel = cfg.getBoolean("httpd", "inheritChannel", false);
        c.setInheritChannel(inheritChannel);
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false));
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
private static Iterable<String> getLabels(ChangeData input, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : input.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && input.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#method_after
private static Iterable<String> getLabels(ChangeData cd, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : cd.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && cd.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#end_block

#method_before
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getAuthor());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getAuthor());
}
#end_block

#method_before
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getCommitter());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getCommitter());
}
#end_block

#method_before
private static String getTopic(ChangeData input) throws OrmException {
    Change c = input.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#method_after
private static String getTopic(ChangeData cd) throws OrmException {
    Change c = cd.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#end_block

#method_before
public Builder<I, T> stored() {
    this.stored = true;
    return this;
}
#method_after
public Builder<T> stored() {
    this.stored = true;
    return this;
}
#end_block

#method_before
public FieldDef<I, T> build(Getter<I, T> getter) {
    return new FieldDef<I, T>(name, type, stored) {

        @Override
        public T get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return false;
        }
    };
}
#method_after
public <I> FieldDef<I, T> build(Getter<I, T> getter) {
    return build((in, a) -> getter.get(in));
}
#end_block

#method_before
public FieldDef<I, T> build(Getter<I, T> getter) {
    return new FieldDef<I, T>(name, type, stored) {

        @Override
        public T get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return false;
        }
    };
}
#method_after
public <I> FieldDef<I, T> build(GetterWithArgs<I, T> getter) {
    return new FieldDef<>(name, type, stored, false, getter);
}
#end_block

#method_before
public FieldDef<I, Iterable<T>> buildRepeatable(Getter<I, Iterable<T>> getter) {
    return new FieldDef<I, Iterable<T>>(name, type, stored) {

        @Override
        public Iterable<T> get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return true;
        }
    };
}
#method_after
public <I> FieldDef<I, Iterable<T>> buildRepeatable(Getter<I, Iterable<T>> getter) {
    return buildRepeatable((in, a) -> getter.get(in));
}
#end_block

#method_before
public FieldDef<I, Iterable<T>> buildRepeatable(Getter<I, Iterable<T>> getter) {
    return new FieldDef<I, Iterable<T>>(name, type, stored) {

        @Override
        public Iterable<T> get(I input, FillArgs args) throws OrmException {
            return getter.get(input, args);
        }

        @Override
        public boolean isRepeatable() {
            return true;
        }
    };
}
#method_after
public <I> FieldDef<I, Iterable<T>> buildRepeatable(GetterWithArgs<I, Iterable<T>> getter) {
    return new FieldDef<>(name, type, stored, true, getter);
}
#end_block

#method_before
private static String checkName(String name) {
    CharMatcher m = CharMatcher.anyOf("abcdefghijklmnopqrstuvwxyz0123456789_");
    checkArgument(m.matchesAllOf(name), "illegal field name: %s", name);
    return name;
}
#method_after
private static String checkName(String name) {
    CharMatcher m = CharMatcher.anyOf("abcdefghijklmnopqrstuvwxyz0123456789_");
    checkArgument(name != null && m.matchesAllOf(name), "illegal field name: %s", name);
    return name;
}
#end_block

#method_before
public final String getName() {
    return name;
}
#method_after
public String getName() {
    return name;
}
#end_block

#method_before
public final FieldType<?> getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return type;
}
#end_block

#method_before
public final boolean isStored() {
    return stored;
}
#method_after
public boolean isStored() {
    return stored;
}
#end_block

#method_before
@Test
public void byDefault() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    RevCommit commit2 = repo.parseBody(repo.commit().message("foosubject").create());
    Change change2 = insert(repo, newChangeForCommit(repo, commit2));
    RevCommit commit3 = repo.parseBody(repo.commit().add("Foo.java", "foo contents").create());
    Change change3 = insert(repo, newChangeForCommit(repo, commit3));
    ChangeInserter ins4 = newChange(repo);
    Change change4 = insert(repo, ins4);
    ReviewInput ri4 = new ReviewInput();
    ri4.message = "toplevel";
    ri4.labels = ImmutableMap.<String, Short>of("Code-Review", (short) 1);
    gApi.changes().id(change4.getId().get()).current().review(ri4);
    ChangeInserter ins5 = newChangeWithTopic(repo, "feature5");
    Change change5 = insert(repo, ins5);
    Change change6 = insert(repo, newChangeForBranch(repo, "branch6"));
    // This query will also get change2 as the id of commit2 starts with '1'.
    assertQuery(change1.getId().get(), change2, change1);
    assertQuery(ChangeTriplet.format(change1), change1);
    assertQuery("foosubject", change2);
    assertQuery("Foo.java", change3);
    assertQuery("Code-Review+1", change4);
    assertQuery("toplevel", change4);
    assertQuery("feature5", change5);
    assertQuery("branch6", change6);
    assertQuery("refs/heads/branch6", change6);
    Change[] expected = new Change[] { change6, change5, change4, change3, change2, change1 };
    assertQuery("user@example.com", expected);
    assertQuery("repo", expected);
}
#method_after
@Test
public void byDefault() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    RevCommit commit2 = repo.parseBody(repo.commit().message("foosubject").create());
    Change change2 = insert(repo, newChangeForCommit(repo, commit2));
    RevCommit commit3 = repo.parseBody(repo.commit().add("Foo.java", "foo contents").create());
    Change change3 = insert(repo, newChangeForCommit(repo, commit3));
    ChangeInserter ins4 = newChange(repo);
    Change change4 = insert(repo, ins4);
    ReviewInput ri4 = new ReviewInput();
    ri4.message = "toplevel";
    ri4.labels = ImmutableMap.<String, Short>of("Code-Review", (short) 1);
    gApi.changes().id(change4.getId().get()).current().review(ri4);
    ChangeInserter ins5 = newChangeWithTopic(repo, "feature5");
    Change change5 = insert(repo, ins5);
    Change change6 = insert(repo, newChangeForBranch(repo, "branch6"));
    assertQuery(change1.getId().get(), change1);
    assertQuery(ChangeTriplet.format(change1), change1);
    assertQuery("foosubject", change2);
    assertQuery("Foo.java", change3);
    assertQuery("Code-Review+1", change4);
    assertQuery("toplevel", change4);
    assertQuery("feature5", change5);
    assertQuery("branch6", change6);
    assertQuery("refs/heads/branch6", change6);
    Change[] expected = new Change[] { change6, change5, change4, change3, change2, change1 };
    assertQuery("user@example.com", expected);
    assertQuery("repo", expected);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (PAT_LEGACY_ID.matcher(query).matches()) {
            try {
                predicates.add(commit(query));
            } catch (IllegalArgumentException e) {
            // Skip.
            }
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
public ChangeJson create(ListChangesOption... options) {
    return create(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#method_after
public ChangeJson create(ListChangesOption first, ListChangesOption... rest) {
    return create(Sets.immutableEnumSet(first, rest));
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<AccountExternalId> extIds = new ArrayList<>(2);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                    extUser.setHashedPassword(HashedPassword.fromPassword(httpPassword).encode());
                }
                extIds.add(extUser);
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    extIds.add(extMailto);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<AccountExternalId> extIds = new ArrayList<>(2);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(HashedPassword.fromPassword(httpPassword).encode());
                }
                extIds.add(extUser);
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    extIds.add(extMailto);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ArrayList<AccountExternalId> l = new ArrayList<>();
    for (AccountExternalId id : db.accountExternalIds().all()) {
        String pw = id.getPassword();
        if (pw != null) {
            HashedPassword hpw = HashedPassword.fromPassword(pw);
            id.setHashedPassword(hpw.encode());
        }
        l.add(id);
    }
    db.accountExternalIds().upsert(l);
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    List<AccountExternalId> newIds = db.accountExternalIds().all().toList();
    for (AccountExternalId id : newIds) {
        if (!id.isScheme(AccountExternalId.SCHEME_USERNAME)) {
            continue;
        }
        String password = id.getPassword();
        if (password != null) {
            HashedPassword hashed = HashedPassword.fromPassword(password);
            id.setPassword(hashed.encode());
        }
    }
    db.accountExternalIds().upsert(newIds);
}
#end_block

#method_before
public void setPassword(String p) {
    password = p;
}
#method_after
public void setPassword(String hashed) {
    password = hashed;
}
#end_block

#method_before
@Test
public void encodeOneLine() throws Exception {
    String password = "secret";
    HashedPassword hpw = HashedPassword.fromPassword(password);
    assertThat(hpw.encode()).doesNotContain("\n");
}
#method_after
@Test
public void encodeOneLine() throws Exception {
    String password = "secret";
    HashedPassword hashed = HashedPassword.fromPassword(password);
    assertThat(hashed.encode()).doesNotContain("\n");
    assertThat(hashed.encode()).doesNotContain("\r");
}
#end_block

#method_before
@Test
public void encodeDecode() throws Exception {
    String password = "secret";
    HashedPassword hpw = HashedPassword.fromPassword(password);
    HashedPassword roundtrip = HashedPassword.decode(hpw.encode());
    assertThat(hpw.encode()).isEqualTo(roundtrip.encode());
}
#method_after
@Test
public void encodeDecode() throws Exception {
    String password = "secret";
    HashedPassword hashed = HashedPassword.fromPassword(password);
    HashedPassword roundtrip = HashedPassword.decode(hashed.encode());
    assertThat(hashed.encode()).isEqualTo(roundtrip.encode());
    assertThat(roundtrip.checkPassword(password)).isTrue();
    assertThat(roundtrip.checkPassword("not the password")).isFalse();
}
#end_block

#method_before
@Test
public void lengthLimit() throws Exception {
    String pw = Strings.repeat("1", 70);
    assertThat(HashedPassword.fromPassword(pw).encode().length()).isLessThan(255);
}
#method_after
@Test
public void lengthLimit() throws Exception {
    String password = Strings.repeat("1", 72);
    // make sure it fits in varchar(255).
    assertThat(HashedPassword.fromPassword(password).encode().length()).isLessThan(255);
}
#end_block

#method_before
@Test
public void basicFunctionality() throws Exception {
    String password = "secret";
    HashedPassword hpw = HashedPassword.fromPassword(password);
    assertThat(hpw.checkPassword("false")).isFalse();
    assertThat(hpw.checkPassword(password)).isTrue();
}
#method_after
@Test
public void basicFunctionality() throws Exception {
    String password = "secret";
    HashedPassword hashed = HashedPassword.fromPassword(password);
    assertThat(hashed.checkPassword("false")).isFalse();
    assertThat(hashed.checkPassword(password)).isTrue();
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
        extUser.setHashedPassword(HashedPassword.fromPassword(input.httpPassword).encode());
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(HashedPassword.fromPassword(input.httpPassword).encode());
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (Strings.isNullOrEmpty(req.getUsername()) || Strings.isNullOrEmpty(req.getPassword())) {
        throw new MissingCredentialsException();
    }
    String username;
    if (authConfig.isUserNameToLowerCase()) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null) {
        throw new UnknownUserException();
    } else if (!who.getAccount().isActive()) {
        throw new UserNotAllowedException("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
    }
    who.checkPassword(req.getPassword(), username);
    return new AuthUser(AuthUser.UUID.create(username), username);
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (Strings.isNullOrEmpty(req.getUsername()) || Strings.isNullOrEmpty(req.getPassword())) {
        throw new MissingCredentialsException();
    }
    String username;
    if (authConfig.isUserNameToLowerCase()) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null) {
        throw new UnknownUserException();
    } else if (!who.getAccount().isActive()) {
        throw new UserNotAllowedException("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
    }
    if (!who.checkPassword(req.getPassword(), username)) {
        throw new InvalidCredentialsException();
    }
    return new AuthUser(AuthUser.UUID.create(username), username);
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (who.checkPassword(password, who.getUserName())) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (who.checkPassword(password, username)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (who.checkPassword(password, who.getUserName())) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private boolean failAuthentication(Response rsp, String username) throws IOException {
    log.warn("Authentication failed for {}: password does not match the one" + " stored in Gerrit", username);
    rsp.sendError(SC_UNAUTHORIZED);
    return false;
}
#method_after
private boolean failAuthentication(Response rsp, String username) throws IOException {
    log.warn("Authentication failed for {}: password does not match the one stored in Gerrit", username);
    rsp.sendError(SC_UNAUTHORIZED);
    return false;
}
#end_block

#method_before
public boolean checkPassword(String password, String username) {
    if (password == null) {
        return false;
    }
    for (AccountExternalId id : getExternalIds()) {
        if (id.isScheme(AccountExternalId.SCHEME_USERNAME) && username.equals(id.getSchemeRest())) {
            String hashedStr = id.getHashedPassword();
            if (!hashedStr.isEmpty()) {
                return HashedPassword.decode(hashedStr).checkPassword(password);
            }
            String want = id.getPassword();
            if (!want.isEmpty()) {
                byte[] wantBytes = Strings.toByteArray(want);
                byte[] gotBytes = Strings.toByteArray(password);
                return Arrays.areEqual(wantBytes, gotBytes);
            }
        }
    }
    return false;
}
#method_after
public boolean checkPassword(String password, String username) {
    if (password == null) {
        return false;
    }
    for (AccountExternalId id : getExternalIds()) {
        // Only process the "username:$USER" entry, which is unique.
        if (!id.isScheme(AccountExternalId.SCHEME_USERNAME) || !username.equals(id.getSchemeRest())) {
            continue;
        }
        String hashedStr = id.getPassword();
        if (!Strings.isNullOrEmpty(hashedStr)) {
            try {
                return HashedPassword.decode(hashedStr).checkPassword(password);
            } catch (DecoderException e) {
                logger.error(String.format("DecoderException for user %s: %s ", username, e.getMessage()));
                return false;
            }
        }
    }
    return false;
}
#end_block

#method_before
public static HashedPassword decode(String encoded) {
    String[] fields = encoded.split(":");
    Preconditions.checkState(fields.length == 2);
    return new HashedPassword(codec.decodeBase64(fields[1]), codec.decodeBase64(fields[0]));
}
#method_after
public static HashedPassword decode(String encoded) throws DecoderException {
    if (!encoded.startsWith(ALGORITHM_PREFIX)) {
        throw new DecoderException("unrecognized algorithm");
    }
    String[] fields = encoded.split(":");
    if (fields.length != 4) {
        throw new DecoderException("want 4 fields");
    }
    Integer cost = Ints.tryParse(fields[1]);
    if (cost == null) {
        throw new DecoderException("cost parse failed");
    }
    if (!(cost >= 4 && cost < 32)) {
        throw new DecoderException("cost should be 4..31 inclusive, got " + cost);
    }
    byte[] salt = codec.decode(fields[2]);
    if (salt.length != 16) {
        throw new DecoderException("salt should be 16 bytes, got " + salt.length);
    }
    return new HashedPassword(codec.decode(fields[3]), salt, cost);
}
#end_block

#method_before
private static byte[] hashPassword(String password, byte[] salt) {
    byte[] pwBytes = password.getBytes(StandardCharsets.UTF_8);
    final int cost = 10;
    return BCrypt.generate(pwBytes, salt, cost);
}
#method_after
private static byte[] hashPassword(String password, byte[] salt, int cost) {
    byte[] pwBytes = password.getBytes(StandardCharsets.UTF_8);
    return BCrypt.generate(pwBytes, salt, cost);
}
#end_block

#method_before
public static HashedPassword fromPassword(String password) {
    byte[] salt = newSalt();
    return new HashedPassword(hashPassword(password, salt), salt);
}
#method_after
public static HashedPassword fromPassword(String password) {
    byte[] salt = newSalt();
    return new HashedPassword(hashPassword(password, salt, DEFAULT_COST), salt, DEFAULT_COST);
}
#end_block

#method_before
public String encode() {
    // NOSUBMIT - how to get rid of the line endings?
    return codec.encodeBase64String(salt).replace("\r\n", "") + ":" + codec.encodeBase64String(hashed).replace("\r\n", "");
}
#method_after
public String encode() {
    return ALGORITHM_PREFIX + cost + ":" + codec.encode(salt) + ":" + codec.encode(hashed);
}
#end_block

#method_before
public boolean checkPassword(String password) {
    return Arrays.areEqual(hashPassword(password, salt), hashed);
}
#method_after
public boolean checkPassword(String password) {
    // Constant-time comparison, because we're paranoid.
    return Arrays.areEqual(hashPassword(password, salt, cost), hashed);
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        extUser.setHashedPassword(HashedPassword.fromPassword(httpPass).encode());
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                checkArgument(g != null, "group not found: %s", n);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = null;
        if (SshMode.useSsh()) {
            sshKey = genSshKey();
            authorizedKeys.addKey(id, publicKey(sshKey, email));
            sshKeyCache.evict(username);
        }
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        indexer.index(id);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(HashedPassword.fromPassword(httpPass).encode());
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                checkArgument(g != null, "group not found: %s", n);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = null;
        if (SshMode.useSsh()) {
            sshKey = genSshKey();
            authorizedKeys.addKey(id, publicKey(sshKey, email));
            sshKeyCache.evict(username);
        }
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        indexer.index(id);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.isGitBasicAuth()) {
        if (authConfig.getAuthType() == OAUTH) {
            authFilter = ProjectOAuthFilter.class;
        } else {
            authFilter = ProjectBasicAuthFilter.class;
        }
    } else {
        // NOSUBMIT - what should this look like now without ProjectDigest filter?
        authFilter = ProjectBasicAuthFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filter("/a/*").through(authFilter);
}
#method_after
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.getAuthType() == OAUTH) {
        authFilter = ProjectOAuthFilter.class;
    } else {
        authFilter = ProjectBasicAuthFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(authFilter);
    filter("/a/*").through(authFilter);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    id.setHashedPassword(HashedPassword.fromPassword(newPassword).encode());
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(HashedPassword.fromPassword(newPassword).encode());
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    Writer w = new BufferedWriter(new OutputStreamWriter(res.getOutputStream(), UTF_8));
    Reader r = new BufferedReader(new InputStreamReader(req.getInputStream(), UTF_8));
    LfsRequest request = gson.fromJson(r, LfsRequest.class);
    String path = req.getPathInfo();
    res.setContentType(CONTENTTYPE_VND_GIT_LFS_JSON);
    LargeFileRepository repo = null;
    try {
        repo = getLargeFileRepository(request, path, new AuthInfo(Charset.forName(MoreObjects.firstNonNull(req.getCharacterEncoding(), Charsets.UTF_8.name())), req.getHeader(HDR_AUTHORIZATION)));
        if (repo == null) {
            // $NON-NLS-1$
            throw new LfsException("unexpected error");
        }
        res.setStatus(SC_OK);
        TransferHandler handler = TransferHandler.forOperation(request.operation, repo, request.objects);
        gson.toJson(handler.process(), w);
    } catch (LfsValidationError e) {
        sendError(res, w, SC_UNPROCESSABLE_ENTITY, e.getMessage());
    } catch (LfsRepositoryNotFound e) {
        sendError(res, w, SC_NOT_FOUND, e.getMessage());
    } catch (LfsRepositoryReadOnly e) {
        sendError(res, w, SC_FORBIDDEN, e.getMessage());
    } catch (LfsRateLimitExceeded e) {
        sendError(res, w, SC_RATE_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsBandwidthLimitExceeded e) {
        sendError(res, w, SC_BANDWIDTH_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsInsufficientStorage e) {
        sendError(res, w, SC_INSUFFICIENT_STORAGE, e.getMessage());
    } catch (LfsUnavailable e) {
        sendError(res, w, SC_SERVICE_UNAVAILABLE, e.getMessage());
    } catch (LfsUnauthorized e) {
        sendError(res, w, SC_UNAUTHORIZED, e.getMessage());
    } catch (LfsException e) {
        sendError(res, w, SC_INTERNAL_SERVER_ERROR, e.getMessage());
    } finally {
        w.flush();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    Writer w = new BufferedWriter(new OutputStreamWriter(res.getOutputStream(), UTF_8));
    Reader r = new BufferedReader(new InputStreamReader(req.getInputStream(), UTF_8));
    LfsRequest request = gson.fromJson(r, LfsRequest.class);
    String path = req.getPathInfo();
    res.setContentType(CONTENTTYPE_VND_GIT_LFS_JSON);
    LargeFileRepository repo = null;
    try {
        repo = getLargeFileRepository(request, path, req.getHeader(HDR_AUTHORIZATION));
        if (repo == null) {
            // $NON-NLS-1$
            throw new LfsException("unexpected error");
        }
        res.setStatus(SC_OK);
        TransferHandler handler = TransferHandler.forOperation(request.operation, repo, request.objects);
        gson.toJson(handler.process(), w);
    } catch (LfsValidationError e) {
        sendError(res, w, SC_UNPROCESSABLE_ENTITY, e.getMessage());
    } catch (LfsRepositoryNotFound e) {
        sendError(res, w, SC_NOT_FOUND, e.getMessage());
    } catch (LfsRepositoryReadOnly e) {
        sendError(res, w, SC_FORBIDDEN, e.getMessage());
    } catch (LfsRateLimitExceeded e) {
        sendError(res, w, SC_RATE_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsBandwidthLimitExceeded e) {
        sendError(res, w, SC_BANDWIDTH_LIMIT_EXCEEDED, e.getMessage());
    } catch (LfsInsufficientStorage e) {
        sendError(res, w, SC_INSUFFICIENT_STORAGE, e.getMessage());
    } catch (LfsUnavailable e) {
        sendError(res, w, SC_SERVICE_UNAVAILABLE, e.getMessage());
    } catch (LfsUnauthorized e) {
        sendError(res, w, SC_UNAUTHORIZED, e.getMessage());
    } catch (LfsException e) {
        sendError(res, w, SC_INTERNAL_SERVER_ERROR, e.getMessage());
    } finally {
        w.flush();
    }
}
#end_block

#method_before
CurrentUser getUser(String auth, Charset cs) {
    if (Strings.isNullOrEmpty(auth)) {
        return anonymous.get();
    }
    if (auth.startsWith(BASIC_AUTH_PREFIX)) {
        String usernamePassword;
        usernamePassword = new String(Base64.decodeBase64(auth.substring(BASIC_AUTH_PREFIX.length())), cs);
        String username;
        int splitPos = usernamePassword.indexOf(':');
        if (splitPos < 0) {
            username = usernamePassword;
        } else {
            username = usernamePassword.substring(0, splitPos);
        }
        AccountState acc = accounts.getByUsername(username);
        if (acc != null) {
            return userFactory.create(acc);
        }
    }
    return anonymous.get();
}
#method_after
CurrentUser getUser(String auth) {
    if (!Strings.isNullOrEmpty(auth) && auth.startsWith(BASIC_AUTH_PREFIX) && authCfg.isGitBasicAuth()) {
        return user.get();
    }
    return anonymous.get();
}
#end_block

#method_before
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path, LfsGerritProtocolServlet.AuthInfo auth) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        throw new LfsException("no repository at " + pathInfo);
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    authorizeUser(userProvider.getUser(auth.auth, auth.cs), state, request.getOperation());
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals(UPLOAD) && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig().getForProject(project);
    // No config means we default to "not enabled".
    if (config != null && config.isEnabled()) {
        // For uploads, check object sizes against limit if configured
        if (request.getOperation().equals(UPLOAD)) {
            if (config.isReadOnly()) {
                throw new LfsRepositoryReadOnly(project.get());
            }
            long maxObjectSize = config.getMaxObjectSize();
            if (maxObjectSize > 0) {
                for (LfsObject object : request.getObjects()) {
                    if (object.getSize() > maxObjectSize) {
                        throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                    }
                }
            }
        }
        return repoResolver.get(project, config.getBackend());
    }
    throw new LfsUnavailable(project.get());
}
#method_after
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path, String auth) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        throw new LfsException("no repository at " + pathInfo);
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    authorizeUser(userProvider.getUser(auth), state, request.getOperation());
    if (request.getOperation().equals(UPLOAD) && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig().getForProject(project);
    // No config means we default to "not enabled".
    if (config != null && config.isEnabled()) {
        // For uploads, check object sizes against limit if configured
        if (request.getOperation().equals(UPLOAD)) {
            if (config.isReadOnly()) {
                throw new LfsRepositoryReadOnly(project.get());
            }
            long maxObjectSize = config.getMaxObjectSize();
            if (maxObjectSize > 0) {
                for (LfsObject object : request.getObjects()) {
                    if (object.getSize() > maxObjectSize) {
                        throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                    }
                }
            }
        }
        return repoResolver.get(project, config.getBackend());
    }
    throw new LfsUnavailable(project.get());
}
#end_block

#method_before
private void authorizeUser(CurrentUser user, ProjectState state, String operation) throws LfsUnauthorized {
    ProjectControl control = state.controlFor(user);
    switch(operation) {
        case "download":
            if (control.isReadable()) {
                return;
            }
            break;
        case UPLOAD:
            if (Capable.OK == control.canPushToAtLeastOneRef()) {
                return;
            }
            break;
    }
    throw new LfsUnauthorized(String.format("User %s is not authorized to perform %s operation", user.getUserName(), operation));
}
#method_after
private void authorizeUser(CurrentUser user, ProjectState state, String operation) throws LfsUnauthorized {
    ProjectControl control = state.controlFor(user);
    if ((operation.equals(DOWNLOAD) && !control.isReadable()) || (operation.equals(UPLOAD) && Capable.OK != control.canPushToAtLeastOneRef())) {
        throw new LfsUnauthorized(String.format("User %s is not authorized to perform %s operation", Strings.isNullOrEmpty(user.getUserName()) ? "anonymous" : user.getUserName(), operation.toLowerCase()));
    }
}
#end_block

#method_before
@Test
public void invalidRange() throws Exception {
    String changeId = createChange().getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    sender.clear();
    ReviewInput review = new ReviewInput();
    ReviewInput.CommentInput comment = new ReviewInput.CommentInput();
    comment.range = new Range();
    comment.range.startLine = 1;
    comment.range.endLine = 1;
    comment.range.startCharacter = -1;
    comment.range.endCharacter = 0;
    comment.path = PushOneCommit.FILE_NAME;
    comment.side = Side.REVISION;
    comment.message = "comment 1";
    review.comments = new HashMap<>();
    review.comments.put(comment.path, Lists.newArrayList(comment));
    exception.expect(BadRequestException.class);
    gApi.changes().id(changeId).current().review(review);
}
#method_after
@Test
public void invalidRange() throws Exception {
    String changeId = createChange().getChangeId();
    ReviewInput review = new ReviewInput();
    ReviewInput.CommentInput comment = new ReviewInput.CommentInput();
    comment.range = new Range();
    comment.range.startLine = 1;
    comment.range.endLine = 1;
    comment.range.startCharacter = -1;
    comment.range.endCharacter = 0;
    comment.path = PushOneCommit.FILE_NAME;
    comment.side = Side.REVISION;
    comment.message = "comment 1";
    review.comments = ImmutableMap.of(comment.path, Lists.newArrayList(comment));
    exception.expect(BadRequestException.class);
    gApi.changes().id(changeId).current().review(review);
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n" + "  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#method_after
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, OrmException {
    ensureCommentsAreAddable(revision, commentsPerPath);
    for (Map.Entry<String, List<T>> e : commentsPerPath.entrySet()) {
        for (T comment : e.getValue()) {
            ensureRangeIsValid(e.getKey(), comment.range);
        }
    }
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws OrmException, BadRequestException {
    Set<String> revisionFilePaths = getAffectedFilePaths(revision);
    for (Map.Entry<String, List<T>> entry : commentsPerPath.entrySet()) {
        String path = entry.getKey();
        PatchSet.Id patchSetId = revision.getChange().currentPatchSetId();
        ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId);
        List<T> comments = entry.getValue();
        for (T comment : comments) {
            ensureLineIsNonNegative(comment.line, path);
            ensureCommentNotOnMagicFilesOfAutoMerge(path, comment);
            ensureRangeIsValid(path, comment.range);
        }
    }
}
#end_block

#method_before
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    cleanUpComments(in);
    checkComments(revision, in);
}
#method_after
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#end_block

#method_before
private void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required " + "for the suggested fix of the robot comment on %s", commentPath));
    }
}
#method_after
private void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given " + "for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsSet(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given " + "for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private void ensureRangeIsSet(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsValid(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not" + " valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#method_after
private void ensureRangeIsValid(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.isGitBasicAuth()) {
        if (authConfig.getAuthType() == OAUTH) {
            authFilter = ProjectOAuthFilter.class;
        } else {
            authFilter = ProjectBasicAuthFilter.class;
        }
    } else {
        authFilter = ProjectDigestFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(ProjectBasicAuthFilter.class);
    filter("/a/*").through(authFilter);
}
#method_after
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.isGitBasicAuth()) {
        if (authConfig.getAuthType() == OAUTH) {
            authFilter = ProjectOAuthFilter.class;
        } else {
            authFilter = ProjectBasicAuthFilter.class;
        }
    } else {
        authFilter = ProjectDigestFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(authFilter);
    filter("/a/*").through(authFilter);
}
#end_block

#method_before
void start() {
    try {
        oracle.requestSuggestions(request, this);
    } catch (Exception e) {
        query = null;
    }
}
#method_after
void start() {
    if (request.getQuery() == null) {
        request.setQuery("");
    }
    oracle.requestSuggestions(request, this);
}
#end_block

#method_before
@Test
public void userReceivesPlaintextEmail() throws Exception {
    // Set user preference to receive only plaintext content
    GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults();
    i.emailFormat = EmailFormat.PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that user has received only plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNull();
    // Reset user preference
    setApiUser(admin);
    i.emailFormat = EmailFormat.HTML_PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
}
#method_after
@Test
public void userReceivesPlaintextEmail() throws Exception {
    // Set user preference to receive only plaintext content
    GeneralPreferencesInfo i = new GeneralPreferencesInfo();
    i.emailFormat = EmailFormat.PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that admin has received only plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNull();
    // Reset user preference
    setApiUser(admin);
    i.emailFormat = EmailFormat.HTML_PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
}
#end_block

#method_before
@Test
public void userReceivesHtmlAndPlaintextEmail() throws Exception {
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that user has received only plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNotNull();
}
#method_after
@Test
public void userReceivesHtmlAndPlaintextEmail() throws Exception {
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that admin has received both HTML and plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNotNull();
}
#end_block

#method_before
@Override
public void run() {
    addReviewers(reviewers, ps);
}
#method_after
@Override
public void run() {
    addReviewers(reviewers, change);
}
#end_block

#method_before
private void addReviewers(Set<Account> reviewers, PatchSet ps) {
    try {
        ReviewInput in = new ReviewInput();
        in.reviewers = new ArrayList<>(reviewers.size());
        for (Account account : reviewers) {
            AddReviewerInput addReviewerInput = new AddReviewerInput();
            addReviewerInput.reviewer = account.getId().toString();
            in.reviewers.add(addReviewerInput);
        }
        gApi.changes().id(ps.getId().getParentKey().get()).revision(ps.getPatchSetId()).review(in);
    } catch (RestApiException e) {
        log.error("Couldn't add reviewers to the change", e);
    }
}
#method_after
private void addReviewers(Set<Account> reviewers, Change change) {
    try {
        // TODO(davido): Switch back to using changes API again,
        // when it supports batch mode for adding reviewers
        ReviewInput in = new ReviewInput();
        in.reviewers = new ArrayList<>(reviewers.size());
        for (Account account : reviewers) {
            AddReviewerInput addReviewerInput = new AddReviewerInput();
            addReviewerInput.reviewer = account.getId().toString();
            in.reviewers.add(addReviewerInput);
        }
        gApi.changes().id(change.getId().get()).current().review(in);
    } catch (RestApiException e) {
        log.error("Couldn't add reviewers to the change", e);
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    try {
        Change.Status status = rsrc.getChange().getStatus();
        boolean visible = isActionAllowed(status) && rsrc.getControl().canDelete(db.get(), status);
        return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(visible);
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    try {
        Change.Status status = rsrc.getChange().getStatus();
        ChangeControl changeControl = rsrc.getControl();
        boolean visible = isActionAllowed(changeControl, status) && changeControl.canDelete(db.get(), status);
        return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(visible);
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private boolean isActionAllowed(Change.Status status) {
    return status != Status.DRAFT || allowDrafts;
}
#method_after
private boolean isActionAllowed(ChangeControl changeControl, Status status) {
    return status != Status.DRAFT || allowDrafts || changeControl.isAdmin();
}
#end_block

#method_before
@Test
public void deleteDraftChangeWithNonDraftPatchSet() throws Exception {
    assume().that(isAllowDrafts()).isTrue();
    PushOneCommit.Result changeResult = createDraftChange();
    Change.Id id = changeResult.getChange().getId();
    setDraftStatusOfPatchSetsOfChange(id, false);
    String changeId = changeResult.getChangeId();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Cannot delete draft change 1: patch set 1 is not" + " a draft");
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteDraftChangeWithNonDraftPatchSet() throws Exception {
    assume().that(isAllowDrafts()).isTrue();
    PushOneCommit.Result changeResult = createDraftChange();
    Change.Id id = changeResult.getChange().getId();
    setDraftStatusOfPatchSetsOfChange(id, false);
    String changeId = changeResult.getChangeId();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Cannot delete draft change %s: patch set 1 is not a draft", id));
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
private void markChangeAsDraft(Change.Id id) throws OrmException, RestApiException {
    Change change = db.changes().get(id);
    change.setStatus(Change.Status.DRAFT);
    db.changes().update(Collections.singletonList(change));
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(ChangeStatus.DRAFT);
}
#method_after
private void markChangeAsDraft(Change.Id id) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new MarkChangeAsDraftUpdateOp());
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(ChangeStatus.DRAFT);
}
#end_block

#method_before
private void setDraftStatusOfPatchSetsOfChange(Change.Id id, boolean draftStatus) throws OrmException {
    Set<PatchSet> patchSets = ImmutableSet.copyOf(db.patchSets().byChange(id));
    patchSets.forEach(patchSet -> patchSet.setDraft(draftStatus));
    db.patchSets().update(patchSets);
}
#method_after
private void setDraftStatusOfPatchSetsOfChange(Change.Id id, boolean draftStatus) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new DraftStatusOfPatchSetsUpdateOp(draftStatus));
        batchUpdate.execute();
    }
    Boolean expectedDraftStatus = draftStatus ? Boolean.TRUE : null;
    List<Boolean> patchSetDraftStatuses = getPatchSetDraftStatuses(id);
    patchSetDraftStatuses.forEach(status -> assertThat(status).isEqualTo(expectedDraftStatus));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    ImmutableList<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
private void ensureDeletable(ChangeContext ctx, Change.Id id, List<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, OrmException, AuthException {
    Change.Status status = ctx.getChange().getStatus();
    if (!ctx.getControl().canDelete(ctx.getDb(), status)) {
        throw new AuthException("Not permitted to delete this change");
    }
    if (status == Change.Status.DRAFT) {
        if (!allowDrafts) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
        for (PatchSet ps : patchSets) {
            if (!ps.isDraft()) {
                throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
            }
        }
    }
}
#method_after
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, OrmException, AuthException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    if (!ctx.getControl().canDelete(ctx.getDb(), status)) {
        throw new AuthException("Deleting change " + id + " is not permitted");
    }
    if (status == Change.Status.DRAFT) {
        if (!allowDrafts && !ctx.getControl().isAdmin()) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
        for (PatchSet ps : patchSets) {
            if (!ps.isDraft()) {
                throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
            }
        }
    }
}
#end_block

#method_before
private void cleanUpReferences(ChangeContext ctx, Change.Id id, List<PatchSet> patchSets) throws OrmException, NoSuchChangeException {
    for (PatchSet ps : patchSets) {
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(ctx.getChange().getProject(), id);
}
#method_after
private void cleanUpReferences(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws OrmException, NoSuchChangeException {
    for (PatchSet ps : patchSets) {
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(ctx.getChange().getProject(), id);
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isOwner() || isAdmin();
        case MERGED:
            return isAdmin();
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean isAdmin() {
    return getUser().isIdentifiedUser() && getUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean isAdmin() {
    return getUser().getCapabilities().canAdministrateServer();
}
#end_block

#method_before
@Test
public void deleteNewChangeOfAnotherUserAsAdmin() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    changeResult.assertOkStatus();
    String changeId = changeResult.getChangeId();
    gApi.changes().id(changeId).delete();
    assertThat(query(changeId)).isEmpty();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeOfAnotherUserAsAdmin() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    changeResult.assertOkStatus();
    String changeId = changeResult.getChangeId();
    setApiUser(admin);
    gApi.changes().id(changeId).delete();
    assertThat(query(changeId)).isEmpty();
}
#end_block

#method_before
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    merge(changeResult);
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("Not permitted to delete this change");
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage(String.format("Deleting merged change %s is not allowed", id));
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
public void testVerifyAgainstDifferentOperation() throws Exception {
    String token = auth.generateToken("o", zeroId(), 1);
    assertThat(auth.verifyAgainstToken(token, "p", zeroId())).isFalse();
}
#method_after
@Test
public void testVerifyAgainstDifferentOperation() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken, "p", zeroId())).isFalse();
}
#end_block

#method_before
@Test
public void testVerifyAgainstDifferentObjectId() throws Exception {
    String token = auth.generateToken("o", zeroId(), 1);
    assertThat(auth.verifyAgainstToken(token, "o", LongObjectId.fromString("123456789012345678901234567890" + "123456789012345678901234567890" + "1234"))).isFalse();
}
#method_after
@Test
public void testVerifyAgainstDifferentObjectId() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken, "o", LongObjectId.fromString("123456789012345678901234567890" + "123456789012345678901234567890" + "1234"))).isFalse();
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getExternalIds(new GerritCallback<JsArray<ExternalIdInfo>>() {

        @Override
        public void onSuccess(JsArray<ExternalIdInfo> results) {
            display();
            identites.display(results);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getExternalIds(new GerritCallback<JsArray<ExternalIdInfo>>() {

        @Override
        public void onSuccess(JsArray<ExternalIdInfo> results) {
            identites.display(results);
            display();
        }
    });
}
#end_block

#method_before
void display(final JsArray<ExternalIdInfo> results) {
    List<ExternalIdInfo> idList = Natives.asList(results);
    Collections.sort(idList, new Comparator<ExternalIdInfo>() {

        @Override
        public int compare(ExternalIdInfo a, ExternalIdInfo b) {
            return emailOf(a).compareTo(emailOf(b));
        }

        private String emailOf(final ExternalIdInfo a) {
            return a.emailAddress() != null ? a.emailAddress() : "";
        }
    });
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final ExternalIdInfo k : idList) {
        addOneId(k);
    }
    updateDeleteButton();
}
#method_after
void display(final JsArray<ExternalIdInfo> results) {
    List<ExternalIdInfo> idList = Natives.asList(results);
    Collections.sort(idList);
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final ExternalIdInfo k : idList) {
        addOneId(k);
    }
    updateDeleteButton();
}
#end_block

#method_before
void addOneId(final ExternalIdInfo k) {
    if (ExternalIdScheme.isScheme(k.identity(), ExternalIdScheme.SCHEME_USERNAME)) {
        // Don't display the username as an identity here.
        return;
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    if (k.canDelete()) {
        final CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
    } else {
        table.setText(row, 1, "");
    }
    if (k.trusted()) {
        table.setText(row, 2, "");
    } else {
        table.setText(row, 2, Util.C.untrustedProvider());
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().identityUntrustedExternalId());
    }
    if (k.emailAddress() != null && k.emailAddress().length() > 0) {
        table.setText(row, 3, k.emailAddress());
    } else {
        table.setText(row, 3, "");
    }
    table.setText(row, 4, describe(k));
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void addOneId(final ExternalIdInfo k) {
    if (k.isUsername()) {
        // Don't display the username as an identity here.
        return;
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    if (k.canDelete()) {
        final CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
    } else {
        table.setText(row, 1, "");
    }
    if (k.isTrusted()) {
        table.setText(row, 2, "");
    } else {
        table.setText(row, 2, Util.C.untrustedProvider());
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().identityUntrustedExternalId());
    }
    if (k.emailAddress() != null && k.emailAddress().length() > 0) {
        table.setText(row, 3, k.emailAddress());
    } else {
        table.setText(row, 3, "");
    }
    table.setText(row, 4, k.describe());
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
private boolean isEnabledForRef(ProjectState project, String refName) {
    String[] refPatterns = pluginCfgFactory.getFromProjectConfigWithInheritance(project, pluginName).getStringList("branch");
    if (refPatterns.length == 0) {
        // Default behavior: no branch-specific config
        return true;
    }
    for (String refPattern : refPatterns) {
        if (RefConfigSection.isValid(refPattern) && match(refName, refPattern)) {
            return true;
        }
    }
    // Branch-specific behavior: ref is not matching
    return false;
}
#method_after
public boolean isEnabledForRef(Project.NameKey projectName, String refName, String validatorOp) {
    PluginConfig conf = configFactory.get(projectName);
    return conf != null && isValidConfig(conf, projectName) && (activeForRef(conf, refName)) && (!hasCriteria(conf, "skipGroup") || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf));
}
#end_block

#method_before
private boolean match(String refName, String refPattern) {
    return RefPatternMatcher.getMatcher(refPattern).match(refName, null);
}
#method_after
private static boolean match(String value, String pattern) {
    return RefPatternMatcher.getMatcher(pattern).match(value, null);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    post(ACCOUNT_KIND, "index").to(Index.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    delete(ACCOUNT_KIND, "external_ids").to(DeleteAccountExternalIds.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    post(ACCOUNT_KIND, "index").to(Index.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    get(ACCOUNT_KIND, "external.ids").to(GetExternalIds.class);
    post(ACCOUNT_KIND, "external.ids:delete").to(DeleteExternalIds.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side));
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#method_after
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.debug(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (Strings.isNullOrEmpty(path)) {
        // TODO Consider the following:
        // Generating an edit with a put (instead of a post) isn't mentioned in
        // the documentation of the REST API. We should consider whether we want
        // to keep this hidden 'feature', make it public via the documentation,
        // or remove it.
        createEdit(resource);
    } else {
        putEdit.apply(resource.getControl(), path, input.content);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (Strings.isNullOrEmpty(path)) {
        // TODO(aliceks): Consider the following:
        // Generating an edit with a put (instead of a post) isn't mentioned in
        // the documentation of the REST API. We should consider whether we want
        // to keep this hidden 'feature', make it public via the documentation,
        // or remove it.
        createEdit(resource);
    } else {
        putEdit.apply(resource.getControl(), path, input.content);
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    // TODO Consider the following:
    // This check is strange. If there was already a change edit, this method
    // wouldn't be called because DeleteContent would take over. We should
    // consider to remove the positive case.
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        Project.NameKey project = rsrc.getProject();
        try (Repository repository = repoManager.openRepository(project)) {
            editModifier.deleteFile(repository, rsrc.getControl(), path);
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    // TODO(aliceks): Consider the following:
    // This check is strange. If there was already a change edit, this method
    // wouldn't be called because DeleteContent would take over. We should
    // consider to remove the positive case.
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        Project.NameKey project = rsrc.getProject();
        try (Repository repository = repoManager.openRepository(project)) {
            editModifier.deleteFile(repository, rsrc.getControl(), path);
        }
    }
    return Response.none();
}
#end_block

#method_before
private boolean isRestoreFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.restorePath);
}
#method_after
private static boolean isRestoreFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.restorePath);
}
#end_block

#method_before
private boolean isRenameFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.oldPath) && !Strings.isNullOrEmpty(input.newPath);
}
#method_after
private static boolean isRenameFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.oldPath) && !Strings.isNullOrEmpty(input.newPath);
}
#end_block

#method_before
private static RevCommit lookupCommit(Repository repository, PatchSet patchSet) throws IOException {
    ObjectId patchSetCommitId = getPatchSetCommitId(patchSet);
    return lookup(repository, patchSetCommitId);
}
#method_after
private static RevCommit lookupCommit(Repository repository, PatchSet patchSet) throws IOException {
    ObjectId patchSetCommitId = getPatchSetCommitId(patchSet);
    try (RevWalk revWalk = new RevWalk(repository)) {
        return revWalk.parseCommit(patchSetCommitId);
    }
}
#end_block

#method_before
private void createEditReference(Repository repository, ChangeControl changeControl, PatchSet basePatchSet, ObjectId newEditCommit, Timestamp timestamp) throws IOException, OrmException {
    Change change = changeControl.getChange();
    String editRefName = getEditRefName(change, basePatchSet);
    updateReference(repository, editRefName, ObjectId.zeroId(), newEditCommit, timestamp);
    reindex(change);
}
#method_after
private void createEditReference(Repository repository, ChangeControl changeControl, PatchSet basePatchSet, ObjectId newEditCommit, Timestamp timestamp) throws IOException, OrmException {
    Change change = changeControl.getChange();
    String editRefName = getEditRefName(change, basePatchSet);
    updateReference(repository, editRefName, ObjectId.zeroId(), newEditCommit, timestamp);
    indexer.index(reviewDb.get(), change);
}
#end_block

#method_before
public ObjectId getMetaId() {
    return metaId;
}
#method_after
@Nullable
public ObjectId getMetaId() {
    return metaId;
}
#end_block

#method_before
@Test
public void refStateToByteArray() {
    assertThat(new String(RefState.toByteArray(P1, "refs/heads/foo", ObjectId.fromString(SHA1)), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + SHA1);
    assertThat(new String(RefState.toByteArray(P1, "refs/heads/foo", null), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + ObjectId.zeroId().name());
}
#method_after
@Test
public void refStateToByteArray() {
    assertThat(new String(RefState.create("refs/heads/foo", ObjectId.fromString(SHA1)).toByteArray(P1), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + SHA1);
    assertThat(new String(RefState.create("refs/heads/foo", (ObjectId) null).toByteArray(P1), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + ObjectId.zeroId().name());
}
#end_block

#method_before
@Test
public void parsePatterns() {
    assertInvalidPattern(null);
    assertInvalidPattern("");
    assertInvalidPattern("project:");
    assertInvalidPattern("project:refs/heads/foo");
    assertInvalidPattern("project:refs/he*ds/bar");
    assertInvalidPattern("project:refs/(he)*ds/bar");
    assertInvalidPattern("project:invalidrefname");
    ListMultimap<Project.NameKey, RefStatePattern> r = StalenessChecker.parsePatterns(byteArrays(P1 + ":refs/heads/*", P2 + ":refs/heads/foo/*/bar", P2 + ":refs/heads/foo/*-baz/*/quux"));
    assertThat(r.keySet()).containsExactly(P1, P2);
    RefStatePattern p = r.get(P1).get(0);
    assertThat(p.prefix()).isEqualTo("refs/heads/");
    assertThat(p.pattern().pattern()).isEqualTo("^\\Qrefs/heads/\\E.*\\Q\\E$");
    assertThat(p.match("refs/heads/foo")).isTrue();
    assertThat(p.match("xrefs/heads/foo")).isFalse();
    assertThat(p.match("refs/tags/foo")).isFalse();
    p = r.get(P2).get(0);
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.pattern().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q/bar\\E$");
    assertThat(p.match("refs/heads/foo//bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/baz")).isFalse();
    p = r.get(P2).get(1);
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.pattern().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q-baz/\\E.*\\Q/quux\\E$");
    assertThat(p.match("refs/heads/foo/-baz//quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y-baz/x/y/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/y")).isFalse();
}
#method_after
@Test
public void parsePatterns() {
    assertInvalidPattern(null);
    assertInvalidPattern("");
    assertInvalidPattern("project:");
    assertInvalidPattern("project:refs/heads/foo");
    assertInvalidPattern("project:refs/he*ds/bar");
    assertInvalidPattern("project:refs/(he)*ds/bar");
    assertInvalidPattern("project:invalidrefname");
    ListMultimap<Project.NameKey, RefStatePattern> r = StalenessChecker.parsePatterns(byteArrays(P1 + ":refs/heads/*", P2 + ":refs/heads/foo/*/bar", P2 + ":refs/heads/foo/*-baz/*/quux"));
    assertThat(r.keySet()).containsExactly(P1, P2);
    RefStatePattern p = r.get(P1).get(0);
    assertThat(p.pattern()).isEqualTo("refs/heads/*");
    assertThat(p.prefix()).isEqualTo("refs/heads/");
    assertThat(p.regex().pattern()).isEqualTo("^\\Qrefs/heads/\\E.*\\Q\\E$");
    assertThat(p.match("refs/heads/foo")).isTrue();
    assertThat(p.match("xrefs/heads/foo")).isFalse();
    assertThat(p.match("refs/tags/foo")).isFalse();
    p = r.get(P2).get(0);
    assertThat(p.pattern()).isEqualTo("refs/heads/foo/*/bar");
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.regex().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q/bar\\E$");
    assertThat(p.match("refs/heads/foo//bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/baz")).isFalse();
    p = r.get(P2).get(1);
    assertThat(p.pattern()).isEqualTo("refs/heads/foo/*-baz/*/quux");
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.regex().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q-baz/\\E.*\\Q/quux\\E$");
    assertThat(p.match("refs/heads/foo/-baz//quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y-baz/x/y/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/y")).isFalse();
}
#end_block

#method_before
@Test
public void refStatePatternToByteArray() {
    assertThat(new String(RefStatePattern.toByteArray(P1, "refs/*"), UTF_8)).isEqualTo(P1 + ":refs/*");
}
#method_after
@Test
public void refStatePatternToByteArray() {
    assertThat(new String(RefStatePattern.create("refs/*").toByteArray(P1), UTF_8)).isEqualTo(P1 + ":refs/*");
}
#end_block

#method_before
@VisibleForTesting
static SetMultimap<Project.NameKey, RefState> parseStates(Iterable<byte[]> states) {
    RefState.check(states != null, null);
    SetMultimap<Project.NameKey, RefState> result = HashMultimap.create();
    for (byte[] b : states) {
        RefState.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefState.check(parts.size() == 3 && !parts.get(0).isEmpty() && !parts.get(1).isEmpty(), s);
        result.put(new Project.NameKey(parts.get(0)), RefState.create(parts.get(1), parts.get(2)));
    }
    return result;
}
#method_after
public static SetMultimap<Project.NameKey, RefState> parseStates(Iterable<byte[]> states) {
    RefState.check(states != null, null);
    SetMultimap<Project.NameKey, RefState> result = HashMultimap.create();
    for (byte[] b : states) {
        RefState.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefState.check(parts.size() == 3 && !parts.get(0).isEmpty() && !parts.get(1).isEmpty(), s);
        result.put(new Project.NameKey(parts.get(0)), RefState.create(parts.get(1), parts.get(2)));
    }
    return result;
}
#end_block

#method_before
@VisibleForTesting
static ListMultimap<Project.NameKey, RefStatePattern> parsePatterns(Iterable<byte[]> patterns) {
    RefStatePattern.check(patterns != null, null);
    ListMultimap<Project.NameKey, RefStatePattern> result = ArrayListMultimap.create();
    for (byte[] b : patterns) {
        RefStatePattern.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefStatePattern.check(parts.size() == 2, s);
        result.put(new Project.NameKey(parts.get(0)), RefStatePattern.create(parts.get(1)));
    }
    return result;
}
#method_after
public static ListMultimap<Project.NameKey, RefStatePattern> parsePatterns(Iterable<byte[]> patterns) {
    RefStatePattern.check(patterns != null, null);
    ListMultimap<Project.NameKey, RefStatePattern> result = ArrayListMultimap.create();
    for (byte[] b : patterns) {
        RefStatePattern.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefStatePattern.check(parts.size() == 2, s);
        result.put(new Project.NameKey(parts.get(0)), RefStatePattern.create(parts.get(1)));
    }
    return result;
}
#end_block

#method_before
static RefState create(String ref, String sha) {
    return new AutoValue_StalenessChecker_RefState(ref, ObjectId.fromString(sha));
}
#method_after
static RefState create(String ref, @Nullable ObjectId id) {
    return new AutoValue_StalenessChecker_RefState(ref, firstNonNull(id, ObjectId.zeroId()));
}
#end_block

#method_before
static byte[] toByteArray(Project.NameKey project, String name, @Nullable ObjectId id) {
    byte[] a = (project.toString() + ':' + name + ':').getBytes(UTF_8);
    byte[] b = new byte[a.length + Constants.OBJECT_ID_STRING_LENGTH];
    System.arraycopy(a, 0, b, 0, a.length);
    firstNonNull(id, ObjectId.zeroId()).copyTo(b, a.length);
    return b;
}
#method_after
byte[] toByteArray(Project.NameKey project) {
    byte[] a = (project.toString() + ':' + ref() + ':').getBytes(UTF_8);
    byte[] b = new byte[a.length + Constants.OBJECT_ID_STRING_LENGTH];
    System.arraycopy(a, 0, b, 0, a.length);
    id().copyTo(b, a.length);
    return b;
}
#end_block

#method_before
static RefStatePattern create(String pat) {
    int star = pat.indexOf('*');
    check(star > 0 && pat.charAt(star - 1) == '/', pat);
    String prefix = pat.substring(0, star);
    check(Repository.isValidRefName(pat.replace('*', 'x')), pat);
    // Quote everything except the '*'s, which become ".*".
    String regex = StreamSupport.stream(Splitter.on('*').split(pat).spliterator(), false).map(Pattern::quote).collect(joining(".*", "^", "$"));
    return new AutoValue_StalenessChecker_RefStatePattern(prefix, Pattern.compile(regex));
}
#method_after
static RefStatePattern create(String pattern) {
    int star = pattern.indexOf('*');
    check(star > 0 && pattern.charAt(star - 1) == '/', pattern);
    String prefix = pattern.substring(0, star);
    check(Repository.isValidRefName(pattern.replace('*', 'x')), pattern);
    // Quote everything except the '*'s, which become ".*".
    String regex = StreamSupport.stream(Splitter.on('*').split(pattern).spliterator(), false).map(Pattern::quote).collect(joining(".*", "^", "$"));
    return new AutoValue_StalenessChecker_RefStatePattern(pattern, prefix, Pattern.compile(regex));
}
#end_block

#method_before
static byte[] toByteArray(Project.NameKey project, String pat) {
    return (project.toString() + ':' + pat).getBytes(UTF_8);
}
#method_after
byte[] toByteArray(Project.NameKey project) {
    return (project.toString() + ':' + pattern()).getBytes(UTF_8);
}
#end_block

#method_before
boolean match(String refName) {
    return pattern().matcher(refName).find();
}
#method_after
boolean match(String refName) {
    return regex().matcher(refName).find();
}
#end_block

#method_before
public ObjectId createNewTreeAndGetId(Repository repository) throws IOException {
    DirCache newTree = createNewTree(repository);
    return writeAndGetId(newTree, repository);
}
#method_after
public ObjectId createNewTreeAndGetId(Repository repository) throws IOException {
    DirCache newTree = createNewTree(repository);
    return writeAndGetId(repository, newTree);
}
#end_block

#method_before
private DirCache createNewTree(Repository repository) throws IOException {
    DirCache newTree = readBaseTree(repository);
    List<DirCacheEditor.PathEdit> pathEdits = getDesiredPathEdits(repository);
    applyPathEdits(newTree, pathEdits);
    return newTree;
}
#method_after
private DirCache createNewTree(Repository repository) throws IOException {
    DirCache newTree = readBaseTree(repository);
    List<DirCacheEditor.PathEdit> pathEdits = getPathEdits(repository);
    applyPathEdits(newTree, pathEdits);
    return newTree;
}
#end_block

#method_before
private void applyPathEdits(DirCache tree, List<DirCacheEditor.PathEdit> pathEdits) {
    DirCacheEditor dirCacheEditor = tree.editor();
    pathEdits.forEach(dirCacheEditor::add);
    dirCacheEditor.finish();
}
#method_after
private static void applyPathEdits(DirCache tree, List<DirCacheEditor.PathEdit> pathEdits) {
    DirCacheEditor dirCacheEditor = tree.editor();
    pathEdits.forEach(dirCacheEditor::add);
    dirCacheEditor.finish();
}
#end_block

#method_before
private ObjectId writeAndGetId(DirCache tree, Repository repository) throws IOException {
    try (ObjectInserter objectInserter = repository.newObjectInserter()) {
        ObjectId treeId = tree.writeTree(objectInserter);
        objectInserter.flush();
        return treeId;
    }
}
#method_after
private static ObjectId writeAndGetId(Repository repository, DirCache tree) throws IOException {
    try (ObjectInserter objectInserter = repository.newObjectInserter()) {
        ObjectId treeId = tree.writeTree(objectInserter);
        objectInserter.flush();
        return treeId;
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    externalIdCache.update(id);
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    externalIdCache.onUpdate(id);
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
public Account.Id lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? accountState.getAccount().getId() : null;
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#method_after
public Optional<Account.Id> lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.empty();
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
        externalIdCache.update(extId);
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
        externalIdCache.onUpdate(extId);
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
        externalIdCache.update(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
        externalIdCache.onUpdate(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        externalIdCache.remove(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        externalIdCache.onRemove(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
            externalIdCache.remove(to, filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
            externalIdCache.onRemove(to, filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            externalIdCache.remove(extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            externalIdCache.onRemove(extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(GpgKey rsrc, Input input) throws ResourceConflictException, PGPException, OrmException, IOException {
    PGPPublicKey key = rsrc.getKeyRing().getPublicKey();
    AccountExternalId.Key extIdKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GPGKEY, BaseEncoding.base16().encode(key.getFingerprint()));
    db.get().accountExternalIds().deleteKeys(Collections.singleton(extIdKey));
    externalIdCache.remove(rsrc.getUser().getAccountId(), extIdKey);
    accountCache.evict(rsrc.getUser().getAccountId());
    try (PublicKeyStore store = storeProvider.get()) {
        store.remove(rsrc.getKeyRing().getPublicKey().getFingerprint());
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        cb.setMessage("Delete public key " + keyIdToString(key.getKeyID()));
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NO_CHANGE:
            case FAST_FORWARD:
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new ResourceConflictException("Failed to delete public key: " + saveResult);
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GpgKey rsrc, Input input) throws ResourceConflictException, PGPException, OrmException, IOException {
    PGPPublicKey key = rsrc.getKeyRing().getPublicKey();
    AccountExternalId.Key extIdKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GPGKEY, BaseEncoding.base16().encode(key.getFingerprint()));
    db.get().accountExternalIds().deleteKeys(Collections.singleton(extIdKey));
    externalIdCache.onRemove(rsrc.getUser().getAccountId(), extIdKey);
    accountCache.evict(rsrc.getUser().getAccountId());
    try (PublicKeyStore store = storeProvider.get()) {
        store.remove(rsrc.getKeyRing().getPublicKey().getFingerprint());
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        cb.setMessage("Delete public key " + keyIdToString(key.getKeyID()));
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NO_CHANGE:
            case FAST_FORWARD:
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new ResourceConflictException("Failed to delete public key: " + saveResult);
        }
    }
    return Response.none();
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, ListKey.class, new TypeLiteral<Multimap<Account.Id, AccountExternalId>>() {
            }).maximumWeight(1).loader(Loader.class);
            bind(ExternalIdCacheImpl.class);
            bind(ExternalIdCache.class).to(ExternalIdCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, AllKey.class, new TypeLiteral<ImmutableSetMultimap<Account.Id, AccountExternalId>>() {
            }).maximumWeight(1).loader(Loader.class);
            bind(ExternalIdCacheImpl.class);
            bind(ExternalIdCache.class).to(ExternalIdCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public void onCreate(Iterable<AccountExternalId> extIds) {
    lock.lock();
    try {
        Multimap<Account.Id, AccountExternalId> n = MultimapBuilder.hashKeys().arrayListValues().build(extIdsByAccount.get(ListKey.ALL));
        for (AccountExternalId extId : extIds) {
            n.put(extId.getAccountId(), extId);
        }
        extIdsByAccount.put(ListKey.ALL, ImmutableMultimap.copyOf(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list avaliable projects", e);
    } finally {
        lock.unlock();
    }
}
#method_after
@Override
public void onCreate(Iterable<AccountExternalId> extIds) {
    lock.lock();
    try {
        Multimap<Account.Id, AccountExternalId> n = MultimapBuilder.hashKeys().arrayListValues().build(extIdsByAccount.get(AllKey.ALL));
        for (AccountExternalId extId : extIds) {
            n.put(extId.getAccountId(), extId);
        }
        extIdsByAccount.put(AllKey.ALL, ImmutableSetMultimap.copyOf(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list external IDs", e);
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
@Override
public Collection<AccountExternalId> byAccount(Account.Id accountId) {
    try {
        return ImmutableSet.copyOf(extIdsByAccount.get(ListKey.ALL).get(accountId));
    } catch (ExecutionException e) {
        log.warn("Cannot list external ids", e);
        return Collections.emptySet();
    }
}
#method_after
@Override
public Collection<AccountExternalId> byAccount(Account.Id accountId) {
    try {
        return extIdsByAccount.get(AllKey.ALL).get(accountId);
    } catch (ExecutionException e) {
        log.warn("Cannot list external ids", e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
@Override
public Multimap<Account.Id, AccountExternalId> load(ListKey key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Multimap<Account.Id, AccountExternalId> extIdsByAccount = MultimapBuilder.hashKeys().arrayListValues().build();
        for (AccountExternalId extId : db.accountExternalIds().all()) {
            extIdsByAccount.put(extId.getAccountId(), extId);
        }
        return ImmutableMultimap.copyOf(extIdsByAccount);
    }
}
#method_after
@Override
public ImmutableSetMultimap<Account.Id, AccountExternalId> load(AllKey key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Multimap<Account.Id, AccountExternalId> extIdsByAccount = MultimapBuilder.hashKeys().arrayListValues().build();
        for (AccountExternalId extId : db.accountExternalIds().all()) {
            extIdsByAccount.put(extId.getAccountId(), extId);
        }
        return ImmutableSetMultimap.copyOf(extIdsByAccount);
    }
}
#end_block

#method_before
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        Collection<AccountExternalId> adminExtIds = getExternalIds(admin);
        db.accountExternalIds().delete(adminExtIds);
        externalIdCache.remove(adminExtIds);
        Collection<AccountExternalId> userExtIds = getExternalIds(user);
        db.accountExternalIds().delete(userExtIds);
        externalIdCache.remove(userExtIds);
        db.accountExternalIds().insert(savedExternalIds);
        externalIdCache.onCreate(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#method_after
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        Collection<AccountExternalId> adminExtIds = getExternalIds(admin);
        db.accountExternalIds().delete(adminExtIds);
        externalIdCache.onRemove(adminExtIds);
        Collection<AccountExternalId> userExtIds = getExternalIds(user);
        db.accountExternalIds().delete(userExtIds);
        externalIdCache.onRemove(userExtIds);
        db.accountExternalIds().insert(savedExternalIds);
        externalIdCache.onCreate(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#end_block

#method_before
@Override
public Set<AccountExternalId.Key> call() throws OrmException, IOException {
    final Map<AccountExternalId.Key, AccountExternalId> have = have();
    List<AccountExternalId> toDelete = new ArrayList<>();
    for (AccountExternalId.Key k : keys) {
        final AccountExternalId id = have.get(k);
        if (id != null && id.canDelete()) {
            toDelete.add(id);
        }
    }
    if (!toDelete.isEmpty()) {
        db.accountExternalIds().delete(toDelete);
        externalIdCache.remove(toDelete);
        accountCache.evict(user.getAccountId());
        for (AccountExternalId e : toDelete) {
            byEmailCache.evict(e.getEmailAddress());
        }
    }
    return toKeySet(toDelete);
}
#method_after
@Override
public Set<AccountExternalId.Key> call() throws OrmException, IOException {
    final Map<AccountExternalId.Key, AccountExternalId> have = have();
    List<AccountExternalId> toDelete = new ArrayList<>();
    for (AccountExternalId.Key k : keys) {
        final AccountExternalId id = have.get(k);
        if (id != null && id.canDelete()) {
            toDelete.add(id);
        }
    }
    if (!toDelete.isEmpty()) {
        db.accountExternalIds().delete(toDelete);
        externalIdCache.onRemove(toDelete);
        accountCache.evict(user.getAccountId());
        for (AccountExternalId e : toDelete) {
            byEmailCache.evict(e.getEmailAddress());
        }
    }
    return toKeySet(toDelete);
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.remove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.onRemove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
            externalIdCache.onCreate(newExtIds);
        }
        Iterable<AccountExternalId.Key> extIdKeysToRemove = Iterables.transform(toRemove, fp -> toExtIdKey(fp.get()));
        db.get().accountExternalIds().deleteKeys(extIdKeysToRemove);
        externalIdCache.remove(rsrc.getUser().getAccountId(), extIdKeysToRemove);
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#method_after
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
            externalIdCache.onCreate(newExtIds);
        }
        List<AccountExternalId.Key> extIdKeysToRemove = toRemove.stream().map(fp -> toExtIdKey(fp.get())).collect(toList());
        db.get().accountExternalIds().deleteKeys(extIdKeysToRemove);
        externalIdCache.onRemove(rsrc.getUser().getAccountId(), extIdKeysToRemove);
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#end_block

#method_before
@Test
public void noExternalIds() throws Exception {
    Collection<AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId());
    db.accountExternalIds().delete(extIds);
    externalIdCache.remove(extIds);
    reloadUser();
    TestKey key = validKeyWithSecondUserId();
    PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check" + " http://test/#/settings/web-identities");
    checker = checkerFactory.create().setStore(store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users");
    AccountExternalId extId = new AccountExternalId(user.getAccountId(), toExtIdKey(key.getPublicKey()));
    db.accountExternalIds().insert(Collections.singleton(extId));
    externalIdCache.onCreate(extId);
    reloadUser();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user");
}
#method_after
@Test
public void noExternalIds() throws Exception {
    Collection<AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId());
    db.accountExternalIds().delete(extIds);
    externalIdCache.onRemove(extIds);
    reloadUser();
    TestKey key = validKeyWithSecondUserId();
    PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check" + " http://test/#/settings/web-identities");
    checker = checkerFactory.create().setStore(store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users");
    AccountExternalId extId = new AccountExternalId(user.getAccountId(), toExtIdKey(key.getPublicKey()));
    db.accountExternalIds().insert(Collections.singleton(extId));
    externalIdCache.onCreate(extId);
    reloadUser();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user");
}
#end_block

#method_before
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException {
    final Collection<AccountExternalId> old = old();
    if (!old.isEmpty()) {
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, newUsername);
        try {
            final AccountExternalId id = new AccountExternalId(user.getAccountId(), key);
            for (AccountExternalId i : old) {
                if (i.getPassword() != null) {
                    id.setPassword(i.getPassword());
                }
            }
            db.accountExternalIds().insert(Collections.singleton(id));
            externalIdCache.onCreate(id);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            AccountExternalId other = db.accountExternalIds().get(key);
            if (other != null && other.getAccountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    db.accountExternalIds().delete(old);
    externalIdCache.remove(old);
    for (AccountExternalId i : old) {
        sshKeyCache.evict(i.getSchemeRest());
        accountCache.evictByUsername(i.getSchemeRest());
    }
    accountCache.evict(user.getAccountId());
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException {
    final Collection<AccountExternalId> old = old();
    if (!old.isEmpty()) {
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, newUsername);
        try {
            final AccountExternalId id = new AccountExternalId(user.getAccountId(), key);
            for (AccountExternalId i : old) {
                if (i.getPassword() != null) {
                    id.setPassword(i.getPassword());
                }
            }
            db.accountExternalIds().insert(Collections.singleton(id));
            externalIdCache.onCreate(id);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            AccountExternalId other = db.accountExternalIds().get(key);
            if (other != null && other.getAccountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    db.accountExternalIds().delete(old);
    externalIdCache.onRemove(old);
    for (AccountExternalId i : old) {
        sshKeyCache.evict(i.getSchemeRest());
        accountCache.evictByUsername(i.getSchemeRest());
    }
    accountCache.evict(user.getAccountId());
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#end_block

#method_before
public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) {
    if (key.isPresent()) {
        try {
            byte[] initVector = new byte[IV_LENGTH];
            rndm.nextBytes(initVector);
            Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
            return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8))));
        } catch (GeneralSecurityException e) {
            log.error("Token generation failed with error", e);
        }
    }
    return "not:required";
}
#method_after
public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) {
    try {
        byte[] initVector = new byte[IV_LENGTH];
        rndm.nextBytes(initVector);
        Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
        return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8))));
    } catch (GeneralSecurityException e) {
        log.error("Token generation failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (!key.isPresent()) {
        return true;
    }
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#method_after
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#end_block

#method_before
private boolean onTime(String dateTime, String operation, String id) {
    DateTime deadline = ISODateTimeFormat.dateTimeParser().parseDateTime(dateTime);
    if (deadline.isBeforeNow()) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#method_after
boolean onTime(String dateTime, String operation, String id) {
    String now = DATE_TIME.print(now());
    if (now.compareTo(dateTime) > 0) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#end_block

#method_before
private String timeout(int expirationSeconds) {
    DateTime now = now();
    return ISODateTimeFormat.dateTime().print(now.plusSeconds(expirationSeconds));
}
#method_after
private String timeout(int expirationSeconds) {
    return DATE_TIME.print(now().plusSeconds(expirationSeconds));
}
#end_block

#method_before
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key.get(), params);
    return cipher;
}
#method_after
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key, params);
    return cipher;
}
#end_block

#method_before
private Optional<SecretKey> generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return Optional.of(generator.generateKey());
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
    }
    return Optional.absent();
}
#method_after
private SecretKey generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return generator.generateKey();
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public List<WebLinkInfo> getFileHistoryLinks(String project, String revision, String file) {
    return filterLinks(fileHistoryLinks, webLink -> webLink.getFileHistoryWebLink(project, revision, file));
}
#method_after
public List<WebLinkInfoCommon> getFileHistoryLinks(String project, String revision, String file) {
    return FluentIterable.from(fileHistoryLinks).transform(webLink -> {
        WebLinkInfo info = webLink.getFileHistoryWebLink(project, revision, file);
        if (info == null) {
            return null;
        }
        WebLinkInfoCommon commonInfo = new WebLinkInfoCommon();
        commonInfo.name = info.name;
        commonInfo.imageUrl = info.imageUrl;
        commonInfo.url = info.url;
        commonInfo.target = info.target;
        return commonInfo;
    }).filter(INVALID_WEBLINK_COMMON).toList();
}
#end_block

#method_before
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinksCommon(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#method_after
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinks(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            if (!r.getOldId().equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId()));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                }
            }
        };
    }
    return bin;
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            if (!r.getOldId().equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId()));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        LimitedByteArrayOutputStream bos = new LimitedByteArrayOutputStream(maxBundleSize, 1024);
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                } catch (LimitExceededException e) {
                    throw new NotImplementedException("The bundle is too big to " + "generate at the server");
                }
            }
        };
    }
    return bin;
}
#end_block

#method_before
@Test
public void testTGZ() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1.getChangeId(), "tgz");
    assertThat(request.getContentType()).isEqualTo("application/x-gzip");
    File tempfile = File.createTempFile("test", null);
    request.writeTo(new FileOutputStream(tempfile));
    InputStream is = new GZIPInputStream(new FileInputStream(tempfile));
    final List<String> untaredFiles = new LinkedList<>();
    try (TarArchiveInputStream debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {
            untaredFiles.add(entry.getName());
        }
    }
    assertThat(untaredFiles).containsExactly(name("project-name") + ".git");
}
#method_after
@Test
public void testTGZ() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1.getChangeId(), "tgz");
    assertThat(request.getContentType()).isEqualTo("application/x-gzip");
    File tempfile = File.createTempFile("test", null);
    request.writeTo(new FileOutputStream(tempfile));
    InputStream is = new GZIPInputStream(new FileInputStream(tempfile));
    final List<String> untarredFiles = new LinkedList<>();
    try (TarArchiveInputStream debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {
            untarredFiles.add(entry.getName());
        }
    }
    assertThat(untarredFiles).containsExactly(name("project-name") + ".git");
}
#end_block

#method_before
public void process(MailMessage message) throws OrmException {
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error("Mail: Message " + message.id() + " is missing required metadata, have " + metadata + ". Will delete message.");
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error("Mail: Address " + metadata.author + " could not be matched to a unique account. It was matched to " + accounts + ". Will delete message.");
        return;
    }
    Account.Id account = accounts.iterator().next();
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        ChangeData cd = queryProvider.get().setLimit(1).byKey(Change.Key.parse(metadata.changeId)).get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Mail: Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(Collectors.toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.error("Mail: Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            // TODO(hiesel) Is this correct?
            throw new OrmException(e);
        }
    }
}
#method_after
public void process(MailMessage message) throws OrmException {
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error("Mail: Message " + message.id() + " is missing required metadata, have " + metadata + ". Will delete message.");
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error("Mail: Address " + metadata.author + " could not be matched to a unique account. It was matched to " + accounts + ". Will delete message.");
        return;
    }
    Account.Id account = accounts.iterator().next();
    if (!reviewDb.get().accounts().get(account).isActive()) {
        log.warn("Mail: Account " + account + " is inactive. Will delete message.");
        return;
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        ChangeData cd = queryProvider.get().setLimit(1).byKey(Change.Key.parse(metadata.changeId)).get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Mail: Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(Collectors.toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.warn("Mail: Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            throw new OrmException(e);
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    ChangeMessage msg;
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        msg = ChangeMessagesUtil.newMessage(ctx, "Patch Set " + psId.get() + ":\n" + parsedComments.get(0).message, tag);
    } else {
        msg = ChangeMessagesUtil.newMessage(ctx, "Patch Set " + psId.get() + ":\n(" + parsedComments.size() + (parsedComments.size() > 1 ? " comments)" : " comment)"), tag);
    }
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg);
    List<Comment> comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = ps;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
        }
        commentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n" + numComments(parsedComments.size());
    }
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg);
    List<Comment> comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = ps;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#end_block

#method_before
protected void dispatchMailProcessor(List<MailMessage> messages, boolean async) {
    for (MailMessage m : messages) {
        if (async) {
            Callable task = () -> {
                try {
                    mailProcessor.process(m);
                    requestDeletion(m.id());
                } catch (OrmException e) {
                    log.error("Mail: Can't process message " + m.id() + " . Won't delete.", e);
                }
                return null;
            };
            workQueue.getDefaultQueue().submit(task);
        } else {
            // Synchronous processing is used only in tests.
            try {
                mailProcessor.process(m);
                requestDeletion(m.id());
            } catch (OrmException e) {
                log.error("Mail: Can't process messages. Won't delete.", e);
            }
        }
    }
}
#method_after
protected void dispatchMailProcessor(List<MailMessage> messages, boolean async) {
    for (MailMessage m : messages) {
        if (async) {
            Callable<?> task = () -> {
                try {
                    mailProcessor.process(m);
                    requestDeletion(m.id());
                } catch (OrmException e) {
                    log.error("Mail: Can't process message " + m.id() + " . Won't delete.", e);
                }
                return null;
            };
            workQueue.getDefaultQueue().submit(task);
        } else {
            // Synchronous processing is used only in tests.
            try {
                mailProcessor.process(m);
                requestDeletion(m.id());
            } catch (OrmException e) {
                log.error("Mail: Can't process messages. Won't delete.", e);
            }
        }
    }
}
#end_block

#method_before
public static <S extends Subject<S, E>, E> ListSubject<S, E> assertThat(List<E> list, Function<E, S> elementAssertThatFunction) {
    // The ListSubjectFactory always returns ListSubjects.
    return (ListSubject<S, E>) assertAbout(new ListSubjectFactory<>(elementAssertThatFunction)).that(list);
}
#method_after
@SuppressWarnings("unchecked")
public static <S extends Subject<S, E>, E> ListSubject<S, E> assertThat(List<E> list, Function<E, S> elementAssertThatFunction) {
    // -> Casting is appropriate.
    return (ListSubject<S, E>) assertAbout(new ListSubjectFactory<>(elementAssertThatFunction)).that(list);
}
#end_block

#method_before
public S element(int index) {
    checkArgument(index >= 0, "index(%s) must be >= 0", index);
    // The constructor only accepts lists.
    List<E> list = (List<E>) actual();
    isNotNull();
    if (index >= list.size()) {
        fail("has an element at index " + index);
    }
    return elementAssertThatFunction.apply(list.get(index));
}
#method_after
public S element(int index) {
    checkArgument(index >= 0, "index(%s) must be >= 0", index);
    // The constructor only accepts lists.
    // -> Casting is appropriate.
    @SuppressWarnings("unchecked")
    List<E> list = (List<E>) actual();
    isNotNull();
    if (index >= list.size()) {
        fail("has an element at index " + index);
    }
    return elementAssertThatFunction.apply(list.get(index));
}
#end_block

#method_before
@Override
public ListSubject<S, E> named(String s, Object... objects) {
    // This object is returned which is of type ListSubject.
    return (ListSubject<S, E>) super.named(s, objects);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListSubject<S, E> named(String s, Object... objects) {
    // -> Casting is appropriate.
    return (ListSubject<S, E>) super.named(s, objects);
}
#end_block

#method_before
@Override
public ListSubject<S, T> getSubject(FailureStrategy failureStrategy, Iterable<?> objects) {
    // The constructor of ListSubject only accepts lists.
    return new ListSubject<>(failureStrategy, (List<T>) objects, elementAssertThatFunction);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListSubject<S, T> getSubject(FailureStrategy failureStrategy, Iterable<?> objects) {
    // -> Casting is appropriate.
    return new ListSubject<>(failureStrategy, (List<T>) objects, elementAssertThatFunction);
}
#end_block

#method_before
private void ensureFixReplacementsAreAddable(String path, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(path, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureRangeIsSet(path, fixReplacementInfo.range);
        ensureReplacementStringIsSet(path, fixReplacementInfo.replacement);
    }
}
#method_after
private void ensureFixReplacementsAreAddable(String path, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(path, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureRangeIsSet(path, fixReplacementInfo.range);
        ensureRangeIsValid(path, fixReplacementInfo.range);
        ensureReplacementStringIsSet(path, fixReplacementInfo.replacement);
    }
}
#end_block

#method_before
private void ensureRangeIsSet(String path, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be indicated " + "for the replacement of the robot comment on %s", path));
    }
}
#method_after
private void ensureRangeIsSet(String path, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given " + "for the replacement of the robot comment on %s", path));
    }
}
#end_block

#method_before
private List<RobotComment> getNewRobotComments(ChangeContext ctx) throws OrmException {
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = createRobotComment(ctx, path, c);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    return toAdd;
}
#method_after
private List<RobotComment> getNewRobotComments(ChangeContext ctx) throws OrmException {
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = createRobotCommentFromInput(ctx, path, c);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    return toAdd;
}
#end_block

#method_before
private FixSuggestionInfo createFixSuggestionInfo(FixReplacementInfo... fixReplacementInfos) {
    FixSuggestionInfo newFixSuggestionInfo = new FixSuggestionInfo();
    newFixSuggestionInfo.fixId = "An ID which must be overridden.";
    newFixSuggestionInfo.description = "A description for a suggested fix.";
    newFixSuggestionInfo.replacements = Arrays.asList(fixReplacementInfos);
    return newFixSuggestionInfo;
}
#method_after
private FixSuggestionInfo createFixSuggestionInfo(FixReplacementInfo... fixReplacementInfos) {
    FixSuggestionInfo newFixSuggestionInfo = new FixSuggestionInfo();
    newFixSuggestionInfo.fixId = "An ID which must be overwritten.";
    newFixSuggestionInfo.description = "A description for a suggested fix.";
    newFixSuggestionInfo.replacements = Arrays.asList(fixReplacementInfos);
    return newFixSuggestionInfo;
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setFocus(true);
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setServeSuggestionsOnOracle(true);
    suggestBox.setFocus(true);
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
    suggestBox.setServeSuggestionsOnOracle(false);
}
#end_block

#method_before
private void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#method_after
void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        short labelMaxValue = LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasMaxPermittedValue() && ai.maxPermittedValue() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        short labelMaxValue = LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.permittedVotingRange() != null && ai.permittedVotingRange().max() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.empty(), true);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private boolean submittable(ChangeData cd) throws OrmException {
    List<SubmitRecord> records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).evaluate();
    for (SubmitRecord sr : records) {
        if (sr.status == SubmitRecord.Status.OK) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean submittable(ChangeData cd) throws OrmException {
    return SubmitRecord.findOkRecord(cd.submitRecords(SUBMIT_RULE_OPTIONS_STRICT)).isPresent();
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    return cd.submitRecords(SUBMIT_RULE_OPTIONS_LENIENT);
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, Collection<String>> permittedLabels = permittedLabels(ctl, cd);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            Integer maxPermittedValue = null;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (permittedLabels.containsKey(lt.getName())) {
                Collection<String> range = permittedLabels.get(lt.getName());
                for (String val : range) {
                    Integer v = parseRangeValue(val);
                    if (v != null && (maxPermittedValue == null || v > maxPermittedValue)) {
                        maxPermittedValue = v;
                    }
                }
            }
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, maxPermittedValue, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, Integer maxPermittedValue, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, maxPermittedValue, tag, date);
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, permittedVotingRange, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, Integer maxPermittedValue, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.maxPermittedValue = maxPermittedValue;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#method_after
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.permittedVotingRange = permittedVotingRange;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            e.addRef(ref);
            scheduleTask(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            e.addRef(ref);
            postEvent(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    scheduleTask(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    scheduleTask(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
private void postEvent(PushOne pushOp, String inputRef) {
    Set<String> refs = inputRef == null ? pushOp.getRefs() : ImmutableSet.of(inputRef);
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    for (String ref : refs) {
        ReplicationScheduledEvent event = new ReplicationScheduledEvent(project.get(), ref, targetNode);
        eventDispatcher.postEvent(new Branch.NameKey(project, ref), event);
    }
}
#method_after
private void postEvent(PushOne pushOp, String ref) {
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    ReplicationScheduledEvent event = new ReplicationScheduledEvent(project.get(), ref, targetNode);
    eventDispatcher.get().postEvent(new Branch.NameKey(project, ref), event);
}
#end_block

#method_before
private void postEvent(RefEvent event) {
    try (ReviewDb db = schema.open()) {
        dispatcher.postEvent(event, db);
    } catch (OrmException e) {
        log.error("Cannot post event", e);
    }
}
#method_after
private void postEvent(RefEvent event) {
    try {
        dispatcher.postEvent(event);
    } catch (OrmException e) {
        log.error("Cannot post event", e);
    }
}
#end_block

#method_before
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    ProcessBuilder proc = new ProcessBuilder("bazel", "build", label.fullName());
    return proc;
}
#method_after
@Override
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    ProcessBuilder proc = new ProcessBuilder("bazel", "build", label.fullName());
    return proc;
}
#end_block

#method_before
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName());
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    return proc;
}
#method_after
@Override
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName());
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    return proc;
}
#end_block

#method_before
public void build(Label label) throws IOException, BuildFailureException {
    ProcessBuilder proc = newBuildProcess(label);
    proc.directory(sourceRoot.toFile()).redirectErrorStream(true);
    log.info("building " + label.fullName());
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + proc.toString());
    }
    if (status != 0) {
        log.warn("build failed: " + new String(out));
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#method_after
public void build(Label label) throws IOException, BuildFailureException {
    ProcessBuilder proc = newBuildProcess(label);
    proc.directory(sourceRoot.toFile()).redirectErrorStream(true);
    log.info("building [" + name() + "] " + label.fullName());
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + proc.toString());
    }
    if (status != 0) {
        log.warn("build failed: " + new String(out));
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#end_block

#method_before
@Provides
@Singleton
BowerComponentsServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return new BowerComponentsServlet(cache, getPaths().builder);
}
#method_after
@Provides
@Singleton
BowerComponentsDevServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new BowerComponentsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Provides
@Singleton
FontsServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return new FontsServlet(cache, getPaths().builder);
}
#method_after
@Provides
@Singleton
FontsDevServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new FontsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String pkg = "gerrit-gwtui";
    String target = "ui_" + rule.select((HttpServletRequest) request);
    if (gwtuiRecompile || !uaInitialized.contains(target)) {
        String rule = "//" + pkg + ":" + target;
        // TODO(davido): instead of assuming specific Buck's internal
        // target directory for gwt_binary() artifacts, ask Buck for
        // the location of user agent permutation GWT zip, e. g.:
        // $ buck targets --show_output //gerrit-gwtui:ui_safari \
        // | awk '{print $2}'
        String child = String.format("%s/__gwt_binary_%s__", pkg, target);
        BuildSystem.Label label = new BuildSystem.Label(pkg, target + ".zip");
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(rule, (HttpServletResponse) res);
                return;
            }
            if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                lastTarget = target;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(target);
    }
    chain.doFilter(request, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String agent = rule.select((HttpServletRequest) request);
    if (unpackedWar != null && (gwtuiRecompile || !uaInitialized.contains(agent))) {
        Label label = builder.gwtZipLabel(agent);
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(label.toString(), (HttpServletResponse) res);
                return;
            }
            if (!agent.equals(lastAgent) || lastTime != zip.lastModified()) {
                lastAgent = agent;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(agent);
    }
    chain.doFilter(request, res);
}
#end_block

#method_before
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            Scanner scan = new java.util.Scanner(stream, "UTF-8").useDelimiter("\n");
            if (scan.hasNext()) {
                Path p = Paths.get(scan.next());
                if (!Files.exists(p)) {
                    throw new FileNotFoundException("source root not found: " + p);
                }
                return p;
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#method_after
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            try (Scanner scan = new Scanner(stream, UTF_8.name()).useDelimiter("\n")) {
                if (scan.hasNext()) {
                    Path p = Paths.get(scan.next());
                    if (!Files.exists(p)) {
                        throw new FileNotFoundException("source root not found: " + p);
                    }
                    return p;
                }
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#end_block

#method_before
@Override
public void build(Label label) throws IOException, BuildFailureException {
    log.info("buck build " + label);
    Properties properties = loadBuckProperties(targetPath(label));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true);
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + buck);
    }
    if (status != 0) {
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#method_after
@Override
public void build(Label label) throws IOException, BuildFailureException {
    log.info("buck build " + label.fullName());
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true);
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + buck);
    }
    if (status != 0) {
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#end_block

#method_before
private static Properties loadBuckProperties(Path gen) throws IOException {
    Properties properties = new Properties();
    Path p = gen.resolve(Paths.get("tools/buck/buck.properties"));
    try (InputStream in = Files.newInputStream(p)) {
        properties.load(in);
    } catch (NoSuchFileException e) {
    // Ignore; will be run from PATH, with a descriptive error if it fails.
    }
    return properties;
}
#method_after
private static Properties loadBuckProperties(Path propPath) throws IOException {
    Properties properties = new Properties();
    try (InputStream in = Files.newInputStream(propPath)) {
        properties.load(in);
    } catch (NoSuchFileException e) {
    // Ignore; will be run from PATH, with a descriptive error if it fails.
    }
    return properties;
}
#end_block

#method_before
@Override
public Path targetPath(Label label) {
    return sourceRoot.resolve("buck-out").resolve("gen").resolve(label.pkg).resolve(label.name).resolve(label.artifact);
}
#method_after
@Override
public Path targetPath(Label label) {
    return sourceRoot.resolve("buck-out").resolve("gen").resolve(label.artifact);
}
#end_block

#method_before
private List<ChangeControl> changeFromNotesFactory(String id, final CurrentUser currentUser) throws OrmException {
    List<ChangeNotes> changes = changeNotesFactory.create(db, parseId(id));
    return FluentIterable.from(changes).transform(new Function<ChangeNotes, ChangeControl>() {

        @Override
        public ChangeControl apply(ChangeNotes changeNote) {
            return controlForChange(changeNote, currentUser);
        }
    }).filter(Predicates.notNull()).toList();
}
#method_after
private List<ChangeControl> changeFromNotesFactory(String id, final CurrentUser currentUser) throws OrmException, UnloggedFailure {
    List<ChangeNotes> changes = changeNotesFactory.create(db, parseId(id));
    return FluentIterable.from(changes).transform(new Function<ChangeNotes, ChangeControl>() {

        @Override
        public ChangeControl apply(ChangeNotes changeNote) {
            return controlForChange(changeNote, currentUser);
        }
    }).filter(Predicates.notNull()).toList();
}
#end_block

#method_before
private List<Change.Id> parseId(String id) {
    try {
        return Arrays.asList(new Change.Id(Integer.parseInt(id)));
    } catch (NumberFormatException e) {
        log.error("Invalid change ID " + id, e);
        return Collections.emptyList();
    }
}
#method_after
private List<Change.Id> parseId(String id) throws UnloggedFailure {
    try {
        return Arrays.asList(new Change.Id(Integer.parseInt(id)));
    } catch (NumberFormatException e) {
        throw new UnloggedFailure(2, "Invalid change ID " + id, e);
    }
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, R resource, Provider<CurrentUser> userProvider, Config cfg) {
    return FluentIterable.from(views).transform((DynamicMap.Entry<RestView<R>> e) -> {
        int d = e.getExportName().indexOf('.');
        if (d < 0) {
            return null;
        }
        RestView<R> view;
        try {
            view = e.getProvider().get();
        } catch (RuntimeException err) {
            log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
            return null;
        }
        if (!(view instanceof UiAction)) {
            return null;
        }
        try {
            CapabilityUtils.checkRequiresCapability(userProvider, e.getPluginName(), view.getClass());
        } catch (AuthException exc) {
            return null;
        }
        UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
        if (dsc == null || !dsc.isVisible()) {
            return null;
        }
        String name = e.getExportName().substring(d + 1);
        PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
        String id = "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name;
        PrivateInternals_UiActionDescription.setId(dsc, id);
        dsc.setEnabled(cfg.getBoolean("action", id, "enabled", false));
        return dsc;
    }).filter(Objects::nonNull);
}
#method_after
public static <R extends RestResource> FluentIterable<UiAction.Description> from(RestCollection<?, R> collection, R resource, Provider<CurrentUser> userProvider) {
    return from(collection.views(), resource, userProvider);
}
#end_block

#method_before
public Map<String, ActionInfo> format(RevisionResource rsrc) {
    return toActionMap(rsrc);
}
#method_after
public Map<String, ActionInfo> format(RevisionResource rsrc) throws OrmException {
    ChangeInfo changeInfo = null;
    RevisionInfo revisionInfo = null;
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        changeInfo = changeJson().format(rsrc);
        revisionInfo = checkNotNull(Iterables.getOnlyElement(changeInfo.revisions.values()));
        changeInfo.revisions = null;
    }
    return toActionMap(rsrc, visitors, changeInfo, revisionInfo);
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    to.actions = toActionMap(ctl);
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
public RevisionInfo addRevisionActions(RevisionInfo to, RevisionResource rsrc) {
    to.actions = toActionMap(rsrc);
    return to;
}
#method_after
public RevisionInfo addRevisionActions(@Nullable ChangeInfo changeInfo, RevisionInfo to, RevisionResource rsrc) throws OrmException {
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        if (changeInfo != null) {
            changeInfo = copy(visitors, changeInfo);
        } else {
            changeInfo = changeJson().format(rsrc);
        }
    }
    to.actions = toActionMap(rsrc, visitors, changeInfo, copy(visitors, to));
    return to;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (rsrc.getControl().getUser().isIdentifiedUser()) {
        Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider, cfg)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeControl ctl, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!ctl.getUser().isIdentifiedUser()) {
        return out;
    }
    Provider<CurrentUser> userProvider = Providers.of(ctl.getUser());
    FluentIterable<UiAction.Description> descs = UiActions.from(changeViews, changeResourceFactory.create(ctl), userProvider);
    // resulting action map.
    if (ctl.getChange().getStatus().isOpen()) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = descs.append(descr);
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        long startSec = System.currentTimeMillis();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("                          > Done (%.3f s)", (System.currentTimeMillis() - startSec) / 1000.0));
    }
}
#method_after
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        Stopwatch sw = Stopwatch.createStarted();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("\t> Done (%.3f s)", sw.elapsed(TimeUnit.MILLISECONDS) / 1000d));
    }
}
#end_block

#method_before
protected void ccExistingReviewers() {
    if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) {
        return;
    }
    try {
        for (Account.Id id : changeData.reviewers().byState(REVIEWER)) {
            add(RecipientType.CC, id);
        }
    } catch (OrmException err) {
        log.warn("Cannot CC users that commented on updated change", err);
    }
}
#method_after
protected void ccExistingReviewers() {
    if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) {
        return;
    }
    try {
        for (Account.Id id : changeData.reviewers().byState(ReviewerStateInternal.REVIEWER)) {
            add(RecipientType.CC, id);
        }
    } catch (OrmException err) {
        log.warn("Cannot CC users that commented on updated change", err);
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getReviewerEmails());
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getEmailsByState(ReviewerStateInternal.REVIEWER));
    soyContext.put("ccEmails", getEmailsByState(ReviewerStateInternal.CC));
// TODO(wyatta): patchSetInfo
}
#end_block

#method_before
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        try {
            Change change = db.get().changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accountResolver, db, repository, patchList);
                reviewerManager.addReviewers(change, owners.get().values());
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#method_after
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        try {
            ReviewDb reviewDb = db.get();
            Change change = reviewDb.changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accountResolver, reviewDb, repository, patchList);
                reviewerManager.addReviewers(change, owners.get().values());
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#end_block

#method_before
private PatchList getPatchList(Event event, Change change) {
    ObjectId newId = null;
    if (event.getNewObjectId() != null) {
        newId = ObjectId.fromString(event.getNewObjectId());
    }
    PatchListKey plKey = new PatchListKey(change.getProject(), null, newId, IGNORE_NONE);
    try {
        return patchListCache.get(plKey);
    } catch (PatchListNotAvailableException e) {
        logger.warn("Could not load patch list: {}", plKey, e);
    }
    return null;
}
#method_after
private PatchList getPatchList(Event event, Change change) {
    ObjectId newId = null;
    if (event.getNewObjectId() != null) {
        newId = ObjectId.fromString(event.getNewObjectId());
    }
    PatchListKey plKey = new PatchListKey(null, newId, IGNORE_NONE);
    try {
        return patchListCache.get(plKey, change.getProject());
    } catch (PatchListNotAvailableException e) {
        logger.warn("Could not load patch list: {}", plKey, e);
    }
    return null;
}
#end_block

#method_before
private Options createOptions(File base, File outputFile) {
    OptionsBuilder optionsBuilder = OptionsBuilder.options();
    optionsBuilder.backend(backend).docType(DOCTYPE).eruby(ERUBY).safe(SafeMode.UNSAFE).baseDir(base).toFile(outputFile);
    AttributesBuilder attributesBuilder = AttributesBuilder.attributes();
    attributesBuilder.attributes(getAttributes());
    optionsBuilder.attributes(attributesBuilder.get());
    return optionsBuilder.get();
}
#method_after
private Options createOptions(File base, File outputFile) {
    OptionsBuilder optionsBuilder = OptionsBuilder.options();
    optionsBuilder.backend(backend).docType(DOCTYPE).eruby(ERUBY).safe(SafeMode.UNSAFE).baseDir(base).toFile(outputFile);
    AttributesBuilder attributesBuilder = AttributesBuilder.attributes();
    attributesBuilder.attributes(getAttributes());
    if (revnumber != null) {
        attributesBuilder.attribute(REVNUMBER_NAME, revnumber);
    }
    optionsBuilder.attributes(attributesBuilder.get());
    return optionsBuilder.get();
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "asciidoctor: FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    if (bazel) {
        renderFiles(inputFiles, null);
    } else {
        try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile))) {
            renderFiles(inputFiles, zip);
            File[] cssFiles = tmpdir.listFiles(new FilenameFilter() {

                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(".css");
                }
            });
            for (File css : cssFiles) {
                zipFile(css, css.getName(), zip);
            }
        }
    }
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "asciidoctor: FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    if (revnumberFile != null) {
        try (BufferedReader reader = new BufferedReader(new FileReader(revnumberFile))) {
            revnumber = reader.readLine();
        }
    }
    if (mktmp) {
        tmpdir = Files.createTempDirectory("asciidoctor-").toFile();
    }
    if (bazel) {
        renderFiles(inputFiles, null);
    } else {
        try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile))) {
            renderFiles(inputFiles, zip);
            File[] cssFiles = tmpdir.listFiles(new FilenameFilter() {

                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(".css");
                }
            });
            for (File css : cssFiles) {
                zipFile(css, css.getName(), zip);
            }
        }
    }
}
#end_block

#method_before
private void renderFiles(List<String> inputFiles, ZipOutputStream zip) throws IOException {
    Asciidoctor asciidoctor = JRubyAsciidoctor.create();
    for (String inputFile : inputFiles) {
        String outName = mapInFileToOutFile(inputFile, inExt, outExt);
        File out = bazel ? new File(outName) : new File(tmpdir, outName);
        if (!bazel) {
            out.getParentFile().mkdirs();
        }
        File input = new File(inputFile);
        Options options = createOptions(bazel ? input.getParentFile() : basedir, out);
        asciidoctor.renderFile(input, options);
        if (zip != null) {
            zipFile(out, outName, zip);
        }
    }
}
#method_after
private void renderFiles(List<String> inputFiles, ZipOutputStream zip) throws IOException {
    Asciidoctor asciidoctor = JRubyAsciidoctor.create();
    for (String inputFile : inputFiles) {
        String outName = mapInFileToOutFile(inputFile, inExt, outExt);
        File out = bazel ? new File(outName) : new File(tmpdir, outName);
        if (!bazel) {
            out.getParentFile().mkdirs();
        }
        File input = new File(inputFile);
        Options options = createOptions(basedir != null ? basedir : input.getParentFile(), out);
        asciidoctor.renderFile(input, options);
        if (zip != null) {
            zipFile(out, outName, zip);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(UpdateChangeByMerge.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // In case the change look up from the index failed,
                // double check against the existing ref if applicable
                Collection<Ref> existingRefs = existing.get(p.commit);
                if (!existingRefs.isEmpty()) {
                    for (Ref ref : existingRefs) {
                        ChangeNotes notes = notesFactory.create(db, project.getNameKey(), Change.Id.fromRef(ref.getName()));
                        if (notes.getChange().getDest().equals(magicBranch.dest)) {
                            // find the change to the same branch
                            logDebug("Found change from existing refs.");
                            reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                            return;
                        }
                    }
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    } else {
                        itr.remove();
                        continue;
                    }
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void fireChangeIndexedEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeIndexed(id);
        } catch (Exception e) {
            eventUtil.logEventListenerError(listener, e);
        }
    }
}
#method_after
private void fireChangeIndexedEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeIndexed(id);
        } catch (Exception e) {
            logEventListenerError(listener, e);
        }
    }
}
#end_block

#method_before
private void fireChangeDeletedFromIndexEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeDeleted(id);
        } catch (Exception e) {
            eventUtil.logEventListenerError(listener, e);
        }
    }
}
#method_after
private void fireChangeDeletedFromIndexEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeDeleted(id);
        } catch (Exception e) {
            logEventListenerError(listener, e);
        }
    }
}
#end_block

#method_before
public void logEventListenerError(Object listener, Exception error) {
    if (log.isDebugEnabled()) {
        log.debug(String.format("Error in event listener %s", listener.getClass().getName(), error));
    } else {
        log.warn("Error in listener {}: {}", listener.getClass().getName(), error.getMessage());
    }
}
#method_after
public static void logEventListenerError(Object listener, Exception error) {
    if (log.isDebugEnabled()) {
        log.debug(String.format("Error in event listener %s", listener.getClass().getName(), error));
    } else {
        log.warn("Error in listener {}: {}", listener.getClass().getName(), error.getMessage());
    }
}
#end_block

#method_before
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackendConfig config = defaultBackend;
    if (!Strings.isNullOrEmpty(backendName)) {
        config = backends.get(backendName);
        if (config == null) {
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    switch(config.type) {
        case FS:
            return fsRepositories.getRepository(config);
        case S3:
            return s3Repositories.getRepository(config);
        default:
            throw new LfsRepositoryNotFound(project.get());
    }
}
#method_after
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackend backend;
    if (Strings.isNullOrEmpty(backendName)) {
        backend = defaultBackend;
    } else {
        backend = backends.get(backendName);
        if (backend == null) {
            log.error(String.format("Project %s is configured with not existing" + " backend %s", project, Strings.isNullOrEmpty(backendName) ? DEFAULT : backendName));
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    LargeFileRepository repository = cache.get(backend);
    if (repository != null) {
        return repository;
    }
    // this is unlikely situation as cache is pre-populated from config but...
    log.error(String.format("Project %s is configured with not existing" + " backend %s of type %s", project, Strings.isNullOrEmpty(backendName) ? DEFAULT : backendName, backend.type));
    throw new LfsRepositoryNotFound(project.get());
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    if (FS.equals(defaultBackend.type)) {
        LocalLargeFileRepository defRepository = fsRepositories.getRepository(defaultBackend);
        serve(defRepository.getServletRegexp()).with(new LfsFsContentServlet(defRepository));
    }
    for (LfsBackendConfig backendCfg : backends.values()) {
        if (FS.equals(backendCfg.type)) {
            LocalLargeFileRepository repository = fsRepositories.getRepository(backendCfg);
            serve(repository.getServletRegexp()).with(new LfsFsContentServlet(repository));
        }
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    populateRepository(defaultBackend);
    for (LfsBackend backend : backends.values()) {
        populateRepository(backend);
    }
}
#end_block

#method_before
@Override
public void requestSuggestions(Request req, Callback cb) {
    Query q = new Query(req, cb);
    if (query == null) {
        query = q;
        q.start();
    } else {
        query = q;
    }
}
#method_after
@Override
public void requestSuggestions(Request req, Callback cb) {
    if (!serveSuggestions) {
        return;
    }
    // backend for each and every keystroke we receive.
    if (requestRetentionTimer != null) {
        requestRetentionTimer.cancel();
    }
    requestRetentionTimer = new Timer() {

        @Override
        public void run() {
            Query q = new Query(req, cb);
            if (query == null) {
                query = q;
                q.start();
            } else {
                query = q;
            }
        }
    };
    requestRetentionTimer.schedule(200);
}
#end_block

#method_before
@Override
public void requestDefaultSuggestions(final Request req, final Callback cb) {
    // We don't want to deal with a null query, but an empty string instead
    req.setQuery("");
    requestSuggestions(req, cb);
}
#method_after
@Override
public void requestDefaultSuggestions(Request req, Callback cb) {
    requestSuggestions(req, cb);
}
#end_block

#method_before
@Override
public void onSuggestionsReady(Request req, Response res) {
    if (query == this) {
        // No new request was started while this query was running.
        // Propose this request's response as the suggestions.
        query = null;
        last = request.getQuery();
        callback.onSuggestionsReady(req, res);
    } else {
        // Another query came in while this one was running. Skip
        // this response and start the most recent query.
        query.start();
    }
}
#method_after
@Override
public void onSuggestionsReady(Request req, Response res) {
    if (cancelOutstandingRequest || !serveSuggestions) {
        // If cancelOutstandingRequest() was called, we ignore this response
        cancelOutstandingRequest = false;
        query = null;
    } else if (query == this) {
        // No new request was started while this query was running.
        // Propose this request's response as the suggestions.
        query = null;
        last = request.getQuery();
        callback.onSuggestionsReady(req, res);
    } else {
        // Another query came in while this one was running. Skip
        // this response and start the most recent query.
        query.start();
    }
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit()).get(new GerritCallback<JsArray<SuggestReviewerInfo>>() {

        @Override
        public void onSuccess(JsArray<SuggestReviewerInfo> result) {
            List<RestReviewerSuggestion> r = new ArrayList<>(result.length());
            for (SuggestReviewerInfo reviewer : Natives.asList(result)) {
                r.add(new RestReviewerSuggestion(reviewer, req.getQuery()));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable err) {
            List<Suggestion> r = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(r));
        }
    });
}
#method_after
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit(), false).get(new GerritCallback<JsArray<SuggestReviewerInfo>>() {

        @Override
        public void onSuccess(JsArray<SuggestReviewerInfo> result) {
            List<RestReviewerSuggestion> r = new ArrayList<>(result.length());
            for (SuggestReviewerInfo reviewer : Natives.asList(result)) {
                r.add(new RestReviewerSuggestion(reviewer, req.getQuery()));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable err) {
            List<Suggestion> r = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(r));
        }
    });
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl) throws IOException, OrmException, BadRequestException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    Map<Account.Id, Double> reviewerScores;
    if (Strings.isNullOrEmpty(query)) {
        reviewerScores = defaultReviewersForEmptyQuery();
    } else {
        List<Account.Id> suggestedAccounts = suggestAccounts(suggestReviewers, visibilityControl);
        reviewerScores = defaultRankingForCandidateList(suggestedAccounts, projectControl);
    }
    // can also return non-candidate account ids.
    for (ReviewerSuggestion r : reviewerSuggestionPlugins) {
        // TODO(hiesel) Thread Pool
        for (SuggestedReviewer s : r.suggestReviewers(query, reviewerScores.keySet())) {
            if (reviewerScores.containsKey(s.account)) {
                reviewerScores.put(s.account, reviewerScores.get(s.account) + s.score);
            } else {
                reviewerScores.put(s.account, s.score);
            }
        }
    }
    // Remove change owner
    reviewerScores.remove(changeNotes.getChange().getOwner());
    // Sort results
    List<Account.Id> sortedSuggestions = reviewerScores.entrySet().stream().sorted(Map.Entry.comparingByValue()).map(e -> e.getKey()).collect(Collectors.toList());
    Collections.reverse(sortedSuggestions);
    // Populate AccountInfo
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (Account.Id id : sortedSuggestions) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = accountLoader.get(id);
        info.count = 1;
        reviewer.add(info);
    }
    accountLoader.fill();
    for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
        GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
        if (result.allowed || result.allowedWithConfirmation) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            suggestedReviewerInfo.count = result.size;
            if (result.allowedWithConfirmation) {
                suggestedReviewerInfo.confirm = true;
            }
            reviewer.add(suggestedReviewerInfo);
        }
    }
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers, visibilityControl);
    }
    List<Account.Id> sortedRecommendations = reviewerRecommender.suggestReviewers(changeNotes, suggestReviewers, projectControl, candidateList);
    // Populate AccountInfo
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (Account.Id id : sortedRecommendations) {
        AccountInfo account = accountLoader.get(id);
        if (account != null) {
            SuggestedReviewerInfo info = new SuggestedReviewerInfo();
            info.account = account;
            info.count = 1;
            reviewer.add(info);
        }
    }
    accountLoader.fill();
    if (!excludeGroups && !Strings.isNullOrEmpty(query)) {
        for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
            GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
            if (result.allowed || result.allowedWithConfirmation) {
                GroupBaseInfo info = new GroupBaseInfo();
                info.id = Url.encode(g.getUUID().get());
                info.name = g.getName();
                SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
                suggestedReviewerInfo.group = info;
                suggestedReviewerInfo.count = result.size;
                if (result.allowedWithConfirmation) {
                    suggestedReviewerInfo.confirm = true;
                }
                // Always add groups at the end as individual accounts are usually
                // more important
                reviewer.add(suggestedReviewerInfo);
            }
        }
    }
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#end_block

#method_before
private List<Account.Id> suggestAccountsFromIndex(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Set<Account.Id> matches = new HashSet<>();
        QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit()).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.add(id);
        }
        return new ArrayList<>(matches);
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#method_after
private List<Account.Id> suggestAccountsFromIndex(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Set<Account.Id> matches = new HashSet<>();
        QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.add(id);
        }
        return new ArrayList<>(matches);
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#end_block

#method_before
private List<Account.Id> suggestAccountsFromDb(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    String a = query;
    String b = a + MAX_SUFFIX;
    Set<Account.Id> r = new HashSet<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.contains(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    accountLoader.fill();
    return new ArrayList<>(r);
}
#method_after
private List<Account.Id> suggestAccountsFromDb(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER;
    String a = query;
    String b = a + MAX_SUFFIX;
    Set<Account.Id> r = new HashSet<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.contains(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    return new ArrayList<>(r);
}
#end_block

#method_before
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 20);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#method_after
@Test
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#end_block

#method_before
@Test
public void defaultReviewerSuggestion() throws Exception {
    String prefix = "defaultReviewerSuggestion-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "User1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "User2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "User3", null);
    setApiUser(user1);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    String changeId2 = createChangeFromAPI();
    addReviewer(changeId2, reviewer1.email);
    addReviewer(changeId2, reviewer2.email);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#method_after
@Test
public void defaultReviewerSuggestion() throws Exception {
    TestAccount user1 = user("customuser1", "User1");
    TestAccount reviewer1 = user("customuser2", "User2");
    TestAccount reviewer2 = user("customuser3", "User3");
    setApiUser(user1);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(user1);
    String changeId2 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId2);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), null, 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#end_block

#method_before
@Test
public void defaultReviewerSuggestionOnFirstChange() throws Exception {
    String prefix = "defaultReviewerSuggestionOnFChange-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "User1", null);
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChange().getChangeId(), "", 4);
    assertThat(reviewers).isEmpty();
}
#method_after
@Test
public void defaultReviewerSuggestionOnFirstChange() throws Exception {
    TestAccount user1 = user("customuser1", "User1");
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChange().getChangeId(), "", 4);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "10")
public void reviewerRanking() throws Exception {
    // Assert that user are ranked by the number of times they have reviewed a
    // change (highest), added comments (medium) or owned a change (low).
    String prefix = "reviewerRanking-";
    TestAccount userWhoOwns = accounts.create(prefix + "user1", prefix + "user1@example.com", "Primum1 Finalis1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "Primum2 Finalis2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "Primum3 Finalis3", null);
    TestAccount userWhoComments = accounts.create(prefix + "user4", prefix + "user4@example.com", "Primum4 Finalis4", null);
    TestAccount userWhoLooksForSuggestions = accounts.create(prefix + "user5", prefix + "user5@example.com", "Primum5 Finalis5", null);
    // Create a changee as userWhoOwns and add some reviewers
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    setApiUser(user1);
    String changeId2 = createChangeFromAPI();
    addReviewer(changeId2, reviewer1.email);
    addReviewer(changeId2, reviewer2.email);
    // Create a comment as a different user
    setApiUser(userWhoComments);
    ReviewInput ri = new ReviewInput();
    ri.message = "Test";
    gApi.changes().id(changeId1).revision(1).review(ri);
    // Create a change as a new user to assert that we receive the correct
    // ranking
    setApiUser(userWhoLooksForSuggestions);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "Primum", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get(), userWhoOwns.id.get(), userWhoComments.id.get()).inOrder();
}
#method_after
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "10")
public void reviewerRanking() throws Exception {
    // Assert that user are ranked by the number of times they have applied a
    // a label to a change (highest), added comments (medium) or owned a
    // change (low).
    String fullName = "Primum Finalis";
    TestAccount userWhoOwns = user("customuser1", fullName);
    TestAccount reviewer1 = user("customuser2", fullName);
    TestAccount reviewer2 = user("customuser3", fullName);
    TestAccount userWhoComments = user("customuser4", fullName);
    TestAccount userWhoLooksForSuggestions = user("customuser5", fullName);
    // Create a change as userWhoOwns and add some reviews
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(user1);
    String changeId2 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId2);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    // Create a comment as a different user
    setApiUser(userWhoComments);
    ReviewInput ri = new ReviewInput();
    ri.message = "Test";
    gApi.changes().id(changeId1).revision(1).review(ri);
    // Create a change as a new user to assert that we receive the correct
    // ranking
    setApiUser(userWhoLooksForSuggestions);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), "Pri", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get(), userWhoOwns.id.get(), userWhoComments.id.get()).inOrder();
}
#end_block

#method_before
@Test
public void reviewerRankingProjectIsolation() throws Exception {
    // Create new project
    Project.NameKey newProject = createProject("test");
    // Create users who review changes in both the default and the new project
    String prefix = "reviewerRankingProjectIsolation-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "Primum1 Finalis1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "Primum2 Finalis2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "Primum3 Finalis3", null);
    setApiUser(user1);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    String changeId2 = createChangeFromAPI(newProject);
    addReviewer(changeId2, reviewer2.email);
    String changeId3 = createChangeFromAPI(newProject);
    addReviewer(changeId3, reviewer2.email);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "Prim", 4);
    // Assert that reviewer1 is on top, even though reviewer2 has more reviews
    // in other projects
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#method_after
@Test
public void reviewerRankingProjectIsolation() throws Exception {
    // Create new project
    Project.NameKey newProject = createProject("test");
    // Create users who review changes in both the default and the new project
    String fullName = "Primum Finalis";
    TestAccount userWhoOwns = user("customuser1", fullName);
    TestAccount reviewer1 = user("customuser2", fullName);
    TestAccount reviewer2 = user("customuser3", fullName);
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(userWhoOwns);
    String changeId2 = createChangeFromApi(newProject);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    setApiUser(userWhoOwns);
    String changeId3 = createChangeFromApi(newProject);
    setApiUser(reviewer2);
    reviewChange(changeId3);
    setApiUser(userWhoOwns);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), "Prim", 4);
    // Assert that reviewer1 is on top, even though reviewer2 has more reviews
    // in other projects
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#end_block

#method_before
private TestAccount user(String name, String fullName, String emailName, AccountGroup... groups) throws Exception {
    String[] groupNames = FluentIterable.from(Arrays.asList(groups)).transform(new Function<AccountGroup, String>() {

        @Override
        public String apply(AccountGroup in) {
            return in.getName();
        }
    }).toArray(String.class);
    return accounts.create(name(name), name(emailName) + "@example.com", fullName, groupNames);
}
#method_after
private TestAccount user(String name, String fullName, String emailName, AccountGroup... groups) throws Exception {
    String[] groupNames = Arrays.stream(groups).map(AccountGroup::getName).toArray(String[]::new);
    return accounts.create(name(name), name(emailName) + "@example.com", fullName, groupNames);
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setFocus(true);
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setServeSuggestionsOnOracle(true);
    suggestBox.setFocus(true);
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
    suggestBox.setServeSuggestionsOnOracle(false);
}
#end_block

#method_before
private void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#method_after
void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc));
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#end_block

#method_before
@Override
public final void requestSuggestions(final Request request, final Callback cb) {
    onRequestSuggestions(request, new Callback() {

        @Override
        public void onSuggestionsReady(final Request request, final Response response) {
            final String qpat = getQueryPattern(request.getQuery());
            final boolean html = isHTML();
            final ArrayList<Suggestion> r = new ArrayList<>();
            for (final Suggestion s : response.getSuggestions()) {
                r.add(new BoldSuggestion(qpat, s, html));
            }
            cb.onSuggestionsReady(request, new Response(r));
        }
    });
}
#method_after
@Override
public final void requestSuggestions(Request request, Callback cb) {
    onRequestSuggestions(request, new Callback() {

        @Override
        public void onSuggestionsReady(final Request request, final Response response) {
            final String qpat = getQueryPattern(request.getQuery());
            final boolean html = isHTML();
            final ArrayList<Suggestion> r = new ArrayList<>();
            for (final Suggestion s : response.getSuggestions()) {
                r.add(new BoldSuggestion(qpat, s, html));
            }
            cb.onSuggestionsReady(request, new Response(r));
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
void format(StringBuilder s) {
    if (!Strings.isNullOrEmpty(name)) {
        s.append(name).append(": ");
    }
    synchronized (this) {
        if (total == UNKNOWN) {
            s.append(count);
        } else {
            s.append(String.format("%d%% (%d/%d)", count * 100 / total, count, total));
        }
    }
}
#method_after
synchronized void format(StringBuilder s, boolean first) {
    if (count == 0) {
        return;
    }
    if (!first) {
        s.append(',');
    }
    s.append(' ');
    if (!Strings.isNullOrEmpty(name)) {
        s.append(name).append(": ");
    }
    if (total == UNKNOWN) {
        s.append(count);
    } else {
        s.append(String.format("%d%% (%d/%d)", count * 100 / total, count, total));
    }
}
#end_block

#method_before
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Task t : tasks) {
            int count = t.count;
            if (count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ');
            t.format(s);
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#method_after
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    int firstLength = s.length();
    for (Task t : tasks) {
        t.format(s, s.length() == firstLength);
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (allowedFormats.getAllowed().isEmpty() && format.equals("tar")) {
        // When no formats are allowed, this is because the server admin wants
        // to disallow downloading patchsets/changes as archives, this
        // is not applicable to the preview_submit call. Allow tar as a
        // fall back.
        f = ArchiveFormat.TAR;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#end_block

#method_before
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
}
#method_after
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
}
#end_block

#method_before
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#method_after
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    assertThat(note).isEqualTo(pushCert);
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    // TODO(hanwen): test fails. What do we really want to check here?
    assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    // TODO
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    if (note[p.value] == '{' || note[p.value] == '[') {
        return parseNoteJSON(note, p);
    }
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#method_after
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#end_block

#method_before
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (gson != null) {
        buildNoteJSON(comments, out);
        return;
    }
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#method_after
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#end_block

#method_before
public final boolean canEdit(Account.FieldName f) {
    return editableAccountFields().contains(f);
}
#method_after
public final boolean canEdit(AccountFieldName f) {
    return editableAccountFields().contains(f);
}
#end_block

#method_before
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(Account.FieldName.valueOf(f));
    }
    return fields;
}
#method_after
public final List<AccountFieldName> editableAccountFields() {
    List<AccountFieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(AccountFieldName.valueOf(f));
    }
    return fields;
}
#end_block

#method_before
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(FieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#method_after
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(AccountFieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
        setUserIdentified(who.getAccount().getId());
        return true;
    } else if (!authConfig.isLdapAuthType()) {
        log.warn("Authentication failed for {}: password does not match the one" + " stored in Gerrit", username);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            setUserIdentified(who.getAccount().getId());
            return true;
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private void setUserIdentified(final Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#method_after
private void setUserIdentified(Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",change_owner":
    // label:Code-Review+2,user=0
    // label:Code-Review+2,change_owner
    // label:Code-Review+2,user=change_owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = new HashSet<>(Lists.transform(args.listMembers.get().setRecursive(true).apply(group), new Function<AccountInfo, Account.Id>() {

            @Override
            public Account.Id apply(AccountInfo accountInfo) {
                return new Account.Id(accountInfo._accountId);
            }
        }));
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    if (who.equals(ARG_ID_CHANGE_OWNER) || who.equals(CHANGE_OWNER_ACCOUNT_ID.toString())) {
        return Collections.singleton(CHANGE_OWNER_ACCOUNT_ID);
    }
    Set<Account.Id> matches = args.accountResolver.findAll(who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.CHANGE_OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_CHANGE_OWNER;
    }
    return Integer.toString(accountId.get());
}
#method_after
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_OWNER;
    }
    return Integer.toString(accountId.get());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "all_assignees").to(GetAllAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
public boolean isAssignee() {
    Account.Id current_assignee = notes.getAssignee();
    if (current_assignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(current_assignee);
    }
    return false;
}
#method_after
public boolean isAssignee() {
    Account.Id currentAssignee = notes.getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#end_block

#method_before
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getUser().getCapabilities().canAdministrateServer() || getRefControl().canEditAssignee() || isAssignee();
}
#method_after
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#end_block

#method_before
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId);
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    if (requestId != null) {
        for (BatchUpdate u : updates) {
            checkArgument(u.requestId == null || u.requestId == requestId, "refusing to overwrite RequestId %s in update with %s", u.requestId, requestId);
            u.setRequestId(requestId);
        }
    }
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel, dryrun);
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel, dryrun);
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        if (!dryrun) {
            for (BatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public Collection<ReceiveCommand> getRefUpdates() throws UpdateException, RestApiException {
    executeUpdateRepo();
    return commands.getCommands().values();
}
#method_after
public Collection<ReceiveCommand> getRefUpdates() {
    return commands.getCommands().values();
}
#end_block

#method_before
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId);
}
#method_after
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId, false);
}
#end_block

#method_before
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        if (!repoOnlyOps.isEmpty()) {
            logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size());
            for (RepoOnlyOp op : repoOnlyOps) {
                op.updateRepo(ctx);
            }
        }
        if (inserter != null) {
            // todo should be optional
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        if (!repoOnlyOps.isEmpty()) {
            logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size());
            for (RepoOnlyOp op : repoOnlyOps) {
                op.updateRepo(ctx);
            }
        }
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates(boolean dryrun) throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    logDebug("Executing change ops (parallel? {})", parallel);
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            logDebug("Preemptively scanning for repo changes");
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // Fail fast before attempting any writes if changes are read-only, as
            // this is a programmer error.
            logDebug("Failing early due to read-only Changes table");
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            if (!parallel) {
                logDebug("Direct execution of task for ops: {}", ops);
            }
            futures.add(executor.submit(task));
        }
        if (parallel) {
            logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
        }
        // TODO(dborowitz): Timing is wrong for non-parallel updates.
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            executeNoteDbUpdates(tasks);
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel, boolean dryrun) throws UpdateException, RestApiException {
    logDebug("Executing change ops (parallel? {})", parallel);
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            logDebug("Preemptively scanning for repo changes");
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // Fail fast before attempting any writes if changes are read-only, as
            // this is a programmer error.
            logDebug("Failing early due to read-only Changes table");
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread(), dryrun);
            tasks.add(task);
            if (!parallel) {
                logDebug("Direct execution of task for ops: {}", ops);
            }
            futures.add(executor.submit(task));
        }
        if (parallel) {
            logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
        }
        // TODO(dborowitz): Timing is wrong for non-parallel updates.
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            if (!dryrun) {
                executeNoteDbUpdates(tasks);
            }
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        ChangeContext ctx;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                logDebug("Inserting change");
                db.changes().insert(cs);
            } else if (deleted) {
                logDebug("Deleting change");
                db.changes().delete(cs);
            } else {
                logDebug("Updating change");
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        ChangeContext ctx;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                logDebug("Inserting change");
                db.changes().insert(cs);
            } else if (deleted) {
                logDebug("Deleting change");
                db.changes().delete(cs);
            } else {
                logDebug("Updating change");
                db.changes().update(cs);
            }
            if (!dryrun) {
                db.commit();
            }
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#end_block

#method_before
void sendMessages() {
    for (CommitValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#method_after
void sendMessages() {
    for (ValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs, ListMultimap<String, String> pushOptions) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    ListMultimap<String, String> options = LinkedListMultimap.create(pushOptions);
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        ref = ref.substring(0, optionStart);
    }
    if (!options.isEmpty()) {
        clp.parseOptionMap(options);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            logDebug("Marking {} base commits uninteresting", magicBranch.baseCommit.size());
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                logDebug("Marking target ref {} ({}) uninteresting", magicBranch.ctl.getRefName(), targetRef.getObjectId().name());
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setDraft(magicBranch.draft).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    ins.setUpdateRefCommand(cmd);
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    ins.setUpdateRefCommand(cmd);
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs, dryrun);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs, boolean dryrun) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        this.allProjects = allProjects;
        if (!dryrun) {
            BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId);
        }
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        this.allProjects = allProjects;
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId, dryrun);
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    // in case superproject subscription is disabled, allBranches would be null
    if (allBranches == null) {
        allBranches = toSubmit.keySet();
    }
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#method_after
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    // in case superproject subscription is disabled, allBranches would be null
    if (allBranches == null) {
        allBranches = toSubmit.keySet();
    }
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp, dryrun);
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    if (magicBranch.merged) {
        if (magicBranch.draft) {
            reject(cmd, "cannot be draft & merged");
            return;
        }
        if (magicBranch.base != null) {
            reject(cmd, "cannot use merged with base");
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
    if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private RevCommit setUpWalkForSelectingChanges() throws IOException {
    RevWalk rw = rp.getRevWalk();
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    RevCommit start = rw.parseCommit(magicBranch.cmd.getNewId());
    rp.getRevWalk().markStart(start);
    if (magicBranch.baseCommit != null) {
        markExplicitBasesUninteresting();
    } else if (magicBranch.merged) {
        logDebug("Marking parents of merged commit {} uninteresting", start.name());
        for (RevCommit c : start.getParents()) {
            rw.markUninteresting(c);
        }
    } else {
        markHeadsAsUninteresting(rw, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
    }
    return start;
}
#method_after
private RevCommit setUpWalkForSelectingChanges() throws IOException {
    RevWalk rw = rp.getRevWalk();
    RevCommit start = rw.parseCommit(magicBranch.cmd.getNewId());
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    rp.getRevWalk().markStart(start);
    if (magicBranch.baseCommit != null) {
        markExplicitBasesUninteresting();
    } else if (magicBranch.merged) {
        logDebug("Marking parents of merged commit {} uninteresting", start.name());
        for (RevCommit c : start.getParents()) {
            rw.markUninteresting(c);
        }
    } else {
        markHeadsAsUninteresting(rw, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
    }
    return start;
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        // When a commit is already merged, the user can't go back and add a
        // Change-Id line if missing. However, we still want perform the rest of
        // the validation for things like Forge Committer.
        // TODO(dborowitz): Do we want to use all other validation checks? If we
        // need some defined subset, then we probably need a new validateFor*
        // method on CommitValidators.
        commitValidators.setValidateChangeId(false);
    }
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1;
    RevCommit c2;
    String changeId;
    c1 = testRepo.commit().message("Non-change 1").create();
    c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
public MergeSuperSet setMergeOpRepoManager(MergeOpRepoManager orm) {
    checkState(this.orm == null);
    this.orm = checkNotNull(orm);
    return this;
}
#method_after
public MergeSuperSet setMergeOpRepoManager(MergeOpRepoManager orm) {
    checkState(this.orm == null);
    this.orm = checkNotNull(orm);
    closeOrm = false;
    return this;
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws IOException, OrmException {
    try {
        ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
        cd.changeControl(user);
        ChangeSet cs = new ChangeSet(cd, cd.changeControl().isVisible(db, cd));
        if (Submit.wholeTopicEnabled(cfg)) {
            return completeChangeSetIncludingTopics(db, cs, user);
        }
        return completeChangeSetWithoutTopic(db, cs, user);
    } finally {
        closeRepos();
    }
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws IOException, OrmException {
    try {
        ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
        cd.changeControl(user);
        ChangeSet cs = new ChangeSet(cd, cd.changeControl().isVisible(db, cd));
        if (Submit.wholeTopicEnabled(cfg)) {
            return completeChangeSetIncludingTopics(db, cs, user);
        }
        return completeChangeSetWithoutTopic(db, cs, user);
    } finally {
        if (closeOrm && orm != null) {
            orm.close();
            orm = null;
        }
    }
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !cd.changeControl().isVisible(db, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            Collection<ChangeData> dest = visible ? visibleChanges : nonVisibleChanges;
            Collection<RevCommit> toWalk = visible ? visibleCommits : nonVisibleCommits;
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            if (!cd.changeControl().isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = cd.visiblePatchSets();
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                dest.add(cd);
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // Always include the input, even if merged. This allows
            // SubmitStrategyOp to correct the situation later, assuming it gets
            // returned by byCommitsOnBranchNotMerged below.
            toWalk.add(commit);
        }
        Ref ref = or.repo.getRefDatabase().getRef(b.get());
        Optional<RevCommit> head = ref != null ? Optional.<RevCommit>of(or.rw.parseCommit(ref.getObjectId())) : Optional.<RevCommit>absent();
        Set<String> visibleHashes = new HashSet<>();
        or.rw.reset();
        if (head.isPresent()) {
            or.rw.markUninteresting(head.get());
        }
        for (RevCommit c : visibleCommits) {
            visibleHashes.add(c.name());
            or.rw.markStart(c);
        }
        for (RevCommit c : or.rw) {
            visibleHashes.add(c.name());
        }
        Iterable<ChangeData> cds = query().byCommitsOnBranchNotMerged(or.repo, db, b, visibleHashes);
        for (ChangeData chd : cds) {
            chd.changeControl(user);
            visibleChanges.add(chd);
        }
        Set<String> nonVisibleHashes = new HashSet<>();
        or.rw.reset();
        if (head.isPresent()) {
            or.rw.markUninteresting(head.get());
        }
        for (RevCommit c : nonVisibleCommits) {
            if (visibleHashes.contains(c.name())) {
                continue;
            }
            nonVisibleHashes.add(c.name());
            or.rw.markStart(c);
        }
        for (RevCommit c : or.rw) {
            if (visibleHashes.contains(c.name())) {
                continue;
            }
            nonVisibleHashes.add(c.name());
        }
        Iterables.addAll(nonVisibleChanges, query().byCommitsOnBranchNotMerged(or.repo, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !cd.changeControl().isVisible(db, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            Collection<RevCommit> toWalk = visible ? visibleCommits : nonVisibleCommits;
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            if (!cd.changeControl().isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = cd.visiblePatchSets();
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // Always include the input, even if merged. This allows
            // SubmitStrategyOp to correct the situation later, assuming it gets
            // returned by byCommitsOnBranchNotMerged below.
            toWalk.add(commit);
        }
        Ref ref = or.repo.getRefDatabase().getRef(b.get());
        Optional<RevCommit> head = ref != null ? Optional.<RevCommit>of(or.rw.parseCommit(ref.getObjectId())) : Optional.<RevCommit>absent();
        Set<String> emptySet = Collections.emptySet();
        Set<String> visibleHashes = walkChangesByHashes(visibleCommits, emptySet, or, head);
        Iterable<ChangeData> cds = query().byCommitsOnBranchNotMerged(or.repo, db, b, visibleHashes);
        for (ChangeData chd : cds) {
            chd.changeControl(user);
            visibleChanges.add(chd);
        }
        Set<String> nonVisibleHashes = walkChangesByHashes(nonVisibleCommits, visibleHashes, or, head);
        Iterables.addAll(nonVisibleChanges, query().byCommitsOnBranchNotMerged(or.repo, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private OpenRepo getRepo(Project.NameKey project) throws IOException {
    if (orm == null) {
        orm = repoManagerProvider.get();
    }
    try {
        OpenRepo or = orm.openRepo(project);
        checkState(or.rw.hasRevSort(RevSort.TOPO));
        return or;
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
}
#method_after
private OpenRepo getRepo(Project.NameKey project) throws IOException {
    if (orm == null) {
        orm = repoManagerProvider.get();
        closeOrm = true;
    }
    try {
        OpenRepo or = orm.openRepo(project);
        checkState(or.rw.hasRevSort(RevSort.TOPO));
        return or;
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textBody.toString();
        va.htmlBody = htmlBody.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, useHtml() ? va.htmlBody : null);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        if (useHtml()) {
            String htmlPart = htmlBody.toString();
            String boundary = generateMultipartBoundary(textPart, htmlPart);
            va.body = buildMultipartBody(boundary, textPart, htmlPart);
            va.textBody = textPart;
            va.htmlBody = htmlPart;
            va.headers.put("Content-Type", new EmailHeader.String("multipart/alternative; " + "boundary=\"" + boundary + "\"; " + "charset=UTF-8"));
        } else {
            va.body = textPart;
            va.textBody = textPart;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#end_block

#method_before
protected void appendHtml(final String html) {
    if (html != null) {
        htmlBody.append(html);
    }
}
#method_after
protected void appendHtml(String html) {
    if (html != null) {
        htmlBody.append(html);
    }
}
#end_block

#method_before
protected String soyTextTemplate(String name) {
    return args.soyTofu.newRenderer("com.google.gerrit.server.mail.template." + name).setContentKind(SanitizedContent.ContentKind.TEXT).setData(soyContext).render();
}
#method_after
protected String soyTextTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.TEXT);
}
#end_block

#method_before
protected String soyHtmlTemplate(String name) {
    return args.soyTofu.newRenderer("com.google.gerrit.server.mail.template." + name).setContentKind(SanitizedContent.ContentKind.HTML).setData(soyContext).render();
}
#method_after
protected String soyHtmlTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.HTML);
}
#end_block

#method_before
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    } else {
        return soyTextTemplate(name);
    }
}
#method_after
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    }
    return soyTextTemplate(name);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriter.getPossibleStatus(p);
    List<ChangeSubIndex> indexes = new ArrayList<>(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, queryBuilder.toQuery(p), opts, getSort());
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = ChangeIndexRewriter.getPossibleStatus(p);
    List<ChangeSubIndex> indexes = new ArrayList<>(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, queryBuilder.toQuery(p), opts, getSort());
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    return new ChangeDataResults(executor.submit(new Callable<List<ChangeData>>() {

        @Override
        public List<ChangeData> call() throws IOException {
            return doRead();
        }
    }));
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }
    }), fields);
}
#end_block

#method_before
private List<ChangeData> doRead() throws IOException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        int realLimit = opts.start() + opts.limit();
        TopFieldDocs[] hits = new TopFieldDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, realLimit, sort);
        }
        TopDocs docs = TopDocs.merge(sort, realLimit, hits);
        List<ChangeData> result = new ArrayList<>(docs.scoreDocs.length);
        Set<String> fields = fields(opts);
        String idFieldName = LEGACY_ID.getName();
        for (int i = opts.start(); i < docs.scoreDocs.length; i++) {
            ScoreDoc sd = docs.scoreDocs[i];
            Document doc = searchers[sd.shardIndex].doc(sd.doc, fields);
            result.add(toChangeData(fields(doc, fields), fields, idFieldName));
        }
        return result;
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#method_after
private List<Document> doRead(Set<String> fields) throws IOException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        int realLimit = opts.start() + opts.limit();
        TopFieldDocs[] hits = new TopFieldDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, realLimit, sort);
        }
        TopDocs docs = TopDocs.merge(sort, realLimit, hits);
        List<Document> result = new ArrayList<>(docs.scoreDocs.length);
        for (int i = opts.start(); i < docs.scoreDocs.length; i++) {
            ScoreDoc sd = docs.scoreDocs[i];
            result.add(searchers[sd.shardIndex].doc(sd.doc, fields));
        }
        return result;
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public List<ChangeData> toList() {
    try {
        return future.get();
    } catch (InterruptedException e) {
        close();
        throw new OrmRuntimeException(e);
    } catch (ExecutionException e) {
        Throwables.propagateIfPossible(e.getCause());
        throw new OrmRuntimeException(e.getCause());
    }
}
#method_after
@Override
public List<ChangeData> toList() {
    try {
        List<Document> docs = future.get();
        List<ChangeData> result = new ArrayList<>(docs.size());
        String idFieldName = LEGACY_ID.getName();
        for (Document doc : docs) {
            result.add(toChangeData(fields(doc, fields), fields, idFieldName));
        }
        return result;
    } catch (InterruptedException e) {
        close();
        throw new OrmRuntimeException(e);
    } catch (ExecutionException e) {
        Throwables.propagateIfPossible(e.getCause());
        throw new OrmRuntimeException(e.getCause());
    }
}
#end_block

#method_before
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
}
#method_after
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    } else {
        // No ChangedLines stored, likely due to failure during reindexing, for
        // example due to LargeObjectException. But we know the field was
        // requested, so update ChangeData to prevent callers from trying to
        // lazily load it, as that would probably also fail.
        cd.setNoChangedLines();
    }
}
#end_block

#method_before
void sendMessages() {
    for (CommitValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#method_after
void sendMessages() {
    for (ValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs, ListMultimap<String, String> pushOptions) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    ListMultimap<String, String> options = LinkedListMultimap.create(pushOptions);
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        ref = ref.substring(0, optionStart);
    }
    if (!options.isEmpty()) {
        clp.parseOptionMap(options);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String pushOption : pushOptions) {
            int e = pushOption.indexOf('=');
            if (0 < e) {
                options.put(pushOption.substring(0, e), pushOption.substring(e + 1));
            } else {
                options.put(pushOption, "");
            }
        }
        clp.parseOptionMap(options);
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            logDebug("Marking {} base commits uninteresting", magicBranch.baseCommit.size());
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                logDebug("Marking target ref {} ({}) uninteresting", magicBranch.ctl.getRefName(), targetRef.getObjectId().name());
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    int i = 0;
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
                i++;
            } catch (IOException e) {
                logWarn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
    logDebug("Marked {} heads as uninteresting", i);
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        logError("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#method_after
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        bu.setRequestId(receiveId);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#end_block

#method_before
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (a.getParent(i) != b.getParent(i)) {
            return false;
        }
    }
    return true;
}
#method_after
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (!a.getParent(i).equals(b.getParent(i))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> external = new HashMap<>();
        for (ExternalIncludedIn ext : includedIn) {
            Multimap<String, String> m = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            for (Map.Entry<String, Collection<String>> e : m.asMap().entrySet()) {
                external.put(e.getKey(), e.getValue());
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external : null));
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Multimap<String, String> external = ArrayListMultimap.create();
        for (ExternalIncludedIn ext : includedIn) {
            external.putAll(ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        return null;
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName);
    // Only accept requests for projects where LFS is enabled
    if (!config.getBoolean("lfs", "enabled", false)) {
        return null;
    }
    if (request.getOperation().equals("upload")) {
        // Check object sizes against limit, if configured
        long maxObjectSize = config.getLong("lfs", "maxObjectSize", 0);
        if (maxObjectSize > 0) {
            for (LfsObject object : request.getObjects()) {
                if (object.getSize() > maxObjectSize) {
                    throw new LfsValidationError("size of object " + object.getOid() + " exceeds limit");
                }
            }
        }
    }
    return getRepository();
}
#method_after
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        return null;
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName);
    // Only accept requests for projects where LFS is enabled
    if (!config.getBoolean("lfs", "enabled", false)) {
        return null;
    }
    if (request.getOperation().equals("upload")) {
        // Check object sizes against limit, if configured
        long maxObjectSize = config.getLong("lfs", "maxObjectSize", 0);
        if (maxObjectSize > 0) {
            for (LfsObject object : request.getObjects()) {
                if (object.getSize() > maxObjectSize) {
                    throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                }
            }
        }
    }
    return getRepository();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).toProvider(SoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            Optional<String> notValid = validateRefCreation(rsrc, u);
            if (notValid.isPresent()) {
                throw new ResourceConflictException(notValid.get());
            }
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            return new BranchInfo(ref, revid.getName(), refControl.canDelete());
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(db.get(), repo, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            refCreationValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (dbProvider.get().changes().byBranchOpenAll(rsrc.getBranchKey()).iterator().hasNext()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    Repository r = repoManager.openRepository(rsrc.getNameKey());
    try {
        RefUpdate.Result result;
        RefUpdate u;
        try {
            u = r.updateRef(rsrc.getRef());
            u.setForceUpdate(true);
            Optional<String> notValid = validateRefDeletion(rsrc, u);
            if (notValid.isPresent()) {
                throw new ResourceConflictException(notValid.get());
            }
            result = u.delete();
        } catch (IOException e) {
            log.error("Cannot delete " + rsrc.getBranchKey(), e);
            throw e;
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u);
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.warn("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    } finally {
        r.close();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "-r", metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#method_after
@Option(name = "--reviewer", aliases = { "-r" }, metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#end_block

#method_before
@Option(name = "-l", metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.getLabel());
        ApprovalsUtil.checkLabel(labelTypes, v.getLabel(), v.getValue());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.getLabel(), v.getValue());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    int i = 0;
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
                i++;
            } catch (IOException e) {
                logWarn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
    logDebug("Marked {} heads as uninteresting", i);
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(db, Collections2.transform(replaceByChange.values(), new Function<ReplaceRequest, Change.Id>() {

        @Override
        public Change.Id apply(ReplaceRequest in) {
            return in.ontoChange;
        }
    }));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private List<Ref> refs(Change.Id changeId) {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange.get(changeId);
}
#method_after
private List<Ref> refs(Change.Id changeId) {
    return refsByChange().get(changeId);
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (a.getParent(i) != b.getParent(i)) {
            return false;
        }
    }
    return true;
}
#method_after
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (!a.getParent(i).equals(b.getParent(i))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean validRefOperation(final ReceiveCommand cmd) {
    RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), currentUser, cmd);
    try {
        messages.addAll(refValidators.validateForRefOperation());
    } catch (RefOperationValidationException e) {
        messages.addAll(Lists.newArrayList(e.getMessages()));
        reject(cmd, e.getMessage());
        return false;
    }
    return true;
}
#method_after
private boolean validRefOperation(ReceiveCommand cmd) {
    RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), user, cmd);
    try {
        messages.addAll(refValidators.validateForRefOperation());
    } catch (RefOperationValidationException e) {
        messages.addAll(Lists.newArrayList(e.getMessages()));
        reject(cmd, e.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Test
public void testUSER_NoPreferredEmailUser() {
    setFrom("USER");
    final String name = "A U. Thor";
    final Account.Id user = user(name, null);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#method_after
@Test
public void testUSER_NoPreferredEmailUser() {
    setFrom("USER");
    final String name = "A U. Thor";
    final Account.Id user = user(name, null);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name + " (Code Review)");
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#end_block

#method_before
@Test
public void testUSERAllowDomain() {
    setFrom("USER");
    setDomain(Arrays.asList("*.example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.example.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(email);
    verify(accountCache);
}
#method_after
@Test
public void testUSERAllowDomain() {
    setFrom("USER");
    setDomains(Arrays.asList("*.example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.example.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(email);
    verify(accountCache);
}
#end_block

#method_before
@Test
public void testUSERNoAllowDomain() {
    setFrom("USER");
    setDomain(Arrays.asList("example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#method_after
@Test
public void testUSERNoAllowDomain() {
    setFrom("USER");
    setDomains(Arrays.asList("example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name + " (Code Review)");
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#end_block

#method_before
@Override
public Address from(final Account.Id fromId) {
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String userEmail = a.getPreferredEmail();
        return new Address(a.getFullName(), canRelay(domains, userEmail) ? userEmail : srvAddr.getEmail());
    }
    return srvAddr;
}
#method_after
@Override
public Address from(final Account.Id fromId) {
    String senderName;
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String fullName = a.getFullName();
        String userEmail = a.getPreferredEmail();
        if (canRelay(userEmail)) {
            return new Address(fullName, userEmail);
        }
        if (fullName == null || "".equals(fullName.trim())) {
            fullName = anonymousCowardName;
        }
        senderName = nameRewriteTmpl.replace("user", fullName).toString();
    } else {
        senderName = serverAddress.name;
    }
    String senderEmail;
    ParameterizedString senderEmailPattern = new ParameterizedString(serverAddress.email);
    if (senderEmailPattern.getParameterNames().isEmpty()) {
        senderEmail = senderEmailPattern.getRawPattern();
    } else {
        senderEmail = senderEmailPattern.replace("userHash", hashOf(senderName)).toString();
    }
    return new Address(senderName, senderEmail);
}
#end_block

#method_before
private boolean canRelay(String[] domains, String userEmail) {
    if (userEmail == null) {
        return false;
    }
    int index = userEmail.indexOf("@");
    if (index == -1) {
        return false;
    }
    String userDomain = userEmail.substring(index + 1);
    for (String domain : domains) {
        // Support wildcard
        domain = Pattern.quote(domain).replace("*", "\\E.*\\Q");
        if (userDomain.matches(domain)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean canRelay(String userEmail) {
    if (userEmail != null) {
        int index = userEmail.indexOf('@');
        if (index > 0 && index < userEmail.length() - 1) {
            return domainPattern.matcher(userEmail.substring(index + 1)).matches();
        }
    }
    return false;
}
#end_block

#method_before
public void addApprovals(ReviewDb db, ChangeUpdate update, LabelTypes labelTypes, PatchSet ps, ChangeControl changeCtl, Map<String, Short> approvals) throws OrmException {
    Iterable<PatchSetApproval> cells = makeApprovals(update, labelTypes, ps, changeCtl, approvals);
    db.patchSetApprovals().insert(cells);
}
#method_after
public Iterable<PatchSetApproval> addApprovals(ReviewDb db, ChangeUpdate update, LabelTypes labelTypes, PatchSet ps, ChangeControl changeCtl, Map<String, Short> approvals) throws OrmException {
    if (approvals.isEmpty()) {
        return Collections.emptyList();
    }
    checkApprovals(approvals, changeCtl);
    List<PatchSetApproval> cells = new ArrayList<>(approvals.size());
    Date ts = update.getWhen();
    for (Map.Entry<String, Short> vote : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(vote.getKey());
        cells.add(new PatchSetApproval(new PatchSetApproval.Key(ps.getId(), ps.getUploader(), lt.getLabelId()), vote.getValue(), ts));
    }
    for (PatchSetApproval psa : cells) {
        update.putApproval(psa.getLabel(), psa.getValue());
    }
    db.patchSetApprovals().insert(cells);
    return cells;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> incomingApprovals = approvalsUtil.makeApprovals(update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, incomingApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    ctx.getDb().patchSetApprovals().insert(incomingApprovals);
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Test
public void pushNewPatchsetOverridingStickyLabel() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyMaxScore(true);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    PushOneCommit.Result r = pushTo("refs/for/master%l=Code-Review+2");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master%l=Code-Review+1");
    r.assertOkStatus();
}
#method_after
@Test
public void pushNewPatchsetOverridingStickyLabel() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyMaxScore(true);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    saveProjectConfig(cfg);
    PushOneCommit.Result r = pushTo("refs/for/master%l=Code-Review+2");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master%l=Code-Review+1");
    r.assertOkStatus();
}
#end_block

#method_before
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    Iterable<PatchSetApproval> incomingApprovals = Collections.emptyList();
    copy(db, ctl, ps, incomingApprovals);
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    copy(db, ctl, ps, Collections.<PatchSetApproval>emptyList());
}
#end_block

#method_before
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps, incomingApprovals));
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps, dontCopy));
}
#end_block

#method_before
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    Iterable<PatchSetApproval> incomingApprovals = Collections.emptyList();
    return getForPatchSet(db, ctl, psId, incomingApprovals);
}
#method_after
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    return getForPatchSet(db, ctl, psId, Collections.<PatchSetApproval>emptyList());
}
#end_block

#method_before
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psId);
    if (ps == null) {
        return Collections.emptyList();
    }
    return getForPatchSet(db, ctl, ps, incomingApprovals);
}
#method_after
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psId);
    if (ps == null) {
        return Collections.emptyList();
    }
    return getForPatchSet(db, ctl, ps, dontCopy);
}
#end_block

#method_before
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : incomingApprovals) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : dontCopy) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            if (!wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                byUser.put(psa.getLabel(), psa.getAccountId(), psa);
            }
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public GroupInfo apply(TopLevelResource resource, GroupInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException {
    return create(input, Collections.singleton(self.get().getAccountId()));
}
#method_after
@Override
public GroupInfo apply(TopLevelResource resource, GroupInput input) throws AuthException, BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException {
    if (input == null) {
        input = new GroupInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    AccountGroup.Id ownerId = owner(input);
    CreateGroupArgs args = new CreateGroupArgs();
    args.setGroupName(name);
    args.groupDescription = Strings.emptyToNull(input.description);
    args.visibleToAll = MoreObjects.firstNonNull(input.visibleToAll, defaultVisibleToAll);
    args.ownerGroupId = ownerId;
    if (input.members != null && !input.members.isEmpty()) {
        List<Account.Id> members = new ArrayList<>();
        for (String nameOrEmailOrId : input.members) {
            Account a = addMembers.findAccount(nameOrEmailOrId);
            if (!a.isActive()) {
                throw new UnprocessableEntityException(String.format("Account Inactive: %s", nameOrEmailOrId));
            }
            members.add(a.getId());
        }
        args.initialMembers = members;
    } else {
        args.initialMembers = ownerId == null ? Collections.singleton(self.get().getAccountId()) : Collections.<Account.Id>emptySet();
    }
    for (GroupCreationValidationListener l : groupCreationValidationListeners) {
        try {
            l.validateNewGroup(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    return json.format(GroupDescriptions.forAccountGroup(createGroup(args)));
}
#end_block

#method_before
@Test
public void checkAlreadyMergedCommit() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertAlreadyMerged("master", c0.getName(), "");
}
#method_after
@Test
public void checkAlreadyMergedCommit() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertCommitMerged("master", c0.getName(), "");
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void checkContentMergedCommit() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    approve(cId.getChangeId());
    RevCommit commitId = cId.getCommit();
    gApi.changes().id(cId.getChangeId()).current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    assertMergeable("master", commitId.getName(), "recursive");
}
#method_after
@Test
public void checkContentMergedCommit() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    RevCommit commitId = cId.getCommit();
    CherryPickInput cpi = new CherryPickInput();
    cpi.destination = "master";
    cpi.message = "cherry pick the commit";
    ChangeApi orig = gApi.changes().id(cId.getChangeId());
    ChangeApi cherry = orig.current().cherryPick(cpi);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    assertContentMerged("master", commitId.getName(), "recursive");
}
#end_block

#method_before
@Test
public void checkInvalidSource() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertBadRequest("master", "fdsafsdf", "recursive", "Cannot resolve 'fdsafsdf' into a commit");
}
#method_after
@Test
public void checkInvalidSource() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertBadRequest("master", "fdsafsdf", "recursive", "Cannot resolve 'fdsafsdf' to a commit");
}
#end_block

#method_before
private void assertUnMergeable(String targetBranch, String source, String strategy, String... conflicts) throws Exception {
    MergeableInfo mergeableInfo = getMergeableInfo(targetBranch, source, strategy);
    assertThat(mergeableInfo.mergeable).isFalse();
    assertThat(mergeableInfo.conflicts).containsExactly(conflicts);
}
#method_after
private void assertUnMergeable(String targetBranch, String source, String strategy, String... conflicts) throws Exception {
    MergeableInfo mergeableInfo = getMergeableInfo(targetBranch, source, strategy);
    assertThat(mergeableInfo.mergeable).isFalse();
    assertThat(mergeableInfo.conflicts).containsExactly((Object[]) conflicts);
}
#end_block

#method_before
public static RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new ChangeAlreadyMergedException("'" + originalCommit.getName() + "' has already been merged!");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    List<String> conflicts = ImmutableList.of();
    if (m instanceof ResolveMerger) {
        conflicts = ((ResolveMerger) m).getUnmergedPaths();
    }
    throw new MergeConflictException(createConflictMessage(conflicts));
}
#method_after
public static RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new ChangeAlreadyMergedException("'" + originalCommit.getName() + "' has already been merged");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    List<String> conflicts = ImmutableList.of();
    if (m instanceof ResolveMerger) {
        conflicts = ((ResolveMerger) m).getUnmergedPaths();
    }
    throw new MergeConflictException(createConflictMessage(conflicts));
}
#end_block

#method_before
public static RevCommit resolveCommit(Repository repo, RevWalk rw, String str) throws BadRequestException, ResourceNotFoundException, IOException {
    try {
        ObjectId commitId = repo.resolve(str);
        if (commitId == null) {
            throw new BadRequestException("Cannot resolve '" + str + "' into a commit");
        }
        return rw.parseCommit(commitId);
    } catch (AmbiguousObjectException | IncorrectObjectTypeException | RevisionSyntaxException e) {
        throw new BadRequestException(e.getMessage());
    } catch (MissingObjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
public static RevCommit resolveCommit(Repository repo, RevWalk rw, String str) throws BadRequestException, ResourceNotFoundException, IOException {
    try {
        ObjectId commitId = repo.resolve(str);
        if (commitId == null) {
            throw new BadRequestException("Cannot resolve '" + str + "' to a commit");
        }
        return rw.parseCommit(commitId);
    } catch (AmbiguousObjectException | IncorrectObjectTypeException | RevisionSyntaxException e) {
        throw new BadRequestException(e.getMessage());
    } catch (MissingObjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void invalidSource() throws Exception {
    changeInTwoBranches("branchA", "a.txt", "branchB", "b.txt");
    ChangeInput in = newMergeChangeInput("branchA", "invalid", "");
    assertCreateFails(in, BadRequestException.class, "Cannot resolve 'invalid' into a commit");
}
#method_after
@Test
public void invalidSource() throws Exception {
    changeInTwoBranches("branchA", "a.txt", "branchB", "b.txt");
    ChangeInput in = newMergeChangeInput("branchA", "invalid", "");
    assertCreateFails(in, BadRequestException.class, "Cannot resolve 'invalid' to a commit");
}
#end_block

#method_before
@Test
public void alreadyMerged() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    ChangeInput in = newMergeChangeInput("master", c0.getName(), "");
    assertCreateFails(in, BadRequestException.class, "'" + c0.getName() + "' has already been merged!");
}
#method_after
@Test
public void alreadyMerged() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    ChangeInput in = newMergeChangeInput("master", c0.getName(), "");
    assertCreateFails(in, ChangeAlreadyMergedException.class, "'" + c0.getName() + "' has already been merged");
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void onlyContentMerged() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    approve(cId.getChangeId());
    RevCommit commitId = cId.getCommit();
    gApi.changes().id(cId.getChangeId()).current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    ChangeInput in = newMergeChangeInput("master", commitId.getName(), "");
    assertCreateSucceeds(in);
}
#method_after
@Test
public void onlyContentMerged() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    RevCommit commitId = cId.getCommit();
    CherryPickInput cpi = new CherryPickInput();
    cpi.destination = "master";
    cpi.message = "cherry pick the commit";
    ChangeApi orig = gApi.changes().id(cId.getChangeId());
    ChangeApi cherry = orig.current().cherryPick(cpi);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    ChangeInput in = newMergeChangeInput("master", commitId.getName(), "");
    assertCreateSucceeds(in);
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create a new branch branchA
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#end_block

#method_before
@Override
public MergeableInfo apply(BranchResource resource) throws IOException, BadRequestException, ResourceNotFoundException {
    MergeableInfo result = new MergeableInfo();
    result.strategy = strategy;
    try (Repository git = gitManager.openRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(git);
        ObjectInserter inserter = new InMemoryInserter(git)) {
        Merger m = MergeUtil.newMerger(git, inserter, strategy);
        Ref destRef = git.getRefDatabase().exactRef(resource.getRef());
        if (destRef == null) {
            throw new ResourceNotFoundException(resource.getRef());
        }
        RevCommit targetCommit = rw.parseCommit(destRef.getObjectId());
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source);
        if (!resource.getControl().canReadCommit(db.get(), git, sourceCommit)) {
            throw new BadRequestException("Do not have read permission for: " + source);
        }
        if (rw.isMergedInto(sourceCommit, targetCommit)) {
            throw new ChangeAlreadyMergedException("'" + source + "' has already been merged!");
        }
        result.mergeable = m.merge(false, targetCommit, sourceCommit);
        if (m instanceof ResolveMerger) {
            result.conflicts = ((ResolveMerger) m).getUnmergedPaths();
        }
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(BranchResource resource) throws IOException, BadRequestException, ResourceNotFoundException {
    if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
        throw new BadRequestException("Submit type: " + submitType + " is not supported");
    }
    MergeableInfo result = new MergeableInfo();
    result.submitType = submitType;
    result.strategy = strategy;
    try (Repository git = gitManager.openRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(git);
        ObjectInserter inserter = new InMemoryInserter(git)) {
        Merger m = MergeUtil.newMerger(git, inserter, strategy);
        Ref destRef = git.getRefDatabase().exactRef(resource.getRef());
        if (destRef == null) {
            throw new ResourceNotFoundException(resource.getRef());
        }
        RevCommit targetCommit = rw.parseCommit(destRef.getObjectId());
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source);
        if (!resource.getControl().canReadCommit(db.get(), git, sourceCommit)) {
            throw new BadRequestException("do not have read permission for: " + source);
        }
        if (rw.isMergedInto(sourceCommit, targetCommit)) {
            result.mergeable = true;
            result.commitMerged = true;
            result.contentMerged = true;
            return result;
        }
        if (m.merge(false, targetCommit, sourceCommit)) {
            result.mergeable = true;
            result.commitMerged = false;
            result.contentMerged = m.getResultTreeId().equals(targetCommit.getTree());
        } else {
            result.mergeable = false;
            if (m instanceof ResolveMerger) {
                result.conflicts = ((ResolveMerger) m).getUnmergedPaths();
            }
        }
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
    return result;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private void json(final Object data, final StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#method_after
private void json(Object data, StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#end_block

#method_before
private Page get() {
    Page p = page;
    if (refreshHeaderFooter && p.isStale()) {
        final Page newPage;
        try {
            newPage = new Page();
        } catch (IOException e) {
            log.error("Cannot refresh site header/footer", e);
            return p;
        }
        p = newPage;
        page = p;
    }
    return p;
}
#method_after
private Page get() {
    Page p = page;
    try {
        if (refreshHeaderFooter && p.isStale()) {
            p = new Page();
            page = p;
        }
    } catch (IOException e) {
        log.error("Cannot refresh site header/footer", e);
    }
    return p;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = select(req);
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xGerritAuth=");
        json(session.get().getXGerritAuth(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    Page.Content page = select(req);
    StringWriter w = new StringWriter();
    CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences(user.asIdentifiedUser()), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    byte[] hpd = w.toString().getBytes(UTF_8);
    byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private void plugins(StringWriter w) {
    List<String> urls = Lists.newArrayList();
    for (WebUiPlugin u : plugins) {
        urls.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath()));
    }
    if (!urls.isEmpty()) {
        w.write(HPD_ID + ".plugins=");
        json(urls, w);
        w.write(";");
    }
}
#method_after
private void plugins(StringWriter w) {
    List<String> urls = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        urls.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath()));
    }
    if (!urls.isEmpty()) {
        w.write(HPD_ID + ".plugins=");
        json(urls, w);
        w.write(";");
    }
}
#end_block

#method_before
private void insertETags(Element e) {
    if ("img".equalsIgnoreCase(e.getTagName()) || "script".equalsIgnoreCase(e.getTagName())) {
        String src = e.getAttribute("src");
        if (src != null && src.startsWith("static/")) {
            String name = src.substring("static/".length());
            StaticServlet.Resource r = staticServlet.getResource(name);
            if (r != null) {
                e.setAttribute("src", src + "?e=" + r.etag);
            }
        }
    }
    for (Node n = e.getFirstChild(); n != null; n = n.getNextSibling()) {
        if (n instanceof Element) {
            insertETags((Element) n);
        }
    }
}
#method_after
private void insertETags(Element e) {
    if ("img".equalsIgnoreCase(e.getTagName()) || "script".equalsIgnoreCase(e.getTagName())) {
        String src = e.getAttribute("src");
        if (src != null && src.startsWith("static/")) {
            String name = src.substring("static/".length());
            ResourceServlet.Resource r = staticServlet.getResource(name);
            if (r != null) {
                e.setAttribute("src", src + "?e=" + r.etag);
            }
        }
    }
    for (Node n = e.getFirstChild(); n != null; n = n.getNextSibling()) {
        if (n instanceof Element) {
            insertETags((Element) n);
        }
    }
}
#end_block

#method_before
boolean isStale() {
    return time != path.lastModified();
}
#method_after
boolean isStale() {
    return time != lastModified(path);
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
private FileInfo injectCssFile(final Document hostDoc, final String id, final File src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParentFile(), src.getName());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#method_after
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#end_block

#method_before
private FileInfo injectXmlFile(final Document hostDoc, final String id, final File src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#method_after
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#end_block

#method_before
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        body.setView(view);
    }
}
#method_after
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
    }
}
#end_block

#method_before
public static void setHeaderVisible(boolean visible) {
    topMenu.setVisible(visible);
    siteHeader.setVisible(visible && (myAccount != null ? myAccount.getGeneralPreferences().isShowSiteHeader() : true));
}
#method_after
public static void setHeaderVisible(boolean visible) {
    topMenu.setVisible(visible);
    siteHeader.setVisible(visible && getUserPreferences().showSiteHeader());
}
#end_block

#method_before
public static Account getUserAccount() {
    return myAccount;
}
#method_after
public static AccountInfo getUserAccount() {
    return myAccount;
}
#end_block

#method_before
public static boolean isSignedIn() {
    return getUserAccount() != null;
}
#method_after
public static boolean isSignedIn() {
    return xGerritAuth != null;
}
#end_block

#method_before
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#method_after
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("login/") + URL.encodePathSegment("#/" + token);
}
#end_block

#method_before
static void deleteSessionCookie() {
    myAccount = null;
    myAccountDiffPref = null;
    xGerritAuth = null;
    refreshMenuBar();
    // If the cookie was HttpOnly, this request to delete it will
    // most likely not be successful.  We can try anyway though.
    // 
    Cookies.removeCookie("GerritAccount");
}
#method_after
static void deleteSessionCookie() {
    myAccount = AccountInfo.create(0, null, null, null);
    myAccountDiffPref = null;
    editPrefs = null;
    myPrefs = GeneralPreferences.createDefault();
    urlAliasMatcher.clearUserAliases();
    xGerritAuth = null;
    refreshMenuBar();
    // If the cookie was HttpOnly, this request to delete it will
    // most likely not be successful.  We can try anyway though.
    // 
    Cookies.removeCookie("GerritAccount");
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    if (canLoadInIFrame(GWT.getModuleBaseURL() + GWT.getModuleName())) {
        UserAgent.assertNotInIFrame();
    }
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    if (!canLoadInIFrame()) {
        UserAgent.assertNotInIFrame();
    }
    setXsrfToken();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    getDocIndex(cbg.add(new GerritCallback<DocInfo>() {

        @Override
        public void onSuccess(DocInfo indexInfo) {
            hasDocumentation = indexInfo != null;
            docUrl = selfRedirect("/Documentation/");
        }
    }));
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
            urlAliasMatcher = new UrlAliasMatcher(info.urlAliases());
            String du = info.gerrit().docUrl();
            if (du != null && !du.isEmpty()) {
                hasDocumentation = true;
                docUrl = du;
            }
            docSearch = info.gerrit().docSearch();
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
            }
            if (result.accountDiffPref != null) {
                // TODO: Support options on the GetDetail REST endpoint so that it can
                // also return the preferences. Then we can fetch everything with a
                // single request and we don't need the callback group anymore.
                CallbackGroup cbg = new CallbackGroup();
                AccountApi.self().view("detail").get(cbg.add(new GerritCallback<AccountInfo>() {

                    @Override
                    public void onSuccess(AccountInfo result) {
                        myAccount = result;
                    }
                }));
                AccountApi.self().view("preferences").get(cbg.add(new GerritCallback<GeneralPreferences>() {

                    @Override
                    public void onSuccess(GeneralPreferences prefs) {
                        myPrefs = prefs;
                        onModuleLoad2(result);
                    }
                }));
                AccountApi.getEditPreferences(cbg.addFinal(new GerritCallback<EditPreferences>() {

                    @Override
                    public void onSuccess(EditPreferences prefs) {
                        EditPreferencesInfo prefsInfo = new EditPreferencesInfo();
                        prefs.copyTo(prefsInfo);
                        editPrefs = prefsInfo;
                    }
                }));
            } else {
                myAccount = AccountInfo.create(0, null, null, null);
                myPrefs = GeneralPreferences.createDefault();
                editPrefs = null;
                onModuleLoad2(result);
            }
        }
    }));
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, hpd.pluginsLoadTimeout, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    });
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (myPrefs.my() != null) {
            myBar.clear();
            String url = null;
            List<TopMenuItem> myMenuItems = Natives.asList(myPrefs.my());
            if (!myMenuItems.isEmpty()) {
                if (myMenuItems.get(0).getUrl().startsWith("#")) {
                    url = myMenuItems.get(0).getUrl().substring(1);
                }
                for (TopMenuItem item : myMenuItems) {
                    addExtensionLink(myBar, item);
                }
            }
            defaultScreenToken = url;
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCHES));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsTags(), ProjectScreen.TAGS));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (hasDocumentation) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
public static void applyUserPreferences() {
    if (myAccount != null) {
        final AccountGeneralPreferences p = myAccount.getGeneralPreferences();
        CopyableLabel.setFlashEnabled(p.isUseFlashClipboard());
        if (siteHeader != null) {
            siteHeader.setVisible(p.isShowSiteHeader());
        }
        if (siteFooter != null) {
            siteFooter.setVisible(p.isShowSiteHeader());
        }
        FormatUtil.setPreferences(myAccount.getGeneralPreferences());
    }
}
#method_after
private static void applyUserPreferences() {
    CopyableLabel.setFlashEnabled(myPrefs.useFlashClipboard());
    if (siteHeader != null) {
        siteHeader.setVisible(myPrefs.showSiteHeader());
    }
    if (siteFooter != null) {
        siteFooter.setVisible(myPrefs.showSiteHeader());
    }
    FormatUtil.setPreferences(myPrefs);
    urlAliasMatcher.updateUserAliases(myPrefs.urlAliases());
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccount();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#end_block

#method_before
private static LinkMenuItem addProjectLink(final LinkMenuBar m, final String text, final String panel) {
    LinkMenuItem i = new LinkMenuItem(text, "") {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            Screen screen = event.getScreen();
            Project.NameKey projectKey;
            if (screen instanceof ProjectScreen) {
                projectKey = ((ProjectScreen) screen).getProjectKey();
            } else {
                projectKey = ProjectScreen.getSavedKey();
            }
            if (projectKey != null) {
                setVisible(true);
                setTargetHistoryToken(Dispatcher.toProjectAdmin(projectKey, panel));
            } else {
                setVisible(false);
            }
            super.onScreenLoad(event);
        }
    };
    m.addItem(i);
    return i;
}
#method_after
private static LinkMenuItem addProjectLink(LinkMenuBar m, TopMenuItem item) {
    LinkMenuItem i = new ProjectLinkMenuItem(item.getName(), item.getUrl()) {

        @Override
        protected void onScreenLoad(Project.NameKey project) {
            String p = panel.replace(PROJECT_NAME_MENU_VAR, URL.encodeQueryString(project.get()));
            if (!panel.startsWith("/x/") && !isAbsolute(panel)) {
                UrlBuilder builder = new UrlBuilder();
                builder.setProtocol(Location.getProtocol());
                builder.setHost(Location.getHost());
                String port = Location.getPort();
                if (port != null && !port.isEmpty()) {
                    builder.setPort(Integer.parseInt(port));
                }
                builder.setPath(Location.getPath());
                p = builder.buildString() + p;
            }
            getElement().setPropertyString("href", p);
        }

        @Override
        public void go() {
            String href = getElement().getPropertyString("href");
            if (href.startsWith("#")) {
                super.go();
            } else {
                Window.open(href, getElement().getPropertyString("target"), "");
            }
        }
    };
    if (item.getTarget() != null && !item.getTarget().isEmpty()) {
        i.getElement().setAttribute("target", item.getTarget());
    }
    if (item.getId() != null) {
        i.getElement().setAttribute("id", item.getId());
    }
    m.addItem(i);
    return i;
}
#end_block

#method_before
private static void addDocLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, selfRedirect("/Documentation/" + href));
    atag.setTarget("_blank");
    m.add(atag);
}
#method_after
private static void addDocLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, docUrl + href);
    atag.setTarget("_blank");
    m.add(atag);
}
#end_block

#method_before
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    if (item.getUrl().startsWith("#") && (item.getTarget() == null || item.getTarget().isEmpty())) {
        LinkMenuItem a = new LinkMenuItem(item.getName(), item.getUrl().substring(1));
        if (item.getId() != null) {
            a.getElement().setAttribute("id", item.getId());
        }
        m.add(a);
    } else {
        Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
        if (item.getTarget() != null && !item.getTarget().isEmpty()) {
            atag.setTarget(item.getTarget());
        }
        if (item.getId() != null) {
            atag.getElement().setAttribute("id", item.getId());
        }
        m.add(atag);
    }
}
#method_after
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    if (item.getUrl().startsWith("#") && (item.getTarget() == null || item.getTarget().isEmpty())) {
        LinkMenuItem a = new LinkMenuItem(item.getName(), item.getUrl().substring(1));
        if (item.getId() != null) {
            a.getElement().setAttribute("id", item.getId());
        }
        m.addItem(a);
    } else {
        Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
        if (item.getTarget() != null && !item.getTarget().isEmpty()) {
            atag.setTarget(item.getTarget());
        }
        if (item.getId() != null) {
            atag.getElement().setAttribute("id", item.getId());
        }
        m.add(atag);
    }
}
#end_block

#method_before
@Test
public void testSubmoduleSubjectCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getShortMessage());
}
#method_after
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "SUBJECT_ONLY")
public void testSubmoduleSubjectCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getShortMessage());
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "true")
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#method_after
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        commit.setMessage(currentCommit.getFullMessage() + "\n\n*submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        // TODO:czhen handle cherrypick footer
        commit.setMessage(currentCommit.getFullMessage() + "\n\n*submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
private RevCommit updateSubmodule(DirCache dc, DirCacheEditor ed, StringBuilder msgbuf, final SubmoduleSubscription s) throws SubmoduleException, IOException {
    OpenRepo subOr;
    try {
        subOr = orm.openRepo(s.getSubmodule().getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access submodule", e);
    }
    DirCacheEntry dce = dc.getEntry(s.getPath());
    RevCommit oldCommit = null;
    if (dce != null) {
        if (!dce.getFileMode().equals(FileMode.GITLINK)) {
            String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
            throw new SubmoduleException(errMsg);
        }
        oldCommit = subOr.rw.parseCommit(dce.getObjectId());
    }
    final RevCommit newCommit;
    if (branchTips.containsKey(s.getSubmodule())) {
        newCommit = branchTips.get(s.getSubmodule());
    } else {
        Ref ref = subOr.repo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            return null;
        }
        newCommit = subOr.rw.parseCommit(ref.getObjectId());
    }
    if (Objects.equals(newCommit, oldCommit)) {
        // gitlink have already been updated for this submodule
        return null;
    }
    ed.add(new PathEdit(s.getPath()) {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(newCommit.getId());
        }
    });
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        createSubmoduleCommitMsg(msgbuf, s, subOr, newCommit, oldCommit);
    }
    subOr.rw.parseBody(newCommit);
    return newCommit;
}
#method_after
private RevCommit updateSubmodule(DirCache dc, DirCacheEditor ed, StringBuilder msgbuf, final SubmoduleSubscription s) throws SubmoduleException, IOException {
    OpenRepo subOr;
    try {
        subOr = orm.openRepo(s.getSubmodule().getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access submodule", e);
    }
    DirCacheEntry dce = dc.getEntry(s.getPath());
    RevCommit oldCommit = null;
    if (dce != null) {
        if (!dce.getFileMode().equals(FileMode.GITLINK)) {
            String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
            throw new SubmoduleException(errMsg);
        }
        oldCommit = subOr.rw.parseCommit(dce.getObjectId());
    }
    final RevCommit newCommit;
    if (branchTips.containsKey(s.getSubmodule())) {
        newCommit = branchTips.get(s.getSubmodule());
    } else {
        Ref ref = subOr.repo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            return null;
        }
        newCommit = subOr.rw.parseCommit(ref.getObjectId());
    }
    if (Objects.equals(newCommit, oldCommit)) {
        // gitlink have already been updated for this submodule
        return null;
    }
    ed.add(new PathEdit(s.getPath()) {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(newCommit.getId());
        }
    });
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        createSubmoduleCommitMsg(msgbuf, s, subOr, newCommit, oldCommit);
    }
    subOr.rw.parseBody(newCommit);
    return newCommit;
}
#end_block

#method_before
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject.equals(VerboseSuperprojectUpdate.SUBJECT_ONLY)) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject.equals(VerboseSuperprojectUpdate.TRUE)) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#method_after
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#end_block

#method_before
public synchronized GlobalPluginConfig getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#method_after
public synchronized Config getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#end_block

#method_before
@Override
public String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    File pluginConfigFile = site.etc_dir.resolve(pluginName + ".secure.config").toFile();
    if (pluginConfigFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
        try {
            cfg.load();
            return cfg.getStringList(section, subsection, name);
        } catch (Exception e) {
        // Do nothing for now
        }
    }
    return null;
}
#method_after
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? cfg.getStringList(section, subsection, name) : null;
}
#end_block

#method_before
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    gApi.accounts().self().deleteWatchedProjects(d);
}
#method_after
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    setApiUser(user);
    gApi.accounts().self().deleteWatchedProjects(d);
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#end_block

#method_before
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Collection<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#method_after
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Set<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#end_block

#method_before
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        for (ProjectWatchKey key : projectWatchKeys) {
            projectWatches.remove(key);
        }
        commit(watchConfig);
    }
}
#method_after
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        boolean commit = false;
        for (ProjectWatchKey key : projectWatchKeys) {
            if (projectWatches.remove(key) != null) {
                commit = true;
            }
        }
        if (commit) {
            commit(watchConfig);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    projectWatches = new HashMap<>();
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectWatchKey : cfg.getSubsections(PROJECT)) {
        ProjectWatchKey key = ProjectWatchKey.parse(projectWatchKey);
        projectWatches.put(key, new HashSet<NotifyType>());
        List<String> notifyValues = Arrays.asList(cfg.getStringList(PROJECT, projectWatchKey, KEY_NOTIFY));
        if (!notifyValues.contains(NOTIFY_NONE)) {
            for (String notify : notifyValues) {
                try {
                    projectWatches.get(key).add(AccountProjectWatch.NotifyType.valueOf(notify));
                } catch (IllegalArgumentException e) {
                    log.warn(String.format("Project watch configuration %s of account %d" + " contains invalid notify type: %s", projectWatchKey, accountId.get(), notify), e);
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Config cfg = readConfig(WATCH_CONFIG);
    projectWatches = parse(accountId, cfg);
}
#end_block

#method_before
Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#method_after
Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    clearSection(cfg, PROJECT);
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        if (e.getValue().isEmpty()) {
            // set notify to 'none' since empty sections are not persisted
            cfg.setString(PROJECT, e.getKey().toString(), KEY_NOTIFY, NOTIFY_NONE);
        } else {
            List<String> notifyValues = FluentIterable.from(e.getValue()).transform(new Function<NotifyType, String>() {

                @Override
                public String apply(NotifyType notify) {
                    return notify.name();
                }
            }).toList();
            cfg.setStringList(PROJECT, e.getKey().toString(), KEY_NOTIFY, notifyValues);
        }
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unset(PROJECT, projectName, KEY_NOTIFY);
    }
    Multimap<String, String> notifyValuesByProject = ArrayListMultimap.create();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#end_block

#method_before
private void checkLoaded() {
    checkNotNull(projectWatches, "project watches not loaded yet");
}
#method_after
private void checkLoaded() {
    checkState(projectWatches != null, "project watches not loaded yet");
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        Account.Id accountId = a.getAccount().getId();
        for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (add(matching, accountId, e.getKey(), e.getValue(), type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(accountId);
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : a.getProjectWatches().entrySet()) {
            Account.Id accountId = a.getAccount().getId();
            if (!projectWatchers.contains(accountId)) {
                add(matching, accountId, e.getKey(), e.getValue(), type);
            }
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching;
    if (args.accountIndexes.getSearchIndex() != null) {
        matching = getWatchersFromIndex(type);
    } else {
        matching = getWatchersFromDb(type);
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private boolean add(Watchers matching, Account.Id accountId, ProjectWatchKey key, Collection<NotifyType> watchedTypes, NotifyType type) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(accountId);
    try {
        if (filterMatch(user, key.filter())) {
            // Otherwise, still return true to stop notifications for this user.
            if (watchedTypes.contains(type)) {
                matching.bcc.accounts.add(accountId);
            }
            return true;
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
    return false;
}
#method_after
private boolean add(Watchers matching, Account.Id accountId, ProjectWatchKey key, Set<NotifyType> watchedTypes, NotifyType type) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(accountId);
    try {
        if (filterMatch(user, key.filter())) {
            // Otherwise, still return true to stop notifications for this user.
            if (watchedTypes.contains(type)) {
                matching.bcc.accounts.add(accountId);
            }
            return true;
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
    return false;
}
#end_block

#method_before
private AccountState makeUser(final String name, final String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(account, Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountExternalId>emptySet(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private AccountState makeUser(final String name, final String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(account, Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountExternalId>emptySet(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private void updateInDb(Account.Id accountId, List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, OrmException {
    Set<AccountProjectWatch.Key> keys = new HashSet<>();
    List<AccountProjectWatch> watchedProjects = new LinkedList<>();
    for (ProjectWatchInfo a : input) {
        if (a.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey();
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, projectKey, a.filter);
        if (!keys.add(key)) {
            throw new BadRequestException("duplicate entry for project " + key.getProjectName().get() + (!AccountProjectWatch.FILTER_ALL.equals(key.getFilter().get()) ? " and filter " + key.getFilter().get() : ""));
        }
        AccountProjectWatch apw = new AccountProjectWatch(key);
        apw.setNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES, toBoolean(a.notifyAbandonedChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS, toBoolean(a.notifyAllComments));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_CHANGES, toBoolean(a.notifyNewChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS, toBoolean(a.notifyNewPatchSets));
        apw.setNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES, toBoolean(a.notifySubmittedChanges));
        watchedProjects.add(apw);
    }
    dbProvider.get().accountProjectWatches().upsert(watchedProjects);
}
#method_after
private void updateInDb(Account.Id accountId, List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, OrmException {
    Set<AccountProjectWatch.Key> keys = new HashSet<>();
    List<AccountProjectWatch> watchedProjects = new LinkedList<>();
    for (ProjectWatchInfo a : input) {
        if (a.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey();
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, projectKey, a.filter);
        if (!keys.add(key)) {
            throw new BadRequestException("duplicate entry for project " + format(key.getProjectName().get(), key.getFilter().get()));
        }
        AccountProjectWatch apw = new AccountProjectWatch(key);
        apw.setNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES, toBoolean(a.notifyAbandonedChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS, toBoolean(a.notifyAllComments));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_CHANGES, toBoolean(a.notifyNewChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS, toBoolean(a.notifyNewPatchSets));
        apw.setNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES, toBoolean(a.notifySubmittedChanges));
        watchedProjects.add(apw);
    }
    dbProvider.get().accountProjectWatches().upsert(watchedProjects);
}
#end_block

#method_before
private Map<ProjectWatchKey, Collection<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Collection<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + info.project + (info.filter != null ? " and filter " + info.filter : ""));
        }
        Set<NotifyType> notifyValues = new HashSet<>();
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#method_after
private Map<ProjectWatchKey, Set<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Set<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + format(info.project, info.filter));
        }
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#end_block

#method_before
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new // 
        AccountExternalId.Key(// 
        AccountExternalId.SCHEME_USERNAME, username);
        final AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.<Account.Id>absent();
    }
    try (ReviewDb db = schema.open()) {
        AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#end_block

#method_before
private void deleteFromDb(Account.Id accountId, List<ProjectWatchInfo> input) throws OrmException, IOException {
    ResultSet<AccountProjectWatch> watchedProjects = dbProvider.get().accountProjectWatches().byAccount(accountId);
    HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>();
    for (AccountProjectWatch watchedProject : watchedProjects) {
        watchedProjectsMap.put(watchedProject.getKey(), watchedProject);
    }
    List<AccountProjectWatch> watchesToDelete = new LinkedList<>();
    for (ProjectWatchInfo projectInfo : input) {
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, new Project.NameKey(projectInfo.project), projectInfo.filter);
        if (watchedProjectsMap.containsKey(key)) {
            watchesToDelete.add(watchedProjectsMap.get(key));
        }
    }
    dbProvider.get().accountProjectWatches().delete(watchesToDelete);
    accountCache.evict(accountId);
}
#method_after
private void deleteFromDb(Account.Id accountId, List<ProjectWatchInfo> input) throws OrmException, IOException {
    ResultSet<AccountProjectWatch> watchedProjects = dbProvider.get().accountProjectWatches().byAccount(accountId);
    HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>();
    for (AccountProjectWatch watchedProject : watchedProjects) {
        watchedProjectsMap.put(watchedProject.getKey(), watchedProject);
    }
    List<AccountProjectWatch> watchesToDelete = new LinkedList<>();
    for (ProjectWatchInfo projectInfo : input) {
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, new Project.NameKey(projectInfo.project), projectInfo.filter);
        if (watchedProjectsMap.containsKey(key)) {
            watchesToDelete.add(watchedProjectsMap.get(key));
        }
    }
    if (!watchesToDelete.isEmpty()) {
        dbProvider.get().accountProjectWatches().delete(watchesToDelete);
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#end_block

#method_before
public static Map<ProjectWatchKey, Collection<NotifyType>> readProjectWatchesFromDb(ReviewDb db, Account.Id who) throws OrmException {
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = new HashMap<>();
    Collection<AccountProjectWatch> accountProjectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    for (AccountProjectWatch apw : accountProjectWatches) {
        ProjectWatchKey key = ProjectWatchKey.create(apw.getProjectNameKey(), apw.getFilter());
        Set<NotifyType> notifyValues = new HashSet<>();
        if (apw.isNotify(NotifyType.ABANDONED_CHANGES)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (apw.isNotify(NotifyType.ALL_COMMENTS)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (apw.isNotify(NotifyType.NEW_CHANGES)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (apw.isNotify(NotifyType.NEW_PATCHSETS)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (apw.isNotify(NotifyType.SUBMITTED_CHANGES)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        projectWatches.put(key, notifyValues);
    }
    return projectWatches;
}
#method_after
public static Map<ProjectWatchKey, Set<NotifyType>> readProjectWatchesFromDb(ReviewDb db, Account.Id who) throws OrmException {
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = new HashMap<>();
    for (AccountProjectWatch apw : db.accountProjectWatches().byAccount(who)) {
        ProjectWatchKey key = ProjectWatchKey.create(apw.getProjectNameKey(), apw.getFilter());
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        for (NotifyType notifyType : NotifyType.values()) {
            if (apw.isNotify(notifyType)) {
                notifyValues.add(notifyType);
            }
        }
        projectWatches.put(key, notifyValues);
    }
    return projectWatches;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    CodeReviewCommit merged = toMerge;
    // Modify the fast forward commit with gitlink update
    if (args.submoduleOp.hasSubscription(args.destBranch)) {
        try {
            merged = args.submoduleOp.composeGitlinksCommit(args.destBranch, merged);
        } catch (SubmoduleException | OrmException e) {
            logError("can not update gitlink for the merge commit at branch: " + args.destBranch);
        }
    }
    args.mergeTip.moveTipTo(merged, toMerge);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException {
    args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    PersonIdent caller = ctx.getUser().asIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
    if (args.mergeTip.getCurrentTip() == null) {
        throw new IllegalStateException("cannot merge commit " + toMerge.name() + " onto a null tip; expected at least one fast-forward prior to" + " this operation");
    }
    // TODO(dborowitz): args.rw is needed because it's a CodeReviewRevWalk.
    // When hoisting BatchUpdate into MergeOp, we will need to teach
    // BatchUpdate how to produce CodeReviewRevWalks.
    CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge);
    // Modify the mergy commit with gitlink update
    if (args.submoduleOp.hasSubscription(args.destBranch)) {
        try {
            merged = args.submoduleOp.composeGitlinksCommit(args.destBranch, merged);
        } catch (SubmoduleException | OrmException e) {
            logError("can not update gitlink for the merge commit at branch: " + args.destBranch);
        }
    }
    args.mergeTip.moveTipTo(merged, toMerge);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    PersonIdent caller = ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
    if (args.mergeTip.getCurrentTip() == null) {
        throw new IllegalStateException("cannot merge commit " + toMerge.name() + " onto a null tip; expected at least one fast-forward prior to" + " this operation");
    }
    // TODO(dborowitz): args.rw is needed because it's a CodeReviewRevWalk.
    // When hoisting BatchUpdate into MergeOp, we will need to teach
    // BatchUpdate how to produce CodeReviewRevWalks.
    CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge);
    args.mergeTip.moveTipTo(amendGitlink(merged), toMerge);
}
#end_block

#method_before
private void checkSubmitRulesAndState() throws ResourceConflictException {
    for (ChangeData cd : commits.changes.values()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState();
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projectsWithChanges = br.keySet();
    Collection<Branch.NameKey> branchesWithChanges = cbb.keySet();
    openRepos(projectsWithChanges);
    for (Branch.NameKey branch : branchesWithChanges) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>();
    SubmoduleOp submoduleOp = subOpFactory.create(br.values(), orm);
    try {
        LinkedHashSet<Branch.NameKey> branches = submoduleOp.getOrdedBranches();
        for (Branch.NameKey branch : branchesWithChanges) {
            if (!branches.contains(branch)) {
                branches.add(branch);
            }
        }
        for (Branch.NameKey branch : branches) {
            OpenRepo or = orm.getRepo(branch.getParentKey());
            if (cbb.containsKey(branch)) {
                BranchBatch submitting = toSubmit.get(branch);
                OpenBranch ob = or.getBranch(branch);
                checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
                Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
                ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
                SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp);
                strategies.add(strategy);
                strategy.addOps(or.getUpdate(), commitsToSubmit);
            } else {
                // no open change for this branch
                // add submodule triggered op into BatchUpdate
                or.getUpdate().addRepoOnlyOp(new SubmoduleOp.RepoOnlyOp(submoduleOp, branch));
            }
        }
        LinkedHashSet<Project.NameKey> projects = submoduleOp.getOrdedProjects();
        for (Project.NameKey project : projectsWithChanges) {
            if (!projects.contains(project)) {
                projects.add(project);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(or.rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commits.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = new PatchSetApproval(new PatchSetApproval.Key(psId, ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    submitter.setValue((short) 1);
    submitter.setGranted(ctx.getWhen());
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#method_after
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = new PatchSetApproval(new PatchSetApproval.Key(psId, ctx.getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    submitter.setValue((short) 1);
    submitter.setGranted(ctx.getWhen());
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#end_block

#method_before
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    checkNotNull(psId);
    String uuid;
    try {
        uuid = ChangeUtil.messageUUID(ctx.getDb());
    } catch (OrmException e) {
        return null;
    }
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), uuid), ctx.getUser().getAccountId(), ctx.getWhen(), psId);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    checkNotNull(psId);
    String uuid;
    try {
        uuid = ChangeUtil.messageUUID(ctx.getDb());
    } catch (OrmException e) {
        return null;
    }
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), uuid), ctx.getAccountId(), ctx.getWhen(), psId);
    m.setMessage(body);
    return m;
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), args.mergeTip.getCurrentTip().name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = gitmodulesFactory.create(targetBranch, orm);
            for (SubmoduleSubscription ss : m.subscribedTo(srcBranch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = branchGitModules.get(targetBranch);
            if (m == null) {
                m = gitmodulesFactory.create(targetBranch, orm);
                branchGitModules.put(targetBranch, m);
            }
            ret.addAll(m.subscribedTo(srcBranch));
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> projects = getOrdedProjects();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    ImmutableSet<Project.NameKey> projects = getProjectsInOrder();
    if (projects == null) {
        return;
    }
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> superProjects = new LinkedHashSet<>();
    try {
        for (Project.NameKey project : projects) {
            // only need superprojects
            if (dst.containsKey(project)) {
                superProjects.add(project);
                // get a new BatchUpdate for the super project
                orm.openRepo(project, false);
                for (Branch.NameKey branch : dst.get(project)) {
                    addOp(orm.getRepo(project).getUpdate(), branch);
                }
            }
        }
        BatchUpdate.execute(orm.batchUpdates(superProjects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = gitmodulesFactory.create(targetBranch, orm);
            for (SubmoduleSubscription ss : m.subscribedTo(srcBranch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = branchGitModules.get(targetBranch);
            if (m == null) {
                m = gitmodulesFactory.create(targetBranch, orm);
                branchGitModules.put(targetBranch, m);
            }
            ret.addAll(m.subscribedTo(srcBranch));
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> projects = getOrdedProjects();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    ImmutableSet<Project.NameKey> projects = getProjectsInOrder();
    if (projects == null) {
        return;
    }
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> superProjects = new LinkedHashSet<>();
    try {
        for (Project.NameKey project : projects) {
            // only need superprojects
            if (dst.containsKey(project)) {
                superProjects.add(project);
                // get a new BatchUpdate for the super project
                orm.openRepo(project, false);
                // TODO:czhen remove this when MergeOp combine this into BatchUpdate
                orm.getRepo(project).resetUpdate();
                for (Branch.NameKey branch : dst.get(project)) {
                    SubmoduleOp.GitlinkOp op = new SubmoduleOp.GitlinkOp(branch);
                    orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
                }
            }
        }
        BatchUpdate.execute(orm.batchUpdates(superProjects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
@Test
public void testRecursiveSubmodules() throws Exception {
    TestRepository<?> topRepo = createProjectWithPush("top-project");
    TestRepository<?> midRepo = createProjectWithPush("mid-project");
    TestRepository<?> bottomRepo = createProjectWithPush("bottom-project");
    allowSubmoduleSubscription("mid-project", "refs/heads/master", "top-project", "refs/heads/master");
    allowSubmoduleSubscription("bottom-project", "refs/heads/master", "mid-project", "refs/heads/master");
    createSubmoduleSubscription(topRepo, "master", "mid-project", "master");
    createSubmoduleSubscription(midRepo, "master", "bottom-project", "master");
    ObjectId bottomHead = bottomRepo.branch("HEAD").commit().insertChangeId().message("some change").add("a.txt", "a contents ").create();
    bottomRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    RevCommit c = bottomRepo.getRevWalk().parseCommit(bottomHead);
    RevCommit c1 = bottomRepo.branch("HEAD").commit().insertChangeId().message("first change").add("asdf", "asdf\n").create();
    bottomRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    bottomRepo.reset(c.getId());
    RevCommit c2 = bottomRepo.branch("HEAD").commit().insertChangeId().message("qwerty").add("qwerty", "qwerty").create();
    RevCommit c3 = bottomRepo.branch("HEAD").commit().insertChangeId().message("qwerty followup").add("qwerty", "qwerty\nqwerty\n").create();
    bottomRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    RevCommit c4 = topRepo.branch("HEAD").commit().insertChangeId().message("new change on top project").add("foo", "bar").create();
    topRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    String id1 = getChangeId(bottomRepo, c1).get();
    String id2 = getChangeId(bottomRepo, c2).get();
    String id3 = getChangeId(bottomRepo, c3).get();
    String id4 = getChangeId(topRepo, c4).get();
    gApi.changes().id(id1).current().review(ReviewInput.approve());
    gApi.changes().id(id2).current().review(ReviewInput.approve());
    gApi.changes().id(id3).current().review(ReviewInput.approve());
    gApi.changes().id(id4).current().review(ReviewInput.approve());
    gApi.changes().id(id1).current().submit();
    ObjectId bottomRepoId = bottomRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    ObjectId midRepoId = midRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    expectToHaveSubmoduleState(midRepo, "master", "bottom-project", bottomRepoId);
    expectToHaveSubmoduleState(topRepo, "master", "mid-project", midRepoId);
}
#method_after
@Test
public void testRecursiveSubmodules() throws Exception {
    TestRepository<?> topRepo = createProjectWithPush("top-project");
    TestRepository<?> midRepo = createProjectWithPush("mid-project");
    TestRepository<?> bottomRepo = createProjectWithPush("bottom-project");
    allowSubmoduleSubscription("mid-project", "refs/heads/master", "top-project", "refs/heads/master");
    allowSubmoduleSubscription("bottom-project", "refs/heads/master", "mid-project", "refs/heads/master");
    createSubmoduleSubscription(topRepo, "master", "mid-project", "master");
    createSubmoduleSubscription(midRepo, "master", "bottom-project", "master");
    ObjectId bottomHead = pushChangeTo(bottomRepo, "refs/for/master", "some message", "same-topic");
    ObjectId topHead = pushChangeTo(topRepo, "refs/for/master", "some message", "same-topic");
    String id1 = getChangeId(bottomRepo, bottomHead).get();
    String id2 = getChangeId(topRepo, topHead).get();
    gApi.changes().id(id1).current().review(ReviewInput.approve());
    gApi.changes().id(id2).current().review(ReviewInput.approve());
    gApi.changes().id(id1).current().submit();
    assertThat(hasSubmodule(midRepo, "master", "bottom-project")).isTrue();
    assertThat(hasSubmodule(topRepo, "master", "mid-project")).isTrue();
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        // b - current commit object (not a hash commit)
        final RevCommit b = rw.parseCommit(key.getNewId());
        // a - ancestor object
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry e = diffEntries.get(i);
            if (paths == null || paths.contains(e.getNewPath()) || paths.contains(e.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, e);
                long oldSize = getFileSize(repo, reader, e.getOldMode(), e.getOldPath(), aTree);
                long newSize = getFileSize(repo, reader, e.getNewMode(), e.getNewPath(), bTree);
                entries.add(newEntry(aTree, fh, newSize - oldSize));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null && b.getParentCount() == 1) {
            PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry e = diffEntries.get(i);
            if (paths == null || paths.contains(e.getNewPath()) || paths.contains(e.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, e);
                long oldSize = getFileSize(repo, reader, e.getOldMode(), e.getOldPath(), aTree);
                long newSize = getFileSize(repo, reader, e.getNewMode(), e.getNewPath(), bTree);
                entries.add(newEntry(aTree, fh, newSize, newSize - oldSize));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            synchronized (lock) {
                return diffFormatter.toFileHeader(diffEntry);
            }
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + project + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        synchronized (lock) {
            return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
        }
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            synchronized (diffEntry) {
                return diffFormatter.toFileHeader(diffEntry);
            }
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + project + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        synchronized (diffEntry) {
            return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
        }
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes(UTF_8);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, sizeDelta);
}
#method_after
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes(UTF_8);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long size = bContent.length;
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, size, sizeDelta);
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long size, long sizeDelta) {
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), size, sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), size, sizeDelta);
    }
    return new PatchListEntry(fileHeader, edits, size, sizeDelta);
}
#end_block

#method_before
private RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#method_after
private RevObject aFor(PatchListKey key, Repository repo, RevWalk rw, ObjectInserter ins, RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            if (key.getParentNum() != null) {
                RevCommit r = b.getParent(key.getParentNum() - 1);
                rw.parseBody(r);
                return r;
            }
            return autoMerger.merge(repo, rw, ins, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#end_block

#method_before
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.reviewer).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#method_after
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.input).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#end_block

#method_before
@Test
public void addCcAccount() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#method_after
@Test
public void addCcAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#end_block

#method_before
@Test
public void addCcGroup() throws Exception {
    List<TestAccount> users = createAccounts(6, "addCcGroup");
    List<String> usernames = new ArrayList<>(6);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    List<TestAccount> firstUsers = users.subList(0, 3);
    List<String> firstUsernames = usernames.subList(0, 3);
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = createGroup("cc1");
    in.state = CC;
    gApi.groups().id(in.reviewer).addMembers(firstUsernames.toArray(new String[firstUsernames.size()]));
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
    } else {
        assertThat(result.ccs).isNull();
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, CC, firstUsers);
    // Verify emails were sent to each of the group's accounts.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    List<Address> expectedAddresses = new ArrayList<>(firstUsers.size());
    for (TestAccount u : firstUsers) {
        expectedAddresses.add(u.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
    // CC a group that overlaps with some existing reviewers and CCed accounts.
    TestAccount reviewer = accounts.create(name("reviewer"), "addCcGroup-reviewer@example.com", "Reviewer");
    result = addReviewer(changeId, reviewer.username);
    assertThat(result.error).isNull();
    sender.clear();
    in.reviewer = createGroup("cc2");
    gApi.groups().id(in.reviewer).addMembers(usernames.toArray(new String[usernames.size()]));
    gApi.groups().id(in.reviewer).addMembers(reviewer.username);
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.ccs).hasSize(3);
        assertThat(result.reviewers).isNull();
        assertReviewers(c, REVIEWER, reviewer);
        assertReviewers(c, CC, users);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(3);
        List<TestAccount> expectedUsers = new ArrayList<>(users.size() + 2);
        expectedUsers.addAll(users);
        expectedUsers.add(reviewer);
        assertReviewers(c, CC, expectedUsers);
    }
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    expectedAddresses = new ArrayList<>(4);
    for (int i = 0; i < 3; i++) {
        expectedAddresses.add(users.get(users.size() - i - 1).emailAddress);
    }
    if (notesMigration.readChanges()) {
        expectedAddresses.add(reviewer.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
}
#method_after
@Test
public void addCcGroup() throws Exception {
    List<TestAccount> users = createAccounts(6, "addCcGroup");
    List<String> usernames = new ArrayList<>(6);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    List<TestAccount> firstUsers = users.subList(0, 3);
    List<String> firstUsernames = usernames.subList(0, 3);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = createGroup("cc1");
    in.state = CC;
    gApi.groups().id(in.reviewer).addMembers(firstUsernames.toArray(new String[firstUsernames.size()]));
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
    } else {
        assertThat(result.ccs).isNull();
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, CC, firstUsers);
    // Verify emails were sent to each of the group's accounts.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    List<Address> expectedAddresses = new ArrayList<>(firstUsers.size());
    for (TestAccount u : firstUsers) {
        expectedAddresses.add(u.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
    // CC a group that overlaps with some existing reviewers and CCed accounts.
    TestAccount reviewer = accounts.create(name("reviewer"), "addCcGroup-reviewer@example.com", "Reviewer");
    result = addReviewer(changeId, reviewer.username);
    assertThat(result.error).isNull();
    sender.clear();
    in.reviewer = createGroup("cc2");
    gApi.groups().id(in.reviewer).addMembers(usernames.toArray(new String[usernames.size()]));
    gApi.groups().id(in.reviewer).addMembers(reviewer.username);
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.ccs).hasSize(3);
        assertThat(result.reviewers).isNull();
        assertReviewers(c, REVIEWER, reviewer);
        assertReviewers(c, CC, users);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(3);
        List<TestAccount> expectedUsers = new ArrayList<>(users.size() + 2);
        expectedUsers.addAll(users);
        expectedUsers.add(reviewer);
        assertReviewers(c, CC, expectedUsers);
    }
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    expectedAddresses = new ArrayList<>(4);
    for (int i = 0; i < 3; i++) {
        expectedAddresses.add(users.get(users.size() - i - 1).emailAddress);
    }
    if (notesMigration.readChanges()) {
        expectedAddresses.add(reviewer.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
}
#end_block

#method_before
@Test
public void reviewAndAddReviewers() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    // Verify reviewer and CC were added. If not in NoteDb read mode, both
    // parties will be returned as CCed.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, observer);
    } else {
        // In legacy mode, change owner should be the only reviewer.
        assertReviewers(c, REVIEWER, admin);
        assertReviewers(c, CC, user, observer);
    }
    // Verify emails were sent to added reviewers.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(3);
    // First email to user.
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    // Second email to reviewer and observer.
    m = messages.get(1);
    if (notesMigration.readChanges()) {
        assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.rcpt()).containsExactly(observer.emailAddress);
        assertThat(m.body()).contains("Hello " + observer.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
    // Third email is review to user and observer.
    m = messages.get(2);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has posted comments on this change.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertThat(m.body()).contains("Patch Set 1: Code-Review+2\n");
}
#method_after
@Test
public void reviewAndAddReviewers() throws Exception {
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    // Verify reviewer and CC were added. If not in NoteDb read mode, both
    // parties will be returned as CCed.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, observer);
    } else {
        // In legacy mode, change owner should be the only reviewer.
        assertReviewers(c, REVIEWER, admin);
        assertReviewers(c, CC, user, observer);
    }
    // Verify emails were sent to added reviewers.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(3);
    // First email to user.
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    // Second email to reviewer and observer.
    m = messages.get(1);
    if (notesMigration.readChanges()) {
        assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.rcpt()).containsExactly(observer.emailAddress);
        assertThat(m.body()).contains("Hello " + observer.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
    // Third email is review to user and observer.
    m = messages.get(2);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has posted comments on this change.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertThat(m.body()).contains("Patch Set 1: Code-Review+2\n");
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    if (actualAccounts == null) {
        assertThat(accounts.iterator().hasNext()).isFalse();
        return;
    }
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#end_block

#method_before
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    addition.apply(rsrc);
    return addition.result;
}
#method_after
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    if (addition.op == null) {
        return addition.result;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, addition.op);
        bu.execute();
        addition.gatherResults();
    }
    return addition.result;
}
#end_block

#method_before
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException {
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException, IOException {
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IOException e) {
        // TODO(logan): return error to client
        throw new UnprocessableEntityException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state());
}
#method_after
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state());
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedCCs != null) {
        emailCCs(rsrc.getChange(), addedCCs);
    }
    if (addedReviewers != null) {
        emailReviewers(rsrc.getChange(), addedReviewers);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account);
            }
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), addedReviewers, addedCCs);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getAccount(), ctx.getWhen());
            }
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added, Collection<Account.Id> copied) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
@Override
public ReviewResult apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public ReviewResult apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public ReviewResult apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        // TODO(logan): return new PatchSetApprovals
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return output;
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            // Generate result details and fill AccountLoader. This occurs outside
            // the Op because the accounts are in a different table.
            PostReviewers.Op op = reviewerResult.op;
            if (migration.readChanges() && op.state == ReviewerState.CC) {
                reviewerResult.result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
                for (Account.Id accountId : op.addedCCs) {
                    reviewerResult.result.ccs.add(reviewerJson.format(new ReviewerInfo(accountId.get()), op.reviewers.get(accountId)));
                }
                accountLoaderFactory.create(true).fill(reviewerResult.result.ccs);
            } else {
                reviewerResult.result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
                for (PatchSetApproval psa : op.addedReviewers) {
                    // New reviewers have value 0, don't bother normalizing.
                    reviewerResult.result.reviewers.add(reviewerJson.format(new ReviewerInfo(psa.getAccountId().get()), op.reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
                }
                accountLoaderFactory.create(true).fill(reviewerResult.result.reviewers);
            }
        }
    }
    return output;
}
#method_after
public ReviewResult apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return output;
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return output;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.needsConfirmation = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getUser().asIdentifiedUser().getAccount(), ctx.getWhen());
        }
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    if (filter == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(SC_NOT_IMPLEMENTED);
        return;
    }
    filter.doFilter(req, res, chain);
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    if (filter.get() == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(SC_NOT_IMPLEMENTED);
        return;
    }
    filter.get().doFilter(req, res, chain);
}
#end_block

#method_before
private void install(Plugin plugin) {
    if (!plugin.getName().equals(pluginName)) {
        return;
    }
    filter = load(plugin);
}
#method_after
private void install(Plugin plugin) {
    if (!plugin.getName().equals(pluginName)) {
        return;
    }
    final GuiceFilter guiceFilter = load(plugin);
    plugin.add(new RegistrationHandle() {

        @Override
        public void remove() {
            filter.compareAndSet(guiceFilter, null);
        }
    });
    filter.set(guiceFilter);
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter guiceFilter;
        try {
            guiceFilter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, "/");
            guiceFilter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                guiceFilter.destroy();
                if (guiceFilter == filter) {
                    filter = null;
                }
            }
        });
        return guiceFilter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter guiceFilter;
        try {
            guiceFilter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, "/");
            guiceFilter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                guiceFilter.destroy();
            }
        });
        return guiceFilter;
    }
    return null;
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().update(zero(normalized.deleted()));
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                if (p.commit.name().equals(changes.get(0).currentPatchSet().getRevision().get())) {
                    // All PatchSets in push are currentPatchSet of target changes
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, SetMultimap<ObjectId, Ref> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.put(ref.getObjectId(), ref);
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@BeforeClass
public static void setTimeForTesting() {
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@BeforeClass
public static void setTimeForTesting() {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
}
#end_block

#method_before
@AfterClass
public static void restoreTime() {
    DateTimeUtils.setCurrentMillisSystem();
}
#method_after
@AfterClass
public static void restoreTime() {
    TestTimeUtil.useSystemTime();
}
#end_block

#method_before
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
}
#method_after
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    gApi.projects().name(project.get()).branch("otherBranch").create(new BranchInput());
    PushOneCommit.Result r2 = push.to("refs/for/otherBranch");
    r2.assertOkStatus();
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    List<ChangeInfo> changes = query(r.getCommitId().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    // Append and push unknown permission
    config += "[access \"" + refsFor + "\"]\n" + "\tunknownPermission = group Registered Users\n";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to("refs/meta/config").assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    assertThat(config).containsMatch("unknownPermission");
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    assertThat(config).containsMatch("unknownPermission");
}
#method_after
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to("refs/meta/config").assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#end_block

#method_before
public void remove(AccessSection section) {
    if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        if (!a.hasMoreConfig()) {
            accessSections.remove(a);
        } else {
            a.setPermissions(new ArrayList<Permission>());
        }
    }
}
#method_after
public void remove(AccessSection section) {
    if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        if (sectionsWithUnknownPermissions.contains(a)) {
            accessSections.remove(a);
        } else {
            a.setPermissions(new ArrayList<Permission>());
        }
    }
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    as.setHasMoreConfig(true);
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    sectionsWithUnknownPermissions.add(as);
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = ReviewDbUtil.unwrapDb(schemaFactory.open())) {
                        return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = unwrapDb(schemaFactory.open())) {
                        return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#end_block

#method_before
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = ReviewDbUtil.unwrapDb(db).changes().get(Iterables.transform(changes, new Function<Integer, Change.Id>() {

                @Override
                public Change.Id apply(Integer in) {
                    return new Change.Id(in);
                }
            }));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : ReviewDbUtil.unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#method_after
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = unwrapDb(db).changes().get(Iterables.transform(changes, new Function<Integer, Change.Id>() {

                @Override
                public Change.Id apply(Integer in) {
                    return new Change.Id(in);
                }
            }));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) ReviewDbUtil.unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    // Use local unwrap as we need to handle BatchUpdateReviewDb as well.
    ReviewDb db = unwrap(ctx.getDb());
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(change.getProject(), id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    ReviewDb db = unwrap(ctx.getDb());
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(change.getProject(), id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return r;
}
#method_after
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        if (!migration.failChangeWrites()) {
            manager.execute();
        } else {
            // results instead of reading from the repo.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return r;
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    ChangeNotes notes = create(db, c.getProject(), c.getId());
    if (notes.getChange() == null) {
        throw new NoSuchChangeException(c.getId());
    }
    return notes;
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    return createChecked(db, c.getProject(), c.getId());
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    ChangeNotes notes = create(db, project, changeId);
    if (notes.getChange() == null) {
        throw new NoSuchChangeException(changeId);
    }
    return notes;
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    Change change = ReviewDbUtil.unwrapDb(db).changes().get(changeId);
    if (change == null || !change.getProject().equals(project)) {
        throw new NoSuchChangeException(changeId);
    }
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(ReviewDbUtil.unwrapDb(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    return new ChangeNotes(args, change).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#method_after
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(ReviewDbUtil.unwrapDb(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    // request scope for the rebuilder to open the db.
                    return new ChangeNotes(args, change, false, null).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.writeChanges()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // this is a programmer error.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.commitChangeWrites()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    try {
        ChangeContext ctx;
        NoteDbUpdateManager updateManager = null;
        boolean dirty = false;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                return;
            }
            deleted = ctx.deleted;
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.writeChanges()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                db.changes().insert(cs);
            } else if (deleted) {
                db.changes().delete(cs);
            } else {
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.writeChanges()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    try {
        ChangeContext ctx;
        NoteDbUpdateManager updateManager = null;
        boolean dirty = false;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                return;
            }
            deleted = ctx.deleted;
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                db.changes().insert(cs);
            } else if (deleted) {
                db.changes().delete(cs);
            } else {
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    final List<String> idList = receiveEvent.commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = receiveEvent.commit.getShortMessage();
            String changeIdPrefix = FooterConstants.CHANGE_ID.getName() + ":";
            if (shortMsg.startsWith(changeIdPrefix) && shortMsg.substring(changeIdPrefix.length()).trim().matches("^I[0-9a-f]{8,}.*$")) {
                throw new CommitValidationException("missing subject; Change-Id must be in commit message footer");
            } else {
                String errMsg = "missing Change-Id in commit message footer";
                messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
                throw new CommitValidationException(errMsg, messages);
            }
        }
    } else if (idList.size() > 1) {
        throw new CommitValidationException("multiple Change-Id lines in commit message footer", messages);
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message footer";
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(changeId) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert Change-Id, install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#method_after
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    }
    return "http://" + getGerritHost(canonicalWebUrl);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return;
    }
    if (!ctx.getChangeControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = ctx.getChangeUpdate();
    ChangeNotes notes = update.getChangeNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updated.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
    }
    change = update.getChange();
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add hashtags; NoteDb is disabled");
    }
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return false;
    }
    if (!ctx.getControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    ChangeNotes notes = update.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    updated.addAll(existingHashtags);
    toAdd.removeAll(existingHashtags);
    toRemove.retainAll(existingHashtags);
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
        addMessage(ctx, update);
    }
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
    return true;
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectControl ctl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.asIdentifiedUser().getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, Input input) throws OrmException, IOException, ResourceConflictException {
    input = Input.init(input);
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteBranchesInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteBranchesInput();
    }
    if (input.branches == null) {
        input.branches = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst));
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.resetRetain(subOr.canMergeFlag);
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, PutDescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new PutDescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(resource.getNameKey(), RefNames.REFS_CONFIG, baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            } else {
                itr.remove();
                continue;
            }
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            } else {
                itr.remove();
                continue;
            }
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#method_after
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change.getLastUpdatedOn().before(ctx.getWhen())) {
        change.setLastUpdatedOn(ctx.getWhen());
    }
    ps = ctx.getDb().patchSets().get(psId);
    ctx.getChangeUpdate().setPatchSetId(psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    if (dirty) {
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, change, ps, user.getAccountId(), message, comments).sendAsync();
    }
    commentAdded.fire(change, ps, user.getAccount(), message.getMessage(), categories, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(ctx.getDb(), ctx.getChangeUpdate(), del);
    plcUtil.upsertComments(ctx.getDb(), ctx.getChangeUpdate(), ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = new ArrayList<>();
    List<PatchLineComment> ups = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getChangeNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#method_after
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getChangeNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getChangeNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getChangeUpdate();
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), ReviewerState.REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getChangeControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Map<String, PatchSetApproval> current = Maps.newHashMap();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getChangeControl(), psId, user.getAccountId())) {
        if (a.isSubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#method_after
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, PatchSetApproval> current = new HashMap<>();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getControl(), psId, user.getAccountId())) {
        if (a.isLegacySubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    Change.Id id = onto.getId();
                    final ReplaceRequest req = new ReplaceRequest(id, c, cmd, false);
                    req.change = onto;
                    if (req.validate(true)) {
                        req.addOps(bu, null);
                        bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                            @Override
                            public PatchSet get() {
                                return req.replaceOp.getPatchSet();
                            }
                        }));
                        bu.addOp(id, new ChangeProgressOp(closeProgress));
                    }
                    break;
                }
            }
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(ctl, input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    ChangeUtil.updated(change);
    ctx.getDb().changes().update(Collections.singleton(change));
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), caller.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), cmsg);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, caller.getAccount(), oldTopicName);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, ctx.getUser().asIdentifiedUser().getAccount(), oldTopicName);
    }
}
#end_block

#method_before
public ConfigInfo apply(ProjectControl ctrl, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = ctrl.getProject().getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.get().create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(ctrl.getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(projectName, RefNames.REFS_CONFIG, baseRev, commitRev, user.get().asIdentifiedUser().getAccount());
            }
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                log.warn(String.format("Failed to update config of project %s.", projectName), e);
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    return apply(rsrc.getControl(), input);
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntryType.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeMergedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    bind(CommentAddedListener.class).to(ChangeHookApiListener.class);
    bind(DraftPublishedListener.class).to(ChangeHookApiListener.class);
    bind(GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    bind(HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    bind(MergeFailedListener.class).to(ChangeHookApiListener.class);
    bind(NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    bind(ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    bind(RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    bind(TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), AgreementSignupListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), DraftPublishedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = receiveEvent.commit.getParent(0);
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
          * If the ref-update hook tries to distinguish behavior between pushes to
          * refs/heads/... and refs/for/..., make sure we send it the correct refname.
          * Also, if this is targetting refs/for/, make sure we behave the same as
          * what a push to refs/for/ would behave; in particular, setting oldrev to
          * 0000000000000000000000000000000000000000.
          */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = ObjectId.zeroId();
    if (receiveEvent.commit.getParentCount() > 0) {
        old = receiveEvent.commit.getParent(0);
    }
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
        * If the ref-update hook tries to distinguish behavior between pushes to
        * refs/heads/... and refs/for/..., make sure we send it the correct
        * refname.
        * Also, if this is targetting refs/for/, make sure we behave the same as
        * what a push to refs/for/ would behave; in particular, setting oldrev
        * to 0000000000000000000000000000000000000000.
        */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        hooks.doPatchsetCreatedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doPatchsetCreatedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("PatchsetCreated hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        hooks.doDraftPublishedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doDraftPublishedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("DraftPublished hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = new HashMap<String, Short>();
    for (Entry<String, ApprovalInfo> e : ev.getApprovals().entrySet()) {
        approvals.put(e.getKey(), e.getValue().value.shortValue());
    }
    try {
        hooks.doCommentAddedHook(getChange(ev.getChange()), getAccount(ev.getAuthor()), getPatchSet(ev.getRevision()), ev.getComment(), approvals, db.get());
    } catch (OrmException e) {
        log.warn("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = convertApprovalsMap(ev.getApprovals());
    Map<String, Short> oldApprovals = convertApprovalsMap(ev.getOldApprovals());
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doCommentAddedHook(notes.getChange(), getAccount(ev.getAuthor()), getPatchSet(notes, ev.getRevision()), ev.getComment(), approvals, oldApprovals, db.get());
    } catch (OrmException e) {
        log.error("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        hooks.doChangeMergedHook(getChange(ev.getChange()), getAccount(ev.getMerger()), getPatchSet(ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeMergedHook(notes.getChange(), getAccount(ev.getMerger()), getPatchSet(notes, ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        hooks.doChangeAbandonedHook(getChange(ev.getChange()), getAccount(ev.getAbandoner()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeAbandonedHook(notes.getChange(), getAccount(ev.getAbandoner()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeAbandoned hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        hooks.doChangeRestoredHook(getChange(ev.getChange()), getAccount(ev.getRestorer()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeRestoredHook(notes.getChange(), getAccount(ev.getRestorer()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeRestored hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        Change change = getChange(ev.getChange());
        PatchSet patch = db.get().patchSets().get(change.currentPatchSetId());
        hooks.doReviewerAddedHook(change, getAccount(ev.getReviewer()), patch, db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), db.get());
    } catch (OrmException e) {
        log.error("ReviewerAdded hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
        log.error("TopicChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), new HashSet<String>(ev.getAddedHashtags()), new HashSet<String>(ev.getRemovedHashtags()), new HashSet<String>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), new HashSet<>(ev.getAddedHashtags()), new HashSet<>(ev.getRemovedHashtags()), new HashSet<>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
        log.error("HashtagsChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
private PatchSet getPatchSet(RevisionInfo info) throws OrmException {
    return db.get().patchSets().get(PatchSet.Id.fromRef(info.ref));
}
#method_after
private PatchSet getPatchSet(ChangeNotes notes, RevisionInfo info) throws OrmException {
    return psUtil.get(db.get(), notes, PatchSet.Id.fromRef(info.ref));
}
#end_block

#method_before
public PatchSetInserter setGroups(Iterable<String> groups) {
    this.groups = groups;
    return this;
}
#method_after
public PatchSetInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be null");
    this.groups = groups;
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException {
    ChangeControl ctl = ctx.getChangeControl();
    change = ctx.getChange();
    Change.Id id = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getChange().getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    // TODO(dborowitz): Throw ResourceConflictException instead of using
    // AtomicUpdate.
    change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isClosed() && !allowClosed) {
                return null;
            }
            if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                return null;
            }
            if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                change.setStatus(Change.Status.NEW);
            }
            change.setCurrentPatchSet(patchSetInfo);
            ChangeUtil.updated(change);
            return change;
        }
    });
    if (change == null) {
        throw new ChangeModifiedException(String.format("Change %s was modified", id));
    }
    approvalCopier.copy(db, ctl, patchSet);
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
            cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(refControl, sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(origCtl.getRefControl(), sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            // ToDo claSigned.fireClaSigned() instead of
            // hooks.doClaSignupHook(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            agreementSignup.fire(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException {
    Account member = rsrc.getUser().getAccount();
    ChangeControl control = rsrc.getControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc, result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    List<PatchSetApproval> added;
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        added = approvalsUtil.addReviewers(db, rsrc.getNotes(), update, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(rsrc.getChange().getId());
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    indexFuture.checkedGet();
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setLabel("Publish").setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    if (!ctx.getChangeControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!ctx.getControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    if (patchSet == null) {
        patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
        if (patchSet == null) {
            throw new ResourceNotFoundException(psId.toString());
        }
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
    return true;
}
#end_block

#method_before
private void saveChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
private void saveChange(ChangeContext ctx) {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        update.setStatus(change.getStatus());
    }
}
#end_block

#method_before
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    patchSet = ctx.getDb().patchSets().get(psId);
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    patchSet.setDraft(false);
    // Force ETag invalidation if not done already
    if (!wasDraftChange) {
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
    ctx.getDb().patchSets().update(Collections.singleton(patchSet));
}
#method_after
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    psUtil.publish(ctx.getDb(), ctx.getUpdate(psId), patchSet);
}
#end_block

#method_before
private void addReviewers(ChangeContext ctx) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getChangeNotes()).values();
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet, footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getChangeUpdate(), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#method_after
private void addReviewers(ChangeContext ctx) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all();
    RevCommit commit = ctx.getRevWalk().parseCommit(ObjectId.fromString(patchSet.getRevision().get()));
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet.isDraft(), footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getUpdate(psId), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#end_block

#method_before
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
@Override
public Change getChange() {
    return change;
}
#method_after
public Change getChange() {
    checkState(change != null, "getChange() only valid after creating change");
    return change;
}
#end_block

#method_before
public ChangeInserter setDraft(boolean draft) {
    change.setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
    patchSet.setDraft(draft);
    return this;
}
#method_after
public ChangeInserter setDraft(boolean draft) {
    checkState(change == null, "setDraft(boolean) only valid before creating change");
    return setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
}
#end_block

#method_before
public ChangeInserter setGroups(Iterable<String> groups) {
    patchSet.setGroups(groups);
    return this;
}
#method_after
public ChangeInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be empty");
    checkState(patchSet == null, "setGroups(Iterable<String>) only valid before creating change");
    this.groups = groups;
    return this;
}
#end_block

#method_before
public PatchSet getPatchSet() {
    return patchSet;
}
#method_after
public PatchSet getPatchSet() {
    checkState(patchSet != null, "getPatchSet() only valid after creating change");
    return patchSet;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws InvalidChangeOperationException, IOException {
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    change.setCurrentPatchSet(patchSetInfo);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSet.getRefName()));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, null);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        ReviewDb db = ctx.getDb();
        if (approvals != null && !approvals.isEmpty()) {
            commentAdded.fire(change, patchSet, user.getAccount(), null, approvals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, InvalidChangeOperationException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
    String refName = patchSet.getId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, user);
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getUser().asIdentifiedUser());
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), caller.getAccountId(), change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change.getId());
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, caller.getAccount(), Strings.emptyToNull(input.message));
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(ctx.getProject(), change.getId());
        cm.setFrom(ctx.getUser().getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), Strings.emptyToNull(input.message));
}
#end_block

#method_before
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    initIndexType();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(true, /* enableMetrics */
        MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    if (!slave) {
        initIndexType();
    }
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : LuceneIndexModule.latestVersionWithOnlineUpgrade();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (!slave && indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(false));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    switch(indexType) {
        case LUCENE:
            modules.add(new LuceneIndexModule());
            break;
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook invocation failed", e);
    }
}
#end_block

#method_before
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        text.setText(info.topic());
        text.setTargetHistoryToken(PageLinks.toChangeQuery(PageLinks.op("topic", info.topic()) + "+" + "is:open"));
    }
}
#method_after
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        String topic = info.topic();
        text.setText(topic);
        text.setTargetHistoryToken(PageLinks.topicQuery(info.status(), topic));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdateAttribute refUpdate = getOneRefUpdate(project.get() + "-refs/heads/master");
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.newRev).isEqualTo(updatedHead.name());
}
#method_after
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdatedEvent refUpdate = eventRecorder.getOneRefUpdate(project.get(), "refs/heads/master");
    assertThat(refUpdate.refUpdate.get().oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.refUpdate.get().newRev).isEqualTo(updatedHead.name());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    changeMergedEvents = new HashMap<>();
    refUpdatedEvents = HashMultimap.create();
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (event instanceof ChangeMergedEvent) {
                ChangeMergedEvent e = (ChangeMergedEvent) event;
                ChangeAttribute c = e.change.get();
                PatchSetAttribute ps = e.patchSet.get();
                log.debug("Merged {},{} as {}", ps.number, c.number, e.newRev);
                changeMergedEvents.put(e.change.get().number, e.newRev);
            } else if (event instanceof RefUpdatedEvent) {
                RefUpdatedEvent e = (RefUpdatedEvent) event;
                RefUpdateAttribute r = e.refUpdate.get();
                log.debug("Branch {} ref updated from {} to {}", r.refName, r.oldRev, r.newRev);
                refUpdatedEvents.put(r.project + "-" + r.refName, r);
            }
        }

        @Override
        public CurrentUser getUser() {
            return factory.create(user.id);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    eventRecorder = eventRecorderFactory.create(user);
}
#end_block

#method_before
@After
public void cleanup() {
    eventListenerRegistration.remove();
    db.close();
}
#method_after
@After
public void cleanup() {
    eventRecorder.close();
    db.close();
}
#end_block

#method_before
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#method_after
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertMerged(change.changeId);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#end_block

#method_before
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    assertThat(changeMergedEvents).isNotEmpty();
    String newRev = changeMergedEvents.get(Integer.toString(change._number));
    assertThat(newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(newRev);
}
#method_after
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    ChangeMergedEvent event = eventRecorder.getOneChangeMerged(change.project, change.branch, Integer.toString(change._number));
    assertThat(event.newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(event.newRev);
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(StarredChangesUtil.DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "red", "blue"))));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList("yellow")), new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue"))));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "invalid label", "blue", "another invalid label"))));
}
#method_after
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "invalid label", "blue", "another invalid label")));
}
#end_block

#method_before
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + StarredChangesUtil.DEFAULT_LABEL + " and " + StarredChangesUtil.IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue", StarredChangesUtil.IGNORE_LABEL))));
}
#method_after
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + DEFAULT_LABEL + " and " + IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "blue", IGNORE_LABEL)));
}
#end_block

#method_before
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(StarredChangesUtil.IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(sender.getMessages()).hasSize(0);
}
#method_after
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    TestAccount user2 = accounts.user2();
    in = new AddReviewerInput();
    in.reviewer = user2.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    assertThat(messages.get(0).rcpt()).containsExactly(user2.emailAddress);
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Add an existing key again
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
}
#method_after
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#end_block

#method_before
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    super.removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#method_after
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#end_block

#method_before
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        try {
            Account.Id accountId = Account.Id.parse(s.substring(0, p));
            String label = s.substring(p + 1);
            return create(accountId, label);
        } catch (NumberFormatException e) {
            return null;
        }
    }
    return null;
}
#method_after
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        Integer id = Ints.tryParse(s.substring(0, p));
        if (id == null) {
            return null;
        }
        Account.Id accountId = new Account.Id(id);
        String label = s.substring(p + 1);
        return create(accountId, label);
    }
    return null;
}
#end_block

#method_before
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            if (labels.contains(DEFAULT_LABEL) && labels.contains(IGNORE_LABEL)) {
                throw IllegalLabelException.mutuallyExclusiveLabels(DEFAULT_LABEL, IGNORE_LABEL);
            }
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Account.Id accountId = Account.Id.parse(refPart);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#method_after
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Integer id = Ints.tryParse(refPart);
            if (id == null) {
                continue;
            }
            Account.Id accountId = new Account.Id(id);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.WHITESPACE.matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#method_after
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user);
        op.updateSuperProjects(db, branches, "receiveID", orm);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), user.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException {
            if (caller == Thread.currentThread()) {
                insertChange(ReceiveCommits.this.db);
            } else {
                try (ReviewDb threadLocalDb = schemaFactory.open()) {
                    insertChange(threadLocalDb);
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> insertChange() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException, RepositoryNotFoundException, IOException, NoSuchChangeException {
            try (RequestState state = requestState(caller)) {
                insertChange(state);
            }
            synchronizedIncrement(newProgress);
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        bu.execute();
    }
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException, NoSuchChangeException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, new SubmitInput());
    }
    addMessage("");
    Change c = notesFactory.createChecked(db, project.getNameKey(), rsrc.getChange().getId()).getChange();
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                }
                try (RequestState state = requestState(caller)) {
                    return insertPatchSet(state);
                }
            } catch (OrmException | IOException e) {
                log.error("Failed to insert patch set", e);
                throw e;
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    Timestamp ts = TimeUtil.nowTs();
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals, ts);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    revisionCreated.fire(change, newPatchSet, user.getAccountId());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        changeMerged.fire(change, newPatchSet, user.getAccount(), newCommit.getName());
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        commentAdded.fire(change, newPatchSet, user.getAccount(), null, approvals, ts);
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
private void updateGroups(RequestState state) throws RestApiException, UpdateException {
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.addOp(psId.getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
                List<String> oldGroups = ps.getGroups();
                if (oldGroups == null) {
                    if (groups == null) {
                        return false;
                    }
                } else if (sameGroups(oldGroups, groups)) {
                    return false;
                }
                psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            try (RequestState state = requestState(caller)) {
                updateGroups(state);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    changeMerged.fire(change, result.newPatchSet, user.getAccount(), commit.getName());
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException, UpdateException, RestApiException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change;
    try {
        change = notesFactory.createChecked(db, project.getNameKey(), cid).getChange();
    } catch (NoSuchChangeException e) {
        log.warn(project.getName() + " change " + cid + " is missing");
        return null;
    }
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (ps == null) {
        log.warn(project.getName() + " patch set " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(project.getNameKey(), ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
public Repository getRepository() throws IOException {
    initRepository();
    return repo;
}
#method_after
@Override
public Repository getRepository() throws IOException {
    return BatchUpdate.this.getRepository();
}
#end_block

#method_before
public ObjectInserter getInserter() throws IOException {
    initRepository();
    return inserter;
}
#method_after
public ObjectInserter getInserter() throws IOException {
    return BatchUpdate.this.getObjectInserter();
}
#end_block

#method_before
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    getBatchRefUpdate().addCommand(cmd);
}
#method_after
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    commands.add(cmd);
}
#end_block

#method_before
public Change getChange() {
    return update.getChange();
}
#method_after
public Change getChange() {
    Change c = ctl.getChange();
    checkNotNull(c);
    return c;
}
#end_block

#method_before
@SuppressWarnings("unused")
public void updateChange(ChangeContext ctx) throws Exception {
}
#method_after
@SuppressWarnings("unused")
public boolean updateChange(ChangeContext ctx) throws Exception {
    return false;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    try {
        Order order = getOrder(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        for (BatchUpdate u : updates) {
            u.executePostOps();
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    return this;
}
#method_after
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    commands = new ChainedReceiveCommands(repo);
    return this;
}
#end_block

#method_before
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
    }
}
#method_after
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
        commands = new ChainedReceiveCommands(repo);
    }
}
#end_block

#method_before
public BatchUpdate insertChange(InsertChangeOp op) {
    Change c = op.getChange();
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#method_after
public BatchUpdate insertChange(InsertChangeOp op) {
    Context ctx = new Context();
    Change c = op.createChange(ctx);
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
public void execute() throws UpdateException, RestApiException {
    execute(Listener.NONE);
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (repo == null || batchRefUpdate == null || batchRefUpdate.getCommands().isEmpty()) {
        return;
    }
    inserter.flush();
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            try {
                ctx = newChangeContext(id);
                for (Op op : e.getValue()) {
                    op.updateChange(ctx);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            ctx.getChangeUpdate().commit();
            indexFutures.add(indexer.indexAsync(id));
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = stageNoteDbUpdate(ctx);
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (newChanges.containsKey(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    db.changes().insert(cs);
                } else if (ctx.deleted) {
                    db.changes().delete(cs);
                } else {
                    db.changes().update(cs);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = db.changes().get(id);
    }
    // - attempting to read a change that doesn't exist yet
    return new ChangeContext(changeControlFactory.controlFor(c, user));
}
#method_after
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = unwrap(db).changes().get(id);
    }
    // Pass in preloaded change to controlFor, to avoid:
    // - reading from a db that does not belong to this update
    // - attempting to read a change that doesn't exist yet
    ChangeNotes notes = changeNotesFactory.createForNew(c);
    ChangeContext ctx = new ChangeContext(changeControlFactory.controlFor(notes, user), new BatchUpdateReviewDb(db));
    return ctx;
}
#end_block

#method_before
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            AccountInfo gerrit = new AccountInfo(null);
            gerrit.name = gerritIdent.getName();
            gerrit.email = gerritIdent.getEmailAddress();
            gitRefUpdated.fire(project, refUpdate, gerrit);
            break;
        }
    }
}
#method_after
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            gitRefUpdated.fire(project, refUpdate, (AccountInfo) null);
            break;
        }
    }
}
#end_block

#method_before
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setAuthor(createPersonIdent(user));
    md.getCommitBuilder().setCommitter(serverIdent);
    return md;
}
#method_after
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setCommitter(serverIdent);
    md.setAuthor(user);
    return md;
}
#end_block

#method_before
public void setAuthor(IdentifiedUser user) {
    this.user = user;
    getCommitBuilder().setAuthor(user.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#method_after
public void setAuthor(IdentifiedUser author) {
    this.author = author;
    getCommitBuilder().setAuthor(author.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#end_block

#method_before
public void close() {
    getRepository().close();
}
#method_after
@Override
public void close() {
    getRepository().close();
}
#end_block

#method_before
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, user.getAccount());
}
#method_after
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, author == null ? null : author.getAccount());
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName).getControl();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject());
    try {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#method_after
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject())) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#end_block

#method_before
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#method_after
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                case FAST_FORWARD:
                case FORCED:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#method_after
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#end_block

#method_before
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#method_after
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = new LinkedList<>();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = Lists.newLinkedList();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#method_after
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = new LinkedList<>();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = new LinkedList<>();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = Lists.newLinkedList();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = new LinkedList<>();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    String nameString = ident.getName() + " <" + ident.getEmailAddress() + ">";
    appendHeaderField(writer, AUTHOR, nameString);
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#end_block

#method_before
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#method_after
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#end_block

#method_before
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#end_block

#method_before
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#end_block

#method_before
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    Set<String> refNames = getRefNamesAllUsers(RefNames.refsDraftCommentsPrefix(author));
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refName : refNames) {
        Change.Id changeId = Change.Id.parse(refName);
        // Avoid loading notes for all affected changes just to be able to auto-
        // rebuild. This is only used in a corner case in the search codepath, so
        // returning slightly stale values is ok.
        DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
        comments.addAll(notes.load().getComments().values());
    }
    return sort(comments);
}
#method_after
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    try (Repository repo = repoManager.openRepository(allUsers)) {
        for (String refName : repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS).keySet()) {
            Account.Id accountId = Account.Id.fromRefSuffix(refName);
            Change.Id changeId = Change.Id.fromRefPart(refName);
            if (accountId == null || changeId == null) {
                continue;
            }
            // Avoid loading notes for all affected changes just to be able to auto-
            // rebuild. This is only used in a corner case in the search codepath,
            // so returning slightly stale values is ok.
            DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
            comments.addAll(notes.load().getComments().values());
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return sort(comments);
}
#end_block

#method_before
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId).values()) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#method_after
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId)) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#end_block

#method_before
public Map<String, Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public Collection<Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private Map<String, Ref> getDraftRefs(Repository repo, final Change.Id changeId) throws IOException {
    final String suffix = "/" + changeId.get();
    return Maps.filterKeys(repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS), new Predicate<String>() {

        @Override
        public boolean apply(String input) {
            return input.endsWith(suffix);
        }
    });
}
#method_after
private Collection<Ref> getDraftRefs(Repository repo, Change.Id changeId) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.refsDraftCommentsPrefix(changeId)).values();
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    boolean updateTs = commit.getParentCount() == 0;
    createdOn = ts;
    parseTag(commit);
    updateTs |= tag != null;
    if (branch == null) {
        branch = parseBranch(commit);
        updateTs |= branch != null;
    }
    if (status == null) {
        status = parseStatus(commit);
        updateTs |= status != null;
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
        updateTs |= changeId != null;
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
        updateTs = true;
    }
    updateTs |= parseChangeMessage(psId, accountId, commit, ts) != null;
    if (topic == null) {
        topic = parseTopic(commit);
        updateTs |= topic != null;
    }
    Set<String> oldHashtags = hashtags;
    parseHashtags(commit);
    updateTs |= hashtags != oldHashtags;
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
        updateTs |= submissionId != null;
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
        updateTs = true;
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
        updateTs |= !submitRecords.isEmpty();
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
        updateTs = true;
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (updateTs) {
        if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
            lastUpdatedOn = ts;
        }
    }
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#end_block

#method_before
private ChangeMessage parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return null;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return null;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return null;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return null;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
    return changeMessage;
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = Lists.newLinkedList();
    List<RevCommit> after = Lists.newLinkedList();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#method_after
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = new LinkedList<>();
    List<RevCommit> after = new LinkedList<>();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#end_block

#method_before
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            getSkipManager().removeAll();
            getSkipManager().render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#method_after
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            skipManager.removeAll();
            skipManager.render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#end_block

#method_before
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("n");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#method_after
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("N");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#end_block

#method_before
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        getSkipManager().removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        getSkipManager().render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#method_after
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        skipManager.removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        skipManager.render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (Element.as(clickEvent.getEventTarget()).hasClassName(getLineNumberClassName()) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().getLineMapper().lineOnOther(side, line);
}
#method_after
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().lineMapper.lineOnOther(side, line);
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user");
                    db.accountSshKeys().insert(Collections.singleton(sshKey));
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    super.onLoad();
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
public void save(String message) throws IOException, ConfigInvalidException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#method_after
public void save(String message) throws IOException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException, ConfigInvalidException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path)) {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try (RevWalk rw = new RevWalk(reader)) {
            RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
            newTree = readTree(srcTree);
            CommitBuilder commit = new CommitBuilder();
            commit.setAuthor(ident);
            commit.setCommitter(ident);
            commit.setMessage(msg);
            super.onSave(commit);
            ObjectId res = newTree.writeTree(inserter);
            if (res.equals(srcTree)) {
                return;
            }
            commit.setTreeId(res);
            if (revision != null) {
                commit.addParentId(revision);
            }
            ObjectId newRevision = inserter.insert(commit);
            updateRef(repo, ident, newRevision, "commit: " + msg);
            revision = newRevision;
        } finally {
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path);
        ObjectInserter i = repo.newObjectInserter();
        ObjectReader r = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        inserter = i;
        reader = r;
        RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
        newTree = readTree(srcTree);
        CommitBuilder commit = new CommitBuilder();
        commit.setAuthor(ident);
        commit.setCommitter(ident);
        commit.setMessage(msg);
        onSave(commit);
        ObjectId res = newTree.writeTree(inserter);
        if (res.equals(srcTree)) {
            return;
        }
        commit.setTreeId(res);
        if (revision != null) {
            commit.addParentId(revision);
        }
        ObjectId newRevision = inserter.insert(commit);
        updateRef(repo, ident, newRevision, "commit: " + msg);
        revision = newRevision;
    } finally {
        inserter = null;
        reader = null;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
            authorizedKeys.load(md);
            if (authorizedKeys.deleteKey(rsrc.getSshKey().getKey().get())) {
                authorizedKeys.commit(md);
            }
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), rsrc.getUser().getAccountId());
        if (keys.remove(rsrc.getSshKey())) {
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        }
    }
    dbProvider.get().accountSshKeys().deleteKeys(Collections.singleton(rsrc.getSshKey().getKey()));
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get());
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    keys = new TreeMap<>();
    int seq = 1;
    for (String line : readUTF8(FILE_NAME).split("\\r?\\n")) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT)) {
            String pub = line.substring(INVALID_KEY_COMMENT.length());
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), pub);
            key.setInvalid();
            keys.put(key.getKey().get(), Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.put(seq++, Optional.<AccountSshKey>absent());
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), line);
            keys.put(key.getKey().get(), Optional.of(key));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException {
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    StringBuilder b = new StringBuilder();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            if (!key.get().isValid()) {
                b.append(INVALID_KEY_COMMENT);
            }
            b.append(key.get().getSshPublicKey().trim());
        } else {
            b.append(DELETED_KEY_COMMENT);
        }
        b.append("\n");
    }
    saveUTF8(FILE_NAME, b.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException {
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    saveUTF8(AuthorizedKeys.FILE_NAME, AuthorizedKeys.serialize(keys));
    return true;
}
#end_block

#method_before
public List<AccountSshKey> getKeys() {
    checkState(keys != null, "SSH keys not loaded yet");
    List<AccountSshKey> result = new ArrayList<>();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            result.add(key.get());
        }
    }
    return result;
}
#method_after
private List<AccountSshKey> getKeys() {
    checkLoaded();
    return Lists.newArrayList(Optional.presentInstances(keys));
}
#end_block

#method_before
public AccountSshKey getKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    Optional<AccountSshKey> key = keys.get(seq);
    return key.isPresent() ? key.get() : null;
}
#method_after
private AccountSshKey getKey(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    return key.orNull();
}
#end_block

#method_before
public AccountSshKey addKey(String pub) {
    checkState(keys != null, "SSH keys not loaded yet");
    int seq = keys.isEmpty() ? 1 : keys.lastKey() + 1;
    AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), pub);
    keys.put(seq, Optional.of(key));
    return key;
}
#method_after
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    int seq = keys.size() + 1;
    AccountSshKey.Id keyId = new AccountSshKey.Id(accountId, seq);
    AccountSshKey key = sshKeyCreator.create(keyId, pub);
    keys.add(Optional.of(key));
    return key;
}
#end_block

#method_before
public boolean deleteKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    if (keys.containsKey(seq) && keys.get(seq).isPresent()) {
        keys.put(seq, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#method_after
private boolean deleteKey(int seq) {
    checkLoaded();
    if (seq <= keys.size() && keys.get(seq - 1).isPresent()) {
        keys.set(seq - 1, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#end_block

#method_before
public void markKeyInvalid(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    AccountSshKey key = getKey(seq);
    if (key != null) {
        key.setInvalid();
    }
}
#method_after
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    AccountSshKey key = getKey(seq);
    if (key != null && key.isValid()) {
        key.setInvalid();
        return true;
    }
    return false;
}
#end_block

#method_before
public void setKeys(List<AccountSshKey> newKeys) {
    keys = new TreeMap<>();
    for (AccountSshKey key : newKeys) {
        keys.put(key.getKey().get(), Optional.of(key));
    }
    for (int seq = 1; seq < keys.lastKey(); seq++) {
        if (!keys.containsKey(seq)) {
            keys.put(seq, Optional.<AccountSshKey>absent());
        }
    }
}
#method_after
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.natural().onResultOf(new Function<AccountSshKey, Integer>() {

        @Override
        public Integer apply(AccountSshKey sshKey) {
            return sshKey.getKey().get();
        }
    });
    keys = Collections.nCopies(o.max(newKeys).getKey().get(), Optional.<AccountSshKey>absent());
    for (AccountSshKey key : newKeys) {
        keys.set(key.getKey().get() - 1, Optional.of(key));
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
            bind(SshKeyCreator.class).to(SshKeyCreatorImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        final AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        final List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : readSshKeys(db, user.getAccountId())) {
            if (k.isValid()) {
                add(db, kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#method_after
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) {
            if (k.isValid()) {
                add(kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#end_block

#method_before
private void add(ReviewDb db, List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(db, k);
    }
}
#method_after
private void add(List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(k);
    }
}
#end_block

#method_before
private void markInvalid(ReviewDb db, AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        k.setInvalid();
        db.accountSshKeys().update(Collections.singleton(k));
        List<AccountSshKey> keys = readFromDb(db, k.getAccount());
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get(), userFactory.create(k.getAccount()));
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(k.getAccount());
            authorizedKeys.load(md);
            authorizedKeys.setKeys(keys);
            authorizedKeys.commit(md);
        }
    } catch (OrmException | IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#method_after
private void markInvalid(AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        authorizedKeys.markKeyInvalid(k.getAccount(), k.getKey().get());
        k.setInvalid();
    } catch (IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#end_block

#method_before
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey;
        if (readFromGit) {
            try (Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(git);
                sshKey = authorizedKeys.getKey(seq);
            }
        } else {
            sshKey = dbProvider.get().accountSshKeys().get(new AccountSshKey.Id(user.getAccountId(), seq));
        }
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey = authorizedKeys.getKey(user.getAccountId(), seq);
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    AccountSshKey sshKey;
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
            authorizedKeys.load(md);
            sshKey = authorizedKeys.addKey(sshPublicKey);
            authorizedKeys.commit(md);
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), user.getAccountId());
        int max = keys.isEmpty() ? 0 : keys.get(keys.size() - 1).getKey().get();
        try {
            sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
            keys.add(sshKey);
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
    try {
        addKeyFactory.create(user, sshKey).send();
    } catch (EmailException e) {
        log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
    }
    sshKeyCache.evict(user.getUserName());
    return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = authorizedKeys.addKey(user.getAccountId(), sshPublicKey);
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (key != null) {
        addSshKey(db, key, username);
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        addSshKey(db, id, username, email, sshKey);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        authorizedKeys.addKey(id, publicKey(sshKey, email));
        sshKeyCache.evict(username);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
public TestAccount create(String username, String group) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, group);
}
#method_after
public TestAccount create(String username, String group) throws Exception {
    return create(username, null, username, group);
}
#end_block

#method_before
public TestAccount create(String username) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, (String[]) null);
}
#method_after
public TestAccount create(String username) throws Exception {
    return create(username, null, username, (String[]) null);
}
#end_block

#method_before
public TestAccount admin() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#method_after
public TestAccount admin() throws Exception {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#end_block

#method_before
public TestAccount admin2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#method_after
public TestAccount admin2() throws Exception {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#end_block

#method_before
public TestAccount user() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user", "user@example.com", "User");
}
#method_after
public TestAccount user() throws Exception {
    return create("user", "user@example.com", "User");
}
#end_block

#method_before
public TestAccount user2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user2", "user2@example.com", "User2");
}
#method_after
public TestAccount user2() throws Exception {
    return create("user2", "user2@example.com", "User2");
}
#end_block

#method_before
public List<SshKeyInfo> apply(IdentifiedUser user) throws OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    List<AccountSshKey> keys = readFromGit ? readFromGit(user.getAccountId()) : readFromDb(dbProvider.get(), user.getAccountId());
    return Lists.transform(keys, new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#method_after
public List<SshKeyInfo> apply(IdentifiedUser user) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    return Lists.transform(authorizedKeys.getKeys(user.getAccountId()), new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#end_block

#method_before
@Override
public String getAvatarUrl(int size) throws RestApiException {
    GetAvatar myGetAvatar = getAvatar.get();
    myGetAvatar.setSize(size);
    return myGetAvatar.apply(account).location();
}
#method_after
@Override
public String getAvatarUrl(int size) throws RestApiException {
    getAvatar.setSize(size);
    return getAvatar.apply(account).location();
}
#end_block

#method_before
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#method_after
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#end_block

#method_before
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#method_after
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, toBlob(inserter, content));
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, content);
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, final ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final ObjectId content) throws IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    FileMode mode = ent.getFileMode();
                    if (FileMode.GITLINK != mode) {
                        ent.setObjectId(content);
                    } else {
                        ent.setLength(0);
                        ent.setLastModified(0);
                        try {
                            ObjectId id = ObjectId.fromString(reader.open(content).getBytes(), 0);
                            ent.setObjectId(id);
                        } catch (LargeObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (MissingObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (IOException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                }
            });
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, final ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final RawInput content) throws InvalidChangeOperationException, IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            final AtomicReference<IOException> ioe = new AtomicReference<>(null);
            final AtomicReference<InvalidChangeOperationException> icoe = new AtomicReference<>(null);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    try {
                        if (ent.getFileMode() == FileMode.GITLINK) {
                            ent.setLength(0);
                            ent.setLastModified(0);
                            ent.setObjectId(ObjectId.fromString(ByteStreams.toByteArray(content.getInputStream()), 0));
                        } else {
                            if (ent.getRawMode() == 0) {
                                ent.setFileMode(FileMode.REGULAR_FILE);
                            }
                            ent.setObjectId(toBlob(ins, content));
                        }
                    } catch (IOException e) {
                        ioe.set(e);
                    } catch (InvalidObjectIdException e) {
                        icoe.set(new InvalidChangeOperationException("Invalid object id in submodule link: " + e.getMessage()));
                        icoe.get().initCause(e);
                    }
                }
            });
            if (ioe.get() != null) {
                throw ioe.get();
            }
            if (icoe.get() != null) {
                throw icoe.get();
            }
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    mergeOp.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = mergeOp.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#method_after
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s, MergeOpRepoManager orm) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    orm.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = orm.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest));
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        mergeOp.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = mergeOp.getRepo(subscriber.getParentKey());
    Repository pdb = or.repo;
    try {
        if (pdb.exactRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.exactRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                mergeOp.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = mergeOp.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
}
#method_after
@Override
public void close() {
    orm.close();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    SubmoduleOp subOp = subOpProvider.get();
    updateSuperProjects(subOp, br.values());
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#end_block

#method_before
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate());
    }
    return updates;
}
#method_after
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(orm.getRepo(project).getUpdate());
    }
    return updates;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
private void updateSuperProjects(SubmoduleOp subOp, Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches, submissionId);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#method_after
private void updateSuperProjects(Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    SubmoduleOp subOp = subOpProvider.get();
    try {
        subOp.updateSuperProjects(db, branches, submissionId, orm);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        mergeOp.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = mergeOp.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
@Override
public String healthCheck(final Check check) throws IOException {
    if (check.equals(Check.ACCESS))
        return healthCheckAccess();
    else
        return healthCheckSysinfo();
}
#method_after
@Override
public String healthCheck(final Check check) throws IOException {
    return execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            if (check.equals(Check.ACCESS))
                return healthCheckAccess();
            else
                return healthCheckSysinfo();
        }
    });
}
#end_block

#method_before
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    try {
        log.debug("Adding comment {} to issue {}", comment, issueKey);
        client().addComment(issueKey, Comment.valueOf(comment));
        log.debug("Added comment {} to issue {}", comment, issueKey);
    } catch (IOException e) {
        log.error("Failed to add comment {} to issue {}", comment, issueKey);
    }
}
#method_after
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Adding comment {} to issue {}", comment, issueKey);
            client().addComment(issueKey, Comment.valueOf(comment));
            log.debug("Added comment {} to issue {}", comment, issueKey);
            return issueKey;
        }
    });
}
#end_block

#method_before
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    try {
        log.debug("Performing action {} on issue {}", actionName, issueKey);
        doPerformAction(issueKey, actionName);
    } catch (IOException e) {
        log.error("Failed to perform action {} on issue {}", actionName, issueKey);
        throw new IOException(e);
    }
}
#method_after
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Performing action {} on issue {}", actionName, issueKey);
            doPerformAction(issueKey, actionName);
            return issueKey;
        }
    });
}
#end_block

#method_before
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    try {
        boolean ret = client().doTransition(issueKey, actionName);
        if (ret) {
            log.debug("Action " + actionName + " successful on Issue " + issueKey);
        } else {
            log.debug("Transitioning to current status not possible");
        }
    } catch (IOException e) {
        StringBuilder sb = new StringBuilder();
        for (Transition t : client().getTransitions(issueKey)) {
            if (sb.length() > 0) {
                sb.append(',');
            }
            sb.append('\'');
            sb.append(t.getName());
            sb.append('\'');
        }
        log.error("Available Transitions: " + sb);
        throw e;
    }
}
#method_after
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    boolean ret = client().doTransition(issueKey, actionName);
    if (ret) {
        log.debug("Action " + actionName + " successful on Issue " + issueKey);
    } else {
        log.debug("Action {} on Issue {} not possible", actionName, issueKey);
    }
}
#end_block

#method_before
@Override
public boolean exists(final String issueKey) throws IOException {
    return client().issueExists(issueKey);
}
#method_after
@Override
public boolean exists(final String issueKey) throws IOException {
    return execute(new Callable<Boolean>() {

        @Override
        public Boolean call() throws Exception {
            return client().issueExists(issueKey);
        }
    });
}
#end_block

#method_before
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (URISyntaxException e) {
            log.error("Connecting failed at {} as user {}", getUrl(), getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#method_after
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (Exception e) {
            log.info("Unable to connect to " + getUrl() + " as " + getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#end_block

#method_before
private String healthCheckAccess() throws IOException {
    try {
        new JiraClient(getUrl(), getUsername(), getPassword()).sysInfo();
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#method_after
private String healthCheckAccess() throws IOException {
    client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#end_block

#method_before
public Issue getIssue(String issueKey) throws IOException {
    IssueRestClient issueClient = this.client.getIssueClient();
    Promise<Issue> promise = issueClient.getIssue(issueKey);
    try {
        return promise.claim();
    } catch (Exception e) {
        log.error("Failed to get issue by issuekey " + issueKey);
        throw new IOException(e);
    }
}
#method_after
public Issue getIssue(String issueKey) throws RestClientException {
    IssueRestClient issueClient = this.client.getIssueClient();
    return issueClient.getIssue(issueKey).claim();
}
#end_block

#method_before
public boolean issueExists(String issueKey) {
    try {
        getIssue(issueKey);
        return true;
    } catch (IOException e) {
        log.error("Issue " + issueKey + " not found " + e.getCause().getMessage());
        return false;
    }
}
#method_after
public boolean issueExists(String issueKey) throws RestClientException {
    boolean ret = true;
    try {
        getIssue(issueKey);
    } catch (RestClientException e) {
        if (e.getStatusCode().get() == 404) {
            log.error("Issue " + issueKey + " not found ");
            ret = false;
        } else {
            throw e;
        }
    }
    return ret;
}
#end_block

#method_before
public Iterable<Transition> getTransitions(String issueKey) throws IOException {
    try {
        return client.getIssueClient().getTransitions(getIssue(issueKey)).get();
    } catch (Exception e) {
        log.error("Failed to retrieve transitions of issue " + issueKey);
        throw new IOException("Transitions error", e);
    }
}
#method_after
public Iterable<Transition> getTransitions(String issueKey) throws RestClientException {
    return client.getIssueClient().getTransitions(getIssue(issueKey)).claim();
}
#end_block

#method_before
public void addComment(String issueKey, Comment comment) throws IOException {
    try {
        log.debug("Trying to add comment for issue " + issueKey);
        Issue issue = getIssue(issueKey);
        URI issueUri = new URI(issue.getSelf().toString() + "/comment/");
        IssueRestClient issueClient = client.getIssueClient();
        Promise<Void> promise = issueClient.addComment(issueUri, comment);
        promise.claim();
        log.debug("Comment added to issue " + issueKey);
    } catch (Exception e) {
        log.error("Could not add comment to issue " + issueKey);
        throw new IOException("Adding Comment to issue " + issueKey + " failed", e);
    }
}
#method_after
public void addComment(String issueKey, Comment comment) throws RestClientException, URISyntaxException {
    log.debug("Trying to add comment for issue " + issueKey);
    Issue issue = getIssue(issueKey);
    URI issueUri;
    issueUri = new URI(issue.getSelf().toString() + "/comment/");
    IssueRestClient issueClient = client.getIssueClient();
    Promise<Void> promise = issueClient.addComment(issueUri, comment);
    promise.claim();
    log.debug("Comment added to issue " + issueKey);
}
#end_block

#method_before
public boolean doTransition(String issueKey, String transition) {
    Transition t;
    boolean result = false;
    try {
        t = getTransitionByName(getTransitions(issueKey), transition);
        TransitionInput input;
        input = new TransitionInput(t.getId());
        log.debug("Setting transition input to: " + input.toString());
        client.getIssueClient().transition(getIssue(issueKey), input).claim();
        result = true;
    } catch (IOException e) {
        log.error(e.getMessage());
    }
    return result;
}
#method_after
public boolean doTransition(String issueKey, String transition) throws RestClientException, InvalidTransitionException {
    Transition t = getTransitionByName(getTransitions(issueKey), transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    TransitionInput input;
    input = new TransitionInput(t.getId());
    log.debug("Setting transition input to: " + input.toString());
    client.getIssueClient().transition(getIssue(issueKey), input).claim();
    return true;
}
#end_block

#method_before
public ServerInfo sysInfo() throws IOException {
    try {
        return client.getMetadataClient().getServerInfo().get();
    } catch (InterruptedException e) {
        log.error("Serverinfo request interrupted");
        throw new IOException(e);
    } catch (ExecutionException e) {
        log.error(e.getMessage());
        throw new IOException(e);
    }
}
#method_after
public ServerInfo sysInfo() throws RestClientException {
    return client.getMetadataClient().getServerInfo().claim();
}
#end_block

#method_before
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) throws IOException {
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            return t;
        }
    }
    throw new IOException("No matching transition found");
}
#method_after
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) {
    Transition ret = null;
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            ret = t;
            break;
        }
    }
    return ret;
}
#end_block

#method_before
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException | IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#method_after
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                if (a.getPatchSetId().equals(control.getChange().currentPatchSetId()) && a.getValue() != 0) {
                    if (msg.length() == 0) {
                        msg.append("Removed the following votes:\n\n");
                    }
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getId(), db);
        db.patchSetApprovals().delete(del);
        update.removeReviewer(rsrc.getUser().getAccountId());
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getId(), ChangeUtil.messageUUID(db)), control.getUser().getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        emailReviewers(rsrc.getChange(), del);
        if (!del.isEmpty()) {
            PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
            for (PatchSetApproval psa : del) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                hooks.doReviewerDeletedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, rsrc.getChange());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getChangeResource().getProject(), rsrc.getChangeResource().getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getReviewerUser().getAccount());
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> approvals) {
    if (approvals.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(approvals.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : approvals) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(GitModules.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#method_after
@Override
public void doReviewerDeletedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent(change);
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (!approvals.isEmpty()) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerDeletedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    AccountState owner = accountCache.get(change.getOwner());
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    // append votes that were removed
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) {
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, Event event) {
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) {
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    ccExistingReviewers();
    includeWatchers(NotifyType.ALL_COMMENTS);
    add(RecipientType.TO, reviewers);
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    boolean includeSizes = !Strings.isNullOrEmpty(req.getParameter("long"));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes ? repo : null), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
static Tree toJsonData(ObjectId id, TreeWalk tw, @Nullable Repository repoForSizes) throws IOException {
    ObjectReader reader = repoForSizes != null ? repoForSizes.newObjectReader() : null;
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (reader != null) {
            FileMode fmode = FileMode.fromBits(mode.getBits());
            if (fmode == FileMode.REGULAR_FILE || fmode == FileMode.EXECUTABLE_FILE) {
                SizedEntry se = new SizedEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.size = reader.getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
                e = se;
            } else if (fmode == FileMode.SYMLINK) {
                TargetEntry se = new TargetEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.target = new String(repoForSizes.open(tw.getObjectId(0), Constants.OBJ_BLOB).getBytes(), UTF_8);
                e = se;
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#method_after
static Tree toJsonData(ObjectId id, TreeWalk tw, boolean includeSizes) throws IOException {
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (includeSizes) {
            if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_FILE) {
                e.size = tw.getObjectReader().getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
            } else if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) {
                e.target = new String(tw.getObjectReader().open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#end_block

#method_before
void close() {
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        try {
            writer.getIndexWriter().close();
        } catch (AlreadyClosedException e) {
        // Ignore.
        }
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#method_after
void close() {
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#end_block

#method_before
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.postRun();
    }
}
#method_after
public void postRun(Injector injector) throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        injector.injectMembers(step);
        step.postRun();
    }
}
#end_block

#method_before
private void saveSecureStore() throws IOException {
    if (!secureStoreClassName.isEmpty() && !secureStoreJarPath.isEmpty()) {
        File secureStoreJar = new File(secureStoreJarPath);
        File dst = new File(site.lib_dir, secureStoreJar.getName());
        Files.copy(secureStoreJar, dst);
        Section gerritSection = sectionFactory.get("gerrit", null);
        gerritSection.set("secureStoreClass", secureStoreClassName);
    }
}
#method_after
private void saveSecureStore() throws IOException {
    if (secureStoreInitData != null) {
        File dst = new File(site.lib_dir, secureStoreInitData.jarFile.getName());
        Files.copy(secureStoreInitData.jarFile, dst);
        Section gerritSection = sectionFactory.get("gerrit", null);
        gerritSection.set("secureStoreClass", secureStoreInitData.className);
    }
}
#end_block

#method_before
@Test
public void testUpgrade() throws IOException, ConfigInvalidException {
    final File p = newSitePath();
    final SitePaths site = new SitePaths(p);
    assertTrue(site.isNew);
    assertTrue(site.site_path.mkdir());
    assertTrue(site.etc_dir.mkdir());
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        Writer w = new FileWriter(new File(p, n));
        try {
            w.write("# " + n + "\n");
        } finally {
            w.close();
        }
    }
    FileBasedConfig old = new FileBasedConfig(new File(p, "gerrit.config"), FS.DETECTED);
    old.setString("ldap", null, "username", "ldap.user");
    old.setString("ldap", null, "password", "ldap.s3kr3t");
    old.setString("sendemail", null, "smtpUser", "email.user");
    old.setString("sendemail", null, "smtpPass", "email.s3kr3t");
    old.save();
    InMemorySecureStore secureStore = new InMemorySecureStore();
    final InitFlags flags = new InitFlags(site, secureStore, Collections.<String>emptyList());
    final ConsoleUI ui = createStrictMock(ConsoleUI.class);
    Section.Factory sections = new Section.Factory() {

        @Override
        public Section get(String name, String subsection) {
            return new Section(flags, site, ui, name, subsection);
        }
    };
    expect(ui.yesno(eq(true), eq("Upgrade '%s'"), eq(p.getCanonicalPath()))).andReturn(true);
    replay(ui);
    UpgradeFrom2_0_x u = new UpgradeFrom2_0_x(site, flags, ui, sections);
    assertTrue(u.isNeedUpgrade());
    u.run();
    assertFalse(u.isNeedUpgrade());
    verify(ui);
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        if ("gerrit.config".equals(n))
            continue;
        if ("secure.config".equals(n))
            continue;
        assertEquals(// 
        "# " + n + "\n", new String(IO.readFully(new File(site.etc_dir, n)), "UTF-8"));
    }
    FileBasedConfig cfg = new FileBasedConfig(site.gerrit_config, FS.DETECTED);
    cfg.load();
    assertEquals("email.user", cfg.getString("sendemail", null, "smtpUser"));
    assertNull(cfg.getString("sendemail", null, "smtpPass"));
    assertEquals("email.s3kr3t", secureStore.get("sendemail", null, "smtpPass"));
    assertEquals("ldap.user", cfg.getString("ldap", null, "username"));
    assertNull(cfg.getString("ldap", null, "password"));
    assertEquals("ldap.s3kr3t", secureStore.get("ldap", null, "password"));
    u.run();
}
#method_after
@Test
public void testUpgrade() throws IOException, ConfigInvalidException {
    final File p = newSitePath();
    final SitePaths site = new SitePaths(p);
    assertTrue(site.isNew);
    assertTrue(site.site_path.mkdir());
    assertTrue(site.etc_dir.mkdir());
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        Writer w = new FileWriter(new File(p, n));
        try {
            w.write("# " + n + "\n");
        } finally {
            w.close();
        }
    }
    FileBasedConfig old = new FileBasedConfig(new File(p, "gerrit.config"), FS.DETECTED);
    old.setString("ldap", null, "username", "ldap.user");
    old.setString("ldap", null, "password", "ldap.s3kr3t");
    old.setString("sendemail", null, "smtpUser", "email.user");
    old.setString("sendemail", null, "smtpPass", "email.s3kr3t");
    old.save();
    final InMemorySecureStore secureStore = new InMemorySecureStore();
    final InitFlags flags = new InitFlags(site, secureStore, Collections.<String>emptyList());
    final ConsoleUI ui = createStrictMock(ConsoleUI.class);
    Section.Factory sections = new Section.Factory() {

        @Override
        public Section get(String name, String subsection) {
            return new Section(flags, site, secureStore, ui, name, subsection);
        }
    };
    expect(ui.yesno(eq(true), eq("Upgrade '%s'"), eq(p.getCanonicalPath()))).andReturn(true);
    replay(ui);
    UpgradeFrom2_0_x u = new UpgradeFrom2_0_x(site, flags, ui, sections);
    assertTrue(u.isNeedUpgrade());
    u.run();
    assertFalse(u.isNeedUpgrade());
    verify(ui);
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        if ("gerrit.config".equals(n))
            continue;
        if ("secure.config".equals(n))
            continue;
        assertEquals(// 
        "# " + n + "\n", new String(IO.readFully(new File(site.etc_dir, n)), "UTF-8"));
    }
    FileBasedConfig cfg = new FileBasedConfig(site.gerrit_config, FS.DETECTED);
    cfg.load();
    assertEquals("email.user", cfg.getString("sendemail", null, "smtpUser"));
    assertNull(cfg.getString("sendemail", null, "smtpPass"));
    assertEquals("email.s3kr3t", secureStore.get("sendemail", null, "smtpPass"));
    assertEquals("ldap.user", cfg.getString("ldap", null, "username"));
    assertNull(cfg.getString("ldap", null, "password"));
    assertEquals("ldap.s3kr3t", secureStore.get("ldap", null, "password"));
    u.run();
}
#end_block

#method_before
public void run() throws IOException, InterruptedException {
    ui.header("HTTP Daemon");
    boolean proxy = false, ssl = false;
    String address = "*";
    int port = -1;
    String context = "/";
    String listenUrl = httpd.get("listenUrl");
    if (listenUrl != null && !listenUrl.isEmpty()) {
        try {
            final URI uri = toURI(listenUrl);
            proxy = uri.getScheme().startsWith("proxy-");
            ssl = uri.getScheme().endsWith("https");
            address = isAnyAddress(new URI(listenUrl)) ? "*" : uri.getHost();
            port = uri.getPort();
            context = uri.getPath();
        } catch (URISyntaxException e) {
            System.err.println("warning: invalid httpd.listenUrl " + listenUrl);
        }
    }
    proxy = ui.yesno(proxy, "Behind reverse proxy");
    if (proxy) {
        ssl = ui.yesno(ssl, "Proxy uses SSL (https://)");
        context = ui.readString(context, "Subdirectory on proxy server");
    } else {
        ssl = ui.yesno(ssl, "Use SSL (https://)");
        context = "/";
    }
    address = ui.readString(address, "Listen on address");
    if (port < 0) {
        if (proxy) {
            port = 8081;
        } else if (ssl) {
            port = 8443;
        } else {
            port = 8080;
        }
    }
    port = ui.readInt(port, "Listen on port");
    final StringBuilder urlbuf = new StringBuilder();
    urlbuf.append(proxy ? "proxy-" : "");
    urlbuf.append(ssl ? "https" : "http");
    urlbuf.append("://");
    urlbuf.append(address);
    if (0 <= port) {
        urlbuf.append(":");
        urlbuf.append(port);
    }
    urlbuf.append(context);
    httpd.set("listenUrl", urlbuf.toString());
    URI uri;
    try {
        uri = toURI(httpd.get("listenUrl"));
        if (uri.getScheme().startsWith("proxy-")) {
            // If its a proxy URL, assume the reverse proxy is on our system
            // at the protocol standard ports (so omit the ports from the URL).
            // 
            String s = uri.getScheme().substring("proxy-".length());
            uri = new URI(s + "://" + uri.getHost() + uri.getPath());
        }
    } catch (URISyntaxException e) {
        throw die("invalid httpd.listenUrl");
    }
    gerrit.string("Canonical URL", "canonicalWebUrl", uri.toString());
    generateSslCertificate();
}
#method_after
@Override
public void run() throws IOException, InterruptedException {
    ui.header("HTTP Daemon");
    boolean proxy = false, ssl = false;
    String address = "*";
    int port = -1;
    String context = "/";
    String listenUrl = httpd.get("listenUrl");
    if (listenUrl != null && !listenUrl.isEmpty()) {
        try {
            final URI uri = toURI(listenUrl);
            proxy = uri.getScheme().startsWith("proxy-");
            ssl = uri.getScheme().endsWith("https");
            address = isAnyAddress(new URI(listenUrl)) ? "*" : uri.getHost();
            port = uri.getPort();
            context = uri.getPath();
        } catch (URISyntaxException e) {
            System.err.println("warning: invalid httpd.listenUrl " + listenUrl);
        }
    }
    proxy = ui.yesno(proxy, "Behind reverse proxy");
    if (proxy) {
        ssl = ui.yesno(ssl, "Proxy uses SSL (https://)");
        context = ui.readString(context, "Subdirectory on proxy server");
    } else {
        ssl = ui.yesno(ssl, "Use SSL (https://)");
        context = "/";
    }
    address = ui.readString(address, "Listen on address");
    if (port < 0) {
        if (proxy) {
            port = 8081;
        } else if (ssl) {
            port = 8443;
        } else {
            port = 8080;
        }
    }
    port = ui.readInt(port, "Listen on port");
    final StringBuilder urlbuf = new StringBuilder();
    urlbuf.append(proxy ? "proxy-" : "");
    urlbuf.append(ssl ? "https" : "http");
    urlbuf.append("://");
    urlbuf.append(address);
    if (0 <= port) {
        urlbuf.append(":");
        urlbuf.append(port);
    }
    urlbuf.append(context);
    httpd.set("listenUrl", urlbuf.toString());
    URI uri;
    try {
        uri = toURI(httpd.get("listenUrl"));
        if (uri.getScheme().startsWith("proxy-")) {
            // If its a proxy URL, assume the reverse proxy is on our system
            // at the protocol standard ports (so omit the ports from the URL).
            // 
            String s = uri.getScheme().substring("proxy-".length());
            uri = new URI(s + "://" + uri.getHost() + uri.getPath());
        }
    } catch (URISyntaxException e) {
        throw die("invalid httpd.listenUrl");
    }
    gerrit.string("Canonical URL", "canonicalWebUrl", uri.toString());
    generateSslCertificate();
}
#end_block

#method_before
public void run() throws IOException, ConfigInvalidException {
    if (!isNeedUpgrade()) {
        return;
    }
    if (!ui.yesno(true, "Upgrade '%s'", site_path.getCanonicalPath())) {
        throw die("aborted by user");
    }
    for (String name : etcFiles) {
        final File src = new File(site_path, name);
        final File dst = new File(etc_dir, name);
        if (src.exists()) {
            if (dst.exists()) {
                throw die("File " + src + " would overwrite " + dst);
            }
            if (!src.renameTo(dst)) {
                throw die("Cannot rename " + src + " to " + dst);
            }
        }
    }
    // We have to reload the configuration after the rename as
    // the initial load pulled up an non-existent (and thus
    // believed to be empty) file.
    // 
    cfg.load();
    final Properties oldprop = readGerritServerProperties();
    if (oldprop != null) {
        final Section database = sections.get("database", null);
        String url = oldprop.getProperty("url");
        if (url != null && !convertUrl(database, url)) {
            database.set("type", "jdbc");
            database.set("driver", oldprop.getProperty("driver"));
            database.set("url", url);
        }
        String username = oldprop.getProperty("user");
        if (username == null || username.isEmpty()) {
            username = oldprop.getProperty("username");
        }
        if (username != null && !username.isEmpty()) {
            cfg.setString("database", null, "username", username);
        }
        String password = oldprop.getProperty("password");
        if (password != null && !password.isEmpty()) {
            sec.set("database", null, "password", password);
        }
    }
    String[] values;
    values = cfg.getStringList("ldap", null, "password");
    cfg.unset("ldap", null, "password");
    sec.setList("ldap", null, "password", Arrays.asList(values));
    values = cfg.getStringList("sendemail", null, "smtpPass");
    cfg.unset("sendemail", null, "smtpPass");
    sec.setList("sendemail", null, "smtpPass", Arrays.asList(values));
    savePublic(cfg);
}
#method_after
@Override
public void run() throws IOException, ConfigInvalidException {
    if (!isNeedUpgrade()) {
        return;
    }
    if (!ui.yesno(true, "Upgrade '%s'", site_path.getCanonicalPath())) {
        throw die("aborted by user");
    }
    for (String name : etcFiles) {
        final File src = new File(site_path, name);
        final File dst = new File(etc_dir, name);
        if (src.exists()) {
            if (dst.exists()) {
                throw die("File " + src + " would overwrite " + dst);
            }
            if (!src.renameTo(dst)) {
                throw die("Cannot rename " + src + " to " + dst);
            }
        }
    }
    // We have to reload the configuration after the rename as
    // the initial load pulled up an non-existent (and thus
    // believed to be empty) file.
    // 
    cfg.load();
    final Properties oldprop = readGerritServerProperties();
    if (oldprop != null) {
        final Section database = sections.get("database", null);
        String url = oldprop.getProperty("url");
        if (url != null && !convertUrl(database, url)) {
            database.set("type", "jdbc");
            database.set("driver", oldprop.getProperty("driver"));
            database.set("url", url);
        }
        String username = oldprop.getProperty("user");
        if (username == null || username.isEmpty()) {
            username = oldprop.getProperty("username");
        }
        if (username != null && !username.isEmpty()) {
            cfg.setString("database", null, "username", username);
        }
        String password = oldprop.getProperty("password");
        if (password != null && !password.isEmpty()) {
            sec.set("database", null, "password", password);
        }
    }
    String[] values;
    values = cfg.getStringList("ldap", null, "password");
    cfg.unset("ldap", null, "password");
    sec.setList("ldap", null, "password", Arrays.asList(values));
    values = cfg.getStringList("sendemail", null, "smtpPass");
    cfg.unset("sendemail", null, "smtpPass");
    sec.setList("sendemail", null, "smtpPass", Arrays.asList(values));
    savePublic(cfg);
}
#end_block

#method_before
public <T extends Enum<?>> T select(final String title, final String name, final T defValue, final boolean nullIfDefault) {
    final boolean set = get(name) != null;
    T oldValue = ConfigUtil.getEnum(flags.cfg, section, subsection, name, defValue);
    T newValue = ui.readEnum(oldValue, "%s", title);
    if (nullIfDefault && newValue == defValue) {
        newValue = null;
    }
    if (!set || oldValue != newValue) {
        if (newValue != null) {
            set(name, newValue);
        } else {
            unset(name);
        }
    }
    return newValue;
}
#method_after
public <T extends Enum<?>> T select(final String title, final String name, final T defValue, final boolean nullIfDefault) {
    final boolean set = get(name) != null;
    T oldValue = flags.cfg.getEnum(section, subsection, name, defValue);
    T newValue = ui.readEnum(oldValue, "%s", title);
    if (nullIfDefault && newValue == defValue) {
        newValue = null;
    }
    if (!set || oldValue != newValue) {
        if (newValue != null) {
            set(name, newValue);
        } else {
            unset(name);
        }
    }
    return newValue;
}
#end_block

#method_before
public void setSecure(String name, String value) {
    if (value != null) {
        flags.sec.set(section, subsection, name, value);
    } else {
        flags.sec.unset(section, subsection, name);
    }
}
#method_after
public void setSecure(String name, String value) {
    if (value != null) {
        secureStore.set(section, subsection, name, value);
    } else {
        secureStore.unset(section, subsection, name);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun(createSysInjector(init));
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    m.add(new InitModule(standalone, initDb, getSecureStoreClassName()));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            bind(String.class).annotatedWith(SecureStoreJarPath.class).toInstance(Strings.nullToEmpty(getSecireStoreJarPath()));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(Strings.nullToEmpty(getSecureStoreClassName()));
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    final SecureStoreInitData secureStoreInitData = discoverSecureStoreClass();
    final String currentSecureStoreClassName = getConfiguredSecureStoreClass();
    if (secureStoreInitData != null && currentSecureStoreClassName != null && !currentSecureStoreClassName.equals(secureStoreInitData.className)) {
        String err = String.format("Different secure store was previously configured: %s.", currentSecureStoreClassName);
        die(err, new RuntimeException("secure store mismatch"));
    }
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = MoreObjects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            String secureStoreClassName;
            if (secureStoreInitData != null) {
                secureStoreClassName = secureStoreInitData.className;
            } else {
                secureStoreClassName = currentSecureStoreClassName;
            }
            if (secureStoreClassName != null) {
                ui.message("Using secure store: %s\n", secureStoreClassName);
            }
            bind(SecureStoreInitData.class).toProvider(Providers.of(secureStoreInitData));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(secureStoreClassName));
            bind(SecureStore.class).toProvider(SecureStoreProvider.class).in(SINGLETON);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            final JdbcSchema db = (JdbcSchema) schema.open();
            try {
                final JdbcExecutor e = new JdbcExecutor(db);
                try {
                    for (String sql : pruneList) {
                        e.execute(sql);
                    }
                } finally {
                    e.close();
                }
            } finally {
                db.close();
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) schema.open();
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
private Injector createSysInjector(final SiteInit init) {
    final List<Module> modules = new ArrayList<>();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(init.ui);
            bind(InitFlags.class).toInstance(init.flags);
        }
    });
    return createDbInjector(SINGLE_USER).createChildInjector(modules);
}
#method_after
private Injector createSysInjector(final SiteInit init) {
    if (sysInjector == null) {
        final List<Module> modules = new ArrayList<>();
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(ConsoleUI.class).toInstance(init.ui);
                bind(InitFlags.class).toInstance(init.flags);
            }
        });
        sysInjector = createDbInjector(SINGLE_USER).createChildInjector(modules);
    }
    return sysInjector;
}
#end_block

#method_before
@Override
protected void afterInit(SiteRun run) throws Exception {
    List<Module> modules = Lists.newArrayList();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(getSitePath());
            bind(Browser.class);
        }
    });
    modules.add(new GerritServerConfigModule());
    Guice.createInjector(modules).injectMembers(this);
    start(run);
}
#method_after
@Override
protected void afterInit(SiteRun run) throws Exception {
    List<Module> modules = Lists.newArrayList();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(getSitePath());
            bind(Browser.class);
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(getConfiguredSecureStoreClass()));
        }
    });
    modules.add(new GerritServerConfigModule());
    Guice.createInjector(modules).injectMembers(this);
    start(run);
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource resource) {
    final ProjectAccessInfo info = new ProjectAccessInfo();
    final ProjectConfig config = resource.getControl().getProjectState().getConfig();
    final ProjectControl pc = resource.getControl();
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    info.local = Maps.newHashMap();
    info.ownerOf = Sets.newHashSet();
    Map<UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#method_after
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException {
    try {
        return this.apply(new ProjectResource(projectControlFactory.controlFor(nameKey, self.get())));
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(nameKey.get());
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource resource) {
    final ProjectAccessInfo info = new ProjectAccessInfo();
    final ProjectConfig config = resource.getControl().getProjectState().getConfig();
    final ProjectControl pc = resource.getControl();
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    info.local = Maps.newHashMap();
    info.ownerOf = Sets.newHashSet();
    Map<UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectConfig config;
    ProjectControl pc = open(projectName);
    RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = Sets.newHashSet();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#end_block

#method_before
private AccessSectionInfo createAccessSection(AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = Maps.newHashMap();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = Maps.newHashMap();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(PermissionRuleActionInfo.values()[r.getAction().ordinal()], r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            pInfo.rules.put(r.getGroup().getUUID().get(), info);
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#method_after
private AccessSectionInfo createAccessSection(AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = new HashMap<>();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = new HashMap<>();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(ACTION_TYPE.get(r.getAction()), r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            pInfo.rules.put(r.getGroup().getUUID().get(), info);
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#end_block

#method_before
@Override
public ProjectAccessInfo get() throws RestApiException {
    return getAccess.apply(project);
}
#method_after
@Override
public ProjectAccessInfo get() throws RestApiException {
    try {
        return getAccess.apply(project);
    } catch (IOException e) {
        throw new RestApiException("Cannot get access rights", e);
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo access() throws RestApiException {
    return accessApi.create(checkExists(), projectJson).get();
}
#method_after
@Override
public ProjectAccessInfo access() throws RestApiException {
    return accessApi.create(checkExists()).get();
}
#end_block

#method_before
@Test
public void testGetDefaultInheritance() throws Exception {
    // create proj
    String newProjectName = name("newProjectAccess");
    RestResponse r = adminSession.put("/projects/" + newProjectName);
    String inheritedName = gApi.projects().name(newProjectName).access().inheritsFrom.name;
    assertThat(inheritedName).isEqualTo(allProjectsName.get());
}
#method_after
@Test
public void testGetDefaultInheritance() throws Exception {
    String newProjectName = createProject("newProjectAccess").get();
    String inheritedName = gApi.projects().name(newProjectName).access().inheritsFrom.name;
    assertThat(inheritedName).isEqualTo(AllProjectsNameProvider.DEFAULT);
}
#end_block

#method_before
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        // Load the current configuration from the repository, ensuring it's the most
        // recent version available. If it differs from what was in the project
        // state, force a cache flush now.
        // 
        Project.NameKey projectName = new Project.NameKey(p);
        try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
            ProjectControl pc = open(projectName);
            ProjectConfig config = ProjectConfig.read(md);
            if (config.updateGroupNames(groupBackend)) {
                md.setMessage("Update group names\n");
                config.commit(md);
                projectCache.evict(config.getProject());
                pc = open(projectName);
            } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
                projectCache.evict(config.getProject());
                pc = open(projectName);
            }
            GetAccess ga = new GetAccess(groupControlFactory, allProjectsName, projectJson);
            access.put(p, ga.apply(new ProjectResource(pc)));
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        } catch (RepositoryNotFoundException e) {
            throw new ResourceNotFoundException(p);
        }
    }
    return access;
}
#method_after
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        Project.NameKey projectName = new Project.NameKey(p);
        access.put(p, getAccess.apply(projectName));
    }
    return access;
}
#end_block

#method_before
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                if (changeControl().isPatchVisible(p, db)) {
                    currentPatchSet = p;
                    return p;
                }
            }
        }
    }
    return currentPatchSet;
}
#method_after
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    setSkipManager(new SkipManager(this, commentManager));
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            getSkipManager().render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    setSkipManager(new SkipManager(this, commentManager));
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            getSkipManager().render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
void render(int context, DiffInfo diff) {
    if (context == DiffPreferencesInfo.WHOLE_FILE_CONTEXT) {
        return;
    }
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0;
    int lineB = 0;
    JsArray<Region> regions = diff.content();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = commentManager.splitSkips(context, skips);
    if (!skips.isEmpty()) {
        boolean isSideBySide = host.diffScreenType == DiffView.SIDE_BY_SIDE;
        CodeMirror cmA = null;
        if (isSideBySide) {
            cmA = host.getCmFromSide(DisplaySide.A);
        }
        CodeMirror cmB = host.getCmFromSide(DisplaySide.B);
        for (SkippedLine skip : skips) {
            SkipBar barA = null;
            SkipBar barB = newSkipBar(cmB, DisplaySide.B, skip);
            skipBars.add(barB);
            if (isSideBySide) {
                barA = newSkipBar(cmA, DisplaySide.A, skip);
                SkipBar.link(barA, barB);
                skipBars.add(barA);
            }
            if (skip.getStartA() == 0 || skip.getStartB() == 0) {
                if (isSideBySide) {
                    barA.upArrow.setVisible(false);
                }
                barB.upArrow.setVisible(false);
                setLine0(barB);
            } else if (skip.getStartA() + skip.getSize() == lineA || skip.getStartB() + skip.getSize() == lineB) {
                if (isSideBySide) {
                    barA.downArrow.setVisible(false);
                }
                barB.downArrow.setVisible(false);
            }
        }
    }
}
#method_after
void render(int context, DiffInfo diff) {
    if (context == DiffPreferencesInfo.WHOLE_FILE_CONTEXT) {
        return;
    }
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0;
    int lineB = 0;
    JsArray<Region> regions = diff.content();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = host.getCommentManager().splitSkips(context, skips);
    renderSkips(skips, lineA, lineB);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Multimap<Account.Id, Change.Id> imports = ArrayListMultimap.create();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "change_id " + "FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getKey(), e.getValue())));
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Multimap<Account.Id, Change.Id> imports = ArrayListMultimap.create();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "change_id " + "FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getValue(), e.getKey())));
        }
        bru.execute(rw, new TextProgressMonitor());
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(accountId, changeId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(accountId, changeId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(changeId, accountId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(accountId, changeId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#method_after
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public Iterable<Account.Id> byChange(final Change.Id changeId) throws OrmException {
    return FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

        @Override
        public boolean apply(String refPart) {
            return refPart.endsWith("/" + changeId.get());
        }
    }).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.fromRefPart(refPart);
        }
    });
}
#method_after
public Set<Account.Id> byChange(Change.Id changeId) throws OrmException {
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.parse(refPart);
        }
    }).toSet();
}
#end_block

#method_before
public Iterable<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#method_after
public Set<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#end_block

#method_before
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Collections.addAll(labels, new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8).split("\n"));
        return labels;
    }
}
#method_after
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Iterables.addAll(labels, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
        return labels;
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    SortedSet<String> invalidLabels = validateLabels(labels);
    if (!invalidLabels.isEmpty()) {
        throw new IllegalArgumentException(String.format("Invalid star labels: %s", Joiner.on(", ").join(labels)));
    }
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
private final void deleteChanges(List<ChangeData> changeData) throws OrmException {
    for (ChangeData cd : changeData) {
        Change.Id id = cd.getId();
        ResultSet<PatchSet> patchSets = null;
        patchSets = db.patchSets().byChange(id);
        if (patchSets != null) {
            deleteFromPatchSets(patchSets);
        }
        // In the future, use schemaVersion to decide what to delete.
        db.patchComments().delete(db.patchComments().byChange(id));
        db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
        db.changeMessages().delete(db.changeMessages().byChange(id));
        db.changes().delete(Collections.singleton(cd.change()));
    }
}
#method_after
private final void deleteChanges(List<ChangeData> changeData) throws OrmException {
    for (ChangeData cd : changeData) {
        Change.Id id = cd.getId();
        ResultSet<PatchSet> patchSets = null;
        patchSets = db.patchSets().byChange(id);
        if (patchSets != null) {
            deleteFromPatchSets(patchSets);
        }
        // In the future, use schemaVersion to decide what to delete.
        db.patchComments().delete(db.patchComments().byChange(id));
        db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
        try {
            starredChangesUtil.unstarAll(cd.project(), id);
        } catch (NoSuchChangeException e) {
        // we can ignore the exception during delete
        }
        db.changeMessages().delete(db.changeMessages().byChange(id));
        db.changes().delete(Collections.singleton(cd.change()));
    }
}
#end_block

#method_before
@UiHandler("indentUnit")
void onIndentUnit(ValueChangeEvent<String> e) {
    String v = e.getValue();
    if (v != null && v.length() > 0) {
        prefs.indentUnit(Math.max(1, Integer.parseInt(v)));
        if (view != null) {
            view.setIndentUnit(prefs.indentUnit());
        }
    }
}
#method_after
@UiHandler("indentUnit")
void onIndentUnit(ValueChangeEvent<String> e) {
    String v = e.getValue();
    if (v != null && v.length() > 0) {
        prefs.indentUnit(Math.max(0, Integer.parseInt(v)));
        if (view != null) {
            view.setIndentUnit(prefs.indentUnit());
        }
    }
}
#end_block

#method_before
void setIndentUnit(int indentunit) {
    cm.setOption("indentUnit", Patch.COMMIT_MSG.equals(path) ? 2 : indentunit);
}
#method_after
void setIndentUnit(int indent) {
    cm.setOption("indentUnit", Patch.COMMIT_MSG.equals(path) ? 2 : indent);
}
#end_block

#method_before
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, String submissionId, SubmitInput submitInput) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, submitInput);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#method_after
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, String submissionId, NotifyHandling notifyHandling) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, notifyHandling);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        if (submitInput != null) {
            cm.setNotify(submitInput.notify);
        }
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#method_after
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        cm.setNotify(notifyHandling);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append('[').append(key).append(": ").append(value).append(']').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append('[').append(key).append(": ").append(value).append(",tag:").append(tag).append(']').toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "ChangeMessage{" + "key=" + key + ", author=" + author + ", writtenOn=" + writtenOn + ", patchset=" + patchset + ", message=[" + message + ", tag=[" + tag + "]}";
}
#method_after
@Override
public String toString() {
    return "ChangeMessage{" + "key=" + key + ", author=" + author + ", writtenOn=" + writtenOn + ", patchset=" + patchset + ", tag=" + tag + ", message=[" + message + "]}";
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    try {
        hooks.doCommentAddedHook(notes.getChange(), user.getAccount(), ps, message.getMessage(), categories, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    try {
        hooks.doCommentAddedHook(notes.getChange(), user.getAccount(), ps, message.getMessage(), approvals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    // TODO(dborowitz): Currently doesn't work for PUBLISH_ALL_REVISIONS with
    // notedb.
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getUpdate(psId);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen(), in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    // get all approvals in cases of quick approve vote
    Map<String, Short> allApprovals = approvalsByKey(current.values());
    allApprovals.putAll(inLabels);
    // get previous label votes
    Map<String, Short> currentLabels = new HashMap<>();
    for (Map.Entry<String, PatchSetApproval> ent : current.entrySet()) {
        currentLabels.put(ent.getValue().getLabel(), ent.getValue().getValue());
    }
    Map<String, Short> previous = new HashMap<>();
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        if (!currentLabels.containsKey(ent.getKey())) {
            previous.put(ent.getKey(), (short) 0);
        } else {
            previous.put(ent.getKey(), currentLabels.get(ent.getKey()));
        }
    }
    ChangeUpdate update = ctx.getUpdate(psId);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen(), in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId, in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getCodeRepo().rw));
        List<PatchLineComment> comments = PatchLineCommentsUtil.PLC_ORDER.sortedCopy(bundle.getPatchLineComments());
        for (PatchLineComment c : comments) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getCodeRepo().rw));
        for (PatchLineComment c : getPatchLineComments(bundle, ps)) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
PersonIdent newAuthorIdent() {
    Account.Id id = getAccountId();
    if (id == null) {
        return serverIdent;
    }
    return changeNoteUtil.newIdent(accountCache.get(id).getAccount(), getWhen(), serverIdent, anonymousCowardName);
}
#method_after
PersonIdent newAuthorIdent() {
    Account.Id id = getAccountId();
    if (id == null) {
        return new PersonIdent(serverIdent, getWhen());
    }
    return changeNoteUtil.newIdent(accountCache.get(id).getAccount(), getWhen(), serverIdent, anonymousCowardName);
}
#end_block

#method_before
private void setTopic(ChangeUpdate update) {
    String msg = message.getMessage();
    Matcher m = TOPIC_SET_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(1);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    m = TOPIC_CHANGED_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(2);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    if (TOPIC_REMOVED_REGEXP.matcher(msg).matches()) {
        update.setTopic(null);
        noteDbChange.setTopic(null);
    }
}
#method_after
private void setTopic(ChangeUpdate update) {
    String msg = message.getMessage();
    if (msg == null) {
        return;
    }
    Matcher m = TOPIC_SET_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(1);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    m = TOPIC_CHANGED_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(2);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    if (TOPIC_REMOVED_REGEXP.matcher(msg).matches()) {
        update.setTopic(null);
        noteDbChange.setTopic(null);
    }
}
#end_block

#method_before
private void setStatus(ChangeUpdate update) {
    String msg = message.getMessage();
    if (STATUS_ABANDONED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.ABANDONED);
        noteDbChange.setStatus(Change.Status.ABANDONED);
        return;
    }
    if (STATUS_RESTORED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.NEW);
        noteDbChange.setStatus(Change.Status.NEW);
    }
}
#method_after
private void setStatus(ChangeUpdate update) {
    String msg = message.getMessage();
    if (msg == null) {
        return;
    }
    if (STATUS_ABANDONED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.ABANDONED);
        noteDbChange.setStatus(Change.Status.ABANDONED);
        return;
    }
    if (STATUS_RESTORED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.NEW);
        noteDbChange.setStatus(Change.Status.NEW);
    }
}
#end_block

#method_before
private void verifyComment(PatchLineComment c) {
    checkArgument(c.getRevId() != null);
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#method_after
private void verifyComment(PatchLineComment c) {
    checkArgument(c.getRevId() != null, "RevId required for comment: %s", c);
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#end_block

#method_before
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, new Delta(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, new Delta(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, new Delta(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, new Delta(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, new Delta(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, Delta.create(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, new Delta(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, new Delta(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#method_after
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#end_block

#method_before
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#method_after
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        if (newChanges.containsKey(ctl.getId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (ctx.deleted) {
                    if (notesMigration.writeChanges()) {
                        new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                    }
                } else {
                    if (notesMigration.writeChanges()) {
                        updateManager = updateManagerFactory.create(ctx.getProject());
                        for (ChangeUpdate u : ctx.updates.values()) {
                            updateManager.add(u);
                        }
                        NoteDbChangeState.applyDelta(ctx.getChange(), updateManager.stage().get(id));
                    }
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                if (newChanges.containsKey(id)) {
                    db.changes().insert(bumpLastUpdatedOn(ctx));
                } else if (ctx.saved) {
                    db.changes().update(bumpLastUpdatedOn(ctx));
                } else if (ctx.deleted) {
                    db.changes().delete(bumpLastUpdatedOn(ctx));
                } else {
                    db.changes().update(bumpRowVersionNotLastUpdatedOn(ctx));
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (updateManager != null) {
                updateManager.execute();
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = updateManagerFactory.create(ctx.getProject());
                    for (ChangeUpdate u : ctx.updates.values()) {
                        updateManager.add(u);
                    }
                    NoteDbChangeState.applyDelta(ctx.getChange(), updateManager.stage().get(id));
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                if (newChanges.containsKey(id)) {
                    db.changes().insert(bumpLastUpdatedOn(ctx));
                } else if (ctx.saved) {
                    db.changes().update(bumpLastUpdatedOn(ctx));
                } else if (ctx.deleted) {
                    db.changes().delete(bumpLastUpdatedOn(ctx));
                } else {
                    db.changes().update(bumpRowVersionNotLastUpdatedOn(ctx));
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
@Test
public void changeFields() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    gApi.changes().id(id.get()).topic(name("a-topic"));
    checker.checkChanges(id);
}
#method_after
@Test
public void changeFields() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    gApi.changes().id(id.get()).topic(name("a-topic"));
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void patchSets() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    r = amendChange(r.getChangeId());
    checker.checkChanges(id);
}
#method_after
@Test
public void patchSets() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    r = amendChange(r.getChangeId());
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void noteDbChangeState() throws Exception {
    notesMigration.setAllEnabled(true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, ChangeNoteUtil.changeRefName(id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "comment by user";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(user);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId userDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(user.getId(), id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in = new DraftInput();
    in.line = 2;
    in.message = "comment by admin";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(admin);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in.message = "revised comment by admin";
    gApi.changes().id(id.get()).current().createDraft(in);
    adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#method_after
@Test
public void noteDbChangeState() throws Exception {
    notesMigration.setAllEnabled(true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, ChangeNoteUtil.changeRefName(id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "comment by user";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(user);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId userDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(user.getId(), id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in = new DraftInput();
    in.line = 2;
    in.message = "comment by admin";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(admin);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in.message = "revised comment by admin";
    gApi.changes().id(id.get()).current().createDraft(in);
    adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#end_block

#method_before
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string: %s", str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size());
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part: %s", p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#method_after
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string for change %s: %s", id, str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size() - 1);
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part for change %s: %s", id, p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#end_block

#method_before
public static void applyDelta(Change change, Delta delta) {
    String oldStr = change.getNoteDbState();
    if (oldStr == null && (delta == null || !delta.newChangeMetaId.isPresent())) {
        // Can't construct a complete state, bail.
        return;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    if (delta == null) {
        return;
    }
    ObjectId changeMetaId;
    if (delta.newChangeMetaId.isPresent()) {
        changeMetaId = delta.newChangeMetaId.get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return;
        }
    } else {
        changeMetaId = oldState.changeMetaId;
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.draftIds);
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds.entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    change.setNoteDbState(new NoteDbChangeState(change.getId(), changeMetaId, draftIds).toString());
}
#method_after
public static void applyDelta(Change change, Delta delta) {
    if (delta == null) {
        return;
    }
    String oldStr = change.getNoteDbState();
    if (oldStr == null && !delta.newChangeMetaId().isPresent()) {
        // point in proceeding.
        return;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    ObjectId changeMetaId;
    if (delta.newChangeMetaId().isPresent()) {
        changeMetaId = delta.newChangeMetaId().get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return;
        }
    } else {
        changeMetaId = oldState.changeMetaId;
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.draftIds);
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds().entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    change.setNoteDbState(toString(changeMetaId, draftIds));
}
#end_block

#method_before
@Override
public String toString() {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#method_after
private static String toString(ObjectId changeMetaId, Map<Account.Id, ObjectId> draftIds) {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public String toString() {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return toString(changeMetaId, draftIds);
}
#end_block

#method_before
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    diffColumns(diffs, Change.class, desc, bundleA, a, bundleB, b);
}
#method_after
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, "rowVersion", "noteDbState");
}
#end_block

#method_before
public Map<Change.Id, NoteDbChangeState.Delta> stage() throws OrmException, IOException {
    if (staged != null) {
        return staged;
    }
    staged = new HashMap<>();
    if (isEmpty()) {
        return staged;
    }
    initChangeRepo();
    if (!draftUpdates.isEmpty()) {
        initAllUsersRepo();
    }
    addCommands();
    Table<Change.Id, Account.Id, ObjectId> allDraftIds = getDraftIds();
    Set<Change.Id> changeIds = new HashSet<>();
    for (ReceiveCommand cmd : changeRepo.cmds.getCommands().values()) {
        Change.Id changeId = Change.Id.fromRef(cmd.getRefName());
        changeIds.add(changeId);
        Optional<ObjectId> metaId = Optional.of(cmd.getNewId());
        staged.put(changeId, new NoteDbChangeState.Delta(changeId, metaId, allDraftIds.rowMap().remove(changeId)));
    }
    for (Map.Entry<Change.Id, Map<Account.Id, ObjectId>> e : allDraftIds.rowMap().entrySet()) {
        // If a change remains in the table at this point, it means we are
        // updating its drafts but not the change itself.
        staged.put(e.getKey(), new NoteDbChangeState.Delta(e.getKey(), Optional.<ObjectId>absent(), e.getValue()));
    }
    return staged;
}
#method_after
public Map<Change.Id, NoteDbChangeState.Delta> stage() throws OrmException, IOException {
    if (staged != null) {
        return staged;
    }
    try (Timer1.Context timer = metrics.stageUpdateLatency.start(CHANGES)) {
        staged = new HashMap<>();
        if (isEmpty()) {
            return staged;
        }
        initChangeRepo();
        if (!draftUpdates.isEmpty()) {
            initAllUsersRepo();
        }
        addCommands();
        Table<Change.Id, Account.Id, ObjectId> allDraftIds = getDraftIds();
        Set<Change.Id> changeIds = new HashSet<>();
        for (ReceiveCommand cmd : changeRepo.cmds.getCommands().values()) {
            Change.Id changeId = Change.Id.fromRef(cmd.getRefName());
            changeIds.add(changeId);
            Optional<ObjectId> metaId = Optional.of(cmd.getNewId());
            staged.put(changeId, NoteDbChangeState.Delta.create(changeId, metaId, allDraftIds.rowMap().remove(changeId)));
        }
        for (Map.Entry<Change.Id, Map<Account.Id, ObjectId>> e : allDraftIds.rowMap().entrySet()) {
            // If a change remains in the table at this point, it means we are
            // updating its drafts but not the change itself.
            staged.put(e.getKey(), NoteDbChangeState.Delta.create(e.getKey(), Optional.<ObjectId>absent(), e.getValue()));
        }
        return staged;
    }
}
#end_block

#method_before
private Table<Change.Id, Account.Id, ObjectId> getDraftIds() {
    Table<Change.Id, Account.Id, ObjectId> draftIds = HashBasedTable.create();
    if (allUsersRepo == null) {
        return draftIds;
    }
    for (ReceiveCommand cmd : allUsersRepo.cmds.getCommands().values()) {
        String r = cmd.getRefName();
        if (r.startsWith(REFS_DRAFT_COMMENTS)) {
            String msg = "invalid draft ref: %s";
            Account.Id accountId = Account.Id.fromRefPart(r.substring(REFS_DRAFT_COMMENTS.length()));
            checkState(accountId != null, msg, r);
            int s = r.lastIndexOf('/');
            checkState(s >= 0 && s < r.length() - 1, msg, r);
            Change.Id changeId = Change.Id.parse(r.substring(s + 1));
            draftIds.put(changeId, accountId, cmd.getNewId());
        }
    }
    return draftIds;
}
#method_after
private Table<Change.Id, Account.Id, ObjectId> getDraftIds() {
    Table<Change.Id, Account.Id, ObjectId> draftIds = HashBasedTable.create();
    if (allUsersRepo == null) {
        return draftIds;
    }
    for (ReceiveCommand cmd : allUsersRepo.cmds.getCommands().values()) {
        String r = cmd.getRefName();
        if (r.startsWith(REFS_DRAFT_COMMENTS)) {
            Account.Id accountId = Account.Id.fromRefPart(r.substring(REFS_DRAFT_COMMENTS.length()));
            checkDraftRef(accountId != null, r);
            int s = r.lastIndexOf('/');
            checkDraftRef(s >= 0 && s < r.length() - 1, r);
            Change.Id changeId = Change.Id.parse(r.substring(s + 1));
            draftIds.put(changeId, accountId, cmd.getNewId());
        }
    }
    return draftIds;
}
#end_block

#method_before
public void execute() throws OrmException, IOException {
    if (isEmpty()) {
        return;
    }
    // TODO(dborowitz): Separate metric for staging latency?
    stage();
    try (Timer1.Context timer = metrics.updateLatency.start(CHANGES)) {
        // ChangeUpdates must execute before ChangeDraftUpdates.
        // 
        // ChangeUpdate will automatically delete draft comments for any published
        // comments, but the updates to the two repos don't happen atomically.
        // Thus if the change meta update succeeds and the All-Users update fails,
        // we may have stale draft comments. Doing it in this order allows stale
        // comments to be filtered out by ChangeNotes, reflecting the fact that
        // comments can only go from DRAFT to PUBLISHED, not vice versa.
        execute(changeRepo);
        execute(allUsersRepo);
    } finally {
        if (allUsersRepo != null) {
            allUsersRepo.close();
        }
        if (changeRepo != null) {
            changeRepo.close();
        }
    }
}
#method_after
public void execute() throws OrmException, IOException {
    if (isEmpty()) {
        return;
    }
    try (Timer1.Context timer = metrics.updateLatency.start(CHANGES)) {
        stage();
        // ChangeUpdates must execute before ChangeDraftUpdates.
        // 
        // ChangeUpdate will automatically delete draft comments for any published
        // comments, but the updates to the two repos don't happen atomically.
        // Thus if the change meta update succeeds and the All-Users update fails,
        // we may have stale draft comments. Doing it in this order allows stale
        // comments to be filtered out by ChangeNotes, reflecting the fact that
        // comments can only go from DRAFT to PUBLISHED, not vice versa.
        execute(changeRepo);
        execute(allUsersRepo);
    } finally {
        if (allUsersRepo != null) {
            allUsersRepo.close();
        }
        if (changeRepo != null) {
            changeRepo.close();
        }
    }
}
#end_block

#method_before
private static void addUpdates(ListMultimap<String, ? extends AbstractChangeUpdate> updates, OpenRepo or) throws OrmException, IOException {
    for (String refName : updates.keySet()) {
        ObjectId old = firstNonNull(or.cmds.getObjectId(or.repo, refName), ObjectId.zeroId());
        ObjectId curr = old;
        for (AbstractChangeUpdate u : updates.get(refName)) {
            ObjectId next = u.apply(or.rw, or.ins, curr);
            if (next == null) {
                continue;
            }
            curr = next;
        }
        if (!old.equals(curr)) {
            or.cmds.add(new ReceiveCommand(old, curr, refName));
        }
    }
}
#method_after
private static <U extends AbstractChangeUpdate> void addUpdates(ListMultimap<String, U> all, OpenRepo or) throws OrmException, IOException {
    for (Map.Entry<String, Collection<U>> e : all.asMap().entrySet()) {
        String refName = e.getKey();
        Collection<U> updates = e.getValue();
        ObjectId old = firstNonNull(or.cmds.getObjectId(or.repo, refName), ObjectId.zeroId());
        // writing partial change meta if the change hasn't been backfilled yet.
        if (!allowWrite(updates, old)) {
            continue;
        }
        ObjectId curr = old;
        for (U u : updates) {
            ObjectId next = u.apply(or.rw, or.ins, curr);
            if (next == null) {
                continue;
            }
            curr = next;
        }
        if (!old.equals(curr)) {
            or.cmds.add(new ReceiveCommand(old, curr, refName));
        }
    }
}
#end_block

#method_before
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().submit();
}
#method_after
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    gApi.changes().id(changeId).current().submit();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test
public void submitOnBehalfOf() throws Exception {
    allowSubmitOnBehalfOf();
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    gApi.changes().id(changeId).current().submit(in);
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void mergeable() throws Exception {
    ObjectId initial = repo().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 1 content");
    PushOneCommit.Result r1 = push1.to("refs/for/master");
    assertMergeable(r1.getChangeId(), true);
    merge(r1);
    // Reset HEAD to initial so the new change is a merge conflict.
    RefUpdate ru = repo().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 2 content");
    PushOneCommit.Result r2 = push2.to("refs/for/master");
    assertMergeable(r2.getChangeId(), false);
// TODO(dborowitz): Test for other-branches.
}
#method_after
@Test
public void mergeable() throws Exception {
    ObjectId initial = repo().exactRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 1 content");
    PushOneCommit.Result r1 = push1.to("refs/for/master");
    assertMergeable(r1.getChangeId(), true);
    merge(r1);
    // Reset HEAD to initial so the new change is a merge conflict.
    RefUpdate ru = repo().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 2 content");
    PushOneCommit.Result r2 = push2.to("refs/for/master");
    assertMergeable(r2.getChangeId(), false);
// TODO(dborowitz): Test for other-branches.
}
#end_block

#method_before
@Test
public void patch() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeApi changeApi = gApi.changes().id(r.getChangeId());
    BinaryResult bin = changeApi.revision(r.getCommit().name()).patch();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), UTF_8);
    ChangeInfo change = changeApi.get();
    RevisionInfo rev = change.revisions.get(change.currentRevision);
    DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US);
    String date = df.format(rev.commit.author.date);
    assertThat(res).isEqualTo(String.format(PATCH, r.getCommitId().name(), date, r.getChangeId()));
}
#method_after
@Test
public void patch() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeApi changeApi = gApi.changes().id(r.getChangeId());
    BinaryResult bin = changeApi.revision(r.getCommit().name()).patch();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), UTF_8);
    ChangeInfo change = changeApi.get();
    RevisionInfo rev = change.revisions.get(change.currentRevision);
    DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US);
    String date = df.format(rev.commit.author.date);
    assertThat(res).isEqualTo(String.format(PATCH, r.getCommit().name(), date, r.getChangeId()));
}
#end_block

#method_before
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    try {
        cfg.commit(md);
    } finally {
        md.close();
    }
}
#method_after
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        cfg.commit(md);
    }
}
#end_block

#method_before
@Override
protected void merge(PushOneCommit.Result r) throws Exception {
    super.merge(r);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.getRef("refs/heads/master").getObjectId()).isEqualTo(r.getCommitId());
    }
}
#method_after
@Override
protected void merge(PushOneCommit.Result r) throws Exception {
    super.merge(r);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.exactRef("refs/heads/master").getObjectId()).isEqualTo(r.getCommit());
    }
}
#end_block

#method_before
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        commonServer.stop();
        commonServer = null;
    }
    TempFileUtil.cleanup();
}
#method_after
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        try {
            commonServer.stop();
        } finally {
            commonServer = null;
        }
    }
    TempFileUtil.cleanup();
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    if (isNoteDbTestEnabled()) {
        NotesMigration.setAllEnabledConfig(baseConfig);
    }
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected TestRepository<?>.CommitBuilder amendBuilder() throws Exception {
    ObjectId head = repo().getRef("HEAD").getObjectId();
    TestRepository<?>.CommitBuilder b = testRepo.amendRef("HEAD");
    Optional<String> id = GitUtil.getChangeId(testRepo, head);
    // preserve an existing Change-Id. Tests probably want this.
    if (id.isPresent()) {
        b.insertChangeId(id.get().substring(1));
    } else {
        b.insertChangeId();
    }
    return b;
}
#method_after
protected TestRepository<?>.CommitBuilder amendBuilder() throws Exception {
    ObjectId head = repo().exactRef("HEAD").getObjectId();
    TestRepository<?>.CommitBuilder b = testRepo.amendRef("HEAD");
    Optional<String> id = GitUtil.getChangeId(testRepo, head);
    // preserve an existing Change-Id. Tests probably want this.
    if (id.isPresent()) {
        b.insertChangeId(id.get().substring(1));
    } else {
        b.insertChangeId();
    }
    return b;
}
#end_block

#method_before
protected PushOneCommit.Result createChange() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    return result;
}
#method_after
protected PushOneCommit.Result createChange() throws Exception {
    return createChange("refs/for/master");
}
#end_block

#method_before
protected PushOneCommit.Result createChange() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    return result;
}
#method_after
protected PushOneCommit.Result createChange(String ref) throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to(ref);
    result.assertOkStatus();
    return result;
}
#end_block

#method_before
protected Context setApiUserAnonymous() {
    return atrScope.newContext(reviewDbProvider, null, anonymousUser.get());
}
#method_after
protected Context setApiUserAnonymous() {
    return atrScope.set(atrScope.newContext(reviewDbProvider, null, anonymousUser.get()));
}
#end_block

#method_before
protected void setUseContributorAgreements(InheritableBoolean value) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    ProjectConfig config = ProjectConfig.read(md);
    config.getProject().setUseContributorAgreements(value);
    config.commit(md);
    projectCache.evict(config.getProject());
}
#method_after
protected void setUseContributorAgreements(InheritableBoolean value) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().setUseContributorAgreements(value);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
protected void setUseSignedOffBy(InheritableBoolean value) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    ProjectConfig config = ProjectConfig.read(md);
    config.getProject().setUseSignedOffBy(value);
    config.commit(md);
    projectCache.evict(config.getProject());
}
#method_after
protected void setUseSignedOffBy(InheritableBoolean value) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().setUseSignedOffBy(value);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
protected void saveProjectConfig(Project.NameKey p, ProjectConfig cfg) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(p);
    try {
        cfg.commit(md);
    } finally {
        md.close();
    }
    projectCache.evict(cfg.getProject());
}
#method_after
protected void saveProjectConfig(Project.NameKey p, ProjectConfig cfg) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(p)) {
        cfg.commit(md);
    }
    projectCache.evict(cfg.getProject());
}
#end_block

#method_before
protected void grant(String permission, Project.NameKey project, String ref, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    md.setMessage(String.format("Grant %s on %s", permission, ref));
    ProjectConfig config = ProjectConfig.read(md);
    AccessSection s = config.getAccessSection(ref, true);
    Permission p = s.getPermission(permission, true);
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    PermissionRule rule = new PermissionRule(config.resolve(adminGroup));
    rule.setForce(force);
    p.add(rule);
    config.commit(md);
    projectCache.evict(config.getProject());
}
#method_after
protected void grant(String permission, Project.NameKey project, String ref, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
        PermissionRule rule = new PermissionRule(config.resolve(adminGroup));
        rule.setForce(force);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    } catch (IOException e) {
        // TODO: propagate this exception
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(ReviewDb db, Project.NameKey project, Change.Id changeId, CurrentUser user) throws NoSuchChangeException, OrmException {
    return controlFor(notesFactory.create(db, project, changeId), user);
}
#end_block

#method_before
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(ReviewDb db, Change.Id changeId, CurrentUser user) throws NoSuchChangeException, OrmException {
    return validateFor(db, notesFactory.createChecked(changeId), user);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, MoveInput input) throws AuthException, RestApiException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canMoveTo(RefNames.fullName(input.destination), dbProvider.get())) {
        throw new AuthException("Move not permitted");
    } else if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        String currPatchsetRev = dbProvider.get().patchSets().get(patchSetId).getRevision().get();
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString((currPatchsetRev)));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destination);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destination + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destination);
        }
    }
    Change.Key changeKey = change.getKey();
    final Branch.NameKey destKey = new Branch.NameKey(projectKey, input.destination);
    List<Change> destChanges = asChanges(queryProvider.get().byBranchKey(destKey, changeKey));
    if (!destChanges.isEmpty()) {
        for (Change destChange : destChanges) {
            if (destChange.getId().get() == change.getId().get()) {
                throw new ResourceConflictException("Change is already destined for branch");
            }
        }
        throw new ResourceConflictException("Destination " + destKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    Branch.NameKey changePrevDest = change.getDest();
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.currentPatchSetId().equals(patchSetId)) {
                    change.setDest(destKey);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("Patch set is not current");
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Patch set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(destKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(msgBuf.toString());
    gApi.get().changes().id(change.getId().get()).revision(db.patchSets().get(patchSetId).getRevision().get()).review(review);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, MoveInput input) throws RestApiException, OrmException, UpdateException {
    ChangeControl control = req.getControl();
    input.destination_branch = RefNames.fullName(input.destination_branch);
    if (!control.canMoveTo(input.destination_branch, dbProvider.get())) {
        throw new AuthException("Move not permitted");
    }
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), new Op(control, input));
        u.execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(req.getChange());
}
#end_block

#method_before
@Test
public void moveChange_shortRef() throws Exception {
    // Move change to a different branch using short ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.getShortName());
    assertThat(r.getChange().change().getDest().equals(newBranch));
}
#method_after
@Test
public void moveChange_shortRef() throws Exception {
    // Move change to a different branch using short ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.getShortName());
    assertThat(r.getChange().change().getDest()).isEqualTo(newBranch);
}
#end_block

#method_before
@Test
public void moveChange_fullRef() throws Exception {
    // Move change to a different branch using full ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.get());
    assertThat(r.getChange().change().getDest().equals(newBranch));
}
#method_after
@Test
public void moveChange_fullRef() throws Exception {
    // Move change to a different branch using full ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.get());
    assertThat(r.getChange().change().getDest()).isEqualTo(newBranch);
}
#end_block

#method_before
@Test
public void moveChangeWithMessage() throws Exception {
    // Provide a message using --message flag (needed?)
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    String moveMessage = "Moving for the move test";
    move(r.getChangeId(), newBranch.get(), moveMessage);
    assertThat(r.getChange().change().getDest().equals(newBranch));
    assertThat(r.getChange().messages().get(1).equals(moveMessage));
}
#method_after
@Test
public void moveChangeWithMessage() throws Exception {
    // Provide a message using --message flag
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    String moveMessage = "Moving for the move test";
    move(r.getChangeId(), newBranch.get(), moveMessage);
    assertThat(r.getChange().change().getDest()).isEqualTo(newBranch);
    StringBuilder expectedMessage = new StringBuilder();
    expectedMessage.append("Change destination moved from master to moveTest");
    expectedMessage.append("\n\n");
    expectedMessage.append(moveMessage);
    assertThat(r.getChange().messages().get(1).getMessage()).isEqualTo(expectedMessage.toString());
}
#end_block

#method_before
@Test
public void moveChangeToSameRefAsCurrent() throws Exception {
    // Move change to the branch same as change's destination
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already destined for branch");
    move(r.getChangeId(), r.getChange().change().getDest().get());
}
#method_after
@Test
public void moveChangeToSameRefAsCurrent() throws Exception {
    // Move change to the branch same as change's destination
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already destined for the specified branch");
    move(r.getChangeId(), r.getChange().change().getDest().get());
}
#end_block

#method_before
@Test
public void moveMergeCommitChange() throws Exception {
    // Move a change which has a merge commit as the current PS
    // Create a merge commit and push for review
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    TestRepository<?>.CommitBuilder commitBuilder = testRepo.branch("HEAD").commit().insertChangeId();
    commitBuilder.parent(r1.getCommit()).parent(r2.getCommit()).message("Move change Merge Commit").author(admin.getIdent()).committer(new PersonIdent(admin.getIdent(), testRepo.getClock()));
    RevCommit c = commitBuilder.create();
    pushHead(testRepo, "refs/for/master", false, false);
    // Try to move the merge commit to another branch
    Branch.NameKey newBranch = new Branch.NameKey(r1.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Merge commit cannot be moved");
    move(GitUtil.getChangeId(testRepo, c).get(), newBranch.get());
}
#method_after
@Test
public void moveMergeCommitChange() throws Exception {
    // Move a change which has a merge commit as the current PS
    // Create a merge commit and push for review
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    TestRepository<?>.CommitBuilder commitBuilder = testRepo.branch("HEAD").commit().insertChangeId();
    commitBuilder.parent(r1.getCommit()).parent(r2.getCommit()).message("Move change Merge Commit").author(admin.getIdent()).committer(new PersonIdent(admin.getIdent(), testRepo.getDate()));
    RevCommit c = commitBuilder.create();
    pushHead(testRepo, "refs/for/master", false, false);
    // Try to move the merge commit to another branch
    Branch.NameKey newBranch = new Branch.NameKey(r1.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Merge commit cannot be moved");
    move(GitUtil.getChangeId(testRepo, c).get(), newBranch.get());
}
#end_block

#method_before
@Test
public void moveChangeToBranchThatContainsCurrentCommit() throws Exception {
    // Move change to a branch for which current PS revision is reachable from
    // tip
    // Create a change
    PushOneCommit.Result r = createChange();
    int changeNum = r.getChange().change().getChangeId();
    // Create a branch with that same commit
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    BranchInput bi = new BranchInput();
    bi.revision = r.getCommitId().name();
    gApi.projects().name(newBranch.getParentKey().get()).branch(newBranch.get()).create(bi);
    // Try to move the change to the branch with the same commit
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Current patchset revision is reachable from tip of " + newBranch.get());
    move(changeNum, newBranch.get());
}
#method_after
@Test
public void moveChangeToBranchThatContainsCurrentCommit() throws Exception {
    // Move change to a branch for which current PS revision is reachable from
    // tip
    // Create a change
    PushOneCommit.Result r = createChange();
    int changeNum = r.getChange().change().getChangeId();
    // Create a branch with that same commit
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    BranchInput bi = new BranchInput();
    bi.revision = r.getCommit().name();
    gApi.projects().name(newBranch.getParentKey().get()).branch(newBranch.get()).create(bi);
    // Try to move the change to the branch with the same commit
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Current patchset revision is reachable from tip of " + newBranch.get());
    move(changeNum, newBranch.get());
}
#end_block

#method_before
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    try {
        cfg.commit(md);
    } finally {
        md.close();
    }
}
#method_after
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        cfg.commit(md);
    }
}
#end_block

#method_before
private void move(String changeId, String destination, String message) throws RestApiException {
    MoveInput in = new MoveInput();
    in.destination = destination;
    in.message = message;
    gApi.changes().id(changeId).move(in);
}
#method_after
private void move(String changeId, String destination, String message) throws RestApiException {
    MoveInput in = new MoveInput();
    in.destination_branch = destination;
    in.message = message;
    gApi.changes().id(changeId).move(in);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
@Override
public String id() {
    return Integer.toString(change.getChange().getId().get());
}
#method_after
@Override
public String id() {
    return Integer.toString(change.getId().get());
}
#end_block

#method_before
@Override
public void move(String destination) throws RestApiException {
    MoveInput input = new MoveInput();
    input.destination = destination;
    move(input);
}
#method_after
@Override
public void move(String destination) throws RestApiException {
    MoveInput in = new MoveInput();
    in.destination_branch = destination;
    move(in);
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException | NoSuchChangeException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        SuggestChangeReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
private Result execute(String ref) throws Exception {
    RevCommit c = commitBuilder.create();
    if (changeId == null) {
        changeId = GitUtil.getChangeId(testRepo, c).get();
    }
    if (tag != null) {
        TagCommand tagCommand = testRepo.git().tag().setName(tag.name);
        if (tag instanceof AnnotatedTag) {
            AnnotatedTag annotatedTag = (AnnotatedTag) tag;
            tagCommand.setAnnotated(true).setMessage(annotatedTag.message).setTagger(annotatedTag.tagger);
        } else {
            tagCommand.setAnnotated(false);
        }
        tagCommand.call();
    }
    return new Result(ref, pushHead(testRepo, ref, tag != null, force), c, subject);
}
#method_after
public Result execute(String ref) throws Exception {
    RevCommit c = commitBuilder.create();
    if (changeId == null) {
        changeId = GitUtil.getChangeId(testRepo, c).get();
    }
    if (tag != null) {
        TagCommand tagCommand = testRepo.git().tag().setName(tag.name);
        if (tag instanceof AnnotatedTag) {
            AnnotatedTag annotatedTag = (AnnotatedTag) tag;
            tagCommand.setAnnotated(true).setMessage(annotatedTag.message).setTagger(annotatedTag.tagger);
        } else {
            tagCommand.setAnnotated(false);
        }
        tagCommand.call();
    }
    return new Result(ref, pushHead(testRepo, ref, tag != null, force), c, subject);
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException, NoSuchChangeException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Iterable<Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.create(c)).values();
    assertThat(actualIds).containsExactlyElementsIn(Sets.newHashSet(TestAccount.ids(expectedReviewers)));
}
#method_after
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException, NoSuchChangeException {
    Iterable<Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.createChecked(db, c)).values();
    assertThat(actualIds).containsExactlyElementsIn(Sets.newHashSet(TestAccount.ids(expectedReviewers)));
}
#end_block

#method_before
static int toMask(final KeyPressEvent event) {
    int mask = event.getUnicodeCharCode();
    if (mask == 0) {
        mask = event.getNativeEvent().getKeyCode();
    }
    if (event.isAltKeyDown()) {
        mask |= KeyCommand.M_ALT;
    }
    if (event.isControlKeyDown()) {
        mask |= KeyCommand.M_CTRL;
    }
    if (event.isMetaKeyDown()) {
        mask |= KeyCommand.M_META;
    }
    return mask;
}
#method_after
static int toMask(final KeyPressEvent event) {
    int mask = event.getUnicodeCharCode();
    if (mask == 0) {
        mask = event.getNativeEvent().getKeyCode();
    }
    if (event.isControlKeyDown()) {
        mask |= KeyCommand.M_CTRL;
    }
    if (event.isMetaKeyDown()) {
        mask |= KeyCommand.M_META;
    }
    return mask;
}
#end_block

#method_before
protected String currentTimeFormatted() {
    PersonIdent p = new PersonIdent(new PersonIdent(repo.getRepository()));
    return new DateFormatter(Optional.<TimeZone>absent(), DateFormatter.Format.ISO).format(p);
}
#method_after
protected String currentTimeFormatted() {
    PersonIdent p = new PersonIdent(repo.getRepository());
    return new DateFormatter(Optional.<TimeZone>absent(), DateFormatter.Format.ISO).format(p);
}
#end_block

#method_before
static List<Edit> intraline(String a, String b) throws Exception {
    return intraline(a, b, new Edit(0, 1, 0, 1));
}
#method_after
private static List<Edit> intraline(String a, String b) throws Exception {
    return intraline(a, b, new Edit(0, countLines(a), 0, countLines(b)));
}
#end_block

#method_before
static List<Edit> intraline(String a, String b, Edit lines) throws Exception {
    Text aText = new Text(a.getBytes("UTF-8"));
    Text bText = new Text(b.getBytes("UTF-8"));
    IntraLineDiff diff = IntraLineLoader.compute(aText, bText, EditList.singleton(lines));
    assertEquals(diff.getStatus(), IntraLineDiff.Status.EDIT_LIST);
    List<Edit> actualEdits = diff.getEdits();
    assertEquals(actualEdits.size(), 1);
    Edit actualEdit = actualEdits.get(0);
    assertEquals(lines.getBeginA(), actualEdit.getBeginA());
    assertEquals(lines.getEndA(), actualEdit.getEndA());
    assertEquals(lines.getBeginB(), actualEdit.getBeginB());
    assertEquals(lines.getEndB(), actualEdit.getEndB());
    assertTrue(actualEdit instanceof ReplaceEdit);
    return ((ReplaceEdit) actualEdit).getInternalEdits();
}
#method_after
private static List<Edit> intraline(String a, String b, Edit lines) throws Exception {
    Text aText = new Text(a.getBytes(UTF_8));
    Text bText = new Text(b.getBytes(UTF_8));
    IntraLineDiff diff;
    diff = IntraLineLoader.compute(aText, bText, EditList.singleton(lines));
    assertThat(diff.getStatus()).isEqualTo(IntraLineDiff.Status.EDIT_LIST);
    List<Edit> actualEdits = diff.getEdits();
    assertThat(actualEdits).hasSize(1);
    Edit actualEdit = actualEdits.get(0);
    assertThat(actualEdit.getBeginA()).isEqualTo(lines.getBeginA());
    assertThat(actualEdit.getEndA()).isEqualTo(lines.getEndA());
    assertThat(actualEdit.getBeginB()).isEqualTo(lines.getBeginB());
    assertThat(actualEdit.getEndB()).isEqualTo(lines.getEndB());
    assertThat(actualEdit).isInstanceOf(ReplaceEdit.class);
    return ((ReplaceEdit) actualEdit).getInternalEdits();
}
#end_block

#method_before
static List<Edit> wordEdit(int as, int ae, int bs, int be) {
    return EditList.singleton(new Edit(as, ae, bs, be));
}
#method_after
// helpers to compute reference values
private static List<Edit> wordEdit(int as, int ae, int bs, int be) {
    return EditList.singleton(new Edit(as, ae, bs, be));
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serve("/*").with(LfsContentServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    bind(LocalLargeFileRepository.class);
    serve("/*").with(LfsContentServlet.class);
}
#end_block

#method_before
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equals(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnMergeBaseUpdate() && kind == MERGE_FIRST_PARENT_UPDATE) || (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE) || (type.isCopyAllScoresIfNoChange() && kind == NO_CHANGE);
}
#method_after
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equals(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnMergeFirstParentUpdate() && kind == MERGE_FIRST_PARENT_UPDATE) || (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE) || (type.isCopyAllScoresIfNoChange() && kind == NO_CHANGE);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commitId);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommitId);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, null);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        List<String> newGroups = groups;
        if (newGroups.isEmpty()) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    if (magicBranch != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
public void setCopyAllScoresOnMergeFirstParentUpdate(boolean copyAllScoresOnMergeFirstParentUpdate) {
    this.copyAllScoresOnMergeFirestParentUpdate = copyAllScoresOnMergeFirstParentUpdate;
}
#method_after
public void setCopyAllScoresOnMergeFirstParentUpdate(boolean copyAllScoresOnMergeFirstParentUpdate) {
    this.copyAllScoresOnMergeFirstParentUpdate = copyAllScoresOnMergeFirstParentUpdate;
}
#end_block

#method_before
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            } else {
                return ChangeKind.REWORK;
            }
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && (sameFirstParents(prior, next) || !sameRestOfParents(prior, next))) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // A trivial rebase can be detected by looking for the next commit
        // having the same tree as would exist when the prior commit is
        // cherry-picked onto the next commit's new first parent.
        ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, MergeUtil.createDryRunInserter(repo), key.strategyName);
        merger.setBase(prior.getParent(0));
        try {
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                } else {
                    return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
                }
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    }
}
#method_after
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            } else {
                return ChangeKind.REWORK;
            }
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && !onlyFirstParentChanged(prior, next)) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // A trivial rebase can be detected by looking for the next commit
        // having the same tree as would exist when the prior commit is
        // cherry-picked onto the next commit's new first parent.
        ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, MergeUtil.createDryRunInserter(repo), key.strategyName);
        merger.setBase(prior.getParent(0));
        try {
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                } else {
                    return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
                }
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    }
}
#end_block

#method_before
private static boolean sameRestOfParents(RevCommit prior, RevCommit next) {
    Set<RevCommit> priorRestParents = mergedInParents(prior.getParents());
    Set<RevCommit> nextRestParents = mergedInParents(next.getParents());
    return priorRestParents.equals(nextRestParents);
}
#method_after
private static boolean sameRestOfParents(RevCommit prior, RevCommit next) {
    Set<RevCommit> priorRestParents = allExceptFirstParent(prior.getParents());
    Set<RevCommit> nextRestParents = allExceptFirstParent(next.getParents());
    return priorRestParents.equals(nextRestParents);
}
#end_block

#method_before
public int shutdown() {
    int cnt = 0;
    if (pool != null) {
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#method_after
public int shutdown() {
    int cnt = 0;
    if (pool != null) {
        for (Runnable r : pool.getQueue()) {
            repLog.warn(String.format("Cancelling replication event %s", r));
        }
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, delay, TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, retryDelay, TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, delay, TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, retryDelay, TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationSshSessionFactory.class).to(DefaultReplicationSshSessionFactory.class);
    EventTypes.registerClass(new RefReplicatedEvent(null, null, null, SUCCEEDED));
    EventTypes.registerClass(new RefReplicationDoneEvent(null, null, 0));
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.register(RefReplicatedEvent.TYPE, RefReplicatedEvent.class);
    EventTypes.register(RefReplicationDoneEvent.TYPE, RefReplicationDoneEvent.class);
    bind(SshSessionFactory.class).toProvider(ReplicationSshSessionFactoryProvider.class);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher, database));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher.get(), database));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean createProject(Project.NameKey project, String head) {
    boolean success = false;
    for (URIish uri : getURIs(project, FilterType.PROJECT_CREATION)) {
        success &= createProject(uri, head);
    }
    return success;
}
#method_after
public boolean createProject(Project.NameKey project, String head) {
    boolean success = true;
    for (URIish uri : getURIs(project, FilterType.PROJECT_CREATION)) {
        success &= createProject(uri, head);
    }
    return success;
}
#end_block

#method_before
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            if (head != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.disableRefLog();
                u.link(head);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#method_after
private static void createLocally(URIish uri, String head) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        repo.create(true);
        if (head != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#end_block

#method_before
private static void updateHeadLocally(URIish uri, String newHead) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            if (newHead != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.link(newHead);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#method_after
private static void updateHeadLocally(URIish uri, String newHead) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        if (newHead != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.link(newHead);
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#end_block

#method_before
private RemoteSession connect(URIish uri) throws TransportException {
    return sshSessionFactory.create().getSession(uri, null, FS.DETECTED, 0);
}
#method_after
private RemoteSession connect(URIish uri) throws TransportException {
    return sshSessionFactoryProvider.get().getSession(uri, null, FS.DETECTED, SSH_REMOTE_TIMEOUT);
}
#end_block

#method_before
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && config.isReplicateAllOnPluginStart()) {
        ReplicationState state = new ReplicationState();
        pushAllFuture.set(pushAll.create(null, ReplicationFilter.all(), state).schedule(30, TimeUnit.SECONDS));
    }
}
#method_after
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && config.isReplicateAllOnPluginStart()) {
        ReplicationState state = new ReplicationState(new GitUpdateProcessing(eventDispatcher.get(), database));
        pushAllFuture.set(pushAll.create(null, ReplicationFilter.all(), state).schedule(30, TimeUnit.SECONDS));
    }
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    if (!commentAddedHook.isPresent()) {
        return;
    }
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval);
                }
                return r;
            }
            return null;
        }
    });
    fireEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    if (!changeMergedHook.isPresent()) {
        return;
    }
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    fireEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    // patchSetAttributeSupplier(change, patchSet, db);
    event.patchSet = null;
    // accountAttributeSupplier(account);
    event.reviewer = null;
    fireEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    if (!topicChangedHook.isPresent()) {
        return;
    }
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
public CheckedFuture<?, IOException> indexAsync(Collection<Change.Id> ids) {
    List<ListenableFuture<?>> futures = new ArrayList<>(ids.size());
    for (Change.Id id : ids) {
        futures.add(indexAsync(id));
    }
    return allAsList(futures);
}
#method_after
public CheckedFuture<?, IOException> indexAsync(Project.NameKey project, Change.Id id) {
    return executor != null ? submit(new IndexTask(project, id)) : Futures.<Object, IOException>immediateCheckedFuture(null);
}
#end_block

#method_before
public void index(ChangeData cd) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd.getId());
}
#method_after
public void index(ChangeData cd) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd);
}
#end_block

#method_before
private void fireChangeIndexedEvent(Change.Id id) {
    Event indexEvent = createIndexEvent(id);
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeIndexed(indexEvent);
    }
}
#method_after
private void fireChangeIndexedEvent(ChangeData change) {
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeIndexed(change);
    }
}
#end_block

#method_before
private void fireChangeDeletedFromIndexEvent(Change.Id id) {
    Event indexEvent = createIndexEvent(id);
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeDeleted(indexEvent);
    }
}
#method_after
private void fireChangeDeletedFromIndexEvent(Change.Id id) {
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeDeleted(id);
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        RequestContext newCtx = new RequestContext() {

            @Override
            public Provider<ReviewDb> getReviewDbProvider() {
                Provider<ReviewDb> db = dbRef.get();
                if (db == null) {
                    try {
                        db = Providers.of(schemaFactory.open());
                    } catch (OrmException e) {
                        ProvisionException pe = new ProvisionException("error opening ReviewDb");
                        pe.initCause(e);
                        throw pe;
                    }
                    dbRef.set(db);
                }
                return db;
            }

            @Override
            public CurrentUser getUser() {
                throw new OutOfScopeException("No user during ChangeIndexer");
            }
        };
        RequestContext oldCtx = context.setContext(newCtx);
        try {
            ChangeData cd = changeDataFactory.create(newCtx.getReviewDbProvider().get(), id);
            index(cd);
            return null;
        } finally {
            context.setContext(oldCtx);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d", id.get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        RequestContext newCtx = new RequestContext() {

            @Override
            public Provider<ReviewDb> getReviewDbProvider() {
                Provider<ReviewDb> db = dbRef.get();
                if (db == null) {
                    try {
                        db = Providers.of(schemaFactory.open());
                    } catch (OrmException e) {
                        ProvisionException pe = new ProvisionException("error opening ReviewDb");
                        pe.initCause(e);
                        throw pe;
                    }
                    dbRef.set(db);
                }
                return db;
            }

            @Override
            public CurrentUser getUser() {
                throw new OutOfScopeException("No user during ChangeIndexer");
            }
        };
        RequestContext oldCtx = context.setContext(newCtx);
        try {
            ChangeData cd = changeDataFactory.create(newCtx.getReviewDbProvider().get(), project, id);
            index(cd);
            return null;
        } finally {
            context.setContext(oldCtx);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d", id.get()), e);
        throw e;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(final Project project, final String refname, final Account uploader, final ObjectId oldId, final ObjectId newId) {
    final List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final DraftPublishedEvent event = new DraftPublishedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<String, Short> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval);
                }
                return r;
            }
            return null;
        }
    });
    fireEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final MergeFailedEvent event = new MergeFailedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeRestoredEvent event = new ChangeRestoredEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final RefUpdate refUpdate, final Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#method_after
@Override
public void doRefUpdatedHook(Branch.NameKey refName, RefUpdate refUpdate, Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    fireEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ReviewerAddedEvent event = new ReviewerAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    fireEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(final Change change, final Account account, final String oldTopic, final ReviewDb db) throws OrmException {
    final TopicChangedEvent event = new TopicChangedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
@Override
public void postEvent(final Change change, final ChangeEvent event, final ReviewDb db) throws OrmException {
    fireEvent(change, event, db);
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) throws OrmException {
    fireEvent(change, event, db);
}
#end_block

#method_before
@Override
public void postEvent(final Branch.NameKey branchName, final RefEvent event) {
    fireEvent(branchName, event);
}
#method_after
@Override
public void postEvent(Branch.NameKey branchName, RefEvent event) {
    fireEvent(branchName, event);
}
#end_block

#method_before
@Override
public void postEvent(final Branch.NameKey branchName, final RefEvent event) {
    fireEvent(branchName, event);
}
#method_after
@Override
public void postEvent(com.google.gerrit.server.events.Event event, ReviewDb db) throws OrmException {
    fireEvent(event, db);
}
#end_block

#method_before
private void fireEvent(final Change change, final ChangeEvent event, final ReviewDb db) throws OrmException {
    dispatcher.fireEvent(change, event, db);
}
#method_after
private void fireEvent(Change change, ChangeEvent event, ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final RefEvent event) {
    dispatcher.fireEvent(branchName, event);
}
#method_after
private void fireEvent(Project.NameKey project, ProjectEvent event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(project, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final RefEvent event) {
    dispatcher.fireEvent(branchName, event);
}
#method_after
private void fireEvent(Branch.NameKey branchName, RefEvent event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private String getDisplayName(final Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#method_after
private String getDisplayName(Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        final int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#method_after
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.toAbsolutePath().toString());
        argv.addAll(args);
        ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.toAbsolutePath().toString());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        String output = null;
        try (InputStream is = ps.getInputStream()) {
            output = readOutput(is);
        } finally {
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.toAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#end_block

#method_before
protected String getName() {
    return hook.getName();
}
#method_after
protected String getName() {
    return hook.getFileName().toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "hook " + hook.getName();
}
#method_after
@Override
public String toString() {
    return "hook " + hook.getFileName();
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) {
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, RefEvent event) {
}
#method_after
@Override
public void postEvent(Event event, ReviewDb db) {
}
#end_block

#method_before
@Before
public void setTimeForTesting() {
    systemTimeZone = System.setProperty("user.timezone", "US/Eastern");
    resetTimeWithClockStep(1, MILLISECONDS);
}
#method_after
@Before
public void setTimeForTesting() {
    resetTimeWithClockStep(1, MILLISECONDS);
}
#end_block

#method_before
private void resetTimeWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    // TODO(dborowitz): Figure out why tests fail when stubbing out
    // SystemReader.
    TestTimeUtil.resetWithClockStep(clockStep, clockStepUnit);
    SystemReader.setInstance(null);
}
#method_after
private void resetTimeWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    systemTimeZone = System.setProperty("user.timezone", "US/Eastern");
    // TODO(dborowitz): Figure out why tests fail when stubbing out
    // SystemReader.
    TestTimeUtil.resetWithClockStep(clockStep, clockStepUnit);
    SystemReader.setInstance(null);
}
#end_block

#method_before
@Test
public void updatedOrderWithMinuteResolution() throws Exception {
    resetTimeWithClockStep(2, MINUTES);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).current().review(new ReviewInput());
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isGreaterThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#method_after
@Test
public void updatedOrderWithMinuteResolution() throws Exception {
    resetTimeWithClockStep(2, MINUTES);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).topic("new-topic");
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isGreaterThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#end_block

#method_before
@Test
public void updatedOrderWithSubMinuteResolution() throws Exception {
    resetTimeWithClockStep(1, SECONDS);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).current().review(new ReviewInput());
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isLessThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#method_after
@Test
public void updatedOrderWithSubMinuteResolution() throws Exception {
    resetTimeWithClockStep(1, SECONDS);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).topic("new-topic");
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isLessThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#end_block

#method_before
@Override
public void afterUpdateRepos() throws ResourceConflictException {
    try {
        markCleanMerges();
        checkCommitStatus();
        findUnmergedChanges();
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#method_after
@Override
public void afterUpdateRepos() throws ResourceConflictException {
    try {
        markCleanMerges();
        List<Change.Id> alreadyMerged = checkCommitStatus();
        findUnmergedChanges(alreadyMerged);
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#end_block

#method_before
private void findUnmergedChanges() throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip());
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void findUnmergedChanges(List<Change.Id> alreadyMerged) throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip(), alreadyMerged);
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void checkCommitStatus() throws ResourceConflictException {
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            return;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
            case ALREADY_MERGED:
                // Merge strategy accepted this change.
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private List<Change.Id> checkCommitStatus() throws ResourceConflictException {
    List<Change.Id> alreadyMerged = new ArrayList<>(commits.getChangeIds().size());
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
                // Merge strategy accepted this change.
                break;
            case ALREADY_MERGED:
                // Already an ancestor of tip.
                alreadyMerged.add(commit.getPatchsetId().getParentKey());
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
    return alreadyMerged;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                parentCommit = destRef.getObjectId();
            } else {
                if (input.newBranch) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(project, changeId));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                } else {
                    parentCommit = destRef.getObjectId();
                }
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(project, changeId));
        }
    }
}
#end_block

#method_before
private static ObjectId emptyTreeId(ObjectInserter inserter) throws IOException {
    return inserter.insert(new TreeFormatter());
}
#method_after
private static ObjectId emptyTreeId(ObjectInserter inserter) throws IOException {
    ObjectId id = inserter.insert(new TreeFormatter());
    inserter.flush();
    return id;
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = notesFactory.create(db, project.getNameKey(), cid).getChange();
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = notesFactory.create(db, project.getNameKey(), cid).getChange();
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UpdateException, RestApiException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, new Op(rsrc, result, reviewers));
        bu.execute();
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    return !added.isEmpty();
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (!added.isEmpty()) {
        patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    }
    return !added.isEmpty();
}
#end_block

#method_before
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    if (!added.isEmpty()) {
        PatchSet patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
        }
    }
}
#method_after
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException {
    // Do not allow creating groups with the same name as system groups
    Map<String, GroupReference> sysGroupNames = SystemGroupBackend.getNames();
    if (sysGroupNames.containsKey(createGroupArgs.getGroupName().toLowerCase())) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#method_after
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException {
    // Do not allow creating groups with the same name as system groups
    List<String> sysGroupNames = SystemGroupBackend.getNames();
    for (String name : sysGroupNames) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#end_block

#method_before
public static boolean isSystemGroup(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:");
}
#method_after
public static boolean isSystemGroup(AccountGroup.UUID uuid) {
    return uuid.get().startsWith(SYSTEM_GROUP_SCHEME);
}
#end_block

#method_before
public static Map<String, GroupReference> getNames() {
    return names;
}
#method_after
public static List<String> getNames() {
    List<String> names = new ArrayList<>();
    for (AccountGroup.UUID uuid : all) {
        int c = uuid.get().indexOf(':');
        names.add(uuid.get().substring(c + 1).replace('-', ' '));
    }
    return names;
}
#end_block

#method_before
public static IndexConfig create(int maxLimit, int maxPages, int maxTerms, int maxPrefixTerms) {
    return new AutoValue_IndexConfig(checkLimit(maxLimit, "maxLimit", Integer.MAX_VALUE), checkLimit(maxPages, "maxPages", Integer.MAX_VALUE), checkLimit(maxTerms, "maxTerms", BooleanQuery.getMaxClauseCount()), checkLimit(maxPrefixTerms, "maxPrefixTerms", DEFAULT_MAX_PREFIX_TERMS));
}
#method_after
public static IndexConfig create(int maxLimit, int maxPages, int maxTerms, int maxPrefixTerms) {
    return new AutoValue_IndexConfig(checkLimit(maxLimit, "maxLimit", Integer.MAX_VALUE), checkLimit(maxPages, "maxPages", Integer.MAX_VALUE), checkLimit(maxTerms, "maxTerms", DEFAULT_MAX_TERMS), checkLimit(maxPrefixTerms, "maxPrefixTerms", DEFAULT_MAX_PREFIX_TERMS));
}
#end_block

#method_before
@Override
public PreferenceInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && self.get().getUserName() != rsrc.getUser().getUserName() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to administrator");
    }
    Account a = db.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException();
    }
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        return new PreferenceInfo(a.getGeneralPreferences(), p, git);
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    return readFromGit ? readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId);
}
#end_block

#method_before
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameField(e, table, from, to);
    }
}
#method_after
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameColumn(e, table, from, to);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    ctx.getRevWalk().parseBody(commit);
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#method_after
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#method_after
@Before
public void setUp() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports notedb.
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (RevWalk walk = new RevWalk(reader);
        ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        noteMap = parser.commentNoteMap;
        change.setDest(new Branch.NameKey(getProjectName(), parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // This is generally an error, but for now at least we support it in
            // tests.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (RevWalk walk = new RevWalk(reader);
        ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        noteMap = parser.commentNoteMap;
        change.setDest(new Branch.NameKey(getProjectName(), parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // TODO(dborowitz): This should be an error, but for now it's required
            // for some tests to pass.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#end_block

#method_before
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS1").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getCurrentPatchSet().getRevision().get()).isEqualTo(commit.name());
    // new revId for the same patch set, ps1
    commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#method_after
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(ps).isNotNull();
    // new revId for the same patch set, ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1 again").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#end_block

#method_before
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1").create();
    update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(changeOwner.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
    // ps2 by other user
    incrementPatchSet(c);
    commit = tr.commit().message("PS2").create();
    update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    ps = notes.getCurrentPatchSet();
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
}
#method_after
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1 created by newChange()
    ChangeNotes notes = newNotes(c);
    PatchSet ps1 = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps1.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(ps1.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps1.getUploader()).isEqualTo(changeOwner.getAccountId());
    // ps2 by other user
    incrementPatchSet(c);
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    PatchSet ps2 = notes.getCurrentPatchSet();
    assertThat(ps2.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps2.getId());
    assertThat(ps2.getRevision().get()).isNotEqualTo(ps1.getRevision());
    assertThat(ps2.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps2.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps2.getCreatedOn()).isEqualTo(update.getWhen());
}
#end_block

#method_before
protected Change newChange() throws IOException, OrmException, ConfigInvalidException {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#end_block

#method_before
protected ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws OrmException, IOException, ConfigInvalidException {
    ChangeUpdate update = TestChanges.newUpdate(injector, repoManager, MIGRATION, c, allUsers, user);
    try (Repository repo = repoManager.openMetadataRepository(c.getProject())) {
        update.load(repo);
    }
    return update;
}
#method_after
protected ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws Exception {
    ChangeUpdate update = TestChanges.newUpdate(injector, repoManager, MIGRATION, c, allUsers, user);
    try (Repository repo = repoManager.openMetadataRepository(c.getProject())) {
        update.load(repo);
    }
    return update;
}
#end_block

#method_before
@VisibleForTesting
void setSubject(String subject) {
    this.subject = subject;
}
#method_after
void setSubject(String subject) {
    this.subject = subject;
}
#end_block

#method_before
@Test
public void approvalsCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) 1);
    update.putApproval("Code-Review", (short) -1);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.putReviewer(otherUser.getAccount().getId(), CC);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    RevCommit commit = parseCommit(update.getRevision());
    assertBodyEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Label: Code-Review=-1\n" + "Label: Verified=+1\n", commit);
    PersonIdent author = commit.getAuthorIdent();
    assertThat(author.getName()).isEqualTo("Change Owner");
    assertThat(author.getEmailAddress()).isEqualTo("1@gerrit");
    assertThat(author.getWhen()).isEqualTo(new Date(c.getCreatedOn().getTime() + 1000));
    assertThat(author.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT-7:00"));
    PersonIdent committer = commit.getCommitterIdent();
    assertThat(committer.getName()).isEqualTo("Gerrit Server");
    assertThat(committer.getEmailAddress()).isEqualTo("noreply@gerrit.com");
    assertThat(committer.getWhen()).isEqualTo(author.getWhen());
    assertThat(committer.getTimeZone()).isEqualTo(author.getTimeZone());
}
#method_after
@Test
public void approvalsCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) 1);
    update.putApproval("Code-Review", (short) -1);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.putReviewer(otherUser.getAccount().getId(), CC);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    RevCommit commit = parseCommit(update.getRevision());
    assertBodyEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Subject: Change subject\n" + "Branch: refs/heads/master\n" + "Commit: " + update.getCommit().name() + "\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Label: Code-Review=-1\n" + "Label: Verified=+1\n", commit);
    PersonIdent author = commit.getAuthorIdent();
    assertThat(author.getName()).isEqualTo("Change Owner");
    assertThat(author.getEmailAddress()).isEqualTo("1@gerrit");
    assertThat(author.getWhen()).isEqualTo(new Date(c.getCreatedOn().getTime() + 1000));
    assertThat(author.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT-7:00"));
    PersonIdent committer = commit.getCommitterIdent();
    assertThat(committer.getName()).isEqualTo("Gerrit Server");
    assertThat(committer.getEmailAddress()).isEqualTo("noreply@gerrit.com");
    assertThat(committer.getWhen()).isEqualTo(author.getWhen());
    assertThat(committer.getTimeZone()).isEqualTo(author.getTimeZone());
}
#end_block

#method_before
@Test
public void changeMessageCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Just a little code change.\n" + "How about a new line");
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Just a little code change.\n" + "How about a new line\n" + "\n" + "Patch-set: 1\n", update.getRevision());
}
#method_after
@Test
public void changeMessageCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Just a little code change.\n" + "How about a new line");
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Just a little code change.\n" + "How about a new line\n" + "\n" + "Patch-set: 1\n" + "Subject: Change subject\n" + "Branch: refs/heads/master\n" + "Commit: " + update.getCommit().name() + "\n", update.getRevision());
}
#end_block

#method_before
@Test
public void changeWithRevision() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Foo");
    RevCommit commit = tr.commit().message("Subject").create();
    update.setCommit(rw, commit);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Foo\n" + "\n" + "Patch-set: 1\n" + "Subject: Subject\n" + "Commit: " + commit.name() + "\n", update.getRevision());
}
#method_after
@Test
public void changeWithRevision() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Foo");
    RevCommit commit = tr.commit().message("Subject").create();
    update.setCommit(rw, commit);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Foo\n" + "\n" + "Patch-set: 1\n" + "Subject: Subject\n" + "Branch: refs/heads/master\n" + "Commit: " + commit.name() + "\n", update.getRevision());
}
#end_block

#method_before
public void putApproval(String label, short value) {
    approvals.put(label, Optional.of(value));
}
#method_after
public void putApproval(String label, short value) {
    putApprovalFor(getUser().getAccountId(), label, value);
}
#end_block

#method_before
public void removeApproval(String label) {
    approvals.put(label, Optional.<Short>absent());
}
#method_after
public void removeApproval(String label) {
    removeApprovalFor(getUser().getAccountId(), label);
}
#end_block

#method_before
public void merge(Iterable<SubmitRecord> submitRecords) {
    this.status = Change.Status.MERGED;
    this.submitRecords = ImmutableList.copyOf(submitRecords);
    checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time");
}
#method_after
public void merge(String submissionId, Iterable<SubmitRecord> submitRecords) {
    this.status = Change.Status.MERGED;
    this.submissionId = submissionId;
    this.submitRecords = ImmutableList.copyOf(submitRecords);
    checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time");
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        writeCommit(batch);
        if (draftUpdate != null) {
            draftUpdate.commit();
        }
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        writeCommit(batch);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(this, builder);
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(this, builder);
    if (draftUpdate != null) {
        draftUpdate.commit();
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) {
    if (isEmpty()) {
        return false;
    }
    commit.setAuthor(newIdent(getUser().getAccount(), when));
    commit.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (subject != null) {
        msg.append(subject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (revId != null) {
        addFooter(msg, FOOTER_COMMIT, revId);
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        Account account = accountCache.get(e.getKey()).getAccount();
        PersonIdent ident = newIdent(account, when);
        addFooter(msg, e.getValue().getFooterKey()).append(ident.getName()).append(" <").append(ident.getEmailAddress()).append(">\n");
    }
    for (Map.Entry<String, Optional<Short>> e : approvals.entrySet()) {
        if (!e.getValue().isPresent()) {
            addFooter(msg, FOOTER_LABEL, '-', e.getKey());
        } else {
            addFooter(msg, FOOTER_LABEL, LabelVote.create(e.getKey(), e.getValue().get()).formatWithEquals());
        }
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    commit.setMessage(msg.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder cb) {
    if (getRevision() != null && isEmpty()) {
        return false;
    }
    cb.setAuthor(newIdent(getUser().getAccount(), when));
    cb.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit.name());
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(ctl.getUser().getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    cb.setMessage(msg.toString());
    return true;
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && status == null && subject == null && submitRecords == null && hashtags == null && topic == null;
}
#method_after
private boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && branch == null && status == null && subject == null && submissionId == null && submitRecords == null && hashtags == null && topic == null && commit == null;
}
#end_block

#method_before
static PersonIdent newIdent(Account author, Date when, PersonIdent serverIdent, String anonymousCowardName) {
    return new PersonIdent(new AccountInfo(author).getName(anonymousCowardName), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone());
}
#method_after
@VisibleForTesting
public static PersonIdent newIdent(Account author, Date when, PersonIdent serverIdent, String anonymousCowardName) {
    return new PersonIdent(new AccountInfo(author).getName(anonymousCowardName), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone());
}
#end_block

#method_before
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#method_after
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#end_block

#method_before
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: new\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#method_after
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#end_block

#method_before
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Patch-Set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: x\n");
}
#method_after
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Patch-Set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: x\n");
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#method_after
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: 1@gerrit\n");
}
#method_after
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic:");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#method_after
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#end_block

#method_before
@Test
public void parseCommit() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Commit: f11d66c4e8d1660f871b7ccf7df802a966975b85");
}
#method_after
@Test
public void parseCommit() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: abcd1234abcd1234abcd1234abcd1234abcd1234");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Commit: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    assertParseFails("Update patch set 1\n" + "Uploaded patch set 1.\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: beef");
}
#end_block

#method_before
private static String status(Status status) {
    switch(status) {
        case ABANDONED:
            return "status:abandoned";
        case DRAFT:
            return "status:draft";
        case MERGED:
            return "status:merged";
        case NEW:
        default:
            return "status:open";
    }
}
#method_after
private static String status(Status status) {
    switch(status) {
        case ABANDONED:
            return "status:abandoned";
        case MERGED:
            return "status:merged";
        case DRAFT:
        case NEW:
        default:
            return "status:open";
    }
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(ins.getChange().getId(), new BatchUpdate.Op() {

                    @Override
                    public void updateChange(ChangeContext ctx) throws Exception {
                        ctx.getUpdate(ps.getId()).setTopic(magicBranch.topic);
                    }
                });
            }
        }
        bu.execute();
    }
    created = true;
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId());
    msg.setMessage(renderMessageWithApprovals(newPatchSet.getPatchSetId(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#method_after
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), createdOn, psId);
    msg.setMessage(renderMessageWithApprovals(psId.get(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, RestApiException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubject("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, RevCommit commit) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = db.changes().get(cid);
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    CurrentUser currentUser = user.get();
    if (!currentUser.isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return byChange(change, currentUser.asIdentifiedUser());
}
#method_after
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    try {
        return byChange(changeControlFactory.controlFor(change, user.get()));
    } catch (NoSuchChangeException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change, IdentifiedUser user) throws IOException {
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(user.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.absent();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(user, change, ref, commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeControl ctl) throws AuthException, IOException {
    if (!ctl.getUser().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = ctl.getUser().asIdentifiedUser();
    Change change = ctl.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.absent();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(ctl, ref);
            return Optional.of(new ChangeEdit(u, change, ref, commit, basePs));
        }
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(Change change, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return db.get().patchSets().get(new PatchSet.Id(change.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(ChangeControl ctl, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), ctl.getNotes(), new PatchSet.Id(ctl.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    if (Objects.equals(commit, currPsCommit)) {
        // Caller gave us latest patch set SHA-1; verified in checkPatchSets.
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change.getDest().get(), tip.name()));
            return;
        }
        RevId revId = new RevId(commit.name());
        List<PatchSet> patchSets = FluentIterable.from(db.get().patchSets().byRevision(revId)).filter(new Predicate<PatchSet>() {

            @Override
            public boolean apply(PatchSet ps) {
                try {
                    Change c = db.get().changes().get(ps.getId().getParentKey());
                    return c != null && c.getDest().equals(change.getDest());
                } catch (OrmException e) {
                    warn(e);
                    // Should cause an error below, that's good.
                    return true;
                }
            }
        }).toSortedList(ChangeUtil.PS_ID_ORDER);
        switch(patchSets.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change.getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change.getKey().get()));
                    return;
                }
                PatchSet.Id psId = insertPatchSet(commit);
                if (psId != null) {
                    checkMergedBitMatchesStatus(psId, commit, true);
                }
                break;
            case 1:
                // Existing patch set of this commit; check that it is the current
                // patch set.
                // TODO(dborowitz): This could be fixed if it's an older patch set of
                // the current change.
                PatchSet.Id id = patchSets.get(0).getId();
                if (!id.equals(change.currentPatchSetId())) {
                    problem(String.format("Expected merged commit %s corresponds to" + " patch set %s, which is not the current patch set %s", commit.name(), id, change.currentPatchSetId()));
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), patchSets));
                break;
        }
    } catch (OrmException | IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#method_after
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    if (Objects.equals(commit, currPsCommit)) {
        // Caller gave us latest patch set SHA-1; verified in checkPatchSets.
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change.getDest().get(), tip.name()));
            return;
        }
        List<PatchSet.Id> psIds = new ArrayList<>();
        for (Ref ref : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (!ref.getObjectId().equals(commit)) {
                continue;
            }
            PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
            if (psId == null) {
                continue;
            }
            try {
                Change c = db.get().changes().get(psId.getParentKey());
                if (c == null || !c.getDest().equals(change.getDest())) {
                    continue;
                }
            } catch (OrmException e) {
                warn(e);
            // Include this patch set; should cause an error below, which is good.
            }
            psIds.add(psId);
        }
        switch(psIds.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change.getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change.getKey().get()));
                    return;
                }
                PatchSet.Id psId = insertPatchSet(commit);
                if (psId != null) {
                    checkMergedBitMatchesStatus(psId, commit, true);
                }
                break;
            case 1:
                // Existing patch set of this commit; check that it is the current
                // patch set.
                // TODO(dborowitz): This could be fixed if it's an older patch set of
                // the current change.
                PatchSet.Id id = psIds.get(0);
                if (!id.equals(change.currentPatchSetId())) {
                    problem(String.format("Expected merged commit %s corresponds to" + " patch set %s, which is not the current patch set %s", commit.name(), id, change.currentPatchSetId()));
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), intKeyOrdering().sortedCopy(psIds)));
                break;
        }
    } catch (IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#end_block

#method_before
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setUploader(user.get().getAccountId()).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#method_after
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#end_block

#method_before
private void deletePatchSet(ProblemInfo p, PatchSet.Id psId) {
    ReviewDb db = this.db.get();
    Change.Id cid = psId.getParentKey();
    try {
        db.changes().beginTransaction(cid);
        try {
            Change c = db.changes().get(cid);
            if (c == null) {
                throw new OrmException("Change missing: " + cid);
            }
            if (psId.equals(c.currentPatchSetId())) {
                List<PatchSet> all = Lists.newArrayList(db.patchSets().byChange(cid));
                if (all.size() == 1 && all.get(0).getId().equals(psId)) {
                    p.status = Status.FIX_FAILED;
                    p.outcome = "Cannot delete patch set; no patch sets would remain";
                    return;
                }
                // If there were multiple missing patch sets, assumes deletePatchSet
                // has been called in decreasing order, so the max remaining PatchSet
                // is the effective current patch set.
                Collections.sort(all, PS_ID_ORDER.reverse());
                PatchSet.Id latest = null;
                for (PatchSet ps : all) {
                    latest = ps.getId();
                    if (!ps.getId().equals(psId)) {
                        break;
                    }
                }
                c.setCurrentPatchSet(patchSetInfoFactory.get(db, latest));
                db.changes().update(Collections.singleton(c));
            }
            // Delete dangling primary key references. Don't delete ChangeMessages,
            // which don't use patch sets as a primary key, and may provide useful
            // historical information.
            db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(psId));
            db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
            db.patchComments().delete(db.patchComments().byPatchSet(psId));
            db.patchSets().deleteKeys(Collections.singleton(psId));
            db.commit();
            p.status = Status.FIXED;
            p.outcome = "Deleted patch set";
        } finally {
            db.rollback();
        }
    } catch (PatchSetInfoNotAvailableException | OrmException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + ' ' + psId, e);
        p.status = Status.FIX_FAILED;
        p.outcome = msg;
    }
}
#method_after
private void deletePatchSet(ProblemInfo p, PatchSet.Id psId) {
    ReviewDb db = this.db.get();
    Change.Id cid = psId.getParentKey();
    try {
        db.changes().beginTransaction(cid);
        try {
            Change c = db.changes().get(cid);
            if (c == null) {
                throw new OrmException("Change missing: " + cid);
            }
            ChangeNotes notes = notesFactory.create(c);
            if (psId.equals(c.currentPatchSetId())) {
                List<PatchSet> all = Lists.newArrayList(db.patchSets().byChange(cid));
                if (all.size() == 1 && all.get(0).getId().equals(psId)) {
                    p.status = Status.FIX_FAILED;
                    p.outcome = "Cannot delete patch set; no patch sets would remain";
                    return;
                }
                // If there were multiple missing patch sets, assumes deletePatchSet
                // has been called in decreasing order, so the max remaining PatchSet
                // is the effective current patch set.
                Collections.sort(all, PS_ID_ORDER.reverse());
                PatchSet.Id latest = null;
                for (PatchSet ps : all) {
                    latest = ps.getId();
                    if (!ps.getId().equals(psId)) {
                        break;
                    }
                }
                c.setCurrentPatchSet(patchSetInfoFactory.get(db, notes, latest));
                db.changes().update(Collections.singleton(c));
            }
            // Delete dangling primary key references. Don't delete ChangeMessages,
            // which don't use patch sets as a primary key, and may provide useful
            // historical information.
            db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(psId));
            db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
            db.patchComments().delete(db.patchComments().byPatchSet(psId));
            db.patchSets().deleteKeys(Collections.singleton(psId));
            db.commit();
            p.status = Status.FIXED;
            p.outcome = "Deleted patch set";
        } finally {
            db.rollback();
        }
    } catch (PatchSetInfoNotAvailableException | OrmException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + ' ' + psId, e);
        p.status = Status.FIX_FAILED;
        p.outcome = msg;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#end_block

#method_before
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameField(e, table, from, to);
    }
}
#method_after
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameColumn(e, table, from, to);
    }
}
#end_block

#method_before
private void add(ReceiveCommand cmd) {
    checkArgument(!cmd.getOldId().equals(cmd.getNewId()), "ref update is a no-op: %s", cmd);
    ReceiveCommand old = commands.get(cmd.getRefName());
    if (old == null) {
        commands.put(cmd.getRefName(), cmd);
        return;
    }
    checkArgument(old.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED, "cannot chain ref update %s after update %s with result %s", cmd, old, old.getResult());
    checkArgument(cmd.getOldId().equals(old.getNewId()), "cannot chain ref update %s after update %s with different new ID");
    commands.put(cmd.getRefName(), new ReceiveCommand(old.getOldId(), cmd.getNewId(), cmd.getRefName()));
}
#method_after
private void add(ReceiveCommand cmd) {
    checkArgument(!cmd.getOldId().equals(cmd.getNewId()), "ref update is a no-op: %s", cmd);
    ReceiveCommand old = commands.get(cmd.getRefName());
    if (old == null) {
        commands.put(cmd.getRefName(), cmd);
        return;
    }
    checkArgument(old.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED, "cannot chain ref update %s after update %s with result %s", cmd, old, old.getResult());
    checkArgument(cmd.getOldId().equals(old.getNewId()), "cannot chain ref update %s after update %s with different new ID", cmd, old);
    commands.put(cmd.getRefName(), new ReceiveCommand(old.getOldId(), cmd.getNewId(), cmd.getRefName()));
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (repo == null || commands.isEmpty()) {
        return;
    }
    inserter.flush();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    inserter.flush();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (self.get() != rsrc.getUser() && self.get().getUserName() != rsrc.getUser().getUserName() && !self.get().getCapabilities().canViewAllAccounts()) {
        throw new AuthException("not allowed to list email addresses");
    }
    List<EmailInfo> emails = Lists.newArrayList();
    for (String email : rsrc.getUser().getEmailAddresses()) {
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.preferred(rsrc.getUser().getAccount().getPreferredEmail());
            emails.add(e);
        }
    }
    Collections.sort(emails, new Comparator<EmailInfo>() {

        @Override
        public int compare(EmailInfo a, EmailInfo b) {
            return a.email.compareTo(b.email);
        }
    });
    return emails;
}
#method_after
@Override
public List<EmailInfo> apply(AccountResource rsrc) {
    List<EmailInfo> emails = Lists.newArrayList();
    for (String email : rsrc.getUser().getEmailAddresses()) {
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.preferred(rsrc.getUser().getAccount().getPreferredEmail());
            emails.add(e);
        }
    }
    Collections.sort(emails, new Comparator<EmailInfo>() {

        @Override
        public int compare(EmailInfo a, EmailInfo b) {
            return a.email.compareTo(b.email);
        }
    });
    return emails;
}
#end_block

#method_before
@Override
protected FileTime getLastModifiedTime(Path p) {
    // since the GWT outputs from the build process all have mtimes of 1980/1/1.
    return now;
}
#method_after
@Override
protected FileTime getLastModifiedTime(Path p) {
    // build process all have mtimes of 1980/1/1.
    return NOW;
}
#end_block

#method_before
protected static String contentType(final String name) {
    int dot = name.lastIndexOf('.');
    String ext = 0 < dot ? name.substring(dot + 1) : "";
    String type = MIME_TYPES.get(ext);
    return type != null ? type : "application/octet-stream";
}
#method_after
protected static String contentType(String name) {
    int dot = name.lastIndexOf('.');
    String ext = 0 < dot ? name.substring(dot + 1) : "";
    String type = MIME_TYPES.get(ext);
    return type != null ? type : "application/octet-stream";
}
#end_block

#method_before
protected FileTime getLastModifiedTime(Path p) {
    try {
        return Files.getLastModifiedTime(p);
    } catch (IOException e) {
        return FileTime.fromMillis(0);
    }
}
#method_after
protected FileTime getLastModifiedTime(Path p) throws IOException {
    return Files.getLastModifiedTime(p);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    if (r == null && maybeStream(p, req, rsp)) {
        return;
    }
    if (r == null) {
        Callable<Resource> loader = newLoader(p);
        try {
            r = cache.get(p, loader);
            if (refresh && r.isStale(p, this)) {
                cache.invalidate(p);
                r = cache.get(p, loader);
            }
        } catch (ExecutionException e) {
            log.warn("Cannot load static resource " + req.getPathInfo(), e);
            CacheHeaders.setNotCacheable(rsp);
            rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
    }
    if (r == Resource.NOT_FOUND) {
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    rsp.setHeader(ETAG, r.etag);
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    if (r == null && maybeStream(p, req, rsp)) {
        return;
    }
    if (r == null) {
        Callable<Resource> loader = newLoader(p);
        try {
            r = cache.get(p, loader);
            if (refresh && r.isStale(p, this)) {
                cache.invalidate(p);
                r = cache.get(p, loader);
            }
        } catch (ExecutionException | IOException e) {
            log.warn("Cannot load static resource " + req.getPathInfo(), e);
            CacheHeaders.setNotCacheable(rsp);
            rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
    }
    if (r == Resource.NOT_FOUND) {
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    rsp.setHeader(ETAG, r.etag);
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private boolean maybeStream(Path p, HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    try {
        if (Files.size(p) < CACHE_FILE_SIZE_LIMIT_BYTES) {
            return false;
        }
    } catch (FileNotFoundException e) {
        cache.put(p, Resource.NOT_FOUND);
        notFound(rsp);
        return true;
    }
    long lastModified = FileUtil.lastModified(p);
    if (req.getDateHeader(IF_MODIFIED_SINCE) >= lastModified) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return true;
    }
    if (lastModified > 0) {
        rsp.setDateHeader(LAST_MODIFIED, lastModified);
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
    }
    rsp.setContentType(contentType(p.toString()));
    OutputStream out = rsp.getOutputStream();
    GZIPOutputStream gz = null;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader(CONTENT_ENCODING, "gzip");
        gz = new GZIPOutputStream(out);
        out = gz;
    }
    Files.copy(p, out);
    if (gz != null) {
        gz.finish();
    }
    return true;
}
#method_after
private boolean maybeStream(Path p, HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    try {
        if (Files.size(p) < CACHE_FILE_SIZE_LIMIT_BYTES) {
            return false;
        }
    } catch (NoSuchFileException e) {
        cache.put(p, Resource.NOT_FOUND);
        notFound(rsp);
        return true;
    }
    long lastModified = FileUtil.lastModified(p);
    if (req.getDateHeader(IF_MODIFIED_SINCE) >= lastModified) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return true;
    }
    if (lastModified > 0) {
        rsp.setDateHeader(LAST_MODIFIED, lastModified);
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
    }
    rsp.setContentType(contentType(p.toString()));
    OutputStream out = rsp.getOutputStream();
    GZIPOutputStream gz = null;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader(CONTENT_ENCODING, "gzip");
        gz = new GZIPOutputStream(out);
        out = gz;
    }
    Files.copy(p, out);
    if (gz != null) {
        gz.finish();
    }
    return true;
}
#end_block

#method_before
private Callable<Resource> newLoader(final Path p) {
    return new Callable<Resource>() {

        @Override
        public Resource call() throws IOException {
            try {
                return new Resource(getLastModifiedTime(p), contentType(p.toString()), Files.readAllBytes(p));
            } catch (FileNotFoundException e) {
                return Resource.NOT_FOUND;
            }
        }
    };
}
#method_after
private Callable<Resource> newLoader(final Path p) {
    return new Callable<Resource>() {

        @Override
        public Resource call() throws IOException {
            try {
                return new Resource(getLastModifiedTime(p), contentType(p.toString()), Files.readAllBytes(p));
            } catch (NoSuchFileException e) {
                return Resource.NOT_FOUND;
            }
        }
    };
}
#end_block

#method_before
boolean isStale(Path p, ResourceServlet rs) {
    FileTime t = rs.getLastModifiedTime(p);
    return t.toMillis() == 0 || lastModified.toMillis() == 0 || !lastModified.equals(t);
}
#method_after
boolean isStale(Path p, ResourceServlet rs) throws IOException {
    FileTime t = rs.getLastModifiedTime(p);
    return t.toMillis() == 0 || lastModified.toMillis() == 0 || !lastModified.equals(t);
}
#end_block

#method_before
@Override
protected FileTime getLastModifiedTime(Path p) {
    // since the GWT outputs from the build process all have mtimes of 1980/1/1.
    return now;
}
#method_after
@Override
protected FileTime getLastModifiedTime(Path p) {
    // build process all have mtimes of 1980/1/1.
    return NOW;
}
#end_block

#method_before
public static File getDistributionArchive() throws FileNotFoundException, IOException {
    File result = myArchive;
    if (result == null) {
        synchronized (GerritLauncher.class) {
            result = myArchive;
            if (result == null) {
                result = locateMyArchive();
                myArchiveFs = FileSystems.newFileSystem(URI.create("jar:" + result.toPath().toUri()), Collections.<String, String>emptyMap());
                myArchive = result;
            }
        }
    }
    return result;
}
#method_after
public static File getDistributionArchive() throws FileNotFoundException, IOException {
    File result = myArchive;
    if (result == null) {
        synchronized (GerritLauncher.class) {
            result = myArchive;
            if (result != null) {
                return result;
            }
            result = locateMyArchive();
            myArchiveFs = FileSystems.newFileSystem(URI.create("jar:" + result.toPath().toUri()), Collections.<String, String>emptyMap());
            myArchive = result;
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    FormatType format = getFormat(req);
    if (format == null) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format) {
        case HTML:
            doGetHtml(req, res);
            break;
        case TEXT:
            doGetText(req, res);
            break;
        case JSON:
            doGetJson(req, res);
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format.get()) {
        case HTML:
            doGetHtml(req, res);
            break;
        case TEXT:
            doGetText(req, res);
            break;
        case JSON:
            doGetJson(req, res);
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
protected FormatType getFormat(HttpServletRequest req) {
    FormatType format;
    try {
        format = FormatType.getFormatType(req);
    } catch (IllegalArgumentException err) {
        return null;
    }
    if (format == DEFAULT) {
        return getDefaultFormat(req);
    }
    return format;
}
#method_after
protected Optional<FormatType> getFormat(HttpServletRequest req) {
    Optional<FormatType> format = FormatType.getFormatType(req);
    if (format.isPresent() && format.get() == DEFAULT) {
        return Optional.of(getDefaultFormat(req));
    }
    return format;
}
#end_block

#method_before
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    // If the repository didn't exist a prior filter would have 404 replied.
    FormatType format = getFormat(req);
    if (format == null) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format) {
        case HTML:
        case JSON:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.getMimeType());
            break;
        case TEXT:
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    // If the repository didn't exist a prior filter would have 404 replied.
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format.get()) {
        case HTML:
        case JSON:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        case TEXT:
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    FormatType format = getFormat(req);
    if (format == null) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.getMimeType());
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format.get()) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        Set<RevCommit> accepted = SubmitDryRun.getAlreadyAccepted(repo, rw);
        RevCommit c = rw.parseCommit(key.commit);
        accepted.addAll(Arrays.asList(c.getParents()));
        return submitDryRun.dryRun(key.submitType, repo, rw, dest, key.into, key.commit, accepted);
    }
}
#method_after
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        Set<RevCommit> accepted = SubmitDryRun.getAlreadyAccepted(repo, rw);
        accepted.add(rw.parseCommit(key.into));
        accepted.addAll(Arrays.asList(rw.parseCommit(key.commit).getParents()));
        return submitDryRun.run(key.submitType, repo, rw, dest, key.into, key.commit, accepted);
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.dryRun(submitType, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.run(submitType, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted, hence there is no dummy 0 approval left when a vote is
        // deleted.
        assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
    }
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
    // When notedb is enabled each reviewer is explicitly recorded in the
    // notedb and this record stays even when all votes of that user have been
    // deleted, hence there is no dummy 0 approval left when a vote is
    // deleted.
    // TODO(dborowitz): Support modifying other users' labels in notedb
    // format.
    // assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    Change change = ctx.getChange();
    ChangeControl ctl = ctx.getChangeControl();
    PatchSet.Id psId = change.currentPatchSetId();
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getChangeUpdate().setPatchSetId(psId);
                ctx.getChangeUpdate().removeApproval(label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ChangeUtil.bumpRowVersionNotLastUpdatedOn(change.getId(), ctx.getDb());
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    Change change = ctx.getChange();
    ChangeControl ctl = ctx.getChangeControl();
    PatchSet.Id psId = change.currentPatchSetId();
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getChangeUpdate().setPatchSetId(psId);
                // TODO(dborowitz): Support modifying other users' labels in notedb
                // format.
                ctx.getChangeUpdate().removeApproval(label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ChangeUtil.bumpRowVersionNotLastUpdatedOn(change.getId(), ctx.getDb());
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), changeMessage);
    }
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    try {
        return object.getAuthor().getEmailAddress().equalsIgnoreCase(getValue());
    } catch (IOException e) {
        return false;
    }
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    return ChangeField.getAuthorParts(object).contains(getValue().toLowerCase());
}
#end_block

#method_before
@Test
public void byAuthor() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = newChange(repo, null, null, userId.get(), null).insert();
    assertQuery("author:jauthor@example.com", change1);
    assertQuery("author:user@example.com");
}
#method_after
@Test
public void byAuthor() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = newChange(repo, null, null, userId.get(), null).insert();
    // By exact email address
    assertQuery("author:jauthor@example.com", change1);
    // By email address part
    assertQuery("author:jauthor", change1);
    assertQuery("author:example", change1);
    assertQuery("author:example.com", change1);
    // By name part
    assertQuery("author:Author", change1);
    // By non-existing email address / name / part
    assertQuery("author:jcommitter@example.com");
    assertQuery("author:somewhere.com");
    assertQuery("author:jcommitter");
    assertQuery("author:Committer");
}
#end_block

#method_before
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = newChange(repo, commit1, null, null, null).insert();
    Change change2 = newChange(repo, commit2, null, null, null).insert();
    assertQuery("added:>4");
    assertQuery("added:3", change1);
    assertQuery("added:>2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("added:<1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("deleted:>3");
    assertQuery("deleted:2", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#method_after
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = newChange(repo, commit1, null, null, null).insert();
    Change change2 = newChange(repo, commit2, null, null, null).insert();
    assertQuery("added:>4");
    assertQuery("-added:<=4");
    assertQuery("added:3", change1);
    assertQuery("-(added:<3 OR added>3)", change1);
    assertQuery("added:>2", change1);
    assertQuery("-added:<=2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("-added:<3", change1);
    assertQuery("added:<1", change2);
    assertQuery("-added:>=1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("-added:>0", change2);
    assertQuery("deleted:>3");
    assertQuery("-deleted:<=3");
    assertQuery("deleted:2", change2);
    assertQuery("-(deleted:<2 OR deleted>2)", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("-deleted:<=1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("-deleted:<2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("-deleted:>=1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo, null, null, null, null);
        ins.insert();
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getPatchSet().getRevision().get());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(new Function<ChangeData, Integer>() {

            @Override
            public Integer apply(ChangeData in) {
                return in.getId().get();
            }
        });
        String name = "batch size " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo, null, null, null, null);
        ins.insert();
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getPatchSet().getRevision().get());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(indexes.getSearchIndex().getSchema(), dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(new Function<ChangeData, Integer>() {

            @Override
            public Integer apply(ChangeData in) {
                return in.getId().get();
            }
        });
        String name = "batch size " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#end_block

#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
        committer = c.getCommitterIdent();
    }
    return true;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(args.getSchema(), Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> commit(String id) {
    if (id.length() == Constants.OBJECT_ID_STRING_LENGTH) {
        return new ExactCommitPredicate(id);
    }
    return new CommitPrefixPredicate(id);
}
#method_after
@Operator
public Predicate<ChangeData> commit(String id) {
    return new CommitPredicate(args.getSchema(), id);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) {
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    if (Strings.isNullOrEmpty(gitOAuthProvider)) {
        pickOnlyProvider();
    } else {
        pickConfiguredProvider();
    }
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String tokenOrPassword = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(tokenOrPassword)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest authRequest = AuthRequest.forExternalUser(username);
    authRequest.setEmailAddress(who.getAccount().getPreferredEmail());
    authRequest.setDisplayName(who.getAccount().getFullName());
    authRequest.setPassword(tokenOrPassword);
    try {
        AuthResult authResult = accountManager.authenticate(authRequest);
        WebSession ws = session.get();
        ws.setUserAccountId(authResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    byte[] decoded = Base64.decodeBase64(hdr.substring(BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthInfo authInfo = new AuthInfo(usernamePassword.substring(0, splitPos), usernamePassword.substring(splitPos + 1), defaultAuthPlugin, defaultAuthProvider);
    if (Strings.isNullOrEmpty(authInfo.tokenOrSecret)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AccountState who = accountCache.getByUsername(authInfo.username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + authInfo.username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest authRequest = AuthRequest.forExternalUser(authInfo.username);
    authRequest.setEmailAddress(who.getAccount().getPreferredEmail());
    authRequest.setDisplayName(who.getAccount().getFullName());
    authRequest.setPassword(authInfo.tokenOrSecret);
    authRequest.setAuthPlugin(authInfo.pluginName);
    authRequest.setAuthProvider(authInfo.exportName);
    try {
        AuthResult authResult = accountManager.authenticate(authRequest);
        WebSession ws = session.get();
        ws.setUserAccountId(authResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + authInfo.username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private String encoding(HttpServletRequest req) {
    return MoreObjects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
}
#method_after
private static String encoding(HttpServletRequest req) {
    return MoreObjects.firstNonNull(req.getCharacterEncoding(), UTF_8.name());
}
#end_block

#method_before
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(LIT_BASIC);
        v.append("realm=\"").append(REALM_NAME).append("\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#method_after
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(BASIC);
        v.append("realm=\"").append(REALM_NAME).append("\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicItem.itemOf(binder(), OAuthLoginService.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (who.getPassword() == null && who.getEmailAddress() != null) {
        return who;
    }
    if (loginService.get() == null) {
        log.warn("no implementation of OAuthLoginService available");
        return who;
    }
    OAuthUserInfo userInfo = loginService.get().login(who.getUserName(), who.getPassword());
    if (userInfo.getEmailAddress() != null) {
        who.setEmailAddress(userInfo.getEmailAddress());
    }
    if (userInfo.getDisplayName() != null) {
        who.setDisplayName(userInfo.getDisplayName());
    }
    return who;
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (Strings.isNullOrEmpty(who.getPassword()) && !Strings.isNullOrEmpty(who.getEmailAddress())) {
        return who;
    }
    if (Strings.isNullOrEmpty(who.getAuthPlugin()) || Strings.isNullOrEmpty(who.getAuthProvider())) {
        throw new AccountException("Cannot authenticate");
    }
    OAuthLoginProvider loginProvider = loginProviders.get(who.getAuthPlugin(), who.getAuthProvider());
    if (loginProvider == null) {
        throw new AccountException("Cannot authenticate");
    }
    OAuthUserInfo userInfo;
    try {
        userInfo = loginProvider.login(who.getUserName(), who.getPassword());
    } catch (IOException e) {
        throw new AccountException("Cannot authenticate", e);
    }
    if (userInfo == null) {
        throw new AccountException("Cannot authenticate");
    }
    if (!Strings.isNullOrEmpty(userInfo.getEmailAddress())) {
        who.setEmailAddress(userInfo.getEmailAddress());
    }
    if (!Strings.isNullOrEmpty(userInfo.getDisplayName())) {
        who.setDisplayName(userInfo.getDisplayName());
    }
    return who;
}
#end_block

#method_before
@Override
public AuthRequest link(ReviewDb db, Id to, AuthRequest who) {
    return who;
}
#method_after
@Override
public AuthRequest link(ReviewDb db, Account.Id to, AuthRequest who) {
    return who;
}
#end_block

#method_before
@Override
public AuthRequest unlink(ReviewDb db, Id to, AuthRequest who) throws AccountException {
    return who;
}
#method_after
@Override
public AuthRequest unlink(ReviewDb db, Account.Id to, AuthRequest who) throws AccountException {
    return who;
}
#end_block

#method_before
@Override
public Id lookup(String accountName) {
    return null;
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    return null;
}
#end_block

#method_before
private void doSearch() {
    final String query = searchBox.getText().trim();
    if ("".equals(query)) {
        return;
    }
    searchBox.setFocus(false);
    switch(dropdown.getSelectedIndex()) {
        case 0:
            // changes
            if (query.matches("^[1-9][0-9]*$")) {
                Gerrit.display(PageLinks.toChange(Change.Id.parse(query)));
            } else {
                Gerrit.display(PageLinks.toChangeQuery(query), QueryScreen.forQuery(query));
            }
            break;
        case 1:
            // doc
            Gerrit.display(PageLinks.toDocumentationQuery(query));
            break;
    }
}
#method_after
private void doSearch() {
    final String query = searchBox.getText().trim();
    if ("".equals(query)) {
        return;
    }
    searchBox.setFocus(false);
    if (dropdown != null && dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc())) {
        // doc
        Gerrit.display(PageLinks.toDocumentationQuery(query));
    } else {
        // changes
        if (query.matches("^[1-9][0-9]*$")) {
            Gerrit.display(PageLinks.toChange(Change.Id.parse(query)));
        } else {
            Gerrit.display(PageLinks.toChangeQuery(query), QueryScreen.forQuery(query));
        }
    }
}
#end_block

#method_before
@Override
public void deleteVote(String vote) throws RestApiException {
    try {
        deleteVote.apply(new VoteResource(reviewer, vote), null);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot delete vote", e);
    }
}
#method_after
@Override
public void deleteVote(String label) throws RestApiException {
    try {
        deleteVote.apply(new VoteResource(reviewer, label), null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete vote", e);
    }
}
#end_block

#method_before
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    for (PatchSetApproval psa : approvalsUtil.byChangeUser(db.get(), rsrc.getNotes(), rsrc.getUser().getAccountId())) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#method_after
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    Iterable<PatchSetApproval> byPatchSetUser = approvalsUtil.byPatchSetUser(db.get(), rsrc.getControl(), rsrc.getChange().currentPatchSetId(), rsrc.getUser().getAccountId());
    for (PatchSetApproval psa : byPatchSetUser) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#end_block

#method_before
@Override
public String id() {
    return Integer.toString(change.getChange().getId().get());
}
#method_after
@Override
public String id() {
    return Integer.toString(change.getId().get());
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.get().addOptions(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        CurrentUser u = user.get();
        if (u.isIdentifiedUser()) {
            u.asIdentifiedUser().clearStarredChanges();
        }
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Changes.class).to(ChangesImpl.class);
    factory(ChangeApiImpl.Factory.class);
    factory(RevisionApiImpl.Factory.class);
    factory(ReviewerApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Changes.class).to(ChangesImpl.class);
    factory(ChangeApiImpl.Factory.class);
    factory(CommentApiImpl.Factory.class);
    factory(DraftApiImpl.Factory.class);
    factory(RevisionApiImpl.Factory.class);
    factory(FileApiImpl.Factory.class);
    factory(ReviewerApiImpl.Factory.class);
}
#end_block

#method_before
@Test
public void get() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = info(triplet);
    assertThat(c.id).isEqualTo(triplet);
    assertThat(c.project).isEqualTo("p");
    assertThat(c.branch).isEqualTo("master");
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
    assertThat(c.subject).isEqualTo("test commit");
    assertThat(c.mergeable).isTrue();
    assertThat(c.changeId).isEqualTo(r.getChangeId());
    assertThat(c.created).isEqualTo(c.updated);
    assertThat(c._number).is(1);
    assertThat(c.owner._accountId).is(admin.getId().get());
    assertThat(c.owner.name).isNull();
    assertThat(c.owner.email).isNull();
    assertThat(c.owner.username).isNull();
    assertThat(c.owner.avatars).isNull();
}
#method_after
@Test
public void get() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    ChangeInfo c = info(triplet);
    assertThat(c.id).isEqualTo(triplet);
    assertThat(c.project).isEqualTo(project.get());
    assertThat(c.branch).isEqualTo("master");
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
    assertThat(c.subject).isEqualTo("test commit");
    assertThat(c.mergeable).isTrue();
    assertThat(c.changeId).isEqualTo(r.getChangeId());
    assertThat(c.created).isEqualTo(c.updated);
    assertThat(c._number).isEqualTo(r.getChange().getId().get());
    assertThat(c.owner._accountId).isEqualTo(admin.getId().get());
    assertThat(c.owner.name).isNull();
    assertThat(c.owner.email).isNull();
    assertThat(c.owner.username).isNull();
    assertThat(c.owner.avatars).isNull();
}
#end_block

#method_before
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).abandon();
}
#method_after
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(r.getChangeId()).abandon();
    ChangeInfo info = get(r.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
}
#end_block

#method_before
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).abandon();
    gApi.changes().id(r.getChangeId()).restore();
}
#method_after
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(r.getChangeId()).restore();
    ChangeInfo info = get(r.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id(r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Patch Set 1: Reverted\n\n" + "This patchset was reverted in change: %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test(expected = ResourceConflictException.class)
public void rebase() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).rebase();
}
#method_after
@Test
public void rebase() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Rebase the second change
    gApi.changes().id(r2.getChangeId()).current().rebase();
    // Second change should have 2 patch sets
    assertThat(r2.getPatchSetId().get()).isEqualTo(2);
    // ...and the committer should be correct
    ChangeInfo info = gApi.changes().id(r2.getChangeId()).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(user.id));
}
#method_after
@Test
public void addReviewer() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When notedb is enabled adding a reviewer records that user as reviewer
    // in notedb. When notedb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = isNoteDbTestEnabled() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
}
#end_block

#method_before
@Test
public void addReviewerToClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.id));
}
#method_after
@Test
public void addReviewerToClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get());
    assertThat(c.reviewers).doesNotContainKey(CC);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    c = gApi.changes().id(r.getChangeId()).get();
    reviewers = c.reviewers.get(REVIEWER);
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled adding a reviewer records that user as reviewer
        // in notedb.
        assertThat(reviewers).hasSize(2);
        Iterator<AccountInfo> reviewerIt = reviewers.iterator();
        assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
        assertThat(reviewerIt.next()._accountId).isEqualTo(user.getId().get());
        assertThat(c.reviewers).doesNotContainKey(CC);
    } else {
        // When notedb is disabled adding a reviewer results in a dummy 0 approval
        // on the change which is treated as CC when the ChangeInfo is created.
        assertThat(reviewers).hasSize(1);
        assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get());
        Collection<AccountInfo> ccs = c.reviewers.get(CC);
        assertThat(ccs).hasSize(1);
        assertThat(ccs.iterator().next()._accountId).isEqualTo(user.getId().get());
    }
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    assertThat(m).containsEntry("Code-Review", new Short((short) 2));
    setApiUser(user);
    try {
        gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review+2");
        fail("AuthException (delete not permitted) expected");
    } catch (AuthException e) {
        assertThat(e.getMessage()).isEqualTo("delete not permitted");
    }
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review+2");
    m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted, hence there is no dummy 0 approval left when a vote is
        // deleted.
        assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertThat(Iterables.getLast(c.messages).message).isEqualTo("Removed Code-Review+2 by Administrator <admin@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    }
}
#end_block

#method_before
@Test
public void createEmptyChange() throws Exception {
    ChangeInfo in = new ChangeInfo();
    in.branch = Constants.MASTER;
    in.subject = "Create a change from the API";
    in.project = project.get();
    ChangeInfo info = gApi.changes().create(in).get();
    assertThat(info.project).isEqualTo(in.project);
    assertThat(info.branch).isEqualTo(in.branch);
    assertThat(info.subject).isEqualTo(in.subject);
}
#method_after
@Test
public void createEmptyChange() throws Exception {
    ChangeInfo in = new ChangeInfo();
    in.branch = Constants.MASTER;
    in.subject = "Create a change from the API";
    in.project = project.get();
    ChangeInfo info = gApi.changes().create(in).get();
    assertThat(info.project).isEqualTo(in.project);
    assertThat(info.branch).isEqualTo(in.branch);
    assertThat(info.subject).isEqualTo(in.subject);
    assertThat(Iterables.getOnlyElement(info.messages).message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test
public void queryChangesNoQuery() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = gApi.changes().query().get();
    assertThat(results).hasSize(2);
    assertThat(results.get(0).changeId).isEqualTo(r2.getChangeId());
    assertThat(results.get(1).changeId).isEqualTo(r1.getChangeId());
}
#method_after
@Test
public void queryChangesNoQuery() throws Exception {
    PushOneCommit.Result r = createChange();
    List<ChangeInfo> results = gApi.changes().query().get();
    assertThat(results.size()).isAtLeast(1);
    List<Integer> ids = new ArrayList<>(results.size());
    for (int i = 0; i < results.size(); i++) {
        ChangeInfo info = results.get(i);
        if (i == 0) {
            assertThat(info._number).isEqualTo(r.getChange().getId().get());
        }
        assertThat(Change.Status.forChangeStatus(info.status).isOpen()).isTrue();
        ids.add(info._number);
    }
    assertThat(ids).contains(r.getChange().getId().get());
}
#end_block

#method_before
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = query("status:open");
    assertThat(results).hasSize(1);
    results = query("status:closed");
    assertThat(results).isEmpty();
}
#method_after
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    assertThat(query("message:test")).isNotEmpty();
    assertThat(query("message:{" + getClass().getName() + "fhqwhgads}")).isEmpty();
}
#end_block

#method_before
@Test
public void queryChangesStart() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query().withStart(1).get();
    assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId());
}
#method_after
@Test
public void queryChangesStart() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query("project:{" + project.get() + "}").withStart(1).get();
    assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId());
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#end_block

#method_before
private Set<Account.Id> getReviewers(String changeId) throws Exception {
    ChangeInfo ci = gApi.changes().id(changeId).get();
    Set<Account.Id> result = Sets.newHashSet();
    for (LabelInfo li : ci.labels.values()) {
        for (ApprovalInfo ai : li.all) {
            result.add(new Account.Id(ai._accountId));
        }
    }
    return result;
}
#method_after
private static Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, new Function<AccountInfo, Account.Id>() {

        @Override
        public Account.Id apply(AccountInfo account) {
            return new Account.Id(account._accountId);
        }
    });
}
#end_block

#method_before
private static void onRemoveReviewer(NativeEvent event) {
    Integer user = getDataId(event);
    if (user != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemoveReviewer(NativeEvent event) {
    Integer user = getDataId(event);
    if (user != null) {
        final ChangeScreen screen = ChangeScreen.get(event);
        ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private static void onRemoveVote(NativeEvent event) {
    Integer user = getDataId(event);
    String vote = getVoteId(event);
    if (user != null && vote != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemoveVote(NativeEvent event) {
    Integer user = getDataId(event);
    String vote = getVoteId(event);
    if (user != null && vote != null) {
        final ChangeScreen screen = ChangeScreen.get(event);
        ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private static String getVoteId(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    while (e != null) {
        String v = e.getAttribute(VOTE_ID);
        if (!v.isEmpty()) {
            return v;
        }
        e = e.getParentElement();
    }
    return null;
}
#method_after
private static String getVoteId(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    while (e != null) {
        String v = e.getAttribute(DATA_VOTE);
        if (!v.isEmpty()) {
            return v;
        }
        e = e.getParentElement();
    }
    return null;
}
#end_block

#method_before
void set(ChangeInfo info) {
    List<String> names = new ArrayList<>(info.labels());
    Set<Integer> removable = info.removable();
    Collections.sort(names);
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label, removable));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
    }
}
#method_after
void set(ChangeInfo info) {
    List<String> names = new ArrayList<>(info.labels());
    Set<Integer> removable = info.removableReviewerIds();
    Collections.sort(names);
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label, removable));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
    }
}
#end_block

#method_before
private Widget renderUsers(LabelInfo label, Set<Integer> removable) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), removable, label.name() + val, null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#method_after
private Widget renderUsers(LabelInfo label, Set<Integer> removable) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0;
    int rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.valueText(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), removable, label.name(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#end_block

#method_before
private static boolean isApproved(LabelInfo label, ApprovalInfo ai) {
    return label.approved() != null && label.approved()._account_id() == ai._account_id();
}
#method_after
private static boolean isApproved(LabelInfo label, ApprovalInfo ai) {
    return label.approved() != null && label.approved()._accountId() == ai._accountId();
}
#end_block

#method_before
private static boolean isRejected(LabelInfo label, ApprovalInfo ai) {
    return label.rejected() != null && label.rejected()._account_id() == ai._account_id();
}
#method_after
private static boolean isRejected(LabelInfo label, ApprovalInfo ai) {
    return label.rejected() != null && label.rejected()._accountId() == ai._accountId();
}
#end_block

#method_before
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, String labelVote, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._account_id()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (labelVote != null) {
            html.setAttribute(VOTE_ID, labelVote);
        }
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button");
            if (labelVote != null) {
                html.setAttribute("title", Util.M.removeVote(labelVote)).setAttribute("onclick", REMOVE_VOTE + "(event)");
            } else {
                html.setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE_REVIEWER + "(event)");
            }
            html.append(new ImageResourceRenderer().render(Gerrit.RESOURCES.removeReviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
static SafeHtml formatUserList(ChangeScreen.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, String label, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._accountId());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._accountId()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._accountId()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (label != null) {
            html.setAttribute(DATA_VOTE, label);
        }
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._accountId())) {
            html.openElement("button");
            if (label != null) {
                html.setAttribute("title", Util.M.removeVote(label)).setAttribute("onclick", REMOVE_VOTE + "(event)");
            } else {
                html.setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE_REVIEWER + "(event)");
            }
            html.append("").closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
void init(ChangeScreen2.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#method_after
void init(ChangeScreen.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacy_id();
    display(info);
    reviewerSuggestOracle.setChange(changeId);
    openForm.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    display(info);
    reviewerSuggestOracle.setChange(changeId);
    openForm.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
@UiHandler("add")
void onAdd(@SuppressWarnings("unused") ClickEvent e) {
    String reviewer = suggestBox.getText();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("add")
void onAdd(@SuppressWarnings("unused") ClickEvent e) {
    addReviewer(suggestBox.getText(), false);
}
#end_block

#method_before
@UiHandler("addMe")
void onAddMe(@SuppressWarnings("unused") ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#method_after
@UiHandler("addMe")
void onAddMe(@SuppressWarnings("unused") ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccount()._accountId());
    addReviewer(accountId, false);
}
#end_block

#method_before
private void addReviewer(final String reviewer, boolean confirmed) {
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            nameTxtBox.setEnabled(true);
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                nameTxtBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            nameTxtBox.setEnabled(true);
        }
    });
}
#method_after
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isSigninFailure(err)) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#end_block

#method_before
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = info.removable();
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, null, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, null, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
    if (Gerrit.isSignedIn()) {
        int currentUser = Gerrit.getUserAccountInfo()._account_id();
        boolean showAddMeButton = info.owner()._account_id() != currentUser && !cc.containsKey(currentUser) && !r.containsKey(currentUser);
        addMe.setVisible(showAddMeButton);
    }
}
#method_after
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.allLabels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._accountId(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    cc.remove(info.owner()._accountId());
    Set<Integer> removable = info.removableReviewerIds();
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, null, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, null, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
    if (Gerrit.isSignedIn()) {
        int currentUser = Gerrit.getUserAccount()._accountId();
        boolean showAddMeButton = info.owner()._accountId() != currentUser && !cc.containsKey(currentUser) && !r.containsKey(currentUser);
        addMe.setVisible(showAddMeButton);
    }
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "type").to(GetContentType.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "type").to(ChangeEdits.GetType.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.base_change(emptyToNull(base));
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    if (Gerrit.info().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameter("list", true).get(cb);
}
#method_after
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameterTrue("list").get(cb);
}
#end_block

#method_before
public static RestApi editWithCommands(int id) {
    return edit(id).addParameter("download-commands", true);
}
#method_after
public static RestApi editWithCommands(int id) {
    return edit(id).addParameterTrue("download-commands");
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.wait_for_merge(true);
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.waitForMerge(true);
    call(id, commit, "submit").post(in, cb);
}
#end_block

#method_before
public static void rebase(int id, String commit, AsyncCallback<ChangeInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(id, commit, "rebase").post(in, cb);
}
#method_after
public static void rebase(int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(id, commit, "rebase").post(rebaseInput, cb);
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getReviewer().getControl();
    Change change = rsrc.getReviewer().getChange();
    Change.Id changeId = change.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(control);
    LabelVote labelVote = rsrc.getVote();
    Account.Id accountId = rsrc.getReviewer().getUser().getAccountId();
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        PatchSetApproval psa = null;
        for (PatchSetApproval a : approvalsUtil.byChangeUser(db, update.getChangeNotes(), accountId)) {
            // implementing ctl.canRemoveVote(v) method.
            if (control.canRemoveReviewer(a)) {
                if (a.getLabel().equals(labelVote.getLabel()) && a.getValue() == rsrc.getVote().getValue()) {
                    msg.append("Removed the following vote:\n\n");
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
                    psa = a;
                    a.setValue((short) 0);
                    break;
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (psa == null) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(changeId, db);
        db.patchSetApprovals().update(Collections.singleton(psa));
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, change);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    ChangeControl ctl = r.getControl();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), ctl.getUser().asIdentifiedUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private List<QueryResult> queryChanges(List<String> queryStrings, List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    Predicate<ChangeData> visibleToMe = enforceVisibility ? new IsVisibleToPredicate(db, changeControlFactory, userProvider.get()) : null;
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<ChangeData>> predicates = new ArrayList<>(cnt);
    List<ChangeDataSource> sources = new ArrayList<>(cnt);
    for (Predicate<ChangeData> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        // ask for one more result from the query.
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + "of results");
        }
        QueryOptions opts = QueryOptions.create(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<ChangeData> s = rewriter.rewrite(q, opts);
        if (!(s instanceof ChangeDataSource)) {
            q = Predicate.and(open(), q);
            s = rewriter.rewrite(q, opts);
        }
        if (!(s instanceof ChangeDataSource)) {
            throw new QueryParseException("invalid query: " + s);
        }
        if (enforceVisibility) {
            s = new AndSource(ImmutableList.of(s, visibleToMe), start);
        }
        predicates.add(s);
        sources.add((ChangeDataSource) s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<ChangeData>> matches = new ArrayList<>(cnt);
    for (ChangeDataSource s : sources) {
        matches.add(s.read());
    }
    List<QueryResult> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    return out;
}
#method_after
private List<QueryResult> queryChanges(List<String> queryStrings, List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    @SuppressWarnings("resource")
    Timer0.Context context = metrics.executionTime.start();
    Predicate<ChangeData> visibleToMe = enforceVisibility ? new IsVisibleToPredicate(db, changeControlFactory, userProvider.get()) : null;
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<ChangeData>> predicates = new ArrayList<>(cnt);
    List<ChangeDataSource> sources = new ArrayList<>(cnt);
    for (Predicate<ChangeData> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        // ask for one more result from the query.
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + "of results");
        }
        QueryOptions opts = QueryOptions.create(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<ChangeData> s = rewriter.rewrite(q, opts);
        if (!(s instanceof ChangeDataSource)) {
            q = Predicate.and(open(), q);
            s = rewriter.rewrite(q, opts);
        }
        if (!(s instanceof ChangeDataSource)) {
            throw new QueryParseException("invalid query: " + s);
        }
        if (enforceVisibility) {
            s = new AndSource(ImmutableList.of(s, visibleToMe), start);
        }
        predicates.add(s);
        sources.add((ChangeDataSource) s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<ChangeData>> matches = new ArrayList<>(cnt);
    for (ChangeDataSource s : sources) {
        matches.add(s.read());
    }
    List<QueryResult> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // only measure successful queries
    context.close();
    return out;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private String idFieldName() {
    return schema.getField(ChangeField.LEGACY_ID, ChangeField.LEGACY_ID2).get().getName();
}
#method_after
@SuppressWarnings("deprecation")
private String idFieldName() {
    return schema.getField(ChangeField.LEGACY_ID2, ChangeField.LEGACY_ID).get().getName();
}
#end_block

#method_before
@ConfigSuite.Default
public static Config defaultConfig() {
    return updateConfig(new Config());
}
#method_after
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setInt("index", null, "maxPages", 10);
    return cfg;
}
#end_block

#method_before
protected void assertBadQuery(QueryRequest query) throws Exception {
    exception.expect(BadRequestException.class);
    query.get();
}
#method_after
protected void assertBadQuery(QueryRequest query) throws Exception {
    try {
        query.get();
        fail("expected BadRequestException for query: " + query);
    } catch (BadRequestException e) {
    // Expected.
    }
}
#end_block

#method_before
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isNotSignedIn(err) || isInvalidXSRF(err) || (isNoSuchEntity(err) && !Gerrit.isSignedIn())) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#method_after
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isSigninFailure(err)) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#end_block

#method_before
public static void showFailure(Throwable caught) {
    if (isNotSignedIn(caught) || isInvalidXSRF(caught)) {
        new NotSignedInDialog().center();
    } else if (isNoSuchEntity(caught)) {
        if (Gerrit.isSignedIn()) {
            new ErrorDialog(Gerrit.C.notFoundBody()).center();
        } else {
            new NotSignedInDialog().center();
        }
    } else if (isInactiveAccount(caught)) {
        new ErrorDialog(Gerrit.C.inactiveAccountBody()).center();
    } else if (isNoSuchAccount(caught)) {
        final String msg = caught.getMessage();
        final String who = msg.substring(NoSuchAccountException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchAccountMessage(who));
        d.setText(Gerrit.C.noSuchAccountTitle());
        d.center();
    } else if (isNameAlreadyUsed(caught)) {
        final String msg = caught.getMessage();
        final String alreadyUsedName = msg.substring(NameAlreadyUsedException.MESSAGE.length());
        new ErrorDialog(Gerrit.M.nameAlreadyUsedBody(alreadyUsedName)).center();
    } else if (isNoSuchGroup(caught)) {
        final String msg = caught.getMessage();
        final String group = msg.substring(NoSuchGroupException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchGroupMessage(group));
        d.setText(Gerrit.C.noSuchGroupTitle());
        d.center();
    } else if (caught instanceof ServerUnavailableException) {
        new ErrorDialog(RpcConstants.C.errorServerUnavailable()).center();
    } else {
        new ErrorDialog(caught).center();
    }
}
#method_after
public static void showFailure(Throwable caught) {
    if (isSigninFailure(caught)) {
        new NotSignedInDialog().center();
    } else if (isNoSuchEntity(caught)) {
        new ErrorDialog(Gerrit.C.notFoundBody()).center();
    } else if (isInactiveAccount(caught)) {
        new ErrorDialog(Gerrit.C.inactiveAccountBody()).center();
    } else if (isNoSuchAccount(caught)) {
        final String msg = caught.getMessage();
        final String who = msg.substring(NoSuchAccountException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchAccountMessage(who));
        d.setText(Gerrit.C.noSuchAccountTitle());
        d.center();
    } else if (isNameAlreadyUsed(caught)) {
        final String msg = caught.getMessage();
        final String alreadyUsedName = msg.substring(NameAlreadyUsedException.MESSAGE.length());
        new ErrorDialog(Gerrit.M.nameAlreadyUsedBody(alreadyUsedName)).center();
    } else if (isNoSuchGroup(caught)) {
        final String msg = caught.getMessage();
        final String group = msg.substring(NoSuchGroupException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchGroupMessage(group));
        d.setText(Gerrit.C.noSuchGroupTitle());
        d.center();
    } else if (caught instanceof ServerUnavailableException) {
        new ErrorDialog(RpcConstants.C.errorServerUnavailable()).center();
    } else {
        new ErrorDialog(caught).center();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicSet.setOf(binder(), ChangeQueryBuilder.DynamicBuilder.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected Predicate<T> operator(final String name, final String value) throws QueryParseException {
    @SuppressWarnings("rawtypes")
    OperatorFactory f = opFactories.get(name);
    if (f == null) {
        f = getDynamicDefinition().getOperatorFactory(name);
    }
    if (f != null) {
        return f.create(this, value);
    }
    throw error("Unsupported operator " + name + ":" + value);
}
#method_after
@SuppressWarnings("unchecked")
private Predicate<T> operator(final String name, final String value) throws QueryParseException {
    @SuppressWarnings("rawtypes")
    OperatorFactory f = opFactories.get(name);
    if (f == null) {
        throw error("Unsupported operator " + name + ":" + value);
    }
    return f.create(this, value);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Predicate<T> create(Q builder, String value) throws QueryParseException {
    try {
        return (Predicate<T>) method.invoke((dBuilder == null) ? builder : dBuilder, value);
    } catch (RuntimeException | IllegalAccessException e) {
        throw error("Error in operator " + name + ":" + value, e);
    } catch (InvocationTargetException e) {
        throw error("Error in operator " + name + ":" + value, e.getCause());
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Predicate<T> create(Q builder, String value) throws QueryParseException {
    try {
        return (Predicate<T>) method.invoke(builder, value);
    } catch (RuntimeException | IllegalAccessException e) {
        throw error("Error in operator " + name + ":" + value, e);
    } catch (InvocationTargetException e) {
        throw error("Error in operator " + name + ":" + value, e.getCause());
    }
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, builders, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts, index);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts, index);
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, getRefControl().forUser(who), notes);
}
#method_after
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes);
}
#end_block

#method_before
public boolean canAbandon(ReviewDb db) throws OrmException {
    if (isPatchSetLocked(db)) {
        return false;
    }
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#method_after
public boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    final List<PatchSetApproval> psApprovals = db.patchSetApprovals().byPatchSet(getChange().currentPatchSetId()).toList();
    for (final PatchSetApproval ap : psApprovals) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null) {
            if (type.getFunctionName().equalsIgnoreCase("PatchSetLock") && ap.getValue() == 1) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId())) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void commit() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void commit() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void rollback() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void rollback() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void updateSchema(StatementExecutor e) {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void updateSchema(StatementExecutor e) {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void pruneSchema(StatementExecutor e) {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void pruneSchema(StatementExecutor e) {
    throw new Disabled();
}
#end_block

#method_before
@Override
public Access<?, ?>[] allRelations() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public Access<?, ?>[] allRelations() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SchemaVersionAccess schemaVersion() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SchemaVersionAccess schemaVersion() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SystemConfigAccess systemConfig() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SystemConfigAccess systemConfig() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountAccess accounts() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountAccess accounts() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountExternalIdAccess accountExternalIds() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountExternalIdAccess accountExternalIds() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountSshKeyAccess accountSshKeys() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountSshKeyAccess accountSshKeys() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupAccess accountGroups() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupAccess accountGroups() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupNameAccess accountGroupNames() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupNameAccess accountGroupNames() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupMemberAccess accountGroupMembers() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupMemberAccess accountGroupMembers() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupMemberAuditAccess accountGroupMembersAudit() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupMemberAuditAccess accountGroupMembersAudit() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public StarredChangeAccess starredChanges() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public StarredChangeAccess starredChanges() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountProjectWatchAccess accountProjectWatches() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountProjectWatchAccess accountProjectWatches() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountPatchReviewAccess accountPatchReviews() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountPatchReviewAccess accountPatchReviews() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public ChangeAccess changes() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public ChangeAccess changes() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchSetApprovalAccess patchSetApprovals() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchSetApprovalAccess patchSetApprovals() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public ChangeMessageAccess changeMessages() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public ChangeMessageAccess changeMessages() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchSetAccess patchSets() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchSetAccess patchSets() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchLineCommentAccess patchComments() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchLineCommentAccess patchComments() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SubmoduleSubscriptionAccess submoduleSubscriptions() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SubmoduleSubscriptionAccess submoduleSubscriptions() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupByIdAccess accountGroupById() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupByIdAccess accountGroupById() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupByIdAudAccess accountGroupByIdAud() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupByIdAudAccess accountGroupByIdAud() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextAccountId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextAccountId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextAccountGroupId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextAccountGroupId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextChangeId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextChangeId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextChangeMessageId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextChangeMessageId() {
    throw new Disabled();
}
#end_block

#method_before
private static int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#method_after
private static int getPluginsLoadTimeout(Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#end_block

#method_before
private void json(final Object data, final StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#method_after
private void json(Object data, StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = select(req);
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".xGerritAuth=");
        json(session.get().getXGerritAuth(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences((IdentifiedUser) user), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    Page.Content page = select(req);
    StringWriter w = new StringWriter();
    CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        setXGerritAuthCookie(req, rsp, session.get());
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences(user.asIdentifiedUser()), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        setXGerritAuthCookie(req, rsp, null);
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    byte[] hpd = w.toString().getBytes(UTF_8);
    byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#method_after
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#end_block

#method_before
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#method_after
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#end_block

#method_before
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    try (Repository git = gitMgr.openRepository(allUsersName.get())) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, DiffPreferencesInfo.defaults());
        // Reset the migrated flag to prevent it from being sent over the wire.
        prefs.migrated = null;
        return prefs;
    }
}
#method_after
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return readFromGit(id, gitMgr, allUsersName.get(), null);
}
#end_block

#method_before
@Nullable
private GroupBackend backend(AccountGroup.UUID uuid) {
    for (GroupBackend g : backends) {
        if (g.handles(uuid)) {
            return g;
        }
    }
    return null;
}
#method_after
@Nullable
private GroupBackend backend(AccountGroup.UUID uuid) {
    if (uuid != null) {
        for (GroupBackend g : backends) {
            if (g.handles(uuid)) {
                return g;
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    return requireBackend(uuid).get(uuid);
}
#method_after
@Override
public GroupDescription.Basic get(AccountGroup.UUID uuid) {
    GroupBackend b = backend(uuid);
    if (b == null) {
        log.warn("Unknown GroupBackend for UUID: " + uuid);
        return null;
    }
    return b.get(uuid);
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    return new UniversalGroupMembership(user);
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    return new UniversalGroupMembership(user);
}
#end_block

#method_before
@Nullable
private GroupMembership membership(AccountGroup.UUID uuid) {
    for (Map.Entry<GroupBackend, GroupMembership> m : memberships.entrySet()) {
        if (m.getKey().handles(uuid)) {
            return m.getValue();
        }
    }
    return null;
}
#method_after
@Nullable
private GroupMembership membership(AccountGroup.UUID uuid) {
    if (uuid != null) {
        for (Map.Entry<GroupBackend, GroupMembership> m : memberships.entrySet()) {
            if (m.getKey().handles(uuid)) {
                return m.getValue();
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean contains(AccountGroup.UUID uuid) {
    return requireMembership(uuid).contains(uuid);
}
#method_after
@Override
public boolean contains(AccountGroup.UUID uuid) {
    GroupMembership m = membership(uuid);
    if (m == null) {
        log.warn("Unknown GroupMembership for UUID: " + uuid);
        return false;
    }
    return m.contains(uuid);
}
#end_block

#method_before
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        lookups.put(requireMembership(uuid), uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        if (entry.getKey().containsAnyOf(entry.getValue())) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.warn("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        if (entry.getKey().containsAnyOf(entry.getValue())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final ExtGroup group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isOwner() {
    if (!group.hasOwnerGroupId()) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup g = groupCache.get(group.getOwnerGroupId());
        AccountGroup.UUID ownerUUID = g != null ? g.getGroupUUID() : null;
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#method_after
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            Multibinder.newSetBinder(binder(), GroupBackend.class).addBinding().to(InternalGroupBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    return changeControl.forUser(who).isVisible(reviewDbProvider.get());
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#method_after
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    // to drafts
                    return changeControl.forUser(who).isRefVisible();
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#end_block

#method_before
private GroupReference groupReference(LdapQuery.Result res) throws NamingException {
    String name = Objects.firstNonNull(res.get("cn"), res.getDN());
    return new GroupReference(new AccountGroup.UUID(LDAP_UUID + res.getDN()), LDAP_NAME + name);
}
#method_after
private static GroupReference groupReference(LdapQuery.Result res) throws NamingException {
    return new GroupReference(new AccountGroup.UUID(LDAP_UUID + res.getDN()), LDAP_NAME + cnFor(res.getDN()));
}
#end_block

#method_before
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return internalBackend.handles(uuid) || isLdapUUID(uuid);
}
#method_after
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return isLdapUUID(uuid);
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    if (isLdapUUID(uuid)) {
        // First see if there is a legacy LDAP UUID stored in the database.
        AccountGroup.ExternalNameKey ext = externalNameKey(uuid);
        for (AccountGroup g : groupCache.get(ext)) {
            if (g.getGroupUUID() != null) {
                return ExtGroups.forAccountGroup(g);
            }
        }
        // Otherwise generate a GroupReference if the name is valid.
        return lookup(ext);
    } else {
        return internalBackend.get(uuid);
    }
}
#method_after
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    String groupDn = uuid.get().substring(LDAP_UUID.length());
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser) || !membershipsOf((IdentifiedUser) user).contains(uuid)) {
        try {
            if (!existsCache.get(groupDn)) {
                return null;
            }
        } catch (ExecutionException e) {
            log.warn(String.format("Cannot lookup group %s in LDAP", groupDn), e);
            return null;
        }
    }
    final String name = LDAP_NAME + cnFor(groupDn);
    return new GroupDescription.Basic() {

        @Override
        public AccountGroup.UUID getGroupUUID() {
            return uuid;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public boolean isVisibleToAll() {
            return true;
        }
    };
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(name);
    if (isLdapUUID(uuid)) {
        ExtGroup g = get(uuid);
        if (g == null) {
            return Collections.emptySet();
        }
        return Collections.singleton(GroupReference.forGroup(g));
    } else if (name.startsWith(LDAP_NAME)) {
        return suggestLdap(name.substring(LDAP_NAME.length()));
    }
    return internalBackend.suggest(name);
}
#method_after
@Override
public Collection<GroupReference> suggest(String name) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(name);
    if (isLdapUUID(uuid)) {
        GroupDescription.Basic g = get(uuid);
        if (g == null) {
            return Collections.emptySet();
        }
        return Collections.singleton(GroupReference.forGroup(g));
    } else if (name.startsWith(LDAP_NAME)) {
        return suggestLdap(name.substring(LDAP_NAME.length()));
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    // TODO(cranger): update to support ldapgroup UUID
    return groupMembershipFactory.create(Iterables.concat(membershipCache.get(findId(user.getExternalIds())), user.getInternalGroups()));
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    String id = findId(user.state().getExternalIds());
    if (id == null) {
        return GroupMembership.EMPTY;
    }
    try {
        return new ListGroupMembership(membershipCache.get(id));
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup membershipsOf %s in LDAP", id), e);
        return GroupMembership.EMPTY;
    }
}
#end_block

#method_before
private Set<GroupReference> suggestLdap(String name) {
    Set<GroupReference> out = Sets.newTreeSet(GROUP_REF_NAME_COMPARATOR);
    try {
        final DirContext ctx = helper.open();
        try {
            final LdapSchema schema = helper.getSchema(ctx);
            final ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            final Set<String> returnAttrs = Collections.<String>emptySet();
            final Map<String, String> params = Collections.emptyMap();
            for (String groupBase : schema.groupBases) {
                LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, returnAttrs);
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(groupReference(res));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#method_after
private Set<GroupReference> suggestLdap(String name) {
    if (name.isEmpty()) {
        return Collections.emptySet();
    }
    Set<GroupReference> out = Sets.newTreeSet(GROUP_REF_NAME_COMPARATOR);
    try {
        DirContext ctx = helper.open();
        try {
            // Do exact lookups until there are at least 3 characters.
            name = Rdn.escapeValue(name) + ((name.length() >= 3) ? "*" : "");
            LdapSchema schema = helper.getSchema(ctx);
            ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            Set<String> returnAttrs = Collections.<String>emptySet();
            Map<String, String> params = Collections.emptyMap();
            for (String groupBase : schema.groupBases) {
                LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, returnAttrs);
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(groupReference(res));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#end_block

#method_before
@Nullable
public static GroupReference findBestSuggestion(GroupBackend groupBackend, String name) {
    Collection<GroupReference> refs = groupBackend.suggest(name);
    if (refs.size() == 1) {
        return refs.iterator().next();
    }
    for (GroupReference ref : refs) {
        if (ref.getName().equals(name) || ref.getUUID().get().equals(name)) {
            return ref;
        }
    }
    return null;
}
#method_after
@Nullable
public static GroupReference findBestSuggestion(GroupBackend groupBackend, String name) {
    Collection<GroupReference> refs = groupBackend.suggest(name);
    if (refs.size() == 1) {
        return Iterables.getOnlyElement(refs);
    }
    for (GroupReference ref : refs) {
        if (isExactSuggestion(ref, name)) {
            return ref;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:") || uuid.get().indexOf(':') < 0;
}
#method_after
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:") || uuid.get().matches("[0-9a-f]{40}");
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    checkArgument(handles(uuid), "internal groups system does not handle UUID: %s", uuid);
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return ExtGroups.forAccountGroup(g);
}
#method_after
@Override
public GroupDescription.Internal get(AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return GroupDescriptions.forAccountGroup(g);
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(final String name) {
    Iterable<AccountGroup> filtered = Iterables.filter(groupCache.all(), new Predicate<AccountGroup>() {

        @Override
        public boolean apply(AccountGroup group) {
            return group.getName().startsWith(name);
        }
    });
    return Lists.newArrayList(Iterables.transform(filtered, ACT_GROUP_TO_GROUP_REF));
}
#method_after
@Override
public Collection<GroupReference> suggest(final String name) {
    Iterable<AccountGroup> filtered = Iterables.filter(groupCache.all(), new Predicate<AccountGroup>() {

        @Override
        public boolean apply(AccountGroup group) {
            // startsWithIgnoreCase
            return group.getName().regionMatches(true, 0, name, 0, name.length());
        }
    });
    return Lists.newArrayList(Iterables.transform(filtered, ACT_GROUP_TO_GROUP_REF));
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    return groupMembershipFactory.create(user.getInternalGroups());
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    return groupMembershipFactory.create(user.state().getInternalGroups());
}
#end_block

#method_before
@Override
protected void configure() {
    final TypeLiteral<Cache<String, Set<AccountGroup.UUID>>> groups = new TypeLiteral<Cache<String, Set<AccountGroup.UUID>>>() {
    };
    // 
    core(groups, GROUP_CACHE).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    final TypeLiteral<Cache<String, Account.Id>> usernames = new TypeLiteral<Cache<String, Account.Id>>() {
    };
    // 
    core(usernames, USERNAME_CACHE).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    Multibinder.newSetBinder(binder(), GroupBackend.class).addBinding().to(LdapGroupBackend.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner() || metaConfigControl.isVisible()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    return detail;
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch;
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommit(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException doesNotExist) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, err);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                ExtGroup g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    replication.scheduleUpdate(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    referenceUpdated.fire(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
private void validateParameters() throws ProjectCreationFailedException {
    if (createProjectArgs.getProjectName() == null || createProjectArgs.getProjectName().isEmpty()) {
        throw new ProjectCreationFailedException("Project name is required");
    }
    if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) {
        createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, createProjectArgs.getProjectName().length() - Constants.DOT_GIT_EXT.length()));
    }
    if (!currentUser.getCapabilities().canCreateProject()) {
        throw new ProjectCreationFailedException(String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName()));
    }
    if (createProjectArgs.ownerIds == null || createProjectArgs.ownerIds.isEmpty()) {
        createProjectArgs.ownerIds = new ArrayList<AccountGroup.UUID>(projectOwnerGroups);
    }
    while (createProjectArgs.branch.startsWith("/")) {
        createProjectArgs.branch = createProjectArgs.branch.substring(1);
    }
    if (!createProjectArgs.branch.startsWith(Constants.R_HEADS)) {
        createProjectArgs.branch = Constants.R_HEADS + createProjectArgs.branch;
    }
    if (!Repository.isValidRefName(createProjectArgs.branch)) {
        throw new ProjectCreationFailedException(String.format("Branch \"%s\" is not a valid name.", createProjectArgs.branch));
    }
}
#method_after
private void validateParameters() throws ProjectCreationFailedException {
    if (createProjectArgs.getProjectName() == null || createProjectArgs.getProjectName().isEmpty()) {
        throw new ProjectCreationFailedException("Project name is required");
    }
    if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) {
        createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, createProjectArgs.getProjectName().length() - Constants.DOT_GIT_EXT.length()));
    }
    if (!currentUser.getCapabilities().canCreateProject()) {
        throw new ProjectCreationFailedException(String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName()));
    }
    if (createProjectArgs.ownerIds == null || createProjectArgs.ownerIds.isEmpty()) {
        createProjectArgs.ownerIds = new ArrayList<AccountGroup.UUID>(projectOwnerGroups);
    }
    List<String> transformedBranches = new ArrayList<String>();
    if (createProjectArgs.branch == null || createProjectArgs.branch.isEmpty()) {
        createProjectArgs.branch = Collections.singletonList(Constants.MASTER);
    }
    for (String branch : createProjectArgs.branch) {
        while (branch.startsWith("/")) {
            branch = branch.substring(1);
        }
        if (!branch.startsWith(Constants.R_HEADS)) {
            branch = Constants.R_HEADS + branch;
        }
        if (!Repository.isValidRefName(branch)) {
            throw new ProjectCreationFailedException(String.format("Branch \"%s\" is not a valid name.", branch));
        }
        if (!transformedBranches.contains(branch)) {
            transformedBranches.add(branch);
        }
    }
    createProjectArgs.branch = transformedBranches;
}
#end_block

#method_before
private AccountState state() {
    if (state == null) {
        state = accountCache.get(getAccountId());
    }
    return state;
}
#method_after
public AccountState state() {
    if (state == null) {
        state = accountCache.get(getAccountId());
    }
    return state;
}
#end_block

#method_before
@Override
public GroupMembership getEffectiveGroups() {
    if (effectiveGroups == null) {
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            effectiveGroups = groupBackend.membershipsOf(state());
        } else {
            effectiveGroups = registeredGroups;
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public GroupMembership getEffectiveGroups() {
    if (effectiveGroups == null) {
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            effectiveGroups = groupBackend.membershipsOf(this);
        } else {
            effectiveGroups = registeredGroups;
        }
    }
    return effectiveGroups;
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = groupCache.get(groupId);
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = groupCache.get(groupId);
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    GroupDescription.Basic ownerGroup = groupBackend.get(group.getOwnerGroupUUID());
    if (ownerGroup != null) {
        detail.setOwnerGroup(GroupReference.forGroup(ownerGroup));
    }
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public void changeGroupOwner(final AccountGroup.Id groupId, final String newOwnerName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            final AccountGroup owner = groupCache.get(new AccountGroup.NameKey(newOwnerName));
            if (owner == null) {
                throw new Failure(new NoSuchEntityException());
            }
            group.setOwnerGroupId(owner.getId());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void changeGroupOwner(final AccountGroup.Id groupId, final String newOwnerName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, newOwnerName);
            if (owner == null) {
                throw new Failure(new NoSuchEntityException());
            }
            group.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public boolean updateGroupNames(GroupBackend groupBackend) {
    boolean dirty = false;
    for (GroupReference ref : groupsByUUID.values()) {
        ExtGroup g = groupBackend.get(ref.getUUID());
        if (g != null && !g.getName().equals(ref.getName())) {
            dirty = true;
            ref.setName(g.getName());
        }
    }
    return dirty;
}
#method_after
public boolean updateGroupNames(GroupBackend groupBackend) {
    boolean dirty = false;
    for (GroupReference ref : groupsByUUID.values()) {
        GroupDescription.Basic g = groupBackend.get(ref.getUUID());
        if (g != null && !g.getName().equals(ref.getName())) {
            dirty = true;
            ref.setName(g.getName());
        }
    }
    return dirty;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), account.getId());
}
#method_after
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), Optional.of(account.getId()));
}
#end_block

#method_before
@Override
public Account.Id lookup(final String accountName) {
    return usernameCache.get(accountName);
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    if (Strings.isNullOrEmpty(accountName)) {
        return null;
    }
    try {
        Optional<Account.Id> id = usernameCache.get(accountName);
        return id != null ? id.orNull() : null;
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup account %s in LDAP", accountName), e);
        return null;
    }
}
#end_block

#method_before
public static GroupReference forGroup(ExtGroup group) {
    return new GroupReference(group.getGroupUUID(), group.getName());
}
#method_after
public static GroupReference forGroup(GroupDescription.Basic group) {
    return new GroupReference(group.getGroupUUID(), group.getName());
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts, input.omitDuplicateComments);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private Project fetchGerritProject(ProjectCache projectCache, String organisation, String repoName) {
    NameKey projectNameKey = Project.NameKey.parse(organisation + "/" + repoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#method_after
private Project fetchGerritProject(ProjectCache projectCache, String fetchOrganisation, String fetchRepoName) {
    NameKey projectNameKey = Project.NameKey.parse(fetchOrganisation + "/" + fetchRepoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#end_block

#method_before
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, pr.getNumber()));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#method_after
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, new Integer(pr.getNumber())));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#end_block

#method_before
private com.google.gerrit.reviewdb.client.Account.Id getOrRegisterAccount(ReviewDb db, String login, String name, String email) throws OrmException, BadRequestException, ResourceConflictException, UnprocessableEntityException, IOException {
    AccountExternalId.Key userExtKey = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, login);
    AccountExternalIdAccess gerritExtIds = db.accountExternalIds();
    AccountExternalId userExtId = gerritExtIds.get(userExtKey);
    if (userExtId == null) {
        return accountImporter.importAccount(login, name, email);
    } else {
        return userExtId.getAccountId();
    }
}
#method_after
private com.google.gerrit.reviewdb.client.Account.Id getOrRegisterAccount(ReviewDb db, String login, String name, String email) throws OrmException, BadRequestException, ResourceConflictException, UnprocessableEntityException, IOException {
    AccountExternalId.Key userExtKey = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, login);
    AccountExternalIdAccess gerritExtIds = db.accountExternalIds();
    AccountExternalId userExtId = gerritExtIds.get(userExtKey);
    if (userExtId == null) {
        return accountImporter.importAccount(login, name, email);
    }
    return userExtId.getAccountId();
}
#end_block

#method_before
public GHRepository getGHRepository() throws IOException {
    if (ghLogin.getMyself().getLogin().equals(organisation)) {
        return ghLogin.getMyself().getRepository(repoName);
    } else {
        return ghLogin.getHub().getOrganization(organisation).getRepository(repoName);
    }
}
#method_after
public GHRepository getGHRepository() throws IOException {
    if (ghLogin.getMyself().getLogin().equals(organisation)) {
        return ghLogin.getMyself().getRepository(repoName);
    }
    return ghLogin.getHub().getOrganization(organisation).getRepository(repoName);
}
#end_block

#method_before
private Runnable save() {
    return new Runnable() {

        @Override
        public void run() {
            if (!cm.isClean(generation)) {
                close.setEnabled(false);
                String text = cm.getValue();
                if (Patch.COMMIT_MSG.equals(path)) {
                    String newText = text.trim();
                    if (!newText.equals(text)) {
                        text = newText;
                        cm.setValue(text);
                    }
                }
                final int g = cm.changeGeneration(false);
                ChangeEditApi.put(revision.getParentKey().get(), path, text, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                        generation = g;
                        setClean(cm.isClean(g));
                    }

                    @Override
                    public void onFailure(final Throwable caught) {
                        close.setEnabled(true);
                    }
                });
            }
        }
    };
}
#method_after
private Runnable save() {
    return new Runnable() {

        @Override
        public void run() {
            if (!cm.isClean(generation)) {
                close.setEnabled(false);
                String text = cm.getValue();
                if (Patch.COMMIT_MSG.equals(path)) {
                    String trimmed = text.trim() + "\r";
                    if (!trimmed.equals(text)) {
                        text = trimmed;
                        cm.setValue(text);
                    }
                }
                final int g = cm.changeGeneration(false);
                ChangeEditApi.put(revision.getParentKey().get(), path, text, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                        generation = g;
                        setClean(cm.isClean(g));
                    }

                    @Override
                    public void onFailure(final Throwable caught) {
                        close.setEnabled(true);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = DriverManager.getConnection("jdbc:derby:memory:DialectDerbyTest;create=true");
    executor = new JdbcExecutor(db);
    dialect = new DialectDerby().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.apache.derby.jdbc.EmbeddedDriver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#method_after
@Before
public void setUp() throws Exception {
    db = DriverManager.getConnection(CONNECT + ";create=true");
    executor = new JdbcExecutor(db);
    dialect = new DialectDerby().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.apache.derby.jdbc.EmbeddedDriver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    try {
        DriverManager.getConnection("jdbc:derby:memory:DialectDerbyTest;drop=true");
    } catch (SQLException e) {
    }
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    try {
        DriverManager.getConnection(CONNECT + ";drop=true");
    } catch (SQLException e) {
    /* as stated in the derby reference manual,
       * section "Setting attributes for the database connection URL"
       * https://db.apache.org/derby/docs/10.11/ref/rrefattribdrop.html
       * "The attribute generates the SQLException 08006 if successful.
       *  If the database does not exist, it generates an error
       *  reporting that the database could not be found."
       *  So we can safely ignore this SQLException here.
       */
    }
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Test
public void testUpgradeSchema() throws SQLException, OrmException {
    final PhoneBookDb p = phoneBook.open();
    try {
        p.updateSchema(executor);
        execute("CREATE SEQUENCE cnt");
        execute("CREATE TABLE foo (cnt INT)");
        execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)");
        execute("ALTER TABLE people DROP COLUMN registered");
        Set<String> sequences, tables;
        p.updateSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertTrue(sequences.contains("cnt"));
        assertTrue(tables.contains("foo"));
        assertTrue(sequences.contains("address_id"));
        assertTrue(tables.contains("addresses"));
        p.pruneSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertFalse(sequences.contains("cnt"));
        assertFalse(tables.contains("foo"));
        final Person.Key pk = new Person.Key("Bob");
        final Person bob = new Person(pk, p.nextAddressId());
        p.people().insert(Collections.singleton(bob));
        final Address addr = new Address(new Address.Key(pk, "home"), "some place");
        p.addresses().insert(Collections.singleton(addr));
    } finally {
        p.close();
    }
// constraint violation for rename column :-(
// final PhoneBookDb2 p2 = phoneBook2.open();
// try {
// ((JdbcSchema) p2).renameField(executor, "people", "registered",
// "isRegistered");
// } finally {
// p2.close();
// }
}
#method_after
@Test
public void testUpgradeSchema() throws SQLException, OrmException {
    final PhoneBookDb p = phoneBook.open();
    try {
        p.updateSchema(executor);
        execute("CREATE SEQUENCE cnt");
        execute("CREATE TABLE foo (cnt INT)");
        execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)");
        execute("ALTER TABLE people DROP COLUMN registered");
        Set<String> sequences, tables;
        p.updateSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertTrue(sequences.contains("cnt"));
        assertTrue(tables.contains("foo"));
        assertTrue(sequences.contains("address_id"));
        assertTrue(tables.contains("addresses"));
        p.pruneSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertFalse(sequences.contains("cnt"));
        assertFalse(tables.contains("foo"));
        final Person.Key pk = new Person.Key("Bob");
        final Person bob = new Person(pk, p.nextAddressId());
        p.people().insert(Collections.singleton(bob));
        final Address addr = new Address(new Address.Key(pk, "home"), "some place");
        p.addresses().insert(Collections.singleton(addr));
    } finally {
        p.close();
    }
    /* rename a column in an existing table to match the new schema */
    final PhoneBookDb2 p2 = phoneBook2.open();
    /* As Apache Derby doesn't support renaming a column as long as a constraint
     * exists on the column, we need to drop the constraint manually.
     * Currently a CHECK constraint is created by gwtorm for all fields with
     * type SqlBooleanTypeInfo.
     * See also https://db.apache.org/derby/docs/10.11/ref/rrefsqljrenamecolumnstatement.html
     * for more information about the restriction of the RENAME COLUMN command.
     */
    String sqlCatalog = "select c.constraintname, ch.checkdefinition" + " from sys.sysconstraints c, sys.systables t, sys.syschecks ch" + " WHERE c.tableid = t.tableid" + "   and t.tablename = ?" + "   and c.constraintid = ch.constraintid";
    PreparedStatement ps = db.prepareStatement(sqlCatalog);
    String tableName = "PEOPLE";
    ps.setString(1, tableName);
    try {
        ResultSet rs = ps.executeQuery();
        List<String> constraintNames = new ArrayList<>();
        List<String> checkDefs = new ArrayList<>();
        while (rs.next()) {
            if (rs.getString(2).contains("registered")) {
                constraintNames.add(rs.getString(1));
                checkDefs.add(rs.getString(2).replace("registered", "is_registered"));
                break;
            }
        }
        rs.close();
        ps.close();
        if (constraintNames.isEmpty()) {
            fail("Constraint not found");
        }
        for (String c : constraintNames) {
            execute("alter table " + tableName + " drop check " + c);
        }
        ((JdbcSchema) p2).renameField(executor, "people", "registered", "isRegistered");
        for (String cd : checkDefs) {
            execute("alter table " + tableName + " add check " + cd);
        }
    } catch (OrmException e) {
        fail(e.getMessage());
    } finally {
        p2.close();
    }
}
#end_block

#method_before
public String getCreateSequenceSql(final SequenceModel seq) {
    final Sequence s = seq.getSequence();
    final StringBuilder r = new StringBuilder();
    r.append("CREATE SEQUENCE ");
    r.append(seq.getSequenceName());
    if (s.startWith() > 0) {
        r.append(" START WITH ");
        r.append(s.startWith());
    }
    if (s.cache() > 0) {
        r.append(" CACHE ");
        r.append(s.cache());
    }
    return r.toString();
}
#method_after
public String getCreateSequenceSql(final SequenceModel seq) {
    final Sequence s = seq.getSequence();
    final StringBuilder r = new StringBuilder();
    r.append("CREATE SEQUENCE ");
    r.append(seq.getSequenceName());
    /*
     * Some gwtorm users seems to imply a start of 1, enforce this constraint
     * here explicitly
     */
    r.append(" START WITH ");
    r.append(s.startWith() > 0 ? s.startWith() : 1);
    if (s.cache() > 0) {
        r.append(" CACHE ");
        r.append(s.cache());
    }
    return r.toString();
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                PatchListEntry e = newEntry(aTree, fh);
                if (com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY.equals(e.getPatchType())) {
                    e.setSizeDelta(getFileSize(repo, reader, diffEntry.getNewPath(), bTree) - getFileSize(repo, reader, diffEntry.getOldPath(), aTree));
                }
                entries.add(e);
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                long sizeDelta = getFileSize(repo, reader, diffEntry.getNewPath(), bTree) - getFileSize(repo, reader, diffEntry.getOldPath(), aTree);
                entries.add(newEntry(aTree, fh, sizeDelta));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes("UTF-8");
    RawText aRawText = new RawText(aText.getContent());
    RawText bRawText = new RawText(bText.getContent());
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits);
}
#method_after
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes("UTF-8");
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, sizeDelta);
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    } else {
        return new PatchListEntry(fileHeader, edits);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#end_block

#method_before
Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base) throws PatchListNotAvailableException {
    ObjectId a = (base == null) ? null : ObjectId.fromString(base.getRevision().get());
    ObjectId b = ObjectId.fromString(revision.get());
    PatchList list = patchListCache.get(new PatchListKey(a, b, Whitespace.IGNORE_NONE), change.getProject());
    Map<String, FileInfo> files = Maps.newTreeMap();
    for (PatchListEntry e : list.getPatches()) {
        FileInfo d = new FileInfo();
        d.status = e.getChangeType() != Patch.ChangeType.MODIFIED ? e.getChangeType().getCode() : null;
        d.oldPath = e.getOldName();
        if (e.getPatchType() == Patch.PatchType.BINARY) {
            d.binary = true;
            d.sizeDelta = e.getSizeDelta() != null ? e.getSizeDelta() : null;
        } else {
            d.linesInserted = e.getInsertions() > 0 ? e.getInsertions() : null;
            d.linesDeleted = e.getDeletions() > 0 ? e.getDeletions() : null;
        }
        FileInfo o = files.put(e.getNewName(), d);
        if (o != null) {
            // This should only happen on a delete-add break created by JGit
            // when the file was rewritten and too little content survived. Write
            // a single record with data from both sides.
            d.status = Patch.ChangeType.REWRITE.getCode();
            if (o.binary != null && o.binary) {
                d.binary = true;
                d.sizeDelta = o.sizeDelta;
            }
            if (o.linesInserted != null) {
                d.linesInserted = o.linesInserted;
            }
            if (o.linesDeleted != null) {
                d.linesDeleted = o.linesDeleted;
            }
        }
    }
    return files;
}
#method_after
Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base) throws PatchListNotAvailableException {
    ObjectId a = (base == null) ? null : ObjectId.fromString(base.getRevision().get());
    ObjectId b = ObjectId.fromString(revision.get());
    PatchList list = patchListCache.get(new PatchListKey(a, b, Whitespace.IGNORE_NONE), change.getProject());
    Map<String, FileInfo> files = Maps.newTreeMap();
    for (PatchListEntry e : list.getPatches()) {
        FileInfo d = new FileInfo();
        d.status = e.getChangeType() != Patch.ChangeType.MODIFIED ? e.getChangeType().getCode() : null;
        d.oldPath = e.getOldName();
        d.sizeDelta = e.getSizeDelta();
        if (e.getPatchType() == Patch.PatchType.BINARY) {
            d.binary = true;
        } else {
            d.linesInserted = e.getInsertions() > 0 ? e.getInsertions() : null;
            d.linesDeleted = e.getDeletions() > 0 ? e.getDeletions() : null;
        }
        FileInfo o = files.put(e.getNewName(), d);
        if (o != null) {
            // This should only happen on a delete-add break created by JGit
            // when the file was rewritten and too little content survived. Write
            // a single record with data from both sides.
            d.status = Patch.ChangeType.REWRITE.getCode();
            d.sizeDelta = o.sizeDelta;
            if (o.binary != null && o.binary) {
                d.binary = true;
            }
            if (o.linesInserted != null) {
                d.linesInserted = o.linesInserted;
            }
            if (o.linesDeleted != null) {
                d.linesDeleted = o.linesDeleted;
            }
        }
    }
    return files;
}
#end_block

#method_before
static PatchListEntry empty(final String fileName) {
    return new PatchListEntry(ChangeType.MODIFIED, PatchType.UNIFIED, null, fileName, EMPTY_HEADER, Collections.<Edit>emptyList(), 0, 0);
}
#method_after
static PatchListEntry empty(final String fileName) {
    return new PatchListEntry(ChangeType.MODIFIED, PatchType.UNIFIED, null, fileName, EMPTY_HEADER, Collections.<Edit>emptyList(), 0, 0, 0);
}
#end_block

#method_before
public Long getSizeDelta() {
    return sizeDelta;
}
#method_after
public long getSizeDelta() {
    return sizeDelta;
}
#end_block

#method_before
void writeTo(final OutputStream out) throws IOException {
    writeEnum(out, changeType);
    writeEnum(out, patchType);
    writeString(out, oldName);
    writeString(out, newName);
    writeBytes(out, header);
    writeVarInt32(out, insertions);
    writeVarInt32(out, deletions);
    writeVarInt32(out, edits.size());
    for (final Edit e : edits) {
        writeVarInt32(out, e.getBeginA());
        writeVarInt32(out, e.getEndA());
        writeVarInt32(out, e.getBeginB());
        writeVarInt32(out, e.getEndB());
    }
}
#method_after
void writeTo(OutputStream out) throws IOException {
    writeEnum(out, changeType);
    writeEnum(out, patchType);
    writeString(out, oldName);
    writeString(out, newName);
    writeBytes(out, header);
    writeVarInt32(out, insertions);
    writeVarInt32(out, deletions);
    writeFixInt64(out, sizeDelta);
    writeVarInt32(out, edits.size());
    for (final Edit e : edits) {
        writeVarInt32(out, e.getBeginA());
        writeVarInt32(out, e.getEndA());
        writeVarInt32(out, e.getBeginB());
        writeVarInt32(out, e.getEndB());
    }
}
#end_block

#method_before
static PatchListEntry readFrom(final InputStream in) throws IOException {
    final ChangeType changeType = readEnum(in, ChangeType.values());
    final PatchType patchType = readEnum(in, PatchType.values());
    final String oldName = readString(in);
    final String newName = readString(in);
    final byte[] hdr = readBytes(in);
    final int ins = readVarInt32(in);
    final int del = readVarInt32(in);
    final int editCount = readVarInt32(in);
    final Edit[] editArray = new Edit[editCount];
    for (int i = 0; i < editCount; i++) {
        int beginA = readVarInt32(in);
        int endA = readVarInt32(in);
        int beginB = readVarInt32(in);
        int endB = readVarInt32(in);
        editArray[i] = new Edit(beginA, endA, beginB, endB);
    }
    return new PatchListEntry(changeType, patchType, oldName, newName, hdr, toList(editArray), ins, del);
}
#method_after
static PatchListEntry readFrom(InputStream in) throws IOException {
    ChangeType changeType = readEnum(in, ChangeType.values());
    PatchType patchType = readEnum(in, PatchType.values());
    String oldName = readString(in);
    String newName = readString(in);
    byte[] hdr = readBytes(in);
    int ins = readVarInt32(in);
    int del = readVarInt32(in);
    long sizeDelta = readFixInt64(in);
    int editCount = readVarInt32(in);
    Edit[] editArray = new Edit[editCount];
    for (int i = 0; i < editCount; i++) {
        int beginA = readVarInt32(in);
        int endA = readVarInt32(in);
        int beginB = readVarInt32(in);
        int endB = readVarInt32(in);
        editArray[i] = new Edit(beginA, endA, beginB, endB);
    }
    return new PatchListEntry(changeType, patchType, oldName, newName, hdr, toList(editArray), ins, del, sizeDelta);
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = projectControl.controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = projectControl.getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change);
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (!hashtags.isEmpty()) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
        if (!approvals.isEmpty()) {
            hooks.doCommentAddedHook(change, ((IdentifiedUser) ctl.getCurrentUser()).getAccount(), patchSet, null, approvals, db);
        }
    }
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = projectControl.controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = projectControl.getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change);
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
        if (approvals != null && !approvals.isEmpty()) {
            hooks.doCommentAddedHook(change, ((IdentifiedUser) ctl.getCurrentUser()).getAccount(), patchSet, null, approvals, db);
        }
    }
    return change;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(Q.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(Q.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(P.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
}
#end_block

#method_before
private void saveLabelConfig() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(cfg);
}
#method_after
private void saveLabelConfig() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.getLabelSections().put(Q.getName(), Q);
    cfg.getLabelSections().put(P.getName(), P);
    saveProjectConfig(cfg);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    post(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.user").to(GetUserPreferences.class);
    put(ACCOUNT_KIND, "preferences.user").to(SetUserPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), BranchWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), FileWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(GitilesWeblinks.class);
    bind(GitilesAccess.Factory.class).to(GerritGitilesAccess.Factory.class);
    bind(new TypeLiteral<RepositoryResolver<HttpServletRequest>>() {
    }).to(Resolver.class);
    listener().to(Lifecycle.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), BranchWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), FileHistoryWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), FileWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(GitilesWeblinks.class);
    bind(GitilesAccess.Factory.class).to(GerritGitilesAccess.Factory.class);
    bind(new TypeLiteral<RepositoryResolver<HttpServletRequest>>() {
    }).to(Resolver.class);
    listener().to(Lifecycle.class);
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    ResultSet<AccountSshKey> byAccountLast = dbProvider.get().accountSshKeys().byAccountLast(user.getAccountId());
    AccountSshKey last = Iterables.getOnlyElement(byAccountLast, null);
    int max = last == null ? 0 : last.getKey().get();
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
        dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
        try {
            addSshKeyFactory.create(user, sshKey).send();
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send SSH key added message to " + email, e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    ResultSet<AccountSshKey> byAccountLast = dbProvider.get().accountSshKeys().byAccountLast(user.getAccountId());
    AccountSshKey last = Iterables.getOnlyElement(byAccountLast, null);
    int max = last == null ? 0 : last.getKey().get();
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
        dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(new SignedPushModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddSshKeySender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Test
public void testParseSimple() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseSimple() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParseWHeader() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, HEADER + F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseWHeader() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, HEADER + F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParseWComments() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, C1 + F_SIMPLE + C2, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseWComments() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, C1 + F_SIMPLE + C2, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParsePaddedFronts() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_F, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParsePaddedFronts() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_F, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParsePaddedEnds() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_E, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParsePaddedEnds() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_E, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParse2Labels() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
    dl.parseLabel(LABEL2, L_COMPLEX, null);
    branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
    branches = dl.getDestinations(LABEL2);
    assertThat(branches).contains(B_COMPLEX);
}
#method_after
@Test
public void testParse2Labels() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
    dl.parseLabel(LABEL2, L_COMPLEX, null);
    branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
    branches = dl.getDestinations(LABEL2);
    assertThat(branches).contains(B_COMPLEX);
}
#end_block

#method_before
@Test
public void testAsText() throws Exception {
    String text = HEADER_PROPER + "#\n" + F_PROPER;
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    String asText = dl.asText(LABEL);
    assertThat(text).isEqualTo(asText);
    dl.parseLabel(LABEL2, asText, null);
    String asText2 = dl.asText(LABEL2);
    assertThat(text).isEqualTo(asText2);
}
#method_after
@Test
public void testAsText() throws Exception {
    String text = HEADER_PROPER + "#\n" + F_PROPER;
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    String asText = dl.asText(LABEL);
    assertThat(text).isEqualTo(asText);
    dl.parseLabel(LABEL2, asText, null);
    assertThat(text).isEqualTo(dl.asText(LABEL2));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> destination(String name) throws QueryParseException, OrmException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountDestinations d = VersionedAccountDestinations.forUser(self());
        d.load(git);
        Set<Branch.NameKey> destinations = d.getDestinationList().getDestinations(name);
        if (destinations != null) {
            return new DestinationPredicate(destinations, name);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named destination (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named destination: " + name, e);
    }
    throw new QueryParseException("Unknown named destination: " + name);
}
#method_after
@Operator
public Predicate<ChangeData> destination(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountDestinations d = VersionedAccountDestinations.forUser(self());
        d.load(git);
        Set<Branch.NameKey> destinations = d.getDestinationList().getDestinations(name);
        if (destinations != null) {
            return new DestinationPredicate(destinations, name);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named destination (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named destination: " + name, e);
    }
    throw new QueryParseException("Unknown named destination: " + name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#end_block

#method_before
public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException {
    destinations.put(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors)));
}
#method_after
public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException {
    destinations.replaceValues(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors)));
}
#end_block

#method_before
public static ServletModule module() {
    return new ServletModule() {

        @Override
        protected void configureServlets() {
            DynamicSet.setOf(binder(), AllRequestFilter.class);
            filter("/*").through(FilterProxy.class);
        }
    };
}
#method_after
public static ServletModule module() {
    return new ServletModule() {

        @Override
        protected void configureServlets() {
            DynamicSet.setOf(binder(), AllRequestFilter.class);
            filter("/*").through(FilterProxy.class);
            bind(StopPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(FilterProxy.class);
        }
    };
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse res, final FilterChain last) throws IOException, ServletException {
    final Iterator<AllRequestFilter> itr = filters.iterator();
    new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {
            if (itr.hasNext()) {
                AllRequestFilter filter = itr.next();
                if (!initializedFilters.contains(filter)) {
                    initFilter(filter);
                }
                filter.doFilter(req, res, this);
            } else {
                last.doFilter(req, res);
            }
        }
    }.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse res, final FilterChain last) throws IOException, ServletException {
    final Iterator<AllRequestFilter> itr = filters.iterator();
    new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {
            while (itr.hasNext()) {
                AllRequestFilter filter = itr.next();
                // webrequests.
                if (initializedFilters.contains(filter) || initFilterIfNeeded(filter)) {
                    filter.doFilter(req, res, this);
                    return;
                }
            }
            last.doFilter(req, res);
        }
    }.doFilter(req, res);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) throws ServletException {
    // Plugins that provide AllRequestFilters might get loaded later at
    // runtime, long after this init method had been called. To allow to
    // correctly init such plugins' AllRequestFilters, we keep the
    // FilterConfig around, and reuse it to lazy init the AllRequestFilters.
    filterConfig = config;
    for (AllRequestFilter f : filters) {
        initFilter(f);
    }
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    // Plugins that provide AllRequestFilters might get loaded later at
    // runtime, long after this init method had been called. To allow to
    // correctly init such plugins' AllRequestFilters, we keep the
    // FilterConfig around, and reuse it to lazy init the AllRequestFilters.
    filterConfig = config;
    for (AllRequestFilter f : filters) {
        initFilterIfNeeded(f);
    }
}
#end_block

#method_before
@Override
public void destroy() {
    for (AllRequestFilter f : filters) {
        f.destroy();
    }
}
#method_after
@Override
public synchronized void destroy() {
    Iterable<AllRequestFilter> filtersToDestroy = initializedFilters;
    initializedFilters = new DynamicSet<>();
    for (AllRequestFilter filter : filtersToDestroy) {
        filter.destroy();
    }
}
#end_block

#method_before
private void addFilter(final AllRequestFilter filter) {
    filters.add(filter);
}
#method_after
private ReloadableRegistrationHandle<AllRequestFilter> addFilter(final AllRequestFilter filter) {
    Key<AllRequestFilter> key = Key.get(AllRequestFilter.class);
    return filters.add(key, Providers.of(filter));
}
#end_block

#method_before
private GitilesView.Builder parseNoCommand(HttpServletRequest req, String repoName) {
    if (req.getAttribute(ATTRIBUTE_REPOSITORY) == null) {
        return GitilesView.hostIndex().setRepositoryName(repoName);
    }
    return GitilesView.repositoryIndex().setRepositoryName(repoName);
}
#method_after
private GitilesView.Builder parseNoCommand(HttpServletRequest req, String repoName) {
    if (req.getAttribute(ATTRIBUTE_REPOSITORY) == null) {
        return GitilesView.hostIndex().setRepositoryPrefix(repoName);
    }
    return GitilesView.repositoryIndex().setRepositoryName(repoName);
}
#end_block

#method_before
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(accessFactory, resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    ServletBinder root = serveRegex(ROOT_REGEX).through(viewFilter);
    if (gitwebRedirect != null) {
        root.through(gitwebRedirect);
    }
    root.through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#method_after
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    ServletBinder root = serveRegex(ROOT_REGEX).through(viewFilter);
    if (gitwebRedirect != null) {
        root.through(gitwebRedirect);
    }
    root.through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#end_block

#method_before
public Builder copyFrom(GitilesView other) {
    if (type == Type.DOC && other.type == Type.ROOTED_DOC) {
        type = Type.ROOTED_DOC;
    }
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
        case DOC:
        case ROOTED_DOC:
        case ARCHIVE:
        case BLAME:
        case SHOW:
            path = other.path;
        // Fallthrough.
        case REVISION:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (other.type == type) {
        // Only copy params for matching type.
        params.putAll(other.params);
        if (type == Type.ARCHIVE) {
            extension = other.extension;
        }
    }
    return this;
}
#method_after
public Builder copyFrom(GitilesView other) {
    if (type == Type.DOC && other.type == Type.ROOTED_DOC) {
        type = Type.ROOTED_DOC;
    }
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case HOST_INDEX:
            repositoryPrefix = other.repositoryPrefix;
            break;
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
        case DOC:
        case ROOTED_DOC:
        case ARCHIVE:
        case BLAME:
        case SHOW:
            path = other.path;
        // Fallthrough.
        case REVISION:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (other.type == type) {
        // Only copy params for matching type.
        params.putAll(other.params);
        if (type == Type.ARCHIVE) {
            extension = other.extension;
        }
    }
    return this;
}
#end_block

#method_before
public Builder setRepositoryName(String repositoryName) {
    this.repositoryName = checkNotNull(repositoryName);
    return this;
}
#method_after
public Builder setRepositoryName(String repositoryName) {
    switch(type) {
        case HOST_INDEX:
            throw new IllegalStateException(String.format("cannot set repository name on %s view", type));
        default:
            this.repositoryName = checkNotNull(repositoryName);
            return this;
    }
}
#end_block

#method_before
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
        case SHOW:
        case DOC:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
        case BLAME:
            checkBlame();
            break;
        case ROOTED_DOC:
            checkRootedDoc();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#method_after
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
        case SHOW:
        case DOC:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
        case BLAME:
            checkBlame();
            break;
        case ROOTED_DOC:
            checkRootedDoc();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryPrefix, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#end_block

#method_before
@Override
public String toString() {
    ToStringHelper b = toStringHelper(type.toString()).omitNullValues().add("host", hostName).add("servlet", servletPath).add("repo", repositoryName).add("rev", revision).add("old", oldRevision).add("path", path).add("extension", extension);
    if (!params.isEmpty()) {
        b.add("params", params);
    }
    b.add("anchor", anchor);
    return b.toString();
}
#method_after
@Override
public String toString() {
    ToStringHelper b = toStringHelper(type.toString()).omitNullValues().add("host", hostName).add("servlet", servletPath).add("prefix", repositoryPrefix).add("repo", repositoryName).add("rev", revision).add("old", oldRevision).add("path", path).add("extension", extension);
    if (!params.isEmpty()) {
        b.add("params", params);
    }
    b.add("anchor", anchor);
    return b.toString();
}
#end_block

#method_before
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            url.append(firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case SHOW:
            url.append(repositoryName).append("/+show/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        case BLAME:
            url.append(repositoryName).append("/+blame/").append(revision.getName()).append('/').append(path);
            break;
        case DOC:
            url.append(repositoryName);
            if (path != null && path.endsWith(".md")) {
                url.append("/+/");
            } else {
                url.append("/+doc/");
            }
            url.append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            break;
        case ROOTED_DOC:
            if (path != null) {
                url.append(path);
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url;
}
#method_after
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            if (repositoryPrefix != null) {
                url.append(repositoryPrefix).append('/');
            }
            params = LinkedListMultimap.create();
            if (repositoryPrefix == null && !this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            url.append(firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case SHOW:
            url.append(repositoryName).append("/+show/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        case BLAME:
            url.append(repositoryName).append("/+blame/").append(revision.getName()).append('/').append(path);
            break;
        case DOC:
            url.append(repositoryName);
            if (path != null && path.endsWith(".md")) {
                url.append("/+/");
            } else {
                url.append("/+doc/");
            }
            url.append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            break;
        case ROOTED_DOC:
            if (path != null) {
                url.append(path);
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url;
}
#end_block

#method_before
public List<Map<String, String>> getBreadcrumbs(List<Boolean> hasSingleTree) {
    checkArgument(!NON_HTML_TYPES.contains(type), "breadcrumbs for %s view not supported", type);
    checkArgument(type != Type.REFS || Strings.isNullOrEmpty(path), "breadcrumbs for REFS view with path not supported");
    checkArgument(hasSingleTree == null || type == Type.PATH, "hasSingleTree must be null for %s view", type);
    String path = this.path;
    ImmutableList.Builder<Map<String, String>> breadcrumbs = ImmutableList.builder();
    breadcrumbs.add(breadcrumb(hostName, hostIndex().copyFrom(this)));
    if (repositoryName != null) {
        List<String> parts = Splitter.on('/').splitToList(repositoryName);
        for (int i = 0; i < parts.size(); i++) {
            String s = Joiner.on('/').join(parts.subList(0, i + 1));
            breadcrumbs.add(breadcrumb(parts.get(i), repositoryIndex().copyFrom(this).setRepositoryName(s)));
        }
    }
    if (type == Type.DIFF) {
        // TODO(dborowitz): Tweak the breadcrumbs template to allow us to render
        // separate links in "old..new".
        breadcrumbs.add(breadcrumb(getRevisionRange(), diff().copyFrom(this).setPathPart("")));
    } else if (type == Type.LOG) {
        if (revision != Revision.NULL) {
            // a breadcrumb) to allow switching between /+log/ and /+/.
            if (oldRevision == Revision.NULL) {
                breadcrumbs.add(breadcrumb(revision.getName(), log().copyFrom(this).setPathPart(null)));
            } else {
                breadcrumbs.add(breadcrumb(getRevisionRange(), log().copyFrom(this).setPathPart(null)));
            }
        } else {
            breadcrumbs.add(breadcrumb(Constants.HEAD, log().copyFrom(this)));
        }
        path = Strings.emptyToNull(path);
    } else if (revision != Revision.NULL) {
        breadcrumbs.add(breadcrumb(revision.getName(), revision().copyFrom(this)));
    }
    if (path != null) {
        if (type != Type.LOG && type != Type.REFS) {
            // The "." breadcrumb would be no different for LOG or REFS.
            breadcrumbs.add(breadcrumb(".", copyWithPath(false).setPathPart("")));
        }
        StringBuilder cur = new StringBuilder();
        List<String> parts = PathUtil.SPLITTER.omitEmptyStrings().splitToList(path);
        checkArgument(hasSingleTree == null || (parts.isEmpty() && hasSingleTree.isEmpty()) || hasSingleTree.size() == parts.size() - 1, "hasSingleTree has wrong number of entries");
        for (int i = 0; i < parts.size(); i++) {
            String part = parts.get(i);
            cur.append(part).append('/');
            String curPath = cur.toString();
            boolean isLeaf = i == parts.size() - 1;
            Builder builder = copyWithPath(isLeaf).setPathPart(curPath);
            if (hasSingleTree != null && i < parts.size() - 1 && hasSingleTree.get(i)) {
                builder.replaceParam(PathServlet.AUTODIVE_PARAM, PathServlet.NO_AUTODIVE_VALUE);
            }
            breadcrumbs.add(breadcrumb(part, builder));
        }
    }
    return breadcrumbs.build();
}
#method_after
public List<Map<String, String>> getBreadcrumbs(List<Boolean> hasSingleTree) {
    checkArgument(!NON_HTML_TYPES.contains(type), "breadcrumbs for %s view not supported", type);
    checkArgument(type != Type.REFS || Strings.isNullOrEmpty(path), "breadcrumbs for REFS view with path not supported");
    checkArgument(hasSingleTree == null || type == Type.PATH, "hasSingleTree must be null for %s view", type);
    String path = this.path;
    ImmutableList.Builder<Map<String, String>> breadcrumbs = ImmutableList.builder();
    breadcrumbs.add(breadcrumb(hostName, hostIndex().copyFrom(this).setRepositoryPrefix(null)));
    if (repositoryPrefix != null) {
        breadcrumbs.addAll(hostIndexBreadcrumbs(repositoryPrefix));
    } else if (repositoryName != null) {
        breadcrumbs.addAll(hostIndexBreadcrumbs(repositoryName));
    }
    if (type == Type.DIFF) {
        // TODO(dborowitz): Tweak the breadcrumbs template to allow us to render
        // separate links in "old..new".
        breadcrumbs.add(breadcrumb(getRevisionRange(), diff().copyFrom(this).setPathPart("")));
    } else if (type == Type.LOG) {
        if (revision != Revision.NULL) {
            // a breadcrumb) to allow switching between /+log/ and /+/.
            if (oldRevision == Revision.NULL) {
                breadcrumbs.add(breadcrumb(revision.getName(), log().copyFrom(this).setPathPart(null)));
            } else {
                breadcrumbs.add(breadcrumb(getRevisionRange(), log().copyFrom(this).setPathPart(null)));
            }
        } else {
            breadcrumbs.add(breadcrumb(Constants.HEAD, log().copyFrom(this)));
        }
        path = Strings.emptyToNull(path);
    } else if (revision != Revision.NULL) {
        breadcrumbs.add(breadcrumb(revision.getName(), revision().copyFrom(this)));
    }
    if (path != null) {
        if (type != Type.LOG && type != Type.REFS) {
            // The "." breadcrumb would be no different for LOG or REFS.
            breadcrumbs.add(breadcrumb(".", copyWithPath(false).setPathPart("")));
        }
        StringBuilder cur = new StringBuilder();
        List<String> parts = PathUtil.SPLITTER.omitEmptyStrings().splitToList(path);
        checkArgument(hasSingleTree == null || (parts.isEmpty() && hasSingleTree.isEmpty()) || hasSingleTree.size() == parts.size() - 1, "hasSingleTree has wrong number of entries");
        for (int i = 0; i < parts.size(); i++) {
            String part = parts.get(i);
            cur.append(part).append('/');
            String curPath = cur.toString();
            boolean isLeaf = i == parts.size() - 1;
            Builder builder = copyWithPath(isLeaf).setPathPart(curPath);
            if (hasSingleTree != null && i < parts.size() - 1 && hasSingleTree.get(i)) {
                builder.replaceParam(PathServlet.AUTODIVE_PARAM, PathServlet.NO_AUTODIVE_VALUE);
            }
            breadcrumbs.add(breadcrumb(part, builder));
        }
    }
    return breadcrumbs.build();
}
#end_block

#method_before
private SoyMapData toSoyMapData(RepositoryDescription desc, String prefix, GitilesView view) {
    return new SoyMapData("name", desc.name.substring(prefix.length()), "description", Strings.nullToEmpty(desc.description), "url", GitilesView.repositoryIndex().copyFrom(view).setRepositoryName(desc.name).toUrl());
}
#method_after
private SoyMapData toSoyMapData(RepositoryDescription desc, @Nullable String prefix, GitilesView view) {
    return new SoyMapData("name", stripPrefix(prefix, desc.name), "description", Strings.nullToEmpty(desc.description), "url", GitilesView.repositoryIndex().copyFrom(view).setRepositoryName(desc.name).toUrl());
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, RepositoryDescription> descs = getDescriptions(req, res);
    if (descs == null) {
        return;
    }
    String prefix = Strings.nullToEmpty(getPrefix(req));
    GitilesView view = ViewFilter.getView(req);
    SoyListData repos = new SoyListData();
    for (RepositoryDescription desc : descs.values()) {
        repos.add(toSoyMapData(desc, prefix, view));
    }
    String hostName = urls.getHostName(req);
    List<Map<String, String>> breadcrumbs = null;
    if (!prefix.isEmpty()) {
        hostName = hostName + '/' + CharMatcher.is('/').trimFrom(prefix);
        breadcrumbs = view.getBreadcrumbs();
    }
    renderHtml(req, res, "gitiles.hostIndex", ImmutableMap.of("hostName", hostName, "breadcrumbs", SoyData.createFromExistingData(breadcrumbs), "baseUrl", urls.getBaseGitUrl(req), "prefix", prefix, "repositories", repos));
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    Map<String, RepositoryDescription> descs = list(req, res, prefix, parseShowBranch(req));
    if (descs == null) {
        return;
    }
    SoyListData repos = new SoyListData();
    for (RepositoryDescription desc : descs.values()) {
        repos.add(toSoyMapData(desc, prefix, view));
    }
    String hostName = urls.getHostName(req);
    List<Map<String, String>> breadcrumbs = null;
    if (prefix != null) {
        hostName = hostName + '/' + prefix;
        breadcrumbs = view.getBreadcrumbs();
    }
    renderHtml(req, res, "gitiles.hostIndex", ImmutableMap.of("hostName", hostName, "breadcrumbs", SoyData.createFromExistingData(breadcrumbs), "baseUrl", urls.getBaseGitUrl(req), "prefix", prefix != null ? prefix + '/' : "", "repositories", repos));
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Set<String> branches = parseShowBranch(req);
    int prefix = Strings.nullToEmpty(getPrefix(req)).length();
    Map<String, RepositoryDescription> descs = getDescriptions(req, res, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(repo.name.substring(prefix)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, RepositoryDescription> descs = getDescriptions(req, res);
    if (descs == null) {
        return;
    }
    int prefix = Strings.nullToEmpty(getPrefix(req)).length();
    if (prefix > 0) {
        Map<String, RepositoryDescription> r = new LinkedHashMap<>();
        for (Map.Entry<String, RepositoryDescription> e : descs.entrySet()) {
            r.put(e.getKey().substring(prefix), e.getValue());
        }
    }
    renderJson(req, res, descs, new TypeToken<Map<String, RepositoryDescription>>() {
    }.getType());
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Map<String, RepositoryDescription> descs = list(req, res, prefix, parseShowBranch(req));
    if (descs == null) {
        return;
    }
    if (prefix != null) {
        Map<String, RepositoryDescription> r = new LinkedHashMap<>();
        for (Map.Entry<String, RepositoryDescription> e : descs.entrySet()) {
            r.put(stripPrefix(prefix, e.getKey()), e.getValue());
        }
        descs = r;
    }
    renderJson(req, res, descs, new TypeToken<Map<String, RepositoryDescription>>() {
    }.getType());
}
#end_block

#method_before
@Override
public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) throws IOException {
    // TODO(sop) take advantage of prefix to narrow scan of repositories.
    prefix = Strings.emptyToNull(prefix);
    if (prefix != null && !prefix.endsWith("/")) {
        prefix += '/';
    }
    Map<String, RepositoryDescription> repos = Maps.newTreeMap(US_COLLATOR);
    for (Repository repo : scanRepositories(basePath, req)) {
        String name = getRepositoryName(repo);
        if (prefix == null || name.startsWith(prefix)) {
            repos.put(name, buildDescription(repo, branches));
        }
        repo.close();
    }
    return repos;
}
#method_after
@Override
public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) throws IOException {
    Map<String, RepositoryDescription> repos = Maps.newTreeMap(US_COLLATOR);
    for (Repository repo : scanRepositories(basePath, prefix, req)) {
        repos.put(getRepositoryName(repo), buildDescription(repo, branches));
        repo.close();
    }
    return repos;
}
#end_block

#method_before
private Collection<Repository> scanRepositories(final File basePath, final HttpServletRequest req) throws IOException {
    List<Repository> repos = Lists.newArrayList();
    Queue<File> todo = Queues.newArrayDeque();
    File[] baseFiles = basePath.listFiles();
    if (baseFiles == null) {
        throw new IOException("base path is not a directory: " + basePath.getPath());
    }
    Collections.addAll(todo, baseFiles);
    while (!todo.isEmpty()) {
        File file = todo.remove();
        try {
            repos.add(resolver.open(req, getRelativePath(file.getPath())));
        } catch (RepositoryNotFoundException e) {
            File[] children = file.listFiles();
            if (children != null) {
                Collections.addAll(todo, children);
            }
        } catch (ServiceNotEnabledException e) {
            throw new IOException(e);
        }
    }
    return repos;
}
#method_after
private Collection<Repository> scanRepositories(File basePath, String prefix, HttpServletRequest req) throws IOException {
    List<Repository> repos = Lists.newArrayList();
    Queue<File> todo = initScan(basePath, prefix);
    while (!todo.isEmpty()) {
        File file = todo.remove();
        try {
            repos.add(resolver.open(req, getRelativePath(file.getPath())));
        } catch (RepositoryNotFoundException e) {
            File[] children = file.listFiles();
            if (children != null) {
                Collections.addAll(todo, children);
            }
        } catch (ServiceNotEnabledException e) {
            throw new IOException(e);
        }
    }
    return repos;
}
#end_block

#method_before
@Override
public GitilesAccess forRequest(final HttpServletRequest req) {
    return new GitilesAccess() {

        @Override
        public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) {
            if (branches != null && !branches.isEmpty()) {
                throw new UnsupportedOperationException("branches set not yet supported");
            }
            RepositoryDescription desc = new RepositoryDescription();
            desc.name = repo.getDescription().getRepositoryName();
            desc.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + desc.name;
            return ImmutableMap.of(desc.name, desc);
        }

        @Override
        public Object getUserKey() {
            return "a user";
        }

        @Override
        public String getRepositoryName() {
            return repo.getDescription().getRepositoryName();
        }

        @Override
        public RepositoryDescription getRepositoryDescription() {
            RepositoryDescription d = new RepositoryDescription();
            d.name = getRepositoryName();
            d.description = "a test data set";
            d.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + d.name;
            return d;
        }

        @Override
        public Config getConfig() {
            return new Config();
        }
    };
}
#method_after
@Override
public GitilesAccess forRequest(final HttpServletRequest req) {
    return new GitilesAccess() {

        @Override
        public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) {
            String name = repo.getDescription().getRepositoryName();
            if (prefix != null) {
                String pattern = CharMatcher.is('/').trimFrom(prefix) + '/';
                if (!name.startsWith(pattern)) {
                    return Collections.emptyMap();
                }
            }
            if (branches != null && !branches.isEmpty()) {
                throw new UnsupportedOperationException("branches set not yet supported");
            }
            RepositoryDescription desc = new RepositoryDescription();
            desc.name = name;
            desc.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + desc.name;
            return ImmutableMap.of(desc.name, desc);
        }

        @Override
        public Object getUserKey() {
            return "a user";
        }

        @Override
        public String getRepositoryName() {
            return repo.getDescription().getRepositoryName();
        }

        @Override
        public RepositoryDescription getRepositoryDescription() {
            RepositoryDescription d = new RepositoryDescription();
            d.name = getRepositoryName();
            d.description = "a test data set";
            d.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + d.name;
            return d;
        }

        @Override
        public Config getConfig() {
            return new Config();
        }
    };
}
#end_block

#method_before
public static Term idTerm(Change.Id id) {
    return intTerm(ID_FIELD, id.get());
}
#method_after
public static Term idTerm(Schema<ChangeData> schema, ChangeData cd) {
    return intTerm(idField(schema).getName(), cd.getId().get());
}
#end_block

#method_before
private SearcherFactory newSearcherFactory() {
    if (useDocValuesForSorting) {
        return new SearcherFactory();
    }
    final Map<String, UninvertingReader.Type> mapping = ImmutableMap.of(ChangeField.LEGACY_ID2.getName(), UninvertingReader.Type.INTEGER, ChangeField.UPDATED.getName(), UninvertingReader.Type.LONG);
    return new SearcherFactory() {

        @Override
        public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {
            checkState(reader instanceof DirectoryReader, "expected DirectoryReader, found %s", reader.getClass().getName());
            return new IndexSearcher(UninvertingReader.wrap((DirectoryReader) reader, mapping));
        }
    };
}
#method_after
private SearcherFactory newSearcherFactory() {
    if (useDocValuesForSorting) {
        return new SearcherFactory();
    }
    @SuppressWarnings("deprecation")
    final Map<String, UninvertingReader.Type> mapping = ImmutableMap.of(ChangeField.LEGACY_ID.getName(), UninvertingReader.Type.INTEGER, ChangeField.UPDATED.getName(), UninvertingReader.Type.LONG);
    return new SearcherFactory() {

        @Override
        public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {
            checkState(reader instanceof DirectoryReader, "expected DirectoryReader, found %s", reader.getClass().getName());
            return new IndexSearcher(UninvertingReader.wrap((DirectoryReader) reader, mapping));
        }
    };
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(schema, cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void delete(Change.Id id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void delete(Change.Id id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(schema, id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Sort getSort() {
    if (useDocValuesForSorting) {
        return new Sort(new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(ID_SORT_FIELD, SortField.Type.LONG, true));
    } else {
        return new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.LONG, true), new SortField(ChangeField.LEGACY_ID2.getName(), SortField.Type.INT, true));
    }
}
#method_after
@SuppressWarnings("deprecation")
private Sort getSort() {
    if (useDocValuesForSorting) {
        return new Sort(new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(idSortField, SortField.Type.LONG, true));
    } else {
        return new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.LONG, true), new SortField(ChangeField.LEGACY_ID.getName(), SortField.Type.INT, true));
    }
}
#end_block

#method_before
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (useDocValuesForSorting) {
        if (values.getField() == ChangeField.LEGACY_ID2) {
            int v = (Integer) getOnlyElement(values.getValues());
            doc.add(new NumericDocValuesField(ID_SORT_FIELD, v));
        } else if (values.getField() == ChangeField.UPDATED) {
            long t = ((Timestamp) getOnlyElement(values.getValues())).getTime();
            doc.add(new NumericDocValuesField(UPDATED_SORT_FIELD, t));
        }
    }
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw FieldType.badFieldType(type);
    }
}
#method_after
@SuppressWarnings("deprecation")
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (useDocValuesForSorting) {
        FieldDef<ChangeData, ?> f = values.getField();
        if (f == ChangeField.LEGACY_ID || f == ChangeField.LEGACY_ID2) {
            int v = (Integer) getOnlyElement(values.getValues());
            doc.add(new NumericDocValuesField(sortFieldName(f), v));
        } else if (f == ChangeField.UPDATED) {
            long t = ((Timestamp) getOnlyElement(values.getValues())).getTime();
            doc.add(new NumericDocValuesField(UPDATED_SORT_FIELD, t));
        }
    }
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw FieldType.badFieldType(type);
    }
}
#end_block

#method_before
public void merge(ReviewDb db, ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    this.db = db;
    logDebug("Beginning merge of {}", changes);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Checking permissions");
            checkPermissions(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, ChangeSet changes, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    this.db = db;
    logDebug("Beginning merge of {}", changes);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg, ObjectId mergeResultRev) throws OrmException, IOException {
    logDebug("Setting change {} merged", c.getId());
    ChangeUpdate update = null;
    final PatchSetApproval submitter;
    PatchSet merged;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id mergedId = commit.change().currentPatchSetId();
        merged = db.patchSets().get(mergedId);
        c = setMergedPatchSet(c.getId(), mergedId);
        submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // did this in the past.
        if (msg != null) {
            cmUtil.addChangeMessage(db, update, msg);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    final Change change = c;
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                sendMergedEmail(change, submitter);
                return null;
            }
        }).call();
    } catch (Exception e) {
        logError("internal server error", e);
    }
    indexer.index(db, c);
    if (submitter != null && mergeResultRev != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg, ObjectId mergeResultRev) throws OrmException, IOException {
    logDebug("Setting change {} merged", c.getId());
    ChangeUpdate update = null;
    final PatchSetApproval submitter;
    PatchSet merged;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id mergedId = commit.change().currentPatchSetId();
        merged = db.patchSets().get(mergedId);
        c = setMergedPatchSet(c.getId(), mergedId);
        submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // did this in the past.
        if (msg != null) {
            cmUtil.addChangeMessage(db, update, msg);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, c);
    try {
        mergedSenderFactory.create(c.getId(), submitter != null ? submitter.getAccountId() : null).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + c.getId(), e);
    }
    if (submitter != null && mergeResultRev != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball i parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball if parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    ui.message("Listing all changes ...");
    SetMultimap<Project.NameKey, Change.Id> openByProject = getOpenChangesByProject(db);
    ui.message("done");
    ui.message("Setting all submitted changes back to new ...");
    int i = 0;
    for (Map.Entry<Project.NameKey, Collection<Change.Id>> e : openByProject.asMap().entrySet()) {
        updateOpenChanges(db, (Set<Change.Id>) e.getValue());
        if (++i % 100 == 0) {
            ui.message("  done " + i + " projects ...");
        }
    }
    ui.message("done");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    String cmd = "UPDATE changes SET status = 'n' WHERE status = 's';";
    ui.message("Running " + cmd);
    try (StatementExecutor e = newExecutor(db)) {
        e.execute(cmd);
    }
    ui.message("done");
}
#end_block

#method_before
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    List<RevCommit> log = getRemoteLog();
    RevCommit tip = log.get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    List<RevCommit> log = getRemoteLog();
    RevCommit tip = log.get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), tip.getCommitterIdent());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#end_block

#method_before
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    // Change 2 stays untouched.
    approve(change2.getChangeId());
    // Change 3 is a fast-forward, no need to merge.
    submit(change3.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), tip.getCommitterIdent());
    // We need to merge change 4.
    submit(change4.getChangeId());
    tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), tip.getCommitterIdent());
    assertNew(change2.getChangeId());
}
#end_block

#method_before
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        submitWithConflict(change1b.getChangeId());
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    }
}
#method_after
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        submitWithConflict(change1b.getChangeId());
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#end_block

#method_before
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, "test-topic", admin);
    change2.assertChange(Change.Status.MERGED, "test-topic", admin);
    change3.assertChange(Change.Status.MERGED, "test-topic", admin);
    assertSubmitter(change1);
    assertSubmitter(change2);
    assertSubmitter(change3);
}
#method_after
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, "test-topic", admin);
    change2.assertChange(Change.Status.MERGED, "test-topic", admin);
    change3.assertChange(Change.Status.MERGED, "test-topic", admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
}
#end_block

#method_before
protected void assertNew(String changeId) throws Exception {
    ChangeInfo c = get(changeId);
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
}
#method_after
protected void assertNew(String changeId) throws Exception {
    assertThat(get(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    ChangeSet submittedChanges = ChangeSet.create(submit(rsrc, caller, false));
    try {
        mergeOpFactory.create(submittedChanges, caller).merge(true);
        change = dbProvider.get().changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> changes;
    if (submitWholeTopic && !Strings.isNullOrEmpty(change.getTopic())) {
        changes = new ArrayList<>();
        for (ChangeData cd : getChangesByTopic(change.getTopic())) {
            changes.add(cd.change());
        }
    } else {
        changes = Arrays.asList(change);
    }
    ChangeSet submittedChanges = ChangeSet.create(changes);
    try {
        mergeOpProvider.get().merge(submittedChanges, caller, true);
        change = dbProvider.get().changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private void checkPermissions(ChangeSet cs) throws ResourceConflictException, OrmException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        if (cd.change().getStatus() != Change.Status.NEW && cd.change().getStatus() != Change.Status.SUBMITTED) {
            throw new OrmException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus());
        } else {
            checkSubmitRule(cd);
        }
    }
}
#method_after
private void checkPermissions(ChangeSet cs) throws ResourceConflictException, OrmException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        if (cd.change().getStatus() != Change.Status.NEW && cd.change().getStatus() != Change.Status.SUBMITTED) {
            throw new OrmException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus());
        } else {
            records.put(cd.change().getId(), checkSubmitRule(cd));
        }
    }
}
#end_block

#method_before
public void merge(boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Submitting all calculated changes while " + "enforcing submit rules");
            submitAllChanges(cs, false);
            logDebug("Checking permissions");
            checkPermissions(cs);
        } else {
            logDebug("Submitting all calculated changes ignoring submit rules");
            submitAllChanges(cs, true);
        }
        try {
            integrateIntoHistory(cs);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge(ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Checking permissions");
            checkPermissions(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", changes);
    Map<Branch.NameKey, ListMultimap<SubmitType, Change>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                List<ChangeData> cds = new ArrayList<>();
                for (Change.Id id : cs.changesByBranch().get(branch)) {
                    cds.add(changeDataFactory.create(db, id));
                }
                ListMultimap<SubmitType, Change> submitting = validateChangeList(cds);
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch));
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    if (submitType != SubmitType.CHERRY_PICK) {
                        // For cherry picking we have relaxed atomic guarantees
                        // as traditionally Gerrit kept going cherry picking if one
                        // failed. We want to keep it for now.
                        updateChangeStatus(submitting.get(submitType), branch, true);
                    }
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false);
                    updateSubscriptions(branch, submitting.get(submitType), getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, ListMultimap<SubmitType, ChangeData>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                List<ChangeData> cds = new ArrayList<>();
                for (Change.Id id : cs.changesByBranch().get(branch)) {
                    cds.add(changeDataFactory.create(db, id));
                }
                ListMultimap<SubmitType, ChangeData> submitting = validateChangeList(cds);
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch), caller);
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    updateChangeStatus(submitting.get(submitType), branch, true, caller);
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false, caller);
                    updateSubmoduleSubscriptions(subOp, branch, getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(subOp, cs.branches());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#end_block

#method_before
private MergeTip preMerge(SubmitStrategy strategy, List<Change> submitted, CodeReviewCommit branchTip) throws MergeException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (Change c : submitted) {
        CodeReviewCommit commit = commits.get(c.getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", c.getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#method_after
private MergeTip preMerge(SubmitStrategy strategy, List<ChangeData> submitted, CodeReviewCommit branchTip) throws MergeException, OrmException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (ChangeData cd : submitted) {
        CodeReviewCommit commit = commits.get(cd.change().getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", cd.change().getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#end_block

#method_before
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#method_after
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, IdentifiedUser caller) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, caller);
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(List<ChangeData> submitted) throws MergeException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.SUBMITTED && chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new or submitted: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            toUpdate.add(chg);
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            toUpdate.add(chg);
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            toUpdate.add(chg);
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, chg);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, ChangeData> validateChangeList(List<ChangeData> submitted) throws MergeException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, ChangeData> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.SUBMITTED && chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new or submitted: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, cd);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(List<Change> submitted, Branch.NameKey destBranch, boolean dryRun) throws NoSuchChangeException, MergeException, ResourceConflictException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (Change c : submitted) {
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new MergeException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(List<ChangeData> submitted, Branch.NameKey destBranch, boolean dryRun, IdentifiedUser caller) throws NoSuchChangeException, MergeException, ResourceConflictException, OrmException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (ChangeData cd : submitted) {
        Change c = cd.change();
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        if (!dryRun) {
            try {
                setApproval(cd, caller);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new MergeException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    });
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try (ReviewDb reviewDb = schemaFactory.open()) {
                patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    });
}
#end_block

#method_before
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : queryProvider.get().byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#method_after
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#end_block

#method_before
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
}
#method_after
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithContentMerge_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    submitWithConflict(change2.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId());
    assertSubmitter(change2.getChangeId(), 1);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithContentMerge_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    submitWithConflict(change2.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId());
    assertNoSubmitter(change2.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitOutOfOrder_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    createChange("Change 2", "b.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content");
    submitWithConflict(change3.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId());
    assertSubmitter(change3.getChangeId(), 1);
}
#method_after
@Test
public void submitOutOfOrder_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    createChange("Change 2", "b.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content");
    submitWithConflict(change3.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId());
    assertNoSubmitter(change3.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitDependentConflictingChangesOutOfOrder() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b1");
    PushOneCommit.Result change3 = createChange("Change 3", "b", "b2");
    assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit());
    // Submit fails; change3 contains the delta "b1" -> "b2", which cannot be
    // applied against tip.
    submitWithConflict(change3.getChangeId());
    ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info3.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict");
    // Tip has not changed.
    List<RevCommit> log = getRemoteLog();
    assertThat(log.get(0)).isEqualTo(initialHead.getId());
}
#method_after
@Test
public void submitDependentConflictingChangesOutOfOrder() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b1");
    PushOneCommit.Result change3 = createChange("Change 3", "b", "b2");
    assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit());
    // Submit fails; change3 contains the delta "b1" -> "b2", which cannot be
    // applied against tip.
    submitWithConflict(change3.getChangeId());
    ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info3.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict");
    // Tip has not changed.
    List<RevCommit> log = getRemoteLog();
    assertThat(log.get(0)).isEqualTo(initialHead.getId());
    assertNoSubmitter(change3.getChangeId(), 1);
}
#end_block

#method_before
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    String endPoint = "/changes/?S=" + start + "&n=" + limit + "&q=project:" + projectName + "&O=" + Integer.toHexString(ListChangesOption.toBits(EnumSet.of(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS)));
    List<ChangeInfo> result;
    try (RestResponse r = checkedGet(endPoint)) {
        result = newGson().fromJson(r.getReader(), new TypeToken<List<ChangeInfo>>() {
        }.getType());
    }
    for (ChangeInfo c : result) {
        for (Map.Entry<String, RevisionInfo> e : c.revisions.entrySet()) {
            e.getValue().commit.commit = e.getKey();
        }
    }
    return result;
}
#method_after
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    String endPoint = "/changes/?S=" + start + ((limit > 0) ? "&n=" + limit : "") + "&q=project:" + projectName + "&O=" + Integer.toHexString(ListChangesOption.toBits(EnumSet.of(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS)));
    List<ChangeInfo> result;
    try (RestResponse r = checkedGet(endPoint)) {
        result = newGson().fromJson(r.getReader(), new TypeToken<List<ChangeInfo>>() {
        }.getType());
    }
    for (ChangeInfo c : result) {
        for (Map.Entry<String, RevisionInfo> e : c.revisions.entrySet()) {
            e.getValue().commit.commit = e.getKey();
        }
    }
    return result;
}
#end_block

#method_before
void replay() throws IOException, OrmException, NoSuchAccountException, NoSuchChangeException, RestApiException, ValidationException {
    int start = 0, count = 1;
    final int limit = 500;
    boolean moreChanges;
    do {
        moreChanges = false;
        List<ChangeInfo> changes = api.queryChanges(srcProject.get(), start, limit);
        pm.beginTask(String.format("Replay Changes (%d)", count), changes.size());
        RevWalk rw = new RevWalk(repo);
        try {
            for (ChangeInfo c : changes) {
                try {
                    replayChange(rw, c);
                } catch (Exception e) {
                    log.error(String.format("Failed to replay change %s.", Url.decode(c.id)), e);
                    throw e;
                }
                if (!moreChanges && Boolean.TRUE.equals(c._moreChanges)) {
                    moreChanges = true;
                    start += limit;
                    count++;
                }
                pm.update(1);
            }
        } finally {
            rw.close();
        }
        pm.endTask();
    } while (moreChanges);
}
#method_after
void replay() throws IOException, OrmException, NoSuchAccountException, NoSuchChangeException, RestApiException, ValidationException {
    int start = 0;
    int limit = GlobalCapability.DEFAULT_MAX_QUERY_LIMIT;
    pm.beginTask("Replay Changes", ProgressMonitor.UNKNOWN);
    for (; ; ) {
        List<ChangeInfo> changes = api.queryChanges(srcProject.get(), start, limit);
        if (changes.isEmpty()) {
            break;
        }
        start += changes.size();
        RevWalk rw = new RevWalk(repo);
        try {
            ChangeInfo last = null;
            for (ChangeInfo c : changes) {
                try {
                    replayChange(rw, c);
                } catch (Exception e) {
                    log.error(String.format("Failed to replay change %s.", Url.decode(c.id)), e);
                    throw e;
                }
                last = c;
                pm.update(1);
            }
            if (!Boolean.TRUE.equals(last._moreChanges)) {
                break;
            }
        } finally {
            rw.close();
        }
    }
    pm.endTask();
}
#end_block

#method_before
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    try {
        return gApi.changes().query("project:" + projectName).withStart(start).withLimit(limit).withOptions(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS).get();
    } catch (RestApiException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    try {
        QueryRequest query = gApi.changes().query("project:" + projectName);
        query.withStart(start).withOptions(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS);
        if (limit > 0) {
            query.withLimit(limit);
        }
        return query.get();
    } catch (RestApiException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Rule[] inlinePluginRules() {
    return new Rule[] { namedAnchor(), namedAnchor2() };
}
#method_after
@Override
public Rule[] inlinePluginRules() {
    return new Rule[] { namedAnchorHtmlStyle(), namedAnchorMarkdownExtensionStyle() };
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    if (info.status() != null && info.status().equals(Change.Status.ABANDONED)) {
        sb.openSpan().setStyleName(RelatedChanges.R.css().strikedSubject());
    } else {
        sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    }
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    if (info.status() == Change.Status.ABANDONED) {
        sb.openSpan().setStyleName(RelatedChanges.R.css().strikedSubject());
    } else {
        sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    }
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebInfo gw = Gerrit.info().gitweb();
    if (gw != null && (!info.hasChangeNumber() || !info.hasRevisionNumber())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    if (info.status() == "ABANDONED" || info.status() == "MERGED") {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
        GitwebInfo gw = Gerrit.info().gitweb();
        if (gw != null) {
            sb.setAttribute("title", gw.getLinkName());
        }
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebInfo gw = Gerrit.info().gitweb();
    if (gw != null && (!info.hasChangeNumber() || !info.hasRevisionNumber())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet.Id psId = change().currentPatchSetId();
    PatchSet ps = db.patchSets().get(psId);
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
static Predicate<ChangeData> create(Schema<ChangeData> schema, Collection<Account.Id> ids) throws QueryParseException {
    if (schema == null || schema.hasField(ChangeField.LEGACY_REVIEWED)) {
        throw new QueryParseException("Only is:reviewed is supported");
    }
    checkSchema(schema);
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : ids) {
        predicates.add(new IsReviewedPredicate(Integer.toString(id.get())));
    }
    return Predicate.or(predicates);
}
#method_after
@SuppressWarnings("deprecation")
static Predicate<ChangeData> create(Schema<ChangeData> schema, Collection<Account.Id> ids) throws QueryParseException {
    if (schema == null || schema.hasField(ChangeField.LEGACY_REVIEWED)) {
        throw new QueryParseException("Only is:reviewed is supported");
    }
    checkSchema(schema);
    List<Predicate<ChangeData>> predicates = new ArrayList<>(ids.size());
    for (Account.Id id : ids) {
        predicates.add(new IsReviewedPredicate(id));
    }
    return Predicate.or(predicates);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    Set<Account.Id> reviewedBy = cd.reviewedBy();
    return !reviewedBy.isEmpty() ? reviewedBy.contains(id) : id == null;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    Set<Account.Id> reviewedBy = cd.reviewedBy();
    return !reviewedBy.isEmpty() ? reviewedBy.contains(id) : id == NOT_REVIEWED;
}
#end_block

#method_before
protected void assertBadQuery(QueryRequest query) throws Exception {
    try {
        query.get();
        fail("expected BadRequestException for query: " + query);
    } catch (BadRequestException e) {
    // Expected.
    }
}
#method_after
protected void assertBadQuery(QueryRequest query) throws Exception {
    exception.expect(BadRequestException.class);
    query.get();
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("git-upload-archive").to(Commands.key(git, "upload-archive"));
    command(git, "upload-archive").to(UploadArchive.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("git-upload-archive").to(Commands.key(git, "upload-archive"));
    command(git, "upload-archive").to(UploadArchive.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be run on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, SetHeadCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (slaveMode) {
        command("git-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command("gerrit-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(git, "receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(gerrit, "test-submit").to(NotSupportedInSlaveModeFailureCommand.class);
    } else {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
protected void readArguments() throws IOException, Failure {
    final String arg_cmd = "argument ";
    List<String> args = Lists.newArrayList();
    // Read arguments in Pkt-Line format
    PacketLineIn packetIn = new PacketLineIn(in);
    for (; ; ) {
        String s = packetIn.readString();
        if (s == PacketLineIn.END)
            break;
        if (!s.startsWith(arg_cmd)) {
            throw new Failure(1, "fatal: 'argument' token or flush expected");
        }
        String[] parts = s.substring(arg_cmd.length()).split("=", 2);
        for (String p : parts) args.add(p);
    }
    try {
        // Parse them into the 'm_options' field
        CmdLineParser parser = new CmdLineParser(m_options);
        parser.parseArgument(args);
    } catch (CmdLineException e) {
        throw new Failure(2, "fatal: unable to parse arguments, " + e);
    }
}
#method_after
protected void readArguments() throws IOException, Failure {
    String argCmd = "argument ";
    List<String> args = Lists.newArrayList();
    // Read arguments in Pkt-Line format
    PacketLineIn packetIn = new PacketLineIn(in);
    for (; ; ) {
        String s = packetIn.readString();
        if (s == PacketLineIn.END) {
            break;
        }
        if (!s.startsWith(argCmd)) {
            throw new Failure(1, "fatal: 'argument' token or flush expected");
        }
        String[] parts = s.substring(argCmd.length()).split("=", 2);
        for (String p : parts) {
            args.add(p);
        }
    }
    try {
        // Parse them into the 'options' field
        CmdLineParser parser = new CmdLineParser(options);
        parser.parseArgument(args);
        if (options.path == null || Arrays.asList(".").equals(options.path)) {
            options.path = Collections.emptyList();
        }
    } catch (CmdLineException e) {
        throw new Failure(2, "fatal: unable to parse arguments, " + e);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    PacketLineOut packetOut = new PacketLineOut(out);
    packetOut.setFlushOnEnd(true);
    packetOut.writeString("ACK");
    packetOut.end();
    try {
        // Parse Git arguments
        readArguments();
        // Verify the user has permissions to read the specified reference
        if (!projectControl.allRefsAreVisible()) {
            throw new Failure(4, "fatal: upload-archive not permitted on this server");
        }
        // Find out the object to get from the specified reference and requested path
        ObjectId treeId = repo.resolve(m_options.treeIsh);
        if (treeId.equals(ObjectId.zeroId())) {
            throw new Failure(5, "fatal: reference not found");
        }
        // Build the archive
        final String format = m_options.format;
        final boolean wasFormatRegistered = registerArchiveFormat(format);
        try {
            // The archive is sent in DATA sideband channel
            SideBandOutputStream sidebandOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, SideBandOutputStream.MAX_BUF, out);
            new ArchiveCommand(repo).setFormat(format).setTree(treeId).setPaths((m_options.path == null ? Collections.emptyList() : m_options.path).toArray(new String[0])).setPrefix(m_options.prefix).setOutputStream(sidebandOut).call();
            sidebandOut.flush();
            sidebandOut.close();
        } catch (GitAPIException e) {
            throw new Failure(6, "fatal: git api exception, " + e);
        } finally {
            if (wasFormatRegistered)
                unregisterArchiveFormat(format);
        }
    } catch (Failure f) {
        // Report the error in ERROR sideband channel
        SideBandOutputStream sidebandError = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.MAX_BUF, out);
        sidebandError.write(f.getMessage().getBytes());
        sidebandError.flush();
        sidebandError.close();
        throw f;
    } finally {
        // In any case, cleanly close the packetOut channel
        packetOut.end();
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    PacketLineOut packetOut = new PacketLineOut(out);
    packetOut.setFlushOnEnd(true);
    packetOut.writeString("ACK");
    packetOut.end();
    try {
        // Parse Git arguments
        readArguments();
        ArchiveFormat f = allowedFormats.getExtensions().get("." + options.format);
        if (f == null) {
            throw new Failure(3, "fatal: upload-archive not permitted");
        }
        // Find out the object to get from the specified reference and paths
        ObjectId treeId = repo.resolve(options.treeIsh);
        if (treeId.equals(ObjectId.zeroId())) {
            throw new Failure(4, "fatal: reference not found");
        }
        // Verify the user has permissions to read the specified reference
        if (!projectControl.allRefsAreVisible() && !canRead(treeId)) {
            throw new Failure(5, "fatal: cannot perform upload-archive operation");
        }
        try {
            // The archive is sent in DATA sideband channel
            SideBandOutputStream sidebandOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, SideBandOutputStream.MAX_BUF, out);
            new ArchiveCommand(repo).setFormat(f.name()).setFormatOptions(getFormatOptions(f)).setTree(treeId).setPaths(options.path.toArray(new String[0])).setPrefix(options.prefix).setOutputStream(sidebandOut).call();
            sidebandOut.flush();
            sidebandOut.close();
        } catch (GitAPIException e) {
            throw new Failure(7, "fatal: git api exception, " + e);
        }
    } catch (Failure f) {
        // Report the error in ERROR sideband channel
        SideBandOutputStream sidebandError = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.MAX_BUF, out);
        sidebandError.write(f.getMessage().getBytes(UTF_8));
        sidebandError.flush();
        sidebandError.close();
        throw f;
    } finally {
        // In any case, cleanly close the packetOut channel
        packetOut.end();
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        ChangeApi.includedIn(changeId.get(), new AsyncCallback<IncludedInInfo>() {

            @Override
            public void onSuccess(IncludedInInfo r) {
                branches.setInnerSafeHtml(formatList(r.branches()));
                tags.setInnerSafeHtml(formatList(r.tags()));
                for (String t : r.systemTypes()) {
                    appendRow(t, r.system(t));
                }
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        ChangeApi.includedIn(changeId.get(), new AsyncCallback<IncludedInInfo>() {

            @Override
            public void onSuccess(IncludedInInfo r) {
                branches.setInnerSafeHtml(formatList(r.branches()));
                tags.setInnerSafeHtml(formatList(r.tags()));
                for (String n : r.externalNames()) {
                    JsArrayString external = r.external(n);
                    if (external.length() > 0) {
                        appendRow(n, external);
                    }
                }
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = db.get().patchSets().get(ctl.getChange().currentPatchSetId());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInDetail d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> systems = new HashMap<>();
        for (DynamicMap.Entry<com.google.gerrit.extensions.config.IncludedIn> i : includedIn) {
            systems.put(i.getExportName(), i.getProvider().get().getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, systems);
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = db.get().patchSets().get(ctl.getChange().currentPatchSetId());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInDetail d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> external = new HashMap<>();
        for (DynamicMap.Entry<ExternalIncludedIn> i : includedIn) {
            external.put(i.getExportName(), i.getProvider().get().getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external : null));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), IncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            attachComments(result);
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#method_after
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
private void postReview() {
    in.message(message.getText().trim());
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#method_after
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
            for (String k : result.keySet()) {
                JsArray<CommentInfo> allRevisions = result.get(k);
                JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
                for (int i = 0; i < allRevisions.length(); i++) {
                    CommentInfo c = allRevisions.get(i);
                    if (!c.has_patch_set() || c.patch_set() == id) {
                        thisRevision.push(c);
                    }
                }
                filtered.put(k, thisRevision);
            }
            // Only count comments for the current revision in the file table, but
            // include all comments in the history table below.
            r.add(filtered);
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    Iterable<ChangeData> all = FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    });
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    Set<Change.Id> reviewed = Sets.newHashSet();
    if (has(REVIEWED)) {
        reviewed = loadReviewed(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes(), reviewed);
        if (r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    Iterable<ChangeData> all = FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    });
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION) || has(MESSAGES)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    Set<Change.Id> reviewed = Sets.newHashSet();
    if (has(REVIEWED)) {
        reviewed = loadReviewed(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes(), reviewed);
        if (r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    PatchSet ps = cd.currentPatchSet();
    if (ps == null) {
        return ImmutableList.of();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setPatchSet(ps).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    atrScope.disableDb();
    assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).get()).hasSize(2);
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    // Identified user may async get stars from DB.
    setApiUserAnonymous();
    atrScope.disableDb();
    assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).get()).hasSize(2);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> query(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try {
        Repository git = args.repoManager.openRepository(allUsers);
        try {
            VersionedAccountQueries q = VersionedAccountQueries.forUser(self());
            q.load(git);
            String query = q.getQueryList().getQuery(name);
            if (query != null) {
                return parse(query);
            }
        } finally {
            git.close();
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named query (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    } catch (ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    }
    throw new QueryParseException("Unknown named query: " + name);
}
#method_after
@Operator
public Predicate<ChangeData> query(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountQueries q = VersionedAccountQueries.forUser(self());
        q.load(git);
        String query = q.getQueryList().getQuery(name);
        if (query != null) {
            return parse(query);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named query (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    }
    throw new QueryParseException("Unknown named query: " + name);
}
#end_block

#method_before
@Test
public void testParseSimple() {
    try {
        QueryList ql = QueryList.parse(F_SIMPLE, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseSimple() throws Exception {
    QueryList ql = QueryList.parse(F_SIMPLE, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseWHeader() {
    try {
        QueryList ql = QueryList.parse(HEADER + F_SIMPLE, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseWHeader() throws Exception {
    QueryList ql = QueryList.parse(HEADER + F_SIMPLE, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseWComments() {
    try {
        QueryList ql = QueryList.parse(C1 + F_SIMPLE + C2, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseWComments() throws Exception {
    QueryList ql = QueryList.parse(C1 + F_SIMPLE + C2, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseFooComment() {
    try {
        QueryList ql = QueryList.parse("#" + L_FOO + L_BAR, null);
        assertTrue(null == ql.getQuery(N_FOO));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseFooComment() throws Exception {
    QueryList ql = QueryList.parse("#" + L_FOO + L_BAR, null);
    assertThat(ql.getQuery(N_FOO)).isNull();
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParsePaddedFronts() {
    try {
        QueryList ql = QueryList.parse(F_PAD_F, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParsePaddedFronts() throws Exception {
    QueryList ql = QueryList.parse(F_PAD_F, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParsePaddedEnds() {
    try {
        QueryList ql = QueryList.parse(F_PAD_E, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParsePaddedEnds() throws Exception {
    QueryList ql = QueryList.parse(F_PAD_E, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseComplex() {
    try {
        QueryList ql = QueryList.parse(L_COMPLEX, null);
        assertTrue(Q_COMPLEX.equals(ql.getQuery(N_FOO)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseComplex() throws Exception {
    QueryList ql = QueryList.parse(L_COMPLEX, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_COMPLEX);
}
#end_block

#method_before
@Test
public void testParseBad() {
    try {
        QueryList ql = QueryList.parse(L_BAD, null);
        assertTrue(false);
    } catch (Exception e) {
        assertTrue(true);
    }
}
#method_after
@Test(expected = IOException.class)
public void testParseBad() throws Exception {
    ValidationError.Sink sink = createNiceMock(ValidationError.Sink.class);
    replay(sink);
    QueryList.parse(L_BAD, sink);
}
#end_block

#method_before
@Test
public void testAsText() {
    String text = HEADER + "#\n" + F_PROPER;
    try {
        QueryList ql = QueryList.parse(F_SIMPLE, null);
        String asText = ql.asText();
        assertTrue(text.equals(asText));
        ql = QueryList.parse(asText, null);
        asText = ql.asText();
        assertTrue(text.equals(asText));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testAsText() throws Exception {
    String expectedText = HEADER + "#\n" + F_PROPER;
    QueryList ql = QueryList.parse(F_SIMPLE, null);
    String asText = ql.asText();
    assertThat(asText).isEqualTo(expectedText);
    ql = QueryList.parse(asText, null);
    asText = ql.asText();
    assertThat(asText).isEqualTo(expectedText);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = getSitePath().resolve("logs").resolve("gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    setupInjectors();
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class))));
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    try {
                        Files.delete(runFile);
                    } catch (IOException err) {
                        log.warn("failed to delete " + runFile, err);
                    }
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                Files.write(runFile, (runId + "\n").getBytes(UTF_8));
                runFile.toFile().setReadable(true, false);
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = getSitePath().resolve("logs").resolve("gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    try {
                        Files.delete(runFile);
                    } catch (IOException err) {
                        log.warn("failed to delete " + runFile, err);
                    }
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                Files.write(runFile, (runId + "\n").getBytes(UTF_8));
                runFile.toFile().setReadable(true, false);
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
@VisibleForTesting
public void start() {
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class))));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AccountSshKey readSshKey(Account.Id id) throws IOException {
    String defaultPublicSshKeyFile = System.getProperty("user.home") + File.separator + ".ssh" + File.separator + "id_rsa.pub";
    if (!Files.exists(Paths.get(defaultPublicSshKeyFile))) {
        defaultPublicSshKeyFile = "";
    }
    String publicSshKeyFile = ui.readString(defaultPublicSshKeyFile, "public SSH key file");
    return !Strings.isNullOrEmpty(publicSshKeyFile) ? createSshKey(id, publicSshKeyFile) : null;
}
#method_after
private AccountSshKey readSshKey(Account.Id id) throws IOException {
    String defaultPublicSshKeyFile = "";
    Path defaultPublicSshKeyPath = Paths.get(System.getProperty("user.home"), ".ssh", "id_rsa.pub");
    if (Files.exists(defaultPublicSshKeyPath)) {
        defaultPublicSshKeyFile = defaultPublicSshKeyPath.toString();
    }
    String publicSshKeyFile = ui.readString(defaultPublicSshKeyFile, "public SSH key file");
    return !Strings.isNullOrEmpty(publicSshKeyFile) ? createSshKey(id, publicSshKeyFile) : null;
}
#end_block

#method_before
public final Runnable wrap(final Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (RuntimeException e) {
                    throw e;
                } catch (Exception e) {
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    } else {
        return new Runnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (RuntimeException e) {
                    throw e;
                } catch (Exception e) {
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
}
#method_after
public final <T> Callable<T> wrap(final Callable<T> callable) {
    final Callable<T> wrapped = wrapImpl(new Callable<T>() {

        @Override
        public T call() throws Exception {
            RequestCleanup cleanup = scope.scope(Key.get(RequestCleanup.class), new Provider<RequestCleanup>() {

                @Override
                public RequestCleanup get() {
                    return new RequestCleanup();
                }
            }).get();
            try {
                return callable.call();
            } finally {
                cleanup.run();
            }
        }
    });
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#end_block

#method_before
@Override
public Context get() {
    return getContext();
}
#method_after
@Override
public Context get() {
    return requireContext();
}
#end_block

#method_before
@Override
public SshSession get() {
    return getContext().getSession();
}
#method_after
@Override
public SshSession get() {
    return requireContext().getSession();
}
#end_block

#method_before
private static Term intTerm(String name, int value) {
    BytesRef bytes = new BytesRef(NumericUtils.BUF_SIZE_INT);
    BytesRefBuilder builder = new BytesRefBuilder();
    builder.append(bytes);
    NumericUtils.intToPrefixCodedBytes(value, 0, builder);
    return new Term(name, bytes);
}
#method_after
private static Term intTerm(String name, int value) {
    BytesRefBuilder builder = new BytesRefBuilder();
    NumericUtils.intToPrefixCodedBytes(value, 0, builder);
    return new Term(name, builder.get());
}
#end_block

#method_before
private void testGetGroup(String url, AccountGroup expectedGroup) throws IOException {
    RestResponse r = session.get(url);
    GroupInfo group = newGson().fromJson(r.getReader(), new TypeToken<GroupInfo>() {
    }.getType());
    assertGroupInfo(expectedGroup, group);
}
#method_after
private void testGetGroup(String url, AccountGroup expectedGroup) throws IOException {
    RestResponse r = session.get(url);
    GroupInfo group = newGson().fromJson(r.getReader(), GroupInfo.class);
    assertGroupInfo(expectedGroup, group);
}
#end_block

#method_before
@Test
public void messagesNotReturnedByDefault() throws GitAPIException, IOException {
    String changeId = createChange();
    postMessage(changeId, "Some nits need to be fixed.");
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChange(changeId);
    assertNull(c.messages);
}
#method_after
@Test
public void messagesNotReturnedByDefault() throws GitAPIException, IOException {
    String changeId = createChange();
    postMessage(changeId, "Some nits need to be fixed.");
    ChangeInfo c = getChange(changeId);
    assertNull(c.messages);
}
#end_block

#method_before
@Test
public void defaultMessage() throws GitAPIException, IOException {
    String changeId = createChange();
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(1, c.messages.size());
    assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message);
}
#method_after
@Test
public void defaultMessage() throws GitAPIException, IOException {
    String changeId = createChange();
    ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(1, c.messages.size());
    assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message);
}
#end_block

#method_before
@Test
public void messagesReturnedInChronologicalOrder() throws GitAPIException, IOException {
    String changeId = createChange();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(3, c.messages.size());
    Iterator<ChangeJson.ChangeMessageInfo> it = c.messages.iterator();
    assertEquals("Uploaded patch set 1.", it.next().message);
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#method_after
@Test
public void messagesReturnedInChronologicalOrder() throws GitAPIException, IOException {
    String changeId = createChange();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(3, c.messages.size());
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertEquals("Uploaded patch set 1.", it.next().message);
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#end_block

#method_before
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(change.getId());
}
#method_after
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(getChangeId());
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Change change = getChange();
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    NoteMap noteMap = null;
    Iterator<Note> notes = null;
    if (ref != null) {
        RevCommit commit = walk.parseCommit(ref.getObjectId());
        noteMap = NoteMap.read(walk.getObjectReader(), commit);
        notes = noteMap.iterator();
    } else {
        return null;
    }
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#method_after
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    if (ref == null) {
        return null;
    }
    RevCommit commit = walk.parseCommit(ref.getObjectId());
    NoteMap noteMap = NoteMap.read(walk.getObjectReader(), commit);
    for (Note note : noteMap) {
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    try {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        Set<Change.Id> reviewed = Sets.newHashSet();
        if (has(REVIEWED)) {
            reviewed = loadReviewed(Collections.singleton(cd));
        }
        ChangeInfo res = toChangeInfo(cd, reviewed, limitToPsId);
        accountLoader.fill();
        return res;
    } catch (OrmException | RuntimeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    try {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        Set<Change.Id> reviewed = Sets.newHashSet();
        if (has(REVIEWED)) {
            reviewed = loadReviewed(Collections.singleton(cd));
        }
        ChangeInfo res = toChangeInfo(cd, reviewed, limitToPsId);
        accountLoader.fill();
        return res;
    } catch (PatchListNotAvailableException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes, Set<Change.Id> reviewed) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, reviewed, Optional.<PatchSet.Id>absent());
            } catch (OrmException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes, Set<Change.Id> reviewed) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, reviewed, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, OrmException, IOException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws OrmException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    if (setCommit) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(c, in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            throw new OrmException(e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl, rebaseChange), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    if (setCommit) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl, rebaseChange), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws OrmException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    try {
        for (RevCommit parent : commit.getParents()) {
            rw.parseBody(parent);
            CommitInfo i = new CommitInfo();
            i.commit = parent.name();
            i.subject = parent.getShortMessage();
            if (addLinks) {
                FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
                i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
            }
            info.parents.add(i);
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
public Response<CommitInfo> apply(RevisionResource rsrc) throws OrmException, IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        Response<CommitInfo> r = Response.ok(json.toCommit(rsrc.getControl(), rw, commit, addLinks));
        if (rsrc.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#method_after
@Override
public Response<CommitInfo> apply(RevisionResource rsrc) throws IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        Response<CommitInfo> r = Response.ok(json.toCommit(rsrc.getControl(), rw, commit, addLinks));
        if (rsrc.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        if (draftsHandling == DraftHandling.PUBLISH_FOR_ALL_REVISIONS) {
            drafts = scanDraftCommentsChange(rsrc);
        } else {
            drafts = scanDraftComments(rsrc);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_FOR_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        if (draftsHandling == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(rsrc);
        } else {
            drafts = patchSetDrafts(rsrc);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line != null ? c.line : 0, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void addLabelDelta(String name, short value) {
    labelDelta.add(new LabelVote(name, value).format());
}
#method_after
private void addLabelDelta(String name, short value) {
    labelDelta.add(LabelVote.create(name, value).format());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (pending) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.addPushCount(1);
        e.addState(ref, state);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (pending) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount();
        e.addState(ref, state);
    }
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Override
public void run() {
    try {
        for (Project.NameKey nameKey : projectCache.all()) {
            replication.scheduleFullSync(nameKey, urlMatch, state);
        }
    } catch (Exception e) {
        wrappedLog.error("Cannot enumerate known projects", e, state);
    }
    state.allTaskScheduled();
}
#method_after
@Override
public void run() {
    try {
        for (Project.NameKey nameKey : projectCache.all()) {
            replication.scheduleFullSync(nameKey, urlMatch, state);
        }
    } catch (Exception e) {
        wrappedLog.error("Cannot enumerate known projects", e, state);
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean hasPushTask() {
    taskLock.lock();
    try {
        if (totalPushCount == 0) {
            return false;
        }
    } finally {
        taskLock.unlock();
    }
    return true;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushProcessing.onOneNodeReplicated(project, ref, uri, status);
    taskLock.lock();
    try {
        finishedPushCount++;
        if (!allScheduled) {
            return;
        }
        if (finishedPushCount < totalPushCount) {
            return;
        }
    } finally {
        taskLock.unlock();
    }
    pushProcessing.onAllNodesReplicated();
    if (type == ReplicationType.COMMAND) {
        allTaskFinished.countDown();
    }
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onOneNodeReplicated(project, ref, uri, status);
    countingLock.lock();
    try {
        finishedPushTasksCount++;
        if (!allScheduled) {
            return;
        }
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
public void waitForReplication() {
    taskLock.lock();
    try {
        if (finishedPushCount == totalPushCount) {
            return;
        }
    } finally {
        taskLock.unlock();
    }
    try {
        allTaskFinished.await();
    } catch (InterruptedException e) {
        log.error("It is interrupted while waiting replication to be completed");
        ;
    }
}
#method_after
public void waitForReplication() throws InterruptedException {
    allPushTasksFinished.await();
}
#end_block

#method_before
public void writeStdOut(final String message) {
    pushProcessing.writeStdOut(message);
}
#method_after
public void writeStdOut(final String message) {
    pushResultProcessing.writeStdOut(message);
}
#end_block

#method_before
public void writeStdErr(final String message) {
    pushProcessing.writeStdErr(message);
}
#method_after
public void writeStdErr(final String message) {
    pushResultProcessing.writeStdErr(message);
}
#end_block

#method_before
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && queue.replicateAllOnPluginStart) {
        ReplicationState state = new ReplicationState(ReplicationType.START_UP);
        pushAllFuture.set(pushAll.create(null, state).schedule(30, TimeUnit.SECONDS));
    }
}
#method_after
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && queue.replicateAllOnPluginStart) {
        ReplicationState state = new ReplicationState(ReplicationType.STARTUP);
        pushAllFuture.set(pushAll.create(null, state).schedule(30, TimeUnit.SECONDS));
    }
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(this, ReplicationType.COMMAND);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.allTaskScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                log.warn("Thread is interrupted while waiting for PushAll operation to finish", e);
            } catch (ExecutionException e) {
                log.warn("An excetion is thrown in PushAll operation", e);
            }
        }
        if (state.hasPushTask()) {
            state.waitForReplication();
        } else {
            writeStdOutSync("All things is up-to-date, no need to replicate!");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(ReplicationType.COMMAND, this);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.markAllPushTasksScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                wrappedLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
public void writeStdOutSync(final String message) {
    synchronized (stdout) {
        stdout.println(message);
        stdout.flush();
    }
}
#method_after
public void writeStdOutSync(final String message) {
    if (wait) {
        synchronized (stdout) {
            stdout.println(message);
            stdout.flush();
        }
    }
}
#end_block

#method_before
public void writeStdErrSync(final String message) {
    synchronized (stderr) {
        stderr.println(message);
        stderr.flush();
    }
}
#method_after
public void writeStdErrSync(final String message) {
    if (wait) {
        synchronized (stderr) {
            stderr.println(message);
            stderr.flush();
        }
    }
}
#end_block

#method_before
static String replaceName(String in, String name) {
    String key = "${name}";
    int n = in.indexOf(key);
    if (0 <= n) {
        return in.substring(0, n) + name + in.substring(n + key.length());
    }
    return null;
}
#method_after
static String replaceName(String in, String name, boolean keyIsOptional) {
    String key = "${name}";
    int n = in.indexOf(key);
    if (0 <= n) {
        return in.substring(0, n) + name + in.substring(n + key.length());
    }
    if (keyIsOptional) {
        return in;
    }
    return null;
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri, state);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs) {
            if (cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.allTaskScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs) {
            if (cfg.wouldPushProject(project) && cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
        } catch (NoRemoteRepositoryException e) {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        } catch (NotSupportedException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (RuntimeException e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } catch (Error e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
        } catch (RemoteRepositoryException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        } catch (NotSupportedException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (RuntimeException e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } catch (Error e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
void replay(GerritApi api) throws IOException, OrmException, NoSuchAccountException, BadRequestException {
    List<RevisionInfo> revisions = new ArrayList<>(changeInfo.revisions.values());
    sortRevisionInfoByNumber(revisions);
    List<PatchSet> patchSets = new ArrayList<>();
    db.changes().beginTransaction(change.getId());
    try {
        PatchSetInfo info = null;
        for (RevisionInfo r : revisions) {
            if (r.draft != null && r.draft) {
                // no import of draft patch sets
                continue;
            }
            PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), r._number));
            String newRef = ps.getId().toRefName();
            ObjectId newId = repo.resolve(newRef);
            String origRef = imported(r.ref);
            ObjectId id = repo.resolve(origRef);
            if (id == null) {
                continue;
            }
            RevCommit commit = rw.parseCommit(id);
            if (newId != null) {
                RevCommit newCommit = rw.parseCommit(newId);
                if (newCommit.equals(commit)) {
                    // already replayed
                    continue;
                } else {
                    // a patch set with the same number was created both in the source
                    // and in the target system
                    log.warn(String.format("[%s] Project %s was modified in target system: " + "Skip replay revision for patch set %s.", pluginName, change.getProject().get(), ps.getId().toString()));
                    continue;
                }
            }
            patchSets.add(ps);
            ps.setUploader(accountUtil.resolveUser(api, r.uploader));
            ps.setCreatedOn(r.created);
            ps.setRevision(new RevId(commit.name()));
            ps.setDraft(r.draft != null && r.draft);
            info = patchSetInfoFactory.get(commit, ps.getId());
            if (changeInfo.currentRevision.equals(info.getRevId())) {
                change.setCurrentPatchSet(info);
            }
            ChangeUtil.insertAncestors(db, ps.getId(), commit);
            updateRef(repo, ps);
        }
        if (change.currentPatchSetId() == null) {
            log.warn(String.format("[%s] Current revision %s of change %s not found." + " Setting last revision %s as current patch set.", pluginName, changeInfo.currentRevision, changeInfo.id, info.getRevId()));
            change.setCurrentPatchSet(info);
        }
        db.patchSets().insert(patchSets);
        db.commit();
    } finally {
        db.rollback();
    }
}
#method_after
void replay(GerritApi api) throws IOException, OrmException, NoSuchAccountException, BadRequestException {
    List<RevisionInfo> revisions = new ArrayList<>(changeInfo.revisions.values());
    sortRevisionInfoByNumber(revisions);
    List<PatchSet> patchSets = new ArrayList<>();
    db.changes().beginTransaction(change.getId());
    try {
        PatchSetInfo info = null;
        for (RevisionInfo r : revisions) {
            if (r.draft != null && r.draft) {
                // no import of draft patch sets
                continue;
            }
            PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), r._number));
            String newRef = ps.getId().toRefName();
            ObjectId newId = repo.resolve(newRef);
            String origRef = imported(r.ref);
            ObjectId id = repo.resolve(origRef);
            if (id == null) {
                continue;
            }
            RevCommit commit = rw.parseCommit(id);
            if (newId != null) {
                RevCommit newCommit = rw.parseCommit(newId);
                if (newCommit.equals(commit)) {
                    // already replayed
                    continue;
                } else {
                    // a patch set with the same number was created both in the source
                    // and in the target system
                    log.warn(String.format("[%s] Project %s was modified in target system: " + "Skip replay revision for patch set %s.", pluginName, change.getProject().get(), ps.getId().toString()));
                    continue;
                }
            }
            patchSets.add(ps);
            ps.setUploader(accountUtil.resolveUser(api, r.uploader));
            ps.setCreatedOn(r.created);
            ps.setRevision(new RevId(commit.name()));
            ps.setDraft(r.draft != null && r.draft);
            info = patchSetInfoFactory.get(commit, ps.getId());
            if (changeInfo.currentRevision.equals(info.getRevId())) {
                change.setCurrentPatchSet(info);
            }
            ChangeUtil.insertAncestors(db, ps.getId(), commit);
            updateRef(repo, ps);
        }
        if (change.currentPatchSetId() == null) {
            log.warn(String.format("[%s] Current revision %s of change %s not found." + " Setting lastest revision %s as current patch set.", pluginName, changeInfo.currentRevision, changeInfo.id, info.getRevId()));
            change.setCurrentPatchSet(info);
        }
        db.patchSets().insert(patchSets);
        db.commit();
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException | IOException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException, IOException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        myRw.parseBody(c);
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException | IOException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSubmoduleSubscriptions() throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try {
        final TreeWalk tw = TreeWalk.forPath(db, GIT_MODULES, mergeTip.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, db, mergeTip, GIT_MODULES);
            final String thisServer = new URI(urlProvider.get()).getHost();
            final Branch.NameKey target = new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get());
            final Set<SubmoduleSubscription> oldSubscriptions = new HashSet<>(schema.submoduleSubscriptions().bySuperProject(destBranch).toList());
            final List<SubmoduleSubscription> newSubscriptions = new SubmoduleSectionParser(bbc, thisServer, target, repoManager).parseAllSections();
            final Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
            for (SubmoduleSubscription s : newSubscriptions) {
                if (oldSubscriptions.contains(s)) {
                    alreadySubscribeds.add(s);
                }
            }
            oldSubscriptions.removeAll(newSubscriptions);
            newSubscriptions.removeAll(alreadySubscribeds);
            if (!oldSubscriptions.isEmpty()) {
                schema.submoduleSubscriptions().delete(oldSubscriptions);
            }
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#method_after
private void updateSubmoduleSubscriptions() throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try {
        final TreeWalk tw = TreeWalk.forPath(db, GIT_MODULES, mergeTip.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, db, mergeTip, GIT_MODULES);
            final String thisServer = new URI(urlProvider.get()).getHost();
            final Branch.NameKey target = new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get());
            final Set<SubmoduleSubscription> oldSubscriptions = new HashSet<>(schema.submoduleSubscriptions().bySuperProject(destBranch).toList());
            List<SubmoduleSubscription> newSubscriptions = subSecParserFactory.create(bbc, thisServer, target).parseAllSections();
            final Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
            for (SubmoduleSubscription s : newSubscriptions) {
                if (oldSubscriptions.contains(s)) {
                    alreadySubscribeds.add(s);
                }
            }
            oldSubscriptions.removeAll(newSubscriptions);
            newSubscriptions.removeAll(alreadySubscribeds);
            if (!oldSubscriptions.isEmpty()) {
                schema.submoduleSubscriptions().delete(oldSubscriptions);
            }
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        try {
                            sb.append("\n").append(c.getFullMessage());
                        } catch (NullPointerException e) {
                            sb.append("\n").append("NPE");
                        }
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException, IOException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        myRw.parseBody(c);
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated ").append(subscriber.getParentKey().get()).append('\n');
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#end_block

#method_before
private static Predicate<ChangeData> topic(String topic) {
    return new TopicPredicate(schema(args.indexes), topic);
}
#method_after
private Predicate<ChangeData> topic(String topic) {
    return new TopicPredicate(schema(indexes), topic);
}
#end_block

#method_before
@Option(name = "--limit", aliases = { "-n" }, metaVar = "CNT", usage = "maximum number of reviewers to list")
public void setLimit(int l) {
    this.limit = l <= 0 ? MAX : Math.min(l, MAX);
}
#method_after
@Option(name = "--limit", aliases = { "-n" }, metaVar = "CNT", usage = "maximum number of reviewers to list")
public void setLimit(int l) {
    this.limit = l <= 0 ? maxSuggestedReviewers : Math.min(l, maxSuggestedReviewers);
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        reviewer.add(new SuggestedReviewerInfo(a));
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            reviewer.add(new SuggestedReviewerInfo(info));
        }
    }
    Collections.sort(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        reviewer.add(new SuggestedReviewerInfo(a));
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            reviewer.add(new SuggestedReviewerInfo(info));
        }
    }
    Collections.sort(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#end_block

#method_before
private String getSortValue() {
    return account != null ? Objects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
}
#method_after
private String getSortValue() {
    return account != null ? MoreObjects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
}
#end_block

#method_before
@Override
public PatchList load(final PatchListKey key) throws Exception {
    final Repository repo = repoManager.openRepository(key.projectKey);
    try {
        return readPatchList(key, repo);
    } finally {
        repo.close();
    }
}
#method_after
@Override
public PatchList load(final PatchListKey key) throws IOException, PatchListNotAvailableException {
    final Repository repo = repoManager.openRepository(key.projectKey);
    try {
        return readPatchList(key, repo);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws Exception {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    final ObjectReader reader = repo.newObjectReader();
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, repo, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = key.getOldId() != null ? FluentIterable.from(patchListCache.get(new PatchListKey(key.projectKey, null, key.getNewId(), key.getWhitespace())).getPatches()).transform(new Function<PatchListEntry, String>() {

            @Override
            public String apply(PatchListEntry entry) {
                return entry.getNewName();
            }
        }).toSet() : null;
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(// 
        cmp, // 
        repo, // 
        reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                entries.add(newEntry(aTree, fh));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    } finally {
        reader.release();
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    final ObjectReader reader = repo.newObjectReader();
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, repo, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = key.getOldId() != null ? FluentIterable.from(patchListCache.get(new PatchListKey(key.projectKey, null, key.getNewId(), key.getWhitespace())).getPatches()).transform(new Function<PatchListEntry, String>() {

            @Override
            public String apply(PatchListEntry entry) {
                return entry.getNewName();
            }
        }).toSet() : null;
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(// 
        cmp, // 
        repo, // 
        reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                entries.add(newEntry(aTree, fh));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    } finally {
        reader.release();
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, DiffFormatter diffFormatter, DiffEntry diffEntry) throws Exception {
    DiffWorkerPool.Worker worker = workerPool.acquire();
    DiffWorkerPool.Worker.Result r;
    r = worker.toFileHeaderWithTimeout(key, diffFormatter, diffEntry, timeoutMillis);
    if (r == DiffWorkerPool.Worker.Result.TIMEOUT) {
        // Don't keep this thread. We have to murder it unsafely, which
        // means its unable to be reused in the future. Return a result produced
        // by HistogramDiff without the usage of MyersDiff.
        // 
        HistogramDiff histogramDiff = new HistogramDiff();
        histogramDiff.setFallbackAlgorithm(null);
        diffFormatter.setDiffAlgorithm(histogramDiff);
        return diffFormatter.toFileHeader(diffEntry);
    }
    workerPool.release(worker);
    if (r.error != null) {
        // 
        throw r.error;
    }
    return r.fileHeader;
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
private static RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#method_after
private RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#end_block

#method_before
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, boolean save) throws IOException {
    String hash = b.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ObjectId treeId;
    ResolveMerger m = (ResolveMerger) MergeStrategy.RESOLVE.newMerger(repo, true);
    final ObjectInserter ins = repo.newObjectInserter();
    try {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void release() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(b.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = b.getParent(0);
            RevCommit theirs = b.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024);
                try {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8");
                    buf.close();
                    InputStream in = buf.openInputStream();
                    try {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    } finally {
                        in.close();
                    }
                } finally {
                    buf.destroy();
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
    } finally {
        ins.release();
    }
    if (save) {
        RefUpdate update = repo.updateRef(refName);
        update.setNewObjectId(treeId);
        update.disableRefLog();
        update.forceUpdate();
    }
    return rw.parseTree(treeId);
}
#method_after
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    return automerge(repo, rw, b, mergeStrategy, true);
}
#end_block

#method_before
private void initOnce() {
    if (pcl == null)
        pcl = new PrologClassLoader();
    if (internalDB == null)
        internalDB = new InternalDatabase();
    if (streamManager == null)
        streamManager = new HashtableOfTerm();
}
#method_after
private void initOnce() {
    if (pcl == null)
        pcl = new PrologClassLoader();
    if (internalDB == null)
        internalDB = new InternalDatabase();
    if (streamManager == null)
        streamManager = new HashtableOfTerm(7);
}
#end_block

#method_before
public Operation jtry9(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S8(this));
}
#method_after
public Operation jtry9(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S9(this));
}
#end_block

#method_before
public Operation jtry10(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S8(this));
}
#method_after
public Operation jtry10(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S10(this));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EventQueue.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(EventQueue.class);
    bind(EventStore.class).to(SQLStore.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(SQLStore.class);
    bind(QueryMaker.class).to(SQLQueryMaker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
}
#method_after
@Override
protected void configure() {
    bind(EventQueue.class).in(Scopes.SINGLETON);
    bind(EventHandler.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(EventQueue.class);
    bind(EventStore.class).to(SQLStore.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(SQLStore.class);
    bind(QueryMaker.class).to(SQLQueryMaker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
}
#end_block

#method_before
@Before
public void setUp() {
    easyMock = new EasyMockSupport();
    storeMock = easyMock.createMock(EventStore.class);
    queueMock = easyMock.createMock(EventQueue.class);
    listener = new EventHandler(storeMock, queueMock);
}
#method_after
@Before
public void setUp() {
    easyMock = new EasyMockSupport();
    storeMock = easyMock.createMock(EventStore.class);
    poolMock = new PoolMock(1);
    listener = new EventHandler(storeMock, poolMock);
}
#end_block

#method_before
@Override
public void onEvent(Event event) {
    if (event instanceof ProjectEvent) {
        if (pool != null) {
            pool.execute(new StoreEventTask((ProjectEvent) event));
        } else {
            (new StoreEventTask((ProjectEvent) event)).run();
        }
    }
}
#method_after
@Override
public void onEvent(Event event) {
    pool.execute(new StoreEventTask((ProjectEvent) event));
}
#end_block

#method_before
public WorkQueue.Executor getPool() {
    return this.pool;
}
#method_after
public ScheduledThreadPoolExecutor getPool() {
    return this.pool;
}
#end_block

#method_before
public void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#method_after
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#end_block

#method_before
@Test
public void forcePushNotAllowed() throws GitAPIException, IOException {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertStatus(Status.REJECTED_OTHER_REASON, "non-fast forward");
}
#method_after
@Test
public void forcePushNotAllowed() throws Exception {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertErrorStatus("non-fast forward");
}
#end_block

#method_before
@Test
public void forcePushAllowed() throws GitAPIException, IOException, ConfigInvalidException {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    grant(Permission.PUSH, project, "refs/*", true);
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertOkStatus();
}
#method_after
@Test
public void forcePushAllowed() throws Exception {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    grant(Permission.PUSH, project, "refs/*", true);
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertOkStatus();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setUseAutoBase(getEnum(rc, RECEIVE, null, KEY_USE_AUTO_BASE, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_AUTO_BASE, p.getUseAutoBase(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    savePluginSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    savePluginSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.useAutoBase != null) {
            p.setUseAutoBase(input.useAutoBase);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(rsrc.getControl().getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(rsrc.getControl().getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (useAutoBase) {
        String magicBranchRef = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(magicBranchRef).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), magicBranchRef), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (useAutoBase && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "You can't push merges with auto base on");
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean useAutoBase, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setUseAutoBase(useAutoBase);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#method_after
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean createNewChangeForAllNotInTarget, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setCreateNewChangeForAllNotInTarget(createNewChangeForAllNotInTarget);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.autoBase = MoreObjects.firstNonNull(input.useAutoBase, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
    useAutoBase = update.useAutoBase;
}
#method_after
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
    createNewChangeForAllNotInTarget = update.createNewChangeForAllNotInTarget;
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setUseAutoBase(createProjectArgs.autoBase);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(createProjectArgs.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    autoBase.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    newChangeForAllNotInTarget.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    autoBase = newInheritedBooleanBox();
    saveEnabler.listenTo(autoBase);
    grid.add(Util.C.useAutoBase(), autoBase);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    newChangeForAllNotInTarget = newInheritedBooleanBox();
    saveEnabler.listenTo(newChangeForAllNotInTarget);
    grid.add(Util.C.createNewChangeForAllNotInTarget(), newChangeForAllNotInTarget);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(autoBase, result.use_auto_base());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(newChangeForAllNotInTarget, result.create_new_change_for_all_not_in_target());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(autoBase), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(newChangeForAllNotInTarget), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> submittedChanges = submit(rsrc, caller, false);
    if (input.waitForMerge) {
        for (Change c : submittedChanges) {
            mergeQueue.merge(c.getDest());
        }
        change = dbProvider.get().changes().get(change.getId());
    } else {
        for (Change c : submittedChanges) {
            mergeQueue.schedule(c.getDest());
        }
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> submittedChanges = submit(rsrc, caller, false);
    if (input.waitForMerge) {
        for (Change c : submittedChanges) {
            // TODO(sbeller): We should make schedule return a Future, then we
            // could do these all in parallel and still block until they're done.
            mergeQueue.merge(c.getDest());
        }
        change = dbProvider.get().changes().get(change.getId());
    } else {
        for (Change c : submittedChanges) {
            mergeQueue.schedule(c.getDest());
        }
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } catch (ResourceConflictException e) {
        throw e;
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } catch (ResourceConflictException e) {
        throw e;
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#method_after
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#end_block

#method_before
private static boolean notModified(HttpServletRequest req, RestResource rsrc, RestView<RestResource> view) {
    if (!isGetOrHead(req)) {
        return false;
    }
    if (view instanceof ETagView) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((ETagView) view).getETag(rsrc));
        }
    }
    if (rsrc instanceof RestResource.HasETag) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((RestResource.HasETag) rsrc).getETag());
        }
    }
    if (rsrc instanceof RestResource.HasLastModified) {
        Timestamp m = ((RestResource.HasLastModified) rsrc).getLastModified();
        long d = req.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE);
        // HTTP times are in seconds, database may have millisecond precision.
        return d / 1000L == m.getTime() / 1000L;
    }
    return false;
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
private static boolean notModified(HttpServletRequest req, RestResource rsrc, RestView<RestResource> view) {
    if (!isGetOrHead(req)) {
        return false;
    }
    if (view instanceof ETagView) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((ETagView) view).getETag(rsrc));
        }
    }
    if (rsrc instanceof RestResource.HasETag) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((RestResource.HasETag) rsrc).getETag());
        }
    }
    if (rsrc instanceof RestResource.HasLastModified) {
        Timestamp m = ((RestResource.HasLastModified) rsrc).getLastModified();
        long d = req.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE);
        // HTTP times are in seconds, database may have millisecond precision.
        return d / 1000L == m.getTime() / 1000L;
    }
    return false;
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.getAttachmentName() != null) {
            res.setHeader("Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\"");
        }
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        if (req == null || !"HEAD".equals(req.getMethod())) {
            OutputStream dst = res.getOutputStream();
            try {
                bin.writeTo(dst);
            } finally {
                dst.close();
            }
        }
    } finally {
        appResult.close();
    }
}
#method_after
@SuppressWarnings("resource")
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.getAttachmentName() != null) {
            res.setHeader("Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\"");
        }
        if (bin.isBase64()) {
            if (req != null && JSON_TYPE.equals(req.getHeader(HttpHeaders.ACCEPT))) {
                bin = stackJsonString(res, bin);
            } else {
                bin = stackBase64(res, bin);
            }
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        if (req == null || !"HEAD".equals(req.getMethod())) {
            OutputStream dst = res.getOutputStream();
            try {
                bin.writeTo(dst);
            } finally {
                dst.close();
            }
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
public GroupControl controlFor(final CurrentUser who, final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(who, group);
}
#method_after
public GroupControl controlFor(final CurrentUser who, final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(who, group, groupBackend);
}
#end_block

#method_before
public GroupControl controlFor(GroupDescription.Basic group) {
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(GroupDescription.Basic group) {
    return new GroupControl(user.get(), group, groupBackend);
}
#end_block

#method_before
public boolean isVisible() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    /* Check for canAdministrateServer may seem redundant, but allows
     * for visibility of all groups that are not an internal group to
     * server administrators.
     */
    return (accountGroup != null && accountGroup.isVisibleToAll()) || user instanceof InternalUser || user.getEffectiveGroups().contains(group.getGroupUUID()) || isOwner() || group.getName().startsWith("ldap/") ? true : user.getCapabilities().canAdministrateServer();
}
#method_after
public boolean isVisible() {
    /* Check for canAdministrateServer may seem redundant, but allows
     * for visibility of all groups that are not an internal group to
     * server administrators.
     */
    return user instanceof InternalUser || user.memberOf(group.getGroupUUID()) || isOwner() || user.getCapabilities().canAdministrateServer() || groupBackend.isVisibleToAll(group.getGroupUUID());
}
#end_block

#method_before
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#method_after
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().memberOf(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#end_block

#method_before
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), uploader);
    PatchSetInserter patchSetInserter = patchSetInserterFactory.create(git, revWalk, changeControl, rebasedCommit).setCopyLabels(true).setValidatePolicy(validate).setDraft(originalPatchSet.isDraft()).setSendMail(sendMail).setRunHooks(runHooks);
    final PatchSet.Id newPatchSetId = patchSetInserter.getPatchSetId();
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader.getAccountId(), TimeUtil.nowTs(), patchSetId);
    cmsg.setMessage("Patch Set " + newPatchSetId.get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetInserter.setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#method_after
public void rebase(Change change, PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(change, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, ValidatePolicy.GERRIT);
    } catch (MergeConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
private static String findBaseRevision(final PatchSet.Id patchSetId, final ReviewDb db, final Branch.NameKey destBranch, final Repository git, List<PatchSetAncestor> patchSetAncestors, List<PatchSet> depPatchSetList, List<Change> depChangeList) throws IOException, OrmException {
    String baseRev = null;
    if (patchSetAncestors == null) {
        patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
    }
    if (patchSetAncestors.size() > 1) {
        throw new IOException("Cannot rebase a change with multiple parents. Parents commits: " + patchSetAncestors.toString());
    }
    if (patchSetAncestors.size() == 0) {
        throw new IOException("Cannot rebase a change without any parents (is this the initial commit?).");
    }
    RevId ancestorRev = patchSetAncestors.get(0).getAncestorRevision();
    if (depPatchSetList == null || depPatchSetList.size() != 1 || !depPatchSetList.get(0).getRevision().equals(ancestorRev)) {
        depPatchSetList = db.patchSets().byRevision(ancestorRev).toList();
    }
    for (PatchSet depPatchSet : depPatchSetList) {
        Change.Id depChangeId = depPatchSet.getId().getParentKey();
        Change depChange;
        if (depChangeList == null || depChangeList.size() != 1 || !depChangeList.get(0).getId().equals(depChangeId)) {
            depChange = db.changes().get(depChangeId);
        } else {
            depChange = depChangeList.get(0);
        }
        if (!depChange.getDest().equals(destBranch)) {
            continue;
        }
        if (depChange.getStatus() == Status.ABANDONED) {
            throw new IOException("Cannot rebase a change with an abandoned parent: " + depChange.getKey().toString());
        }
        if (depChange.getStatus().isOpen()) {
            if (depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                throw new IOException("Change is already based on the latest patch set of the dependent change.");
            }
            PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
            baseRev = latestDepPatchSet.getRevision().get();
        }
        break;
    }
    if (baseRev == null) {
        // We are dependent on a merged PatchSet or have no PatchSet
        // dependencies at all.
        Ref destRef = git.getRef(destBranch.get());
        if (destRef == null) {
            throw new IOException("The destination branch does not exist: " + destBranch.get());
        }
        baseRev = destRef.getObjectId().getName();
        if (baseRev.equals(ancestorRev.get())) {
            throw new IOException("Change is already up to date.");
        }
    }
    return baseRev;
}
#method_after
private static String findBaseRevision(final PatchSet.Id patchSetId, final ReviewDb db, final Branch.NameKey destBranch, final Repository git, List<PatchSetAncestor> patchSetAncestors, List<PatchSet> depPatchSetList, List<Change> depChangeList) throws IOException, OrmException {
    String baseRev = null;
    if (patchSetAncestors == null) {
        patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
    }
    if (patchSetAncestors.size() > 1) {
        throw new IOException("Cannot rebase a change with multiple parents. Parent commits: " + patchSetAncestors.toString());
    }
    if (patchSetAncestors.size() == 0) {
        throw new IOException("Cannot rebase a change without any parents (is this the initial commit?).");
    }
    RevId ancestorRev = patchSetAncestors.get(0).getAncestorRevision();
    if (depPatchSetList == null || depPatchSetList.size() != 1 || !depPatchSetList.get(0).getRevision().equals(ancestorRev)) {
        depPatchSetList = db.patchSets().byRevision(ancestorRev).toList();
    }
    for (PatchSet depPatchSet : depPatchSetList) {
        Change.Id depChangeId = depPatchSet.getId().getParentKey();
        Change depChange;
        if (depChangeList == null || depChangeList.size() != 1 || !depChangeList.get(0).getId().equals(depChangeId)) {
            depChange = db.changes().get(depChangeId);
        } else {
            depChange = depChangeList.get(0);
        }
        if (!depChange.getDest().equals(destBranch)) {
            continue;
        }
        if (depChange.getStatus() == Status.ABANDONED) {
            throw new IOException("Cannot rebase a change with an abandoned parent: " + depChange.getKey().toString());
        }
        if (depChange.getStatus().isOpen()) {
            if (depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                throw new IOException("Change is already based on the latest patch set of the dependent change.");
            }
            PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
            baseRev = latestDepPatchSet.getRevision().get();
        }
        break;
    }
    if (baseRev == null) {
        // We are dependent on a merged PatchSet or have no PatchSet
        // dependencies at all.
        Ref destRef = git.getRef(destBranch.get());
        if (destRef == null) {
            throw new IOException("The destination branch does not exist: " + destBranch.get());
        }
        baseRev = destRef.getObjectId().getName();
        if (baseRev.equals(ancestorRev.get())) {
            throw new IOException("Change is already up to date.");
        }
    }
    return baseRev;
}
#end_block

#method_before
private ObjectId rebaseCommit(final Repository git, final ObjectInserter inserter, final RevCommit original, final RevCommit base, final MergeUtil mergeUtil, final PersonIdent committerIdent) throws IOException, PathConflictException {
    final RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new IOException("Change is already up to date.");
    }
    final ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, inserter);
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new PathConflictException("The change could not be rebased due to a path conflict during merge.");
    }
    final CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    cb.setCommitter(committerIdent);
    final ObjectId objectId = inserter.insert(cb);
    inserter.flush();
    return objectId;
}
#method_after
private ObjectId rebaseCommit(Repository git, ObjectInserter inserter, RevCommit original, RevCommit base, MergeUtil mergeUtil, PersonIdent committerIdent) throws MergeConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new IOException("Change is already up to date.");
    }
    ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, inserter);
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    cb.setCommitter(committerIdent);
    ObjectId objectId = inserter.insert(cb);
    inserter.flush();
    return objectId;
}
#end_block

#method_before
public boolean canRebase(RevisionResource r) {
    Repository git;
    try {
        git = gitManager.openRepository(r.getChange().getProject());
    } catch (RepositoryNotFoundException err) {
        return false;
    } catch (IOException err) {
        return false;
    }
    try {
        findBaseRevision(r.getPatchSet().getId(), db, r.getChange().getDest(), git, null, null, null);
        return true;
    } catch (IOException e) {
        return false;
    } catch (OrmException e) {
        return false;
    } finally {
        git.close();
    }
}
#method_after
public boolean canRebase(RevisionResource r) {
    Repository git;
    try {
        git = gitManager.openRepository(r.getChange().getProject());
    } catch (RepositoryNotFoundException err) {
        return false;
    } catch (IOException err) {
        return false;
    }
    try {
        findBaseRevision(r.getPatchSet().getId(), db.get(), r.getChange().getDest(), git, null, null, null);
        return true;
    } catch (IOException e) {
        return false;
    } catch (OrmException e) {
        return false;
    } finally {
        git.close();
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId());
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
@Option(name = "-r", metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#method_after
@Option(name = "--reviewer", aliases = { "-r" }, metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
CheckedFuture<Void, OrmException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<Void, InsertException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error("Cannot read database before replacement", err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error("Cannot read repository before replacement", err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (changeKind == ChangeKind.REWORK) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private List<Ref> refs(Change.Id changeId) {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null && PatchSet.isRef(ref.getName())) {
                refsByChange.put(Change.Id.fromRef(ref.getName()), ref);
            }
        }
    }
    return refsByChange.get(changeId);
}
#method_after
private List<Ref> refs(Change.Id changeId) {
    return refsByChange().get(changeId);
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException, IOException {
    Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    indexer.index(db, change);
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || !submit.getAccountId().equals(caller.getAccountId())) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#method_after
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (!hasUser || Gerrit.getUserAccount().getGeneralPreferences().isMuteCommonPathPrefixes()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && !ChangeType.DELETED.matches(info.status())) {
        if (ChangeType.ADDED.matches(info.status())) {
            sb.append(info.lines_inserted()).append(" lines");
        } else {
            sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.lines_inserted() + info.lines_deleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.lines_inserted()).append(" lines");
            } else {
                sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
            }
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta2(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn2());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && (info.lines_inserted() != 0 || info.lines_deleted() != 0)) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(5, (int) (((double) w) * info.lines_inserted() / t));
        int d = Math.max(5, (int) (((double) w) * info.lines_deleted() / t));
        sb.setAttribute("title", Util.M.patchTableSize_LongModify(info.lines_inserted(), info.lines_deleted()));
        if (0 < info.lines_inserted()) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < info.lines_deleted()) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta2(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn2());
    if (showChangeSizeBars && !Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && (info.lines_inserted() != 0 || info.lines_deleted() != 0)) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(5, (int) (((double) w) * info.lines_inserted() / t));
        int d = Math.max(5, (int) (((double) w) * info.lines_deleted() / t));
        sb.setAttribute("title", Util.M.patchTableSize_LongModify(info.lines_inserted(), info.lines_deleted()));
        if (0 < info.lines_inserted()) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < info.lines_deleted()) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void footer(SafeHtmlBuilder sb) {
    sb.openTr().setStyleName(R.css().nohover());
    sb.openTh().setStyleName(R.css().pointer()).closeTh();
    if (mode == Mode.REVIEW) {
        sb.openTh().setStyleName(R.css().reviewed()).closeTh();
    } else {
        sb.openTh().setStyleName(R.css().removeButton()).closeTh();
    }
    sb.openTh().setStyleName(R.css().status()).closeTh();
    // path
    sb.openTd().closeTd();
    // comments
    sb.openTd().setAttribute("colspan", 3).closeTd();
    // delta1
    sb.openTh().setStyleName(R.css().deltaColumn1()).append(Util.M.patchTableSize_Modify(inserted, deleted)).closeTh();
    // delta2
    sb.openTh().setStyleName(R.css().deltaColumn2());
    int w = 80;
    int t = inserted + deleted;
    int i = Math.max(1, (int) (((double) w) * inserted / t));
    int d = Math.max(1, (int) (((double) w) * deleted / t));
    if (i + d > w && i > d) {
        i = w - d;
    } else if (i + d > w && d > i) {
        d = w - i;
    }
    if (0 < inserted) {
        sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
    }
    if (0 < deleted) {
        sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
    }
    sb.closeTh();
    sb.closeTr();
}
#method_after
private void footer(SafeHtmlBuilder sb) {
    sb.openTr().setStyleName(R.css().nohover());
    sb.openTh().setStyleName(R.css().pointer()).closeTh();
    if (mode == Mode.REVIEW) {
        sb.openTh().setStyleName(R.css().reviewed()).closeTh();
    } else {
        sb.openTh().setStyleName(R.css().removeButton()).closeTh();
    }
    sb.openTh().setStyleName(R.css().status()).closeTh();
    // path
    sb.openTd().closeTd();
    // comments
    sb.openTd().setAttribute("colspan", 3).closeTd();
    // delta1
    sb.openTh().setStyleName(R.css().deltaColumn1()).append(Util.M.patchTableSize_Modify(inserted, deleted)).closeTh();
    // delta2
    sb.openTh().setStyleName(R.css().deltaColumn2());
    if (showChangeSizeBars) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(1, (int) (((double) w) * inserted / t));
        int d = Math.max(1, (int) (((double) w) * deleted / t));
        if (i + d > w && i > d) {
            i = w - d;
        } else if (i + d > w && d > i) {
            d = w - i;
        }
        if (0 < inserted) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < deleted) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTh();
    sb.closeTr();
}
#end_block

#method_before
static void call(final Button b, final String project) {
    b.setEnabled(false);
    ChangeApi.createDraftChange(project, "refs/meta/config", Util.C.editConfigMessage(), null, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(result.legacy_id(), 1), "project.config"));
        }

        @Override
        public void onFailure(Throwable caught) {
            b.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
static void call(final Button b, final String project) {
    b.setEnabled(false);
    ChangeApi.createChange(project, RefNames.REFS_CONFIG, Util.C.editConfigMessage(), null, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(result.legacy_id(), 1), "project.config"));
        }

        @Override
        public void onFailure(Throwable caught) {
            b.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { toc(), note() };
}
#method_after
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { note(), toc() };
}
#end_block

#method_before
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), whitespace(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode((DivNode.Style) pop(), parse(body).getChildren())));
}
#method_after
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), Sp(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode(popAsString(), parse(body))));
}
#end_block

#method_before
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(DivNode.Style.NOTE)), sequence(string("promo"), push(DivNode.Style.PROMO)), sequence(string("aside"), push(DivNode.Style.ASIDE)));
}
#method_after
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(match())), sequence(string("promo"), push(match())), sequence(string("aside"), push(match())));
}
#end_block

#method_before
public RootNode parse(StringBuilderVar body) {
    // parsing within a block.
    return parser.parseMarkdown(body.getChars());
}
#method_after
public List<Node> parse(StringBuilderVar body) {
    // parsing within a block.
    if (parser == null) {
        parser = newParser();
    }
    return parser.parseMarkdown(body.getChars()).getChildren();
}
#end_block

#method_before
String getStyleName() {
    return style.name().toLowerCase(Locale.US);
}
#method_after
public String getStyleName() {
    return style;
}
#end_block

#method_before
@Override
public void accept(Visitor visitor) {
    visitor.visit(this);
}
#method_after
@Override
public void accept(org.pegdown.ast.Visitor visitor) {
    ((Visitor) visitor).visit(this);
}
#end_block

#method_before
String getTitle(Node root) {
    if (root instanceof HeaderNode) {
        HeaderNode h = (HeaderNode) root;
        if (h.getLevel() == 1) {
            return TocSerializer.getText(h);
        }
    }
    List<Node> ch = root.getChildren();
    if (ch != null) {
        for (Node n : ch) {
            String title = getTitle(n);
            if (title != null) {
                return title;
            }
        }
    }
    return null;
}
#method_after
static String getTitle(Node node) {
    if (node instanceof HeaderNode) {
        if (((HeaderNode) node).getLevel() == 1) {
            return getInnerText(node);
        }
        return null;
    }
    for (Node child : node.getChildren()) {
        String title = getTitle(child);
        if (title != null) {
            return title;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        if (Strings.isNullOrEmpty(path)) {
            path = INDEX_MD;
        } else if (path.endsWith("/")) {
            path += INDEX_MD;
        }
        if (!path.endsWith(".md")) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        RevTree root = getRoot(view, rw);
        if (root == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        String srcmd = readFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownHelper fmt = new MarkdownHelper(view);
        RootNode doc = parseFile(view, path, fmt, srcmd);
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        String navmd = readFile(rw, root, "navbar.md");
        RootNode nav = navmd != null ? parseFile(view, "navbar.md", fmt, navmd) : null;
        showDoc(req, res, fmt, nav, doc);
    } finally {
        rw.release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Config cfg = getAccess(req).getConfig();
    if (!cfg.getBoolean("markdown", "render", true)) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        RevTree root;
        try {
            root = rw.parseTree(view.getRevision().getId());
        } catch (IncorrectObjectTypeException e) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile navmd = findFile(rw, root, NAVBAR_MD);
        String reqEtag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        String curEtag = etag(srcmd, navmd);
        if (reqEtag != null && reqEtag.equals(curEtag)) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        int inputLimit = cfg.getInt("markdown", "inputLimit", 5 << 20);
        RootNode doc = GitilesMarkdown.parseFile(view, srcmd.path, srcmd.read(rw.getObjectReader(), inputLimit));
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        RootNode nav = null;
        if (navmd != null) {
            nav = GitilesMarkdown.parseFile(view, navmd.path, navmd.read(rw.getObjectReader(), inputLimit));
            if (nav == null) {
                res.setStatus(SC_INTERNAL_SERVER_ERROR);
                return;
            }
        }
        res.setHeader(HttpHeaders.ETAG, curEtag);
        showDoc(req, res, view, nav, doc);
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, MarkdownHelper fmt, RootNode nav, RootNode doc) throws IOException {
    String title = MoreObjects.firstNonNull(Strings.emptyToNull(fmt.getTitle(doc)), ViewFilter.getView(req).getPathPart());
    Map<String, Object> data = new HashMap<>();
    data.put("breadcrumbs", null);
    data.put("repositoryName", null);
    data.put("title", title);
    data.put("navbarHtml", fmt.renderHTML(nav));
    data.put("bodyHtml", fmt.renderHTML(doc));
    renderHtml(req, res, "gitiles.markdownDoc", data);
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, RootNode nav, RootNode doc) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.put("pageTitle", MoreObjects.firstNonNull(MarkdownHelper.getTitle(doc), view.getPathPart()));
    data.put("sourceUrl", GitilesView.path().copyFrom(view).toUrl());
    data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
    data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    data.put("navbarHtml", new MarkdownToHtml(view).toSoyHtml(nav));
    data.put("bodyHtml", new MarkdownToHtml(view).toSoyHtml(doc));
    String page = renderer.render(SOY_TEMPLATE, data);
    byte[] raw = page.getBytes(UTF_8);
    res.setContentType(FormatType.HTML.getMimeType());
    res.setCharacterEncoding(UTF_8.name());
    setCacheHeaders(res);
    if (acceptsGzipEncoding(req)) {
        res.setHeader(HttpHeaders.CONTENT_ENCODING, "gzip");
        raw = gzip(raw);
    }
    res.setContentLength(raw.length);
    res.setStatus(HttpServletResponse.SC_OK);
    res.getOutputStream().write(raw);
}
#end_block

#method_before
void render(HttpServletResponse res, String templateName, Map<String, ?> soyData) throws IOException {
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    byte[] data = newRenderer(templateName).setData(soyData).render().getBytes(UTF_8);
    res.setContentLength(data.length);
    res.getOutputStream().write(data);
}
#method_after
public String render(String templateName, Map<String, ?> soyData) {
    return newRenderer(templateName).setData(soyData).render();
}
#end_block

#method_before
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    ChangeInfo cherryInfo = cherry.get();
    assertThat((Iterable<?>) cherryInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> it = cherryInfo.messages.iterator();
    assertThat(it.next().message).isEqualTo("Cherry picked as patch set 1.");
    assertThat(cherryInfo.subject).contains(in.message);
    assertThat(cherryInfo.topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    String cherryPickedRevision = cherry.get().currentRevision;
    String expectedMessage = String.format("Patch Set 1: Cherry Picked\n\n" + "This patchset was cherry picked to branch %s as commit %s", in.destination, cherryPickedRevision);
    Iterator<ChangeMessageInfo> origIt = orig.get().messages.iterator();
    origIt.next();
    assertThat(origIt.next().message).isEqualTo(expectedMessage);
    assertThat((Iterable<?>) cherry.get().messages).hasSize(1);
    Iterator<ChangeMessageInfo> cherryIt = cherry.get().messages.iterator();
    expectedMessage = "Patch Set 1: Cherry Picked from branch master.";
    assertThat(cherryIt.next().message).isEqualTo(expectedMessage);
    assertThat(cherry.get().subject).contains(in.message);
    assertThat(cherry.get().topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
public static void registerClass(Event event) {
    typesByString.put(event.getType(), event.getClass());
}
#method_after
public static void registerClass(Event event) {
    String type = event.getType();
    if (typesByString.containsKey(type)) {
        throw new IllegalArgumentException("Event type already registered: " + type);
    }
    typesByString.put(type, event.getClass());
}
#end_block

#method_before
public static Class getClass(String type) {
    return typesByString.get(type);
}
#method_after
public static Class<?> getClass(String type) {
    return typesByString.get(type);
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, final Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(new HttpResponse<T>(res, null, null));
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        long start = System.currentTimeMillis();
        final T data;
        final String type;
        if (isJsonBody(res)) {
            try {
                // javac generics bug
                data = RestApi.<T>cast(parseJson(res));
                type = JSON_TYPE;
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else if (isEncodedBase64(res)) {
            data = NativeString.wrap(decodeBase64(res.getText())).cast();
            type = simpleType(res.getHeader("X-FYI-Content-Type"));
        } else if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            type = TEXT_TYPE;
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        Scheduler.ScheduledCommand cmd = new Scheduler.ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    cb.onSuccess(new HttpResponse<>(res, type, data));
                } finally {
                    if (!background) {
                        RpcStatus.INSTANCE.onRpcComplete();
                    }
                }
            }
        };
        // Defer handling the response if the parse took a while.
        if ((System.currentTimeMillis() - start) > 75) {
            Scheduler.get().scheduleDeferred(cmd);
        } else {
            cmd.execute();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#method_after
@Override
public void onResponseReceived(Request req, final Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(new HttpResponse<T>(res, null, null));
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        long start = System.currentTimeMillis();
        final T data;
        final String type;
        if (isJsonBody(res)) {
            try {
                JSONValue val = parseJson(res);
                if (isJsonEncoded(res) && val.isString() != null) {
                    data = NativeString.wrap(val.isString().stringValue()).cast();
                    type = simpleType(res.getHeader("X-FYI-Content-Type"));
                } else {
                    data = RestApi.<T>cast(val);
                    type = JSON_TYPE;
                }
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            type = TEXT_TYPE;
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        Scheduler.ScheduledCommand cmd = new Scheduler.ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    cb.onSuccess(new HttpResponse<>(res, type, data));
                } finally {
                    if (!background) {
                        RpcStatus.INSTANCE.onRpcComplete();
                    }
                }
            }
        };
        // Defer handling the response if the parse took a while.
        if ((System.currentTimeMillis() - start) > 75) {
            Scheduler.get().scheduleDeferred(cmd);
        } else {
            cmd.execute();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
public <T extends JavaScriptObject> void post(String content, HttpCallback<T> cb) {
    sendRaw(POST, content, cb);
}
#method_after
public <T extends JavaScriptObject> void post(String content, HttpCallback<T> cb) {
    sendText(POST, content, cb);
}
#end_block

#method_before
public <T extends JavaScriptObject> void put(String content, HttpCallback<T> cb) {
    sendRaw(PUT, content, cb);
}
#method_after
public <T extends JavaScriptObject> void put(String content, HttpCallback<T> cb) {
    sendText(PUT, content, cb);
}
#end_block

#method_before
private static BinaryResult stackBase64(HttpServletResponse res, final BinaryResult src) throws IOException {
    BinaryResult b64;
    long len = src.getContentLength();
    if (0 <= len && len <= (7 << 20)) {
        b64 = base64(src);
    } else {
        b64 = new BinaryResult() {

            @Override
            public void writeTo(final OutputStream out) throws IOException {
                try (OutputStreamWriter w = new OutputStreamWriter(new OutputStream() {

                    @Override
                    public void write(int b) throws IOException {
                        out.write(b);
                    }

                    @Override
                    public void close() {
                    // do not close `out`, but only `w` and `e`
                    }
                }, ISO_8859_1);
                    OutputStream e = BaseEncoding.base64().encodingStream(w)) {
                    src.writeTo(e);
                    e.flush();
                }
            }
        };
    }
    res.setHeader("X-FYI-Content-Encoding", "base64");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1");
}
#method_after
private static BinaryResult stackBase64(HttpServletResponse res, final BinaryResult src) throws IOException {
    BinaryResult b64;
    long len = src.getContentLength();
    if (0 <= len && len <= (7 << 20)) {
        b64 = base64(src);
    } else {
        b64 = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (OutputStreamWriter w = new OutputStreamWriter(new FilterOutputStream(out) {

                    @Override
                    public void close() {
                    // Do not close out, but only w and e.
                    }
                }, ISO_8859_1);
                    OutputStream e = BaseEncoding.base64().encodingStream(w)) {
                    src.writeTo(e);
                }
            }
        };
    }
    res.setHeader("X-FYI-Content-Encoding", "base64");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1");
}
#end_block

#method_before
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (Gerrit.getConfig().getMuteCommonPathsInFileTable()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#method_after
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (!hasUser || Gerrit.getUserAccount().getGeneralPreferences().isMuteCommonPathPrefixes()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && !ChangeType.DELETED.matches(info.status())) {
        if (ChangeType.ADDED.matches(info.status())) {
            sb.append(info.lines_inserted()).append(" lines");
        } else {
            sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        sb.append(info.lines_inserted() + info.lines_deleted());
    }
    sb.closeTd();
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change, timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
protected void submitStatusOnly(String changeId) throws IOException, OrmException {
    approve(changeId);
    Change c = db.changes().byKey(new Change.Key(changeId)).toList().get(0);
    c.setStatus(Change.Status.SUBMITTED);
    db.changes().update(Collections.singleton(c));
    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), admin.id, LabelId.SUBMIT), (short) 1, new Timestamp(System.currentTimeMillis()))));
}
#method_after
protected void submitStatusOnly(String changeId) throws IOException, OrmException {
    approve(changeId);
    Change c = queryProvider.get().byKeyPrefix(changeId).get(0).change();
    c.setStatus(Change.Status.SUBMITTED);
    db.changes().update(Collections.singleton(c));
    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), admin.id, LabelId.SUBMIT), (short) 1, new Timestamp(System.currentTimeMillis()))));
    indexer.index(db, c);
}
#end_block

#method_before
protected void assertSubmitter(String changeId, int psId) throws OrmException {
    ChangeNotes cn = notesFactory.create(Iterables.getOnlyElement(db.changes().byKey(new Change.Key(changeId))));
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter.isSubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#method_after
protected void assertSubmitter(String changeId, int psId) throws OrmException {
    ChangeNotes cn = notesFactory.create(getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change());
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter.isSubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#end_block

#method_before
public void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public List<CodeReviewCommit> reduceToMinimalMerge(MergeSorter mergeSorter, Collection<CodeReviewCommit> toSort) throws MergeException {
    List<CodeReviewCommit> result = new ArrayList<>();
    try {
        result.addAll(mergeSorter.sort(toSort));
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    Collections.sort(result, CodeReviewCommit.ORDER);
    return result;
}
#end_block

#method_before
private void deleteActionCategories(ReviewDb db) throws OrmException {
    try {
        Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        try {
            stmt.executeUpdate("DELETE FROM approval_categories WHERE position < 0");
        } finally {
            stmt.close();
        }
    } catch (SQLException e) {
        throw new OrmException(e);
    }
}
#method_after
private void deleteActionCategories(ReviewDb db) throws SQLException {
    try (Statement stmt = newStatement(db)) {
        stmt.executeUpdate("DELETE FROM approval_categories WHERE position < 0");
    }
}
#end_block

#method_before
private void exportProjectConfig(ReviewDb db) throws OrmException, SQLException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM projects ORDER BY name");
    while (rs.next()) {
        final String name = rs.getString("name");
        final Project.NameKey nameKey = new Project.NameKey(name);
        Repository git;
        try {
            git = mgr.openRepository(nameKey);
        } catch (RepositoryNotFoundException notFound) {
            // inheritable permissions. For example 'All-Projects'.
            try {
                git = mgr.createRepository(nameKey);
            } catch (IOException err) {
                throw new OrmException("Cannot create repository " + name, err);
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
        try {
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, nameKey, git);
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            ProjectConfig config = ProjectConfig.read(md);
            loadProject(rs, config.getProject());
            config.getAccessSections().clear();
            convertRights(config);
            // 
            if (config.getProject().getNameKey().equals(systemConfig.wildProjectName)) {
                AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
                Permission read = meta.getPermission(READ, true);
                read.getRule(config.resolve(projectOwners), true);
            }
            md.setMessage("Import project configuration from SQL\n");
            config.commit(md);
        } catch (ConfigInvalidException err) {
            throw new OrmException("Cannot read project " + name, err);
        } catch (IOException err) {
            throw new OrmException("Cannot export project " + name, err);
        } finally {
            git.close();
        }
    }
    rs.close();
    stmt.close();
}
#method_after
private void exportProjectConfig(ReviewDb db) throws OrmException, SQLException {
    try (Statement s = newStatement(db);
        ResultSet rs = s.executeQuery("SELECT * FROM projects ORDER BY name")) {
        while (rs.next()) {
            final String name = rs.getString("name");
            final Project.NameKey nameKey = new Project.NameKey(name);
            Repository git;
            try {
                git = mgr.openRepository(nameKey);
            } catch (RepositoryNotFoundException notFound) {
                // inheritable permissions. For example 'All-Projects'.
                try {
                    git = mgr.createRepository(nameKey);
                } catch (IOException err) {
                    throw new OrmException("Cannot create repository " + name, err);
                }
            } catch (IOException e) {
                throw new OrmException(e);
            }
            try {
                MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, nameKey, git);
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                ProjectConfig config = ProjectConfig.read(md);
                loadProject(rs, config.getProject());
                config.getAccessSections().clear();
                convertRights(config);
                // 
                if (config.getProject().getNameKey().equals(systemConfig.wildProjectName)) {
                    AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
                    Permission read = meta.getPermission(READ, true);
                    read.getRule(config.resolve(projectOwners), true);
                }
                md.setMessage("Import project configuration from SQL\n");
                config.commit(md);
            } catch (ConfigInvalidException err) {
                throw new OrmException("Cannot read project " + name, err);
            } catch (IOException err) {
                throw new OrmException("Cannot export project " + name, err);
            } finally {
                git.close();
            }
        }
    }
}
#end_block

#method_before
private void readOldRefRights(ReviewDb db) throws SQLException {
    rightsByProject = new HashMap<>();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM ref_rights");
    while (rs.next()) {
        OldRefRight right = new OldRefRight(rs);
        if (right.group == null || right.category == null) {
            continue;
        }
        List<OldRefRight> list;
        list = rightsByProject.get(right.project);
        if (list == null) {
            list = new ArrayList<>();
            rightsByProject.put(right.project, list);
        }
        list.add(right);
    }
    rs.close();
    stmt.close();
}
#method_after
private void readOldRefRights(ReviewDb db) throws SQLException {
    rightsByProject = new HashMap<>();
    try (Statement s = newStatement(db);
        ResultSet rs = s.executeQuery("SELECT * FROM ref_rights")) {
        while (rs.next()) {
            OldRefRight right = new OldRefRight(rs);
            if (right.group == null || right.category == null) {
                continue;
            }
            List<OldRefRight> list;
            list = rightsByProject.get(right.project);
            if (list == null) {
                list = new ArrayList<>();
                rightsByProject.put(right.project, list);
            }
            list.add(right);
        }
    }
}
#end_block

#method_before
private void readProjectParents(ReviewDb db) throws SQLException {
    parentsByProject = new HashMap<>();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM projects");
    while (rs.next()) {
        String name = rs.getString("name");
        String parent_name = rs.getString("parent_name");
        if (parent_name == null) {
            parent_name = systemConfig.wildProjectName.get();
        }
        // 
        parentsByProject.put(// 
        new Project.NameKey(name), new Project.NameKey(parent_name));
    }
    rs.close();
    stmt.close();
}
#method_after
private void readProjectParents(ReviewDb db) throws SQLException {
    parentsByProject = new HashMap<>();
    try (Statement s = newStatement(db);
        ResultSet rs = s.executeQuery("SELECT * FROM projects")) {
        while (rs.next()) {
            String name = rs.getString("name");
            String parent_name = rs.getString("parent_name");
            if (parent_name == null) {
                parent_name = systemConfig.wildProjectName.get();
            }
            // 
            parentsByProject.put(// 
            new Project.NameKey(name), new Project.NameKey(parent_name));
        }
    }
}
#end_block

#method_before
private void alterTable(ReviewDb db, String sqlFormat) throws SQLException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        stmt.executeUpdate(String.format(sqlFormat, "patch_set_approvals", "category_id"));
    } finally {
        stmt.close();
    }
}
#method_after
private void alterTable(ReviewDb db, String sqlFormat) throws SQLException {
    try (Statement stmt = newStatement(db)) {
        stmt.executeUpdate(String.format(sqlFormat, "patch_set_approvals", "category_id"));
    }
}
#end_block

#method_before
private void migratePatchSetApprovals(ReviewDb db, LegacyLabelTypes labelTypes) throws SQLException {
    PreparedStatement stmt = ((JdbcSchema) db).getConnection().prepareStatement("UPDATE patch_set_approvals SET category_id = ?, granted=granted" + " WHERE category_id = ?");
    try {
        for (LegacyLabelType type : labelTypes.getLegacyLabelTypes()) {
            stmt.setString(1, type.getName());
            stmt.setString(2, type.getId());
            stmt.addBatch();
        }
        stmt.executeBatch();
    } finally {
        stmt.close();
    }
}
#method_after
private void migratePatchSetApprovals(ReviewDb db, LegacyLabelTypes labelTypes) throws SQLException {
    try (PreparedStatement stmt = prepareStatement(db, "UPDATE patch_set_approvals SET category_id = ?, granted=granted" + " WHERE category_id = ?")) {
        for (LegacyLabelType type : labelTypes.getLegacyLabelTypes()) {
            stmt.setString(1, type.getName());
            stmt.setString(2, type.getId());
            stmt.addBatch();
        }
        stmt.executeBatch();
    }
}
#end_block

#method_before
static LegacyLabelTypes getLegacyTypes(ReviewDb db) throws SQLException {
    List<LegacyLabelType> types = Lists.newArrayListWithCapacity(2);
    Statement catStmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet catRs = catStmt.executeQuery("SELECT category_id, name, function_name, copy_min_score" + " FROM approval_categories" + " ORDER BY position, name");
        PreparedStatement valStmt = ((JdbcSchema) db).getConnection().prepareStatement("SELECT value, name" + " FROM approval_category_values" + " WHERE category_id = ?");
        try {
            while (catRs.next()) {
                String id = catRs.getString("category_id");
                valStmt.setString(1, id);
                List<LabelValue> values = Lists.newArrayListWithCapacity(5);
                ResultSet valRs = valStmt.executeQuery();
                while (valRs.next()) {
                    values.add(new LabelValue(valRs.getShort("value"), valRs.getString("name")));
                }
                LegacyLabelType type = new LegacyLabelType(getLabelName(catRs.getString("name")), values);
                type.setId(id);
                type.setFunctionName(catRs.getString("function_name"));
                type.setCopyMinScore("Y".equals(catRs.getString("copy_min_score")));
                types.add(type);
            }
        } finally {
            valStmt.close();
        }
    } finally {
        catStmt.close();
    }
    return new LegacyLabelTypes(types);
}
#method_after
static LegacyLabelTypes getLegacyTypes(ReviewDb db) throws SQLException {
    List<LegacyLabelType> types = Lists.newArrayListWithCapacity(2);
    try (Statement catStmt = newStatement(db);
        ResultSet catRs = catStmt.executeQuery("SELECT category_id, name, function_name, copy_min_score" + " FROM approval_categories" + " ORDER BY position, name");
        PreparedStatement valStmt = prepareStatement(db, "SELECT value, name" + " FROM approval_category_values" + " WHERE category_id = ?")) {
        while (catRs.next()) {
            String id = catRs.getString("category_id");
            valStmt.setString(1, id);
            List<LabelValue> values = Lists.newArrayListWithCapacity(5);
            try (ResultSet valRs = valStmt.executeQuery()) {
                while (valRs.next()) {
                    values.add(new LabelValue(valRs.getShort("value"), valRs.getString("name")));
                }
            }
            LegacyLabelType type = new LegacyLabelType(getLabelName(catRs.getString("name")), values);
            type.setId(id);
            type.setFunctionName(catRs.getString("function_name"));
            type.setCopyMinScore("Y".equals(catRs.getString("copy_min_score")));
            types.add(type);
        }
    }
    return new LegacyLabelTypes(types);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db, String mergeResultRev) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
private void fireEventForUnrestrictedListeners(final Event event) {
    for (ChangeListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#method_after
private void fireEventForUnrestrictedListeners(final Event event) {
    for (EventListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#end_block

#method_before
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) {
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    hooks.addChangeListener(listener, currentUser);
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    hooks.addEventListener(listener, currentUser);
}
#end_block

#method_before
@Override
protected void onExit(final int rc) {
    hooks.removeChangeListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#method_after
@Override
protected void onExit(final int rc) {
    hooks.removeEventListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#end_block

#method_before
@Override
public void destroy() {
    hooks.removeChangeListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#method_after
@Override
public void destroy() {
    hooks.removeEventListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#end_block

#method_before
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            hooks.removeChangeListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#method_after
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            hooks.removeEventListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    boolean useTopicSubmit = submitWholeTopic && !resource.getChange().getTopic().isEmpty();
    return new UiAction.Description().setLabel(useTopicSubmit ? labelSubmitTopic : label).setTitle(useTopicSubmit ? titlePatternSubmitTopic : Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change, timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    IoAcceptor acceptor = sshDaemon.getIoAcceptor();
    if (acceptor == null) {
        throw new Failure(1, "fatal: sshd no longer running");
    }
    for (String sessionId : sessionIds) {
        boolean connectionFound = false;
        int id = (int) Long.parseLong(sessionId, 16);
        for (final IoSession io : acceptor.getManagedSessions().values()) {
            ServerSession serverSession = (ServerSession) ServerSession.getSession(io, true);
            SshSession sshSession = serverSession != null ? serverSession.getAttribute(SshSession.KEY) : null;
            if (sshSession.getSessionId() == id) {
                connectionFound = true;
                stdout.println("closing connection " + sessionId + "...");
                io.close(true);
                break;
            }
        }
        if (!connectionFound) {
            stderr.print("close connection " + id + ": no such connection\n");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    IoAcceptor acceptor = sshDaemon.getIoAcceptor();
    if (acceptor == null) {
        throw new Failure(1, "fatal: sshd no longer running");
    }
    for (String sessionId : sessionIds) {
        boolean connectionFound = false;
        int id = (int) Long.parseLong(sessionId, 16);
        for (IoSession io : acceptor.getManagedSessions().values()) {
            ServerSession serverSession = (ServerSession) ServerSession.getSession(io, true);
            SshSession sshSession = serverSession != null ? serverSession.getAttribute(SshSession.KEY) : null;
            if (sshSession != null && sshSession.getSessionId() == id) {
                connectionFound = true;
                stdout.println("closing connection " + sessionId + "...");
                IoCloseFuture future = io.close(true);
                if (wait) {
                    try {
                        future.await();
                        stdout.println("closed connection " + sessionId);
                    } catch (InterruptedException e) {
                        log.warn("Wait for connection to close interrupted: " + e.getMessage());
                    }
                }
                break;
            }
        }
        if (!connectionFound) {
            stderr.print("close connection " + sessionId + ": no such connection\n");
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    if (submitWholeTopic && !topic.isEmpty()) {
        ReviewDb db = dbProvider.get();
        ResultSet<Change> changesByTopic = null;
        try {
            changesByTopic = db.changes().byTopic(topic);
        } catch (OrmException e1) {
            // TODO(sbeller): Auto-generated catch block,
            e1.printStackTrace();
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.toList().size()));
        boolean visibility = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
        Project.NameKey previousProject = resource.getChange().getProject();
        for (Change c : changesByTopic) {
            ChangeControl changeControl = null;
            if (c.getProject().equals(previousProject)) {
                // Avoid calling changeControlFactory all the time as it is quite costly.
                changeControl = resource.getControl().getProjectControl().controlFor(c);
            } else {
                try {
                    changeControl = changeControlFactory.controlFor(c, resource.getUser());
                } catch (NoSuchChangeException e) {
                    visibility = false;
                // todo also log/tell the user
                }
                previousProject = changeControl.getChange().getProject();
            }
            if (changeControl != null) {
                visibility &= changeControl.canSubmit();
            }
        }
        return new UiAction.Description().setLabel(labelSubmitTopic).setTitle(Strings.emptyToNull(titlePatternSubmitTopic.replace(params))).setVisible(visibility);
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private Change submitToDatabase(ReviewDb db, Change change, final Timestamp timestamp) throws OrmException {
    return db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setStatus(Change.Status.SUBMITTED);
                change.setLastUpdatedOn(timestamp);
                return change;
            }
            return null;
        }
    });
}
#method_after
private Change submitToDatabase(ReviewDb db, Change.Id changeId, final Timestamp timestamp) throws OrmException {
    return db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setStatus(Change.Status.SUBMITTED);
                change.setLastUpdatedOn(timestamp);
                return change;
            }
            return null;
        }
    });
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        if (submitWholeTopic) {
            String topic = change.getTopic();
            ResultSet<Change> changes = db.changes().byTopic(topic);
            for (Change c : changes) {
                c = submitToDatabase(db, c, timestamp);
                if (c == null) {
                    return null;
                }
            }
        } else {
            change = submitToDatabase(db, change, timestamp);
            if (change == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (submitWholeTopic) {
        for (Change c : db.changes().byTopic(change.getTopic())) {
            indexer.index(db, c);
        }
    } else {
        indexer.index(db, change);
    }
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    if (submitWholeTopic) {
        return submitWholeTopic(rsrc, caller, force);
    } else {
        return submitThisChange(rsrc, caller, force);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.get().apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query, int limit) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(query);
        mySuggestReviewers.setLimit(limit);
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    return new SuggestedReviewersRequest() {

        @Override
        public List<SuggestedReviewerInfo> get() throws RestApiException {
            return ChangeApiImpl.this.suggestReviewers(this);
        }
    };
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(query);
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    return suggestReviewers().withQuery(query);
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return ChangeInfoMapper.INSTANCE.apply(changeJson.get().addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.get().addOptions(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.allOf(ListChangesOption.class));
}
#method_after
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.complementOf(EnumSet.of(ListChangesOption.CHECK)));
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.accounts", value = "false")
public void suggestReviewersNoResult1() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfig(name = "suggest.accounts", value = "false")
public void suggestReviewersNoResult1() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.accounts", value = "true"), @GerritConfig(name = "suggest.from", value = "1"), @GerritConfig(name = "accounts.visibility", value = "NONE") })
public void suggestReviewersNoResult2() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.accounts", value = "true"), @GerritConfig(name = "suggest.from", value = "1"), @GerritConfig(name = "accounts.visibility", value = "NONE") })
public void suggestReviewersNoResult2() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.from", value = "2")
public void suggestReviewersNoResult3() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfig(name = "suggest.from", value = "2")
public void suggestReviewersNoResult3() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
public void suggestReviewersChange() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 6);
    reviewers = suggestReviewers(changeId, "u", 5);
    assertEquals(reviewers.size(), 5);
    reviewers = suggestReviewers(changeId, "users3", 10);
    assertEquals(reviewers.size(), 1);
}
#method_after
@Test
public void suggestReviewersChange() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, "u", 5);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, "users3", 10);
    assertThat(reviewers).hasSize(1);
}
#end_block

#method_before
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersSameGroupVisibility() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertTrue(reviewers.isEmpty());
    reviewers = suggestReviewers(new RestSession(server, user2), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
    reviewers = suggestReviewers(new RestSession(server, user3), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
}
#method_after
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersSameGroupVisibility() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).isEmpty();
    reviewers = suggestReviewers(new RestSession(server, user2), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
    reviewers = suggestReviewers(new RestSession(server, user3), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
}
#end_block

#method_before
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersViewAllAccounts() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertTrue(reviewers.isEmpty());
    grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
}
#method_after
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersViewAllAccounts() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).isEmpty();
    grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2")
public void suggestReviewersMaxNbrSuggestions() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5);
    assertEquals(2, reviewers.size());
}
#method_after
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2")
public void suggestReviewersMaxNbrSuggestions() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5);
    assertThat(reviewers).hasSize(2);
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.fullTextSearch", value = "true")
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5);
    assertEquals(4, reviewers.size());
}
#method_after
@Test
@GerritConfig(name = "suggest.fullTextSearch", value = "true")
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5);
    assertThat(reviewers).hasSize(4);
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.fulltextsearch", value = "true"), @GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") })
public void suggestReviewersFullTextSearchLimitMaxMatches() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3);
    assertEquals(2, reviewers.size());
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.fulltextsearch", value = "true"), @GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") })
public void suggestReviewersFullTextSearchLimitMaxMatches() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3);
    assertThat(reviewers).hasSize(2);
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query, int limit) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = SUGGESTED_REVIEWER_INFO_ORDERING.sortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = ORDERING.immutableSortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#end_block

#method_before
private VisibilityControl getVisibility(final ChangeResource rsrc) {
    if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account account) throws OrmException {
                return true;
            }
        };
    } else {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account account) throws OrmException {
                IdentifiedUser who = identifiedUserFactory.create(dbProvider, account.getId());
                // to drafts
                return rsrc.getControl().forUser(who).isRefVisible();
            }
        };
    }
}
#method_after
private VisibilityControl getVisibility(final ChangeResource rsrc) {
    if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account.Id account) throws OrmException {
                return true;
            }
        };
    } else {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account.Id account) throws OrmException {
                IdentifiedUser who = identifiedUserFactory.create(dbProvider, account);
                // to drafts
                return rsrc.getControl().forUser(who).isRefVisible();
            }
        };
    }
}
#end_block

#method_before
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    LinkedHashMap<Account.Id, AccountInfo> r = Maps.newLinkedHashMap();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl);
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                AccountInfo info = new AccountInfo(p.getId());
                addSuggestion(r, p, info, visibilityControl);
            }
        }
    }
    return Lists.newArrayList(r.values());
}
#method_after
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> r = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    if (addSuggestion(r, p.getId(), visibilityControl)) {
                        queryEmail.put(e.getAccountId(), e.getEmailAddress());
                    }
                }
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        AccountInfo info = r.get(p.getKey());
        if (info != null) {
            info.email = p.getValue();
        }
    }
    return new ArrayList<>(r.values());
}
#end_block

#method_before
private List<AccountInfo> suggestAccountFullTextSearch(VisibilityControl visibilityControl) throws OrmException {
    String str = query.toLowerCase();
    LinkedHashMap<Account.Id, AccountInfo> accountMap = Maps.newLinkedHashMap();
    List<Account> fullNameMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches);
    List<Account> emailMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches);
    for (Account a : reviewerSuggestionCache.get()) {
        if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) {
            fullNameMatches.add(a);
        } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) {
            emailMatches.add(a);
        }
        if (fullNameMatches.size() >= fullTextMaxMatches) {
            break;
        }
    }
    for (Account a : fullNameMatches) {
        addSuggestion(accountMap, a, new AccountInfo(a.getId()), visibilityControl);
        if (accountMap.size() >= limit) {
            break;
        }
    }
    if (accountMap.size() < limit) {
        for (Account a : emailMatches) {
            addSuggestion(accountMap, a, new AccountInfo(a.getId()), visibilityControl);
            if (accountMap.size() >= limit) {
                break;
            }
        }
    }
    return Lists.newArrayList(accountMap.values());
}
#method_after
private List<AccountInfo> suggestAccountFullTextSearch(VisibilityControl visibilityControl) throws OrmException {
    String str = query.toLowerCase();
    Map<Account.Id, AccountInfo> accountMap = new LinkedHashMap<>();
    List<Account> fullNameMatches = new ArrayList<>(fullTextMaxMatches);
    List<Account> emailMatches = new ArrayList<>(fullTextMaxMatches);
    for (Account a : reviewerSuggestionCache.get()) {
        if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) {
            fullNameMatches.add(a);
        } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) {
            emailMatches.add(a);
        }
        if (fullNameMatches.size() >= fullTextMaxMatches) {
            break;
        }
    }
    for (Account a : fullNameMatches) {
        addSuggestion(accountMap, a.getId(), visibilityControl);
        if (accountMap.size() >= limit) {
            break;
        }
    }
    if (accountMap.size() < limit) {
        for (Account a : emailMatches) {
            addSuggestion(accountMap, a.getId(), visibilityControl);
            if (accountMap.size() >= limit) {
                break;
            }
        }
    }
    accountLoader.fill();
    return Lists.newArrayList(accountMap.values());
}
#end_block

#method_before
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account.getId()) && account.isActive() && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControlFactory.get().canSee(account)) {
        map.put(account.getId(), info);
    }
}
#method_after
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account.Id account, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account) && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControl.canSee(account)) {
        map.put(account, accountLoader.get(account));
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account)) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#method_after
private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws SQLException, OrmException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    String table = "changes";
    try (StatementExecutor e = newExecutor(db)) {
        for (String index : dialect.listIndexes(schema.getConnection(), table)) {
            if (index.startsWith("changes_")) {
                dialect.dropIndex(e, table, index);
            }
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws SQLException, OrmException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    Map<String, OrmException> errors = new HashMap<>();
    try (StatementExecutor e = newExecutor(db)) {
        for (String index : listChangesIndexes(schema)) {
            ui.message("Dropping index " + index + " on table " + TABLE);
            try {
                dialect.dropIndex(e, TABLE, index);
            } catch (OrmException err) {
                errors.put(index, err);
            }
        }
    }
    for (String index : listChangesIndexes(schema)) {
        String msg = "Failed to drop index " + index;
        OrmException err = errors.get(index);
        if (err != null) {
            msg += ": " + err.getMessage();
        }
        ui.message(msg);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeEditApi.get(revision, path, new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group2.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    });
    group2.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            content = null;
        }
    });
    group1.done();
    group2.done();
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            content = null;
        }
    });
    group1.done();
    group2.done();
    group3.done();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style);
    reviewers.init(style, ccText);
    hashtags.init(style);
    initReplyButton();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style);
    reviewers.init(style, ccText);
    hashtags.init(style);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
private void initReplyButton() {
    reply.setTitle(Gerrit.getConfig().getReplyTitle());
    reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getConfig().getReplyLabel()).closeDiv());
}
#method_after
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).is_edit()) {
        reply.setTitle(Gerrit.getConfig().getReplyTitle());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getConfig().getReplyLabel()).closeDiv());
        reply.setVisible(true);
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            reply.setVisible(editMode.isVisible());
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            reply.setVisible(true);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    reply.setVisible(false);
    addFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    reply.setVisible(true);
    addFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
public void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (addBox == null) {
        addBox = new AddFileBox(changeId, revision);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(addButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(addBox);
    p.showRelativeTo(addButton);
    GlobalKey.dialog(p);
    addBox.setFocus(true);
    popup = p;
}
#method_after
public void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (addBox == null) {
        addBox = new AddFileBox(changeId, revision);
    }
    addBox.clearPath();
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(addButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(addBox);
    p.showRelativeTo(addButton);
    GlobalKey.dialog(p);
    addBox.setFocus(true);
    popup = p;
}
#end_block

#method_before
@UiHandler("open")
void onOpen(@SuppressWarnings("unused") ClickEvent e) {
    hide();
    Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(changeId, revision._number()), path.getText()));
}
#method_after
@UiHandler("open")
void onOpen(@SuppressWarnings("unused") ClickEvent e) {
    open(path.getText());
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    path.setText("");
    hide();
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    hide();
}
#end_block

#method_before
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.setOption("keyMap", "vim_ro");
    cm.focus();
}
#method_after
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    CallbackGroup group = new CallbackGroup();
    if (prefs.syntaxHighlighting() && !Patch.COMMIT_MSG.equals(path)) {
        final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
        ChangeFileApi.getContentType(revision, path, cmGroup.add(new GerritCallback<String>() {

            @Override
            public void onSuccess(String result) {
                type = result;
                injectMode(result, modeInjectorCb);
            }
        }));
    }
    cmGroup.done();
    ChangeApi.detail(revision.getParentKey().get(), group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }
    }));
    ChangeFileApi.getContentOrMessage(revision, path, group.addFinal(new ScreenLoadCallback<String>(this) {

        @Override
        protected void preDisplay(String content) {
            setShowTabs(prefs.showTabs());
            initEditor(content);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    final CallbackGroup group = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (prefs.syntaxHighlighting() && !Patch.COMMIT_MSG.equals(path)) {
        final AsyncCallback<Void> modeInjectorCb = group.addEmpty();
        ChangeFileApi.getContentType(revision, path, cmGroup.add(new GerritCallback<String>() {

            @Override
            public void onSuccess(String result) {
                ModeInfo mode = ModeInfo.findMode(result, path);
                type = mode != null ? mode.mime() : null;
                injectMode(result, modeInjectorCb);
            }
        }));
    }
    cmGroup.done();
    ChangeApi.detail(revision.getParentKey().get(), group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }
    }));
    ChangeFileApi.getContentOrMessage(revision, path, group.addFinal(new ScreenLoadCallback<String>(this) {

        @Override
        protected void preDisplay(String content) {
            initEditor(content);
        }
    }));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            adjustCodeMirrorHeight();
        }
    });
    closeHandler = Window.addWindowClosingHandler(new ClosingHandler() {

        @Override
        public void onWindowClosing(ClosingEvent event) {
            if (!cm.isClean(generation)) {
                event.setMessage(EditConstants.I.closeUnsavedChanges());
            }
        }
    });
    generation = cm.changeGeneration(true);
    save.setEnabled(false);
    cm.on(new ChangesHandler() {

        @Override
        public void handle(CodeMirror cm) {
            save.setEnabled(!cm.isClean(generation));
        }
    });
    adjustCodeMirrorHeight();
    setLineLength(prefs.lineLength());
    cm.refresh();
    cm.focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            cm.adjustHeight(header.getOffsetHeight());
        }
    });
    closeHandler = Window.addWindowClosingHandler(new ClosingHandler() {

        @Override
        public void onWindowClosing(ClosingEvent event) {
            if (!cm.isClean(generation)) {
                event.setMessage(EditConstants.I.closeUnsavedChanges());
            }
        }
    });
    generation = cm.changeGeneration(true);
    save.setEnabled(false);
    cm.on(new ChangesHandler() {

        @Override
        public void handle(CodeMirror cm) {
            save.setEnabled(!cm.isClean(generation));
        }
    });
    cm.adjustHeight(header.getOffsetHeight());
    cm.on("cursorActivity", updateCursorPosition());
    cm.extras().showTabs(prefs.showTabs());
    cm.extras().lineLength(prefs.lineLength());
    cm.refresh();
    cm.focus();
    updateActiveLine();
}
#end_block

#method_before
@UiHandler("save")
void onSave(@SuppressWarnings("unused") ClickEvent e) {
    if (cm.isClean(generation)) {
        upToChange();
        return;
    }
    ChangeFileApi.putContentOrMessage(revision, path, cm.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            upToChange();
        }
    });
}
#method_after
@UiHandler("save")
void onSave(@SuppressWarnings("unused") ClickEvent e) {
    save().run();
}
#end_block

#method_before
private void initEditor(String content) {
    String mode = prefs.syntaxHighlighting() ? ModeInjector.getContentType(type) : null;
    cm = CodeMirror.create(editor, Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", mode));
    cm.addKeyMap(KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save()));
    cm.setValue(content);
    columnMargin = DOM.createDiv();
    columnMargin.setClassName(style.columnMargin());
    cm.mover().appendChild(columnMargin);
}
#method_after
private void initEditor(String content) {
    ModeInfo mode = prefs.syntaxHighlighting() ? ModeInfo.findMode(type, path) : null;
    cm = CodeMirror.create(editor, Configuration.create().set("value", content).set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", mode != null ? mode.mode() : null));
    cm.addKeyMap(KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save()));
}
#end_block

#method_before
public static Config newDefaultConfig() {
    Config cfg = new Config();
    cfg.setEnum("auth", null, "type", AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setString("gerrit", null, "allProjects", "Test-Projects");
    cfg.setString("user", null, "name", "Gerrit Code Review");
    cfg.setString("user", null, "email", "gerrit@localhost");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setString("cache", null, "directory", null);
    return cfg;
}
#method_after
public static Config newDefaultConfig() {
    Config cfg = new Config();
    cfg.setEnum("auth", null, "type", AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setString("gerrit", null, "allProjects", "Test-Projects");
    cfg.setString("user", null, "name", "Gerrit Code Review");
    cfg.setString("user", null, "email", "gerrit@localhost");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setString("cache", null, "directory", null);
    cfg.setString("index", null, "type", "lucene");
    cfg.setBoolean("index", "lucene", "testInmemory", true);
    cfg.setInt("index", "lucene", "testVersion", 4);
    return cfg;
}
#end_block

#method_before
@Override
protected void configure() {
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    install(new SchemaVersion.Module());
    bind(File.class).annotatedWith(SitePath.class).toInstance(new File("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    try {
        bind(SocketAddress.class).annotatedWith(RemotePeer.class).toInstance(new InetSocketAddress(InetAddress.getLocalHost(), 1234));
    } catch (UnknownHostException e) {
        throw newProvisionException(e);
    }
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(InMemoryDatabase.class);
    bind(ChangeHooks.class).to(DisabledChangeHooks.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new SmtpEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new MergeabilityChecksExecutorModule());
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
}
#method_after
@Override
protected void configure() {
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    install(new SchemaVersion.Module());
    bind(File.class).annotatedWith(SitePath.class).toInstance(new File("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toInstance(new InetSocketAddress(InetAddresses.forString("127.0.0.1"), 1234));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(InMemoryDatabase.class);
    bind(ChangeHooks.class).to(DisabledChangeHooks.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new SmtpEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new MergeabilityChecksExecutorModule());
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeQueryRewriter.class).to(IndexRewriteImpl.class);
    bind(IndexRewriteImpl.BasicRewritesImpl.class);
    bind(IndexCollection.class);
    listener().to(IndexCollection.class);
    install(new FactoryModuleBuilder().implement(ChangeIndexer.class, ChangeIndexerImpl.class).build(ChangeIndexer.Factory.class));
    if (indexExecutor != null) {
        bind(ListeningExecutorService.class).annotatedWith(IndexExecutor.class).toInstance(indexExecutor);
    } else {
        install(new IndexExecutorModule(threads));
    }
}
#method_after
@Override
protected void configure() {
    bind(ChangeQueryRewriter.class).to(IndexRewriteImpl.class);
    bind(BasicChangeRewrites.class);
    bind(IndexCollection.class);
    listener().to(IndexCollection.class);
    install(new FactoryModuleBuilder().implement(ChangeIndexer.class, ChangeIndexerImpl.class).build(ChangeIndexer.Factory.class));
    if (indexExecutor != null) {
        bind(ListeningExecutorService.class).annotatedWith(IndexExecutor.class).toInstance(indexExecutor);
    } else {
        install(new IndexExecutorModule(threads));
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = luceneModule != null ? luceneModule : new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setTestChangeMerge(cfg.getBoolean("changeMerge", "test", false));
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
private void setForOpenChange(final ChangeInfo info, final String revision) {
    relatedChangesTab = createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip());
    ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new AsyncCallback<RelatedInfo>() {

        @Override
        public void onSuccess(RelatedInfo result) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(result.changes().length()));
            relatedChangesTab.setChanges(info.project(), revision, result.changes());
        }

        @Override
        public void onFailure(Throwable err) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(Resources.C.notAvailable()));
            relatedChangesTab.setError(err.getMessage());
        }
    });
    if (info.mergeable()) {
        StringBuilder conflictsQuery = new StringBuilder();
        conflictsQuery.append("status:open");
        conflictsQuery.append(" is:mergeable");
        conflictsQuery.append(" ").append(op("conflicts", info.legacy_id().get()));
        ChangeList.query(conflictsQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                JsArray<ChangeAndCommit> changes = convertChangeList(result);
                if (changes.length() > 0) {
                    getTab().setTitle(Resources.M.conflictingChanges(changes.length()));
                    getTab().setChanges(info.project(), revision, changes);
                }
            }

            @Override
            public void onFailure(Throwable err) {
                getTab().setTitle(Resources.M.conflictingChanges(Resources.C.notAvailable()));
                getTab().setError(err.getMessage());
            }

            private RelatedChangesTab getTab() {
                if (conflictingChangesTab == null) {
                    conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip());
                }
                return conflictingChangesTab;
            }
        });
    }
}
#method_after
private void setForOpenChange(final ChangeInfo info, final String revision) {
    ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new AsyncCallback<RelatedInfo>() {

        @Override
        public void onSuccess(RelatedInfo result) {
            if (result.changes().length() > 0) {
                getTab().setTitle(Resources.M.relatedChanges(result.changes().length()));
                getTab().setChanges(info.project(), revision, result.changes());
            }
        }

        @Override
        public void onFailure(Throwable err) {
            getTab().setTitle(Resources.M.relatedChanges(Resources.C.notAvailable()));
            getTab().setError(err.getMessage());
        }

        private RelatedChangesTab getTab() {
            if (relatedChangesTab == null) {
                relatedChangesTab = createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip());
            }
            return relatedChangesTab;
        }
    });
    if (info.mergeable()) {
        StringBuilder conflictsQuery = new StringBuilder();
        conflictsQuery.append("status:open");
        conflictsQuery.append(" is:mergeable");
        conflictsQuery.append(" ").append(op("conflicts", info.legacy_id().get()));
        ChangeList.query(conflictsQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                JsArray<ChangeAndCommit> changes = convertChangeList(result);
                if (changes.length() > 0) {
                    getTab().setTitle(Resources.M.conflictingChanges(changes.length()));
                    getTab().setChanges(info.project(), revision, changes);
                }
            }

            @Override
            public void onFailure(Throwable err) {
                getTab().setTitle(Resources.M.conflictingChanges(Resources.C.notAvailable()));
                getTab().setError(err.getMessage());
            }

            private RelatedChangesTab getTab() {
                if (conflictingChangesTab == null) {
                    conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip());
                }
                return conflictingChangesTab;
            }
        });
    }
}
#end_block

#method_before
public void run() {
    ui.header("Index");
    boolean upgrading = !site.isNew && index.get("type") == null;
    index.select("Type", "type", IndexType.LUCENE);
    if (upgrading) {
        ui.message("The index must be rebuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path");
    }
}
#method_after
public void run() throws IOException {
    ui.header("Index");
    IndexType type = index.select("Type", "type", IndexType.LUCENE);
    if (site.isNew && type == IndexType.LUCENE) {
        createLuceneIndex();
    } else {
        ui.message("The index must be built before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n");
        initFlags.autoStart = false;
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (!allowFileRegex) {
            args.indexes.getSearchIndex();
        }
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    index = new FakeIndex(FakeIndex.V2);
    indexes = new IndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new IndexRewriteImpl(indexes, null, new IndexRewriteImpl.BasicRewritesImpl(null, indexes));
}
#method_after
@Before
public void setUp() throws Exception {
    index = new FakeIndex(FakeIndex.V2);
    indexes = new IndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new IndexRewriteImpl(indexes, null, new BasicChangeRewrites(null, indexes));
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public void setLimit(int n) {
    limit = n;
}
#method_after
public void setLimit(int n) {
    limitFromCaller = n;
}
#end_block

#method_before
public List<List<ChangeData>> queryChanges(List<String> queries) throws OrmException, QueryParseException {
    final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = Lists.newArrayListWithCapacity(cnt);
    List<ChangeDataSource> sources = Lists.newArrayListWithCapacity(cnt);
    for (String query : queries) {
        Predicate<ChangeData> q = parseQuery(query, visibleToMe);
        Predicate<ChangeData> s = queryRewriter.rewrite(q, start);
        if (!(s instanceof ChangeDataSource)) {
            q = Predicate.and(queryBuilder.status_open(), q);
            s = queryRewriter.rewrite(q, start);
        }
        if (!(s instanceof ChangeDataSource)) {
            throw new QueryParseException("invalid query: " + s);
        }
        // Don't trust QueryRewriter to have left the visible predicate.
        AndSource a = new AndSource(ImmutableList.of(s, visibleToMe), start);
        limits.add(limit(q));
        sources.add(a);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<ChangeData>> matches = Lists.newArrayListWithCapacity(cnt);
    for (ChangeDataSource s : sources) {
        matches.add(s.read());
    }
    List<List<ChangeData>> out = Lists.newArrayListWithCapacity(cnt);
    for (int i = 0; i < cnt; i++) {
        List<ChangeData> results = matches.get(i).toList();
        if (results.size() > maxLimit) {
            moreResults = true;
        }
        int limit = limits.get(i);
        if (limit < results.size()) {
            results = results.subList(0, limit);
        }
        out.add(results);
    }
    return out;
}
#method_after
public QueryResult queryChanges(Predicate<ChangeData> query) throws OrmException, QueryParseException {
    return queryChanges(ImmutableList.of(query)).get(0);
}
#end_block

#method_before
boolean isDisabled() {
    return maxLimit <= 0;
}
#method_after
boolean isDisabled() {
    return permittedLimit <= 0;
}
#end_block

#method_before
private Iterable<ChangeData> queryRecentChanges(int limit) throws OrmException {
    QueryProcessor qp = queryProcessor.get();
    qp.setLimit(limit);
    String query = "project:{" + projectName + "} is:open";
    try {
        return Iterables.limit(queryProcessor.get().queryChanges(query), limit);
    } catch (QueryParseException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
private Iterable<ChangeData> queryRecentChanges(int limit) throws OrmException {
    QueryProcessor qp = queryProcessor.get();
    qp.setLimit(limit);
    ChangeQueryBuilder qb = qp.getQueryBuilder();
    Predicate<ChangeData> p = Predicate.and(qb.project(projectName.get()), qb.status_open());
    try {
        return qp.queryChanges(p).changes();
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return false;
        }
    } catch (Exception e) {
        log.warn(String.format("Could not determine visibility for project '%s'!", project));
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#method_after
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db.get(), gerritServerConfig, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db.get(), rsrc.getChange()), false, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = eval(evaluator);
    } catch (RuleEvalException | RuleEvalTimeoutException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).canSubmit();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private List<Term> evaluateImpl() throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProjectName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm.isList()) {
            r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    ProjectState projectState = projectControl.getProjectState();
    PrologEnvironment env;
    try {
        if (rulesInputStream == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", rulesInputStream);
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, changeControl);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env) throws RuleEvalException {
    ProjectState projectState = projectControl.getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (fastEvalLabels) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (fastEvalLabels) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
public Term getSubmitRule() {
    return submitRule;
}
#method_after
public Term getSubmitRule() {
    checkState(submitRule != null, "getSubmitRule() invalid before evaluation");
    return submitRule;
}
#end_block

#method_before
private String getProjectName() {
    if (projectName == null) {
        projectName = projectControl.getProjectState().getProject().getName();
    }
    return projectName;
}
#method_after
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException {
    PatchSet.Id basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet().getId();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = Objects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
public String getContentType(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            return registry.getMimeType(path, Text.asByteArray(repo.open(tw.getObjectId(0)))).toString();
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public String getContentType(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectReader reader = repo.newObjectReader();
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            ObjectLoader blobLoader = reader.open(tw.getObjectId(0), OBJ_BLOB);
            byte[] raw = blobLoader.isLarge() ? null : blobLoader.getCachedBytes();
            return registry.getMimeType(path, raw).toString();
        } finally {
            reader.release();
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessage expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessageException expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    for (int i = 1; i < args.length; i++) {
        commandName = commandName + "." + args[i];
    }
    return commandName;
}
#method_after
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    for (String arg : dcmd.getArguments()) {
        commandName = commandName + "." + arg;
    }
    return commandName;
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
private Resource useDeveloperBuild(ServletContextHandler app) throws IOException {
    final File dir = GerritLauncher.getDeveloperBuckOut();
    final File gen = new File(dir, "gen");
    final File root = dir.getParentFile();
    final File dstwar = makeWarTempDir();
    File ui = new File(dstwar, "gerrit_ui");
    File p = new File(ui, "permutations");
    mkdir(ui);
    p.createNewFile();
    p.deleteOnExit();
    app.addFilter(new FilterHolder(new Filter() {

        private final boolean gwtuiRecompile = System.getProperty("gerrit.disable-gwtui-recompile") == null;

        private final UserAgentRule rule = new UserAgentRule();

        private final Map<String, Boolean> uaInitialized = new HashMap<>();

        private String lastTarget;

        private long lastTime;

        @Override
        public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            String pkg = "gerrit-gwtui";
            String target = "ui_" + rule.select((HttpServletRequest) request);
            if (gwtuiRecompile || uaInitialized.get(target) == null) {
                String rule = "//" + pkg + ":" + target;
                // TODO(davido): instead of assuming specific Buck's internal
                // target directory for gwt_binary() artifacts, ask Buck for
                // the location of user agent permutation GWT zip, e. g.:
                // $ buck targets --show_output //gerrit-gwtui:ui_safari \
                // | awk '{print $2}'
                String child = String.format("%s/__gwt_binary_%s__", pkg, target);
                File zip = new File(new File(gen, child), target + ".zip");
                synchronized (this) {
                    try {
                        build(root, gen, rule);
                    } catch (BuildFailureException e) {
                        displayFailure(rule, e.why, (HttpServletResponse) res);
                        return;
                    }
                    if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                        lastTarget = target;
                        lastTime = zip.lastModified();
                        unpack(zip, dstwar);
                    }
                }
                if (uaInitialized.get(target) == null) {
                    uaInitialized.put(target, Boolean.TRUE);
                }
            }
            chain.doFilter(request, res);
        }

        private void displayFailure(String rule, byte[] why, HttpServletResponse res) throws IOException {
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setContentType("text/html");
            res.setCharacterEncoding(Charsets.UTF_8.name());
            CacheHeaders.setNotCacheable(res);
            Escaper html = HtmlEscapers.htmlEscaper();
            PrintWriter w = res.getWriter();
            w.write("<html><title>BUILD FAILED</title><body>");
            w.format("<h1>%s FAILED</h1>", html.escape(rule));
            w.write("<pre>");
            w.write(html.escape(RawParseUtils.decode(why)));
            w.write("</pre>");
            w.write("</body></html>");
            w.close();
        }

        @Override
        public void init(FilterConfig config) {
        }

        @Override
        public void destroy() {
        }
    }), "/", EnumSet.of(DispatcherType.REQUEST));
    return Resource.newResource(dstwar.toURI());
}
#method_after
private Resource useDeveloperBuild(ServletContextHandler app) throws IOException {
    final File dir = GerritLauncher.getDeveloperBuckOut();
    final File gen = new File(dir, "gen");
    final File root = dir.getParentFile();
    final File dstwar = makeWarTempDir();
    File ui = new File(dstwar, "gerrit_ui");
    File p = new File(ui, "permutations");
    mkdir(ui);
    p.createNewFile();
    p.deleteOnExit();
    app.addFilter(new FilterHolder(new Filter() {

        private final boolean gwtuiRecompile = System.getProperty("gerrit.disable-gwtui-recompile") == null;

        private final UserAgentRule rule = new UserAgentRule();

        private final Set<String> uaInitialized = new HashSet<>();

        private String lastTarget;

        private long lastTime;

        @Override
        public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            String pkg = "gerrit-gwtui";
            String target = "ui_" + rule.select((HttpServletRequest) request);
            if (gwtuiRecompile || !uaInitialized.contains(target)) {
                String rule = "//" + pkg + ":" + target;
                // TODO(davido): instead of assuming specific Buck's internal
                // target directory for gwt_binary() artifacts, ask Buck for
                // the location of user agent permutation GWT zip, e. g.:
                // $ buck targets --show_output //gerrit-gwtui:ui_safari \
                // | awk '{print $2}'
                String child = String.format("%s/__gwt_binary_%s__", pkg, target);
                File zip = new File(new File(gen, child), target + ".zip");
                synchronized (this) {
                    try {
                        build(root, gen, rule);
                    } catch (BuildFailureException e) {
                        displayFailure(rule, e.why, (HttpServletResponse) res);
                        return;
                    }
                    if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                        lastTarget = target;
                        lastTime = zip.lastModified();
                        unpack(zip, dstwar);
                    }
                }
                uaInitialized.add(target);
            }
            chain.doFilter(request, res);
        }

        private void displayFailure(String rule, byte[] why, HttpServletResponse res) throws IOException {
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setContentType("text/html");
            res.setCharacterEncoding(Charsets.UTF_8.name());
            CacheHeaders.setNotCacheable(res);
            Escaper html = HtmlEscapers.htmlEscaper();
            PrintWriter w = res.getWriter();
            w.write("<html><title>BUILD FAILED</title><body>");
            w.format("<h1>%s FAILED</h1>", html.escape(rule));
            w.write("<pre>");
            w.write(html.escape(RawParseUtils.decode(why)));
            w.write("</pre>");
            w.write("</body></html>");
            w.close();
        }

        @Override
        public void init(FilterConfig config) {
        }

        @Override
        public void destroy() {
        }
    }), "/", EnumSet.of(DispatcherType.REQUEST));
    return Resource.newResource(dstwar.toURI());
}
#end_block

#method_before
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not supported");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException {
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            if (prevEdit.getFullMessage().equals(msg)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException {
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    RevCommit prevEdit = edit.getEditCommit();
    if (prevEdit.getParentCount() == 0) {
        throw new InvalidChangeOperationException("Modify edit against root commit not supported");
    }
    if (prevEdit.getFullMessage().equals(msg)) {
        throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            String refName = edit.getRefName();
            ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, byte[] content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, content);
}
#method_after
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, RawInput content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, content);
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, repo, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not supported");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, toBlob(inserter, content), base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, Repository repo, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, byte[] content, RevCommit base) throws IOException, InvalidChangeOperationException {
    DirCache newTree = createTree(reader, prevEdit);
    editTree(op, repo, rw, base, newTree.editor(), ins, fileName, content);
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable final ObjectId content, RevCommit base) throws IOException, InvalidChangeOperationException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    ent.setObjectId(content);
                }
            });
            break;
        case RESTORE_ENTRY:
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree().getId());
            // from the base's parent commit.
            if (tw == null && base.getParentCount() == 1) {
                tw = TreeWalk.forPath(rw.getObjectReader(), fileName, rw.parseCommit(base.getParent(0)).getTree());
            }
            if (tw == null) {
                throw new InvalidChangeOperationException(String.format("cannot restore path %s: missing in base revision %s", fileName, base.abbreviate(8).name()));
            }
            final FileMode mode = tw.getFileMode(0);
            final ObjectId oid = tw.getObjectId(0);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(mode);
                    ent.setObjectId(oid);
                }
            });
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@Test
public void deleteEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.delete(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void deleteEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId())).isFalse();
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void updateExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("Exception expected");
    } catch (InvalidChangeOperationException ex) {
        assertEquals(ex.getMessage(), "New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyMessage(edit.get(), msg));
    edit = editUtil.byChange(change);
    assertEquals(msg, edit.get().getEditCommit().getFullMessage());
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("InvalidChangeOperationException expected");
    } catch (InvalidChangeOperationException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertThat(info.commit.commit).isEqualTo(edit.get().getRevision().get());
    assertThat(info.commit.parents).hasSize(1);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    EditInfo info = toEditInfo(true);
    assertThat(info.files).hasSize(2);
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertThat(l.get(0)).isEqualTo("/COMMIT_MSG");
    assertThat(l.get(1)).isEqualTo("foo");
}
#end_block

#method_before
@Test
public void deleteExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.deleteFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.deleteFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NOT_FOUND, r.getStatusCode());
}
#method_after
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NOT_FOUND);
}
#end_block

#method_before
@Test
public void deleteExistingFileRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFileRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change2, ps2));
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertEquals(RefUpdate.Result.FORCED, modifier.restoreFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertThat(modifier.createEdit(change2, ps2)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertThat(adminSession.post(urlEdit2(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void changeEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void changeEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void emptyPutRequest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.put(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals("".getBytes(), toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void emptyPutRequest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.put(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), "".getBytes());
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertThat(adminSession.post(urlEdit()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    String content = r.getEntityContent();
    assertThat(StringUtils.newStringUtf8(Base64.decodeBase64(content))).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
}
#end_block

#method_before
@Test
public void getFileNotFoundRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void writeNoChanges() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_OLD);
        fail();
    } catch (InvalidChangeOperationException e) {
        assertEquals("no changes were made", e.getMessage());
    }
}
#method_after
@Test
public void writeNoChanges() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_OLD));
        fail();
    } catch (InvalidChangeOperationException e) {
        assertThat(e.getMessage()).isEqualTo("no changes were made");
    }
}
#end_block

#method_before
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/publish_edit";
}
#method_after
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/edit:publish";
}
#end_block

#method_before
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/rebase_edit";
}
#method_after
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/edit:rebase";
}
#end_block

#method_before
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@Override
public void start() {
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "ThreadPoolSize", Runtime.getRuntime().availableProcessors()), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        for (final Project.NameKey name : cache.all()) {
            pool.execute(new Runnable() {

                @Override
                public void run() {
                    cache.get(name);
                }
            });
        }
        pool.shutdown();
    }
}
#method_after
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        pool.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
            }
        });
    }
}
#end_block

#method_before
public void evict(final Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#method_after
@Override
public void evict(final Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#end_block

#method_before
protected void assertApproved(String changeId) throws IOException {
    ChangeInfo c = getChange(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertEquals(1, cr.all.size());
    assertEquals(2, cr.all.get(0).value.intValue());
    assertEquals("Administrator", cr.all.get(0).name);
}
#method_after
protected void assertApproved(String changeId) throws IOException {
    ChangeInfo c = getChange(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertEquals(1, cr.all.size());
    assertEquals(2, cr.all.get(0).value.intValue());
    assertEquals(admin.getId(), new Account.Id(cr.all.get(0)._accountId));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = statusToChangeStatus(in.getStatus());
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#end_block

#method_before
private static void finish(ChangeInfo info) {
    info.id = Joiner.on('~').join(Url.encode(info.project), Url.encode(info.branch), Url.encode(info.changeId));
}
#method_after
static void finish(ChangeInfo info) {
    info.id = Joiner.on('~').join(Url.encode(info.project), Url.encode(info.branch), Url.encode(info.changeId));
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeJson.changeStatusToStatus(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(input.status != null ? Change.Status.forChangeStatus(input.status) : Change.Status.NEW);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = Maps.newHashMap();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup(d.getGroupUUID())) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = Maps.newHashMap();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup(d.getGroupUUID())) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
private void writeAudits(final List<AccountGroupById> toRemoved) throws OrmException {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupsFromGroup(me, toRemoved);
}
#method_after
private void writeAudits(final List<AccountGroupById> toRemoved) {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupsFromGroup(me, toRemoved);
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) {
        if (w.isNotify(type)) {
            projectWatchers.add(w.getAccountId());
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\"", state.getProject().getName(), nc.getName(), nc.getFilter()), e);
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) {
        if (w.isNotify(type)) {
            projectWatchers.add(w.getAccountId());
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\"", state.getProject().getName(), nc.getName(), nc.getFilter()), e);
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private void add(Watchers matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    try {
        if (filterMatch(user, w.getFilter())) {
            matching.bcc.accounts.add(w.getAccountId());
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
}
#method_after
private void add(Watchers matching, NotifyConfig nc) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(null, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        boolean isLimitedUser = !projectControl.canPushBatchChangesWithoutLimitation();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (isLimitedUser && maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(currentUser);
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, FluentIterable.from(Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(new FileUrlMapper()), Objects.firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#method_after
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, FluentIterable.from(Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(new FileUrlMapper()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#end_block

#method_before
private void setDefaultAccess() throws ServletException {
    if (accessFactory == null || resolver == null) {
        String basePath = config.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = config.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(config), config, fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
}
#method_after
private void setDefaultAccess() throws ServletException {
    if (accessFactory == null || resolver == null) {
        String basePath = config.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = config.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(config), config, fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
}
#end_block

#method_before
// We cannot have all user provided commentlinks in one regular expression
// because in these comment links we may have references to groups by number and name.
// To prevent any possible interference between the regular expressions, we use a matcher
public List<Map<String, String>> linkify(HttpServletRequest req, String message) {
    // Because we're relying on 'req' as a dynamic parameter, we need to construct
    // the CommentLinkInfo for ChangeIds on the fly
    String baseGerritUrl = urls.getBaseGerritUrl(req);
    CommentLinkInfo changeIds = new CommentLinkInfo("ChangeIdLinks", changeId, baseGerritUrl + "#/q/$2,n,z", "");
    mCommentLinks.add(changeIds);
    List<Map<String, String>> parsed = Lists.newArrayList();
    parsed.add(ImmutableMap.of("text", message));
    for (CommentLinkInfo clp : mCommentLinks) {
        for (int index = 0; index < parsed.size(); index++) {
            Map<String, String> piece = parsed.get(index);
            if (piece.get("url") == null) {
                List<Map<String, String>> resultingReplacement = clp.replace(piece.get("text"));
                if (resultingReplacement != null) {
                    parsed.remove(index);
                    for (Map<String, String> it : resultingReplacement) {
                        parsed.add(index, it);
                        index++;
                    }
                }
            }
        }
    }
    // remove the ChangeIds CommentLink
    mCommentLinks.remove(mCommentLinks.size() - 1);
    return parsed;
}
#method_after
public List<Map<String, String>> linkify(HttpServletRequest req, String message) {
    List<CommentLinkInfo> operationalCommentLinks = new ArrayList<>(commentLinks);
    // Because we're relying on 'req' as a dynamic parameter, we need to construct
    // the CommentLinkInfo for ChangeIds on the fly.
    String baseGerritUrl = urls.getBaseGerritUrl(req);
    if (baseGerritUrl != null) {
        CommentLinkInfo changeIds = new CommentLinkInfo(CHANGE_ID_PATTERN, baseGerritUrl + "#/q/$0,n,z");
        operationalCommentLinks.add(changeIds);
    }
    List<Map<String, String>> parsed = Lists.newArrayList();
    parsed.add(ImmutableMap.of("text", message));
    for (int index = 0; index < parsed.size(); index++) {
        if (parsed.get(index).get("url") != null) {
            continue;
        }
        Matcher m = allPattern.matcher(parsed.get(index).get("text"));
        if (!m.find()) {
            continue;
        }
        for (CommentLinkInfo cli : operationalCommentLinks) {
            // No need to apply more rules if this is already a link.
            if (parsed.get(index).get("url") != null) {
                break;
            }
            String text = parsed.get(index).get("text");
            parsed.remove(index);
            parsed.addAll(index, cli.linkify(text));
        }
    }
    return parsed;
}
#end_block

#method_before
@Test
public void linkifyMessageChangeId() throws Exception {
    Config config = new Config();
    config.setString("commentlink", "bugzilla", "match", "(bug\\s+#?)(\\d+)");
    config.setString("commentlink", "bugzilla", "link", "http://bugs.example.com/show_bug.cgi?id=$2");
    config.setString("commentlink", "tracker", "match", "([Bb]ug:\\s+)(\\d+)");
    config.setString("commentlink", "tracker", "html", "$1<a href=\"http://trak.example.com/$2\">$2</a>");
    Linkifier l = new Linkifier(TestGitilesUrls.URLS, config);
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "Change-Id: I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), ImmutableMap.of("text", " exists")), l.linkify(REQ, "Change-Id: I0123456789 exists"));
}
#method_after
@Test
public void linkifyMessageChangeId() throws Exception {
    Config config = new Config();
    Linkifier l = new Linkifier(TestGitilesUrls.URLS, config);
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "Change-Id: I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), ImmutableMap.of("text", " exists")), l.linkify(REQ, "Change-Id: I0123456789 exists"));
}
#end_block

#method_before
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    // Change proto.
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    // Approvals.
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    // Changed lines.
    IndexableField added = doc.getField(ADDED_FIELD);
    IndexableField deleted = doc.getField(DELETED_FIELD);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
    // Mergeable.
    cd.setMergeable("1".equals(doc.get(MERGEABLE_FIELD)));
    return cd;
}
#method_after
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    // Change proto.
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    // Approvals.
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    // Changed lines.
    IndexableField added = doc.getField(ADDED_FIELD);
    IndexableField deleted = doc.getField(DELETED_FIELD);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
    // Mergeable.
    String mergeable = doc.get(MERGEABLE_FIELD);
    if ("1".equals(mergeable)) {
        cd.setMergeable(true);
    } else if ("0".equals(mergeable)) {
        cd.setMergeable(false);
    }
    return cd;
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (Values<ChangeData> vs : schema.buildFields(cd, fillArgs)) {
            if (vs.getValues() != null) {
                add(result, vs);
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) {
    Document result = new Document();
    for (Values<ChangeData> vs : schema.buildFields(cd, fillArgs)) {
        if (vs.getValues() != null) {
            add(result, vs);
        }
    }
    return result;
}
#end_block

#method_before
private void add(Document doc, Values<ChangeData> values) throws OrmException {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        @SuppressWarnings("deprecation")
        boolean legacy = values.getField() == ChangeField.LEGACY_UPDATED;
        if (legacy) {
            for (Object value : values.getValues()) {
                int t = queryBuilder.toIndexTimeInMinutes((Timestamp) value);
                doc.add(new IntField(name, (int) t, store));
            }
        } else {
            for (Object value : values.getValues()) {
                doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
            }
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw QueryBuilder.badFieldType(type);
    }
}
#method_after
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        @SuppressWarnings("deprecation")
        boolean legacy = values.getField() == ChangeField.LEGACY_UPDATED;
        if (legacy) {
            for (Object value : values.getValues()) {
                int t = queryBuilder.toIndexTimeInMinutes((Timestamp) value);
                doc.add(new IntField(name, t, store));
            }
        } else {
            for (Object value : values.getValues()) {
                doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
            }
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw QueryBuilder.badFieldType(type);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = (IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#method_after
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new CommentPredicate(args, index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new CommentPredicate(args, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.db, args.projectCache, args.listChildProjects, args.self, name);
}
#method_after
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> f(String file) throws QueryParseException {
    return file(file);
}
#method_after
@Operator
public Predicate<ChangeData> f(String file) {
    return file(file);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        return new RegexPathPredicate(FIELD_FILE, file);
    } else {
        return EqualsFilePredicate.create(args, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) {
    if (file.startsWith("^")) {
        return new RegexPathPredicate(file);
    } else {
        return EqualsFilePredicate.create(args, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> path(String path) throws QueryParseException {
    if (path.startsWith("^")) {
        return new RegexPathPredicate(FIELD_PATH, path);
    } else {
        return new EqualsPathPredicate(FIELD_PATH, path);
    }
}
#method_after
@Operator
public Predicate<ChangeData> path(String path) {
    if (path.startsWith("^")) {
        return new RegexPathPredicate(path);
    } else {
        return new EqualsPathPredicate(FIELD_PATH, path);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new MessagePredicate(args, index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new MessagePredicate(args, index, text);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(file(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(message(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(comment(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(projects(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    try {
        predicates.add(projects(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#end_block

#method_before
public static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#method_after
static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#end_block

#method_before
public boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            Ref ref;
            Repository repo = null;
            try {
                repo = repoManager.openRepository(c.getProject());
                ref = repo.getRef(c.getDest().get());
            } catch (IOException e) {
                throw new OrmException(e);
            } finally {
                if (repo != null) {
                    repo.close();
                }
            }
            SubmitTypeRecord rec = new SubmitRuleEvaluator(this).setUser(userFactory.create(c.getOwner())).getSubmitType();
            if (rec.status != SubmitTypeRecord.Status.OK) {
                throw new OrmException("Error in mergeability check: " + rec.errorMessage);
            }
            String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
            mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref != null ? ref.getObjectId() : ObjectId.zeroId(), rec.type, mergeStrategy, c.getDest());
        }
    }
    return mergeable;
}
#method_after
public boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(c.getProject());
                Ref ref = repo.getRef(c.getDest().get());
                SubmitTypeRecord rec = new SubmitRuleEvaluator(this).getSubmitType();
                if (rec.status != SubmitTypeRecord.Status.OK) {
                    throw new OrmException("Error in mergeability check: " + rec.errorMessage);
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, rec.type, mergeStrategy, c.getDest(), repo, db);
            } catch (IOException e) {
                throw new OrmException(e);
            } finally {
                if (repo != null) {
                    repo.close();
                }
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    return object.isMergeable();
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    return getValue().equals(getField().get(object, args));
}
#end_block

#method_before
public void delete(int cdId) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.delete(cdId);
    }
}
#method_after
public void delete(int id) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.delete(id);
    }
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
@Override
public void delete(int id) throws IOException {
}
#end_block

#method_before
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException {
    List<Change> changes = findChanges(id.encoded());
    if (changes.size() != 1) {
        try {
            changeUtil.deleteChange(Integer.parseInt(id.get()));
        } catch (NumberFormatException | IOException e) {
            throw new ResourceNotFoundException(id.get(), e);
        }
        throw new ResourceNotFoundException(id);
    }
    ChangeControl control;
    try {
        control = changeControlFactory.validateFor(changes.get(0), user.get());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(id);
    }
    return new ChangeResource(control);
}
#method_after
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException {
    List<Change> changes = findChanges(id.encoded());
    if (changes.isEmpty()) {
        Integer changeId = Ints.tryParse(id.get());
        if (changeId != null) {
            try {
                changeIndexer.delete(changeId);
            } catch (IOException e) {
                throw new ResourceNotFoundException(id.get(), e);
            }
        }
    }
    if (changes.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    ChangeControl control;
    try {
        control = changeControlFactory.validateFor(changes.get(0), user.get());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(id);
    }
    return new ChangeResource(control);
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.change().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (OrmException | SolrServerException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.change().getStatus().isOpen()) {
            delete(id, openIndex);
        } else {
            delete(id, closedIndex);
        }
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
@Override
public void delete(int id) throws IOException {
    String idString = Integer.toString(id);
    delete(idString, openIndex);
    delete(idString, closedIndex);
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
private void delete(String id, CloudSolrServer index) throws IOException {
    try {
        index.deleteById(id);
        commit(index);
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void delete(int cdId) throws IOException {
    Term id = QueryBuilder.idTerm(cdId);
    try {
        Futures.allAsList(openIndex.delete(id), closedIndex.delete(id)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void delete(int id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
@Override
public void delete(int id) throws IOException {
}
#end_block

#method_before
private void doAssertApproval(int expected, ChangeInfo c) {
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat((int) cr.defaultValue).isEqualTo(-1);
    assertThat(cr.all.size()).isEqualTo(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value.intValue()).isEqualTo(expected);
}
#method_after
private void doAssertApproval(int expected, ChangeInfo c) {
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat((int) cr.defaultValue).isEqualTo(-1);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value.intValue()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    Q.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    Q.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result.size()).isEqualTo(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result).hasSize(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result.isEmpty()).isFalse();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#end_block

#method_before
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts.isEmpty()).isTrue();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts).isEmpty();
}
#end_block

#method_before
@Test
public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, "refs/for/master").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related.size()).isEqualTo(0);
}
#method_after
@Test
public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, "refs/for/master").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related).isEmpty();
}
#end_block

#method_before
@Test
public void getRelatedLinear() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    for (Commit c : ImmutableList.of(c2, c1)) {
        List<ChangeAndCommit> related = getRelated(getPatchSetId(c));
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + c.getChangeId()).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + c.getChangeId()).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedLinear() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    for (Commit c : ImmutableList.of(c2, c1)) {
        List<ChangeAndCommit> related = getRelated(getPatchSetId(c));
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + c.getChangeId()).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + c.getChangeId()).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedReorder() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    for (PatchSet.Id ps : ImmutableList.of(c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedReorder() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    for (PatchSet.Id ps : ImmutableList.of(c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedReorderAndExtend() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits, create a new commit on top, and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    add(git, "c.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    PatchSet.Id c3ps1 = getPatchSetId(c3);
    for (PatchSet.Id ps : ImmutableList.of(c3ps1, c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedReorderAndExtend() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits, create a new commit on top, and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    add(git, "c.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    PatchSet.Id c3ps1 = getPatchSetId(c3);
    for (PatchSet.Id ps : ImmutableList.of(c3ps1, c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedEdit() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    add(git, "b.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    Change ch2 = getChange(c2);
    editModifier.createEdit(ch2, getPatchSet(ch2));
    String editRev = editUtil.byChange(ch2).get().getRevision().get();
    List<ChangeAndCommit> related = getRelated(ch2.getId(), 0);
    assertThat(related.size()).isEqualTo(3);
    assertThat(related.get(0).changeId).named("related to " + c2.getChangeId()).isEqualTo(c3.getChangeId());
    assertThat(related.get(1).changeId).named("related to " + c2.getChangeId()).isEqualTo(c2.getChangeId());
    assertThat(related.get(1)._revisionNumber.intValue()).named("has edit revision number").isEqualTo(0);
    assertThat(related.get(1).commit.commit).named("has edit revision " + editRev).isEqualTo(editRev);
    assertThat(related.get(2).changeId).named("related to " + c2.getChangeId()).isEqualTo(c1.getChangeId());
}
#method_after
@Test
public void getRelatedEdit() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    add(git, "b.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    Change ch2 = getChange(c2);
    editModifier.createEdit(ch2, getPatchSet(ch2));
    String editRev = editUtil.byChange(ch2).get().getRevision().get();
    List<ChangeAndCommit> related = getRelated(ch2.getId(), 0);
    assertThat(related).hasSize(3);
    assertThat(related.get(0).changeId).named("related to " + c2.getChangeId()).isEqualTo(c3.getChangeId());
    assertThat(related.get(1).changeId).named("related to " + c2.getChangeId()).isEqualTo(c2.getChangeId());
    assertThat(related.get(1)._revisionNumber.intValue()).named("has edit revision number").isEqualTo(0);
    assertThat(related.get(1).commit.commit).named("has edit revision " + editRev).isEqualTo(editRev);
    assertThat(related.get(2).changeId).named("related to " + c2.getChangeId()).isEqualTo(c1.getChangeId());
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Ref ref = git.getRef(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, ref, result.submitType, git);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectCache.get(change.getProject()).getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, other, SubmitType.CHERRY_PICK, git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Ref ref = git.getRef(change.getDest().get());
        boolean refresh = force || isStale(change, ref);
        if (!refresh && !otherBranches) {
            return result;
        }
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        if (refresh) {
            result.mergeable = refresh(change, ps, ref, result.submitType, strategy, git);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, other, CHERRY_PICK, strategy, git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#end_block

#method_before
private boolean refresh(final Change change, final PatchSet ps, final Ref ref, SubmitType type, Repository git) throws OrmException, IOException {
    final boolean mergeable = isMergeable(change, ps, ref, type, git);
    Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change c) {
            if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                c.setMergeable(mergeable);
                c.setLastSha1MergeTested(toRevId(ref));
                return c;
            } else {
                return null;
            }
        }
    });
    if (c != null) {
        indexer.index(db.get(), c);
    }
    return mergeable;
}
#method_after
private boolean refresh(final Change change, final PatchSet ps, final Ref ref, SubmitType type, String strategy, Repository git) throws OrmException, IOException {
    final boolean mergeable = isMergeable(change, ps, ref, type, strategy, git);
    Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change c) {
            if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                c.setMergeable(mergeable);
                c.setLastSha1MergeTested(toRevId(ref));
                return c;
            } else {
                return null;
            }
        }
    });
    if (reindex && c != null) {
        indexer.index(db.get(), c);
    }
    return mergeable;
}
#end_block

#method_before
private boolean isMergeable(Change change, PatchSet ps, Ref ref, SubmitType type, Repository git) {
    ObjectId commit;
    try {
        commit = ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Invalid revision on patch set " + ps);
        return false;
    }
    ObjectId into = ref != null && ref.getObjectId() != null ? ref.getObjectId() : ObjectId.zeroId();
    return cache.load(commit, into, type, change.getDest(), git);
}
#method_after
private boolean isMergeable(Change change, PatchSet ps, Ref ref, SubmitType type, String strategy, Repository git) {
    ObjectId commit;
    try {
        commit = ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Invalid revision on patch set " + ps);
        return false;
    }
    return cache.get(commit, ref, type, strategy, change.getDest(), git, db.get());
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(CACHE_NAME, EntryKey.class, Boolean.class).maximumWeight(1 << 20).weigher(MergeabilityWeigher.class);
            bind(MergeabilityCache.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(CACHE_NAME, EntryKey.class, Boolean.class).maximumWeight(1 << 20).weigher(MergeabilityWeigher.class).loader(Loader.class);
            bind(MergeabilityCache.class);
        }
    };
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof EntryKey) {
        EntryKey k = (EntryKey) o;
        return commit.equals(k.commit) && into.equals(k.into) && submitType == k.submitType;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof EntryKey) {
        EntryKey k = (EntryKey) o;
        return commit.equals(k.commit) && into.equals(k.into) && submitType == k.submitType && mergeStrategy.equals(k.mergeStrategy);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(commit, into, submitType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(commit, into, submitType, mergeStrategy);
}
#end_block

#method_before
private void writeObject(ObjectOutputStream out) throws IOException {
    writeNotNull(out, commit);
    writeNotNull(out, into);
    writeVarInt32(out, submitType.ordinal());
}
#method_after
private void writeObject(ObjectOutputStream out) throws IOException {
    writeNotNull(out, commit);
    writeNotNull(out, into);
    Character c = SUBMIT_TYPES.get(submitType);
    if (c == null) {
        throw new IOException("Invalid submit type: " + submitType);
    }
    out.writeChar(c);
    writeString(out, mergeStrategy);
}
#end_block

#method_before
private void readObject(ObjectInputStream in) throws IOException {
    commit = readNotNull(in);
    into = readNotNull(in);
    submitType = SubmitType.values()[readVarInt32(in)];
}
#method_after
private void readObject(ObjectInputStream in) throws IOException {
    commit = readNotNull(in);
    into = readNotNull(in);
    char t = in.readChar();
    submitType = SUBMIT_TYPES.inverse().get(t);
    if (submitType == null) {
        throw new IOException("Invalid submit type code: " + t);
    }
    mergeStrategy = readString(in);
}
#end_block

#method_before
@Override
public int weigh(EntryKey k, Boolean v) {
    return // Size of EntryKey, 64-bit JVM.
    16 + 2 * (16 + 20) + 1 + // Size of Boolean.
    1;
}
#method_after
@Override
public int weigh(EntryKey k, Boolean v) {
    return // Size of EntryKey, 64-bit JVM.
    16 + 2 * (16 + 20) + 3 * 8 + // Size of Boolean.
    8;
}
#end_block

#method_before
public boolean get(ObjectId commit, ObjectId into, SubmitType submitType, Branch.NameKey dest) {
    EntryKey key = new EntryKey(commit, into, submitType);
    Boolean result = cache.getIfPresent(key);
    if (result != null) {
        return result;
    }
    Project.NameKey p = dest.getParentKey();
    try {
        Repository repo = repoManager.openRepository(p);
        try {
            return load(key, dest, repo);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        return failed(key, e);
    }
}
#method_after
public boolean get(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy, Branch.NameKey dest, Repository repo, ReviewDb db) {
    ObjectId into = intoRef != null ? intoRef.getObjectId() : ObjectId.zeroId();
    EntryKey key = new EntryKey(commit, into, submitType, mergeStrategy, dest, repo, db);
    try {
        return cache.get(key);
    } catch (ExecutionException e) {
        log.error(String.format("Error checking mergeability of %s into %s (%s)", key.commit.name(), key.into.name(), key.submitType.name()), e.getCause());
        return false;
    }
}
#end_block

#method_before
public Change.Id editCommitMessage(ChangeControl ctl, PatchSet.Id patchSetId, String message, PersonIdent myIdent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    Change.Id changeId = patchSetId.getParentKey();
    PatchSet originalPS = db.get().patchSets().get(patchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getChange().getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(originalPS.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            Change change = db.get().changes().get(changeId);
            PersonIdent authorIdent = user().newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
            PatchSet newPatchSet = new PatchSet(id);
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user().getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            change = patchSetInserterFactory.create(git, revWalk, ctl, newCommit).setPatchSet(newPatchSet).setMessage(msg).setCopyLabels(true).setValidatePolicy(RECEIVE_COMMITS).setDraft(originalPS.isDraft()).insert();
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public Change.Id editCommitMessage(ChangeControl ctl, PatchSet ps, String message, PersonIdent myIdent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    Change change = ctl.getChange();
    Change.Id changeId = change.getId();
    if (Strings.isNullOrEmpty(message)) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getChange().getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            PersonIdent authorIdent = user().newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
            PatchSet newPatchSet = new PatchSet(id);
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user().getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            change = patchSetInserterFactory.create(git, revWalk, ctl, newCommit).setPatchSet(newPatchSet).setMessage(msg).setCopyLabels(true).setValidatePolicy(RECEIVE_COMMITS).setDraft(ps.isDraft()).insert();
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
public void deleteDraftChange(Change.Id changeId) throws NoSuchChangeException, OrmException, IOException {
    ReviewDb db = this.db.get();
    Change change = db.changes().get(changeId);
    if (change == null || change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps, change);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
    indexer.delete(db, change);
}
#method_after
public void deleteDraftChange(Change change) throws NoSuchChangeException, OrmException, IOException {
    Change.Id changeId = change.getId();
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    ReviewDb db = this.db.get();
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps, change);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
    indexer.delete(db, change);
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws ResourceConflictException, AuthException, ResourceNotFoundException, OrmException, IOException {
    if (rsrc.getChange().getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft");
    }
    if (!rsrc.getControl().canDeleteDraft(dbProvider.get())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    if (!allowDrafts) {
        throw new ResourceConflictException("Draft workflow is disabled.");
    }
    try {
        changeUtil.deleteDraftChange(rsrc.getChange().getId());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws ResourceConflictException, AuthException, ResourceNotFoundException, OrmException, IOException {
    if (rsrc.getChange().getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft");
    }
    if (!rsrc.getControl().canDeleteDraft(dbProvider.get())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    if (!allowDrafts) {
        throw new ResourceConflictException("Draft workflow is disabled.");
    }
    try {
        changeUtil.deleteDraftChange(rsrc.getChange());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
    return Response.none();
}
#end_block

