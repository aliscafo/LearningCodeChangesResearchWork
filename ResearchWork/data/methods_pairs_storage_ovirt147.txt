307
#method_before
@Override
public String toString() {
    return String.format("vmId = %s, status = %s", getVmId(), getStatus());
}
#method_after
@Override
public String toString() {
    return String.format("vmId = %s, status = %s, exit status = %s", getVmId(), getStatus(), getExitStatus());
}
#end_block

#method_before
@Test
public void testIscsiLogin() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.ConnectStorageToVds, StorageServerConnectionParametersBase.class, new String[] { "VdsId", "StorageServerConnection.connection", "StorageServerConnection.portal", "StorageServerConnection.iqn", "StorageServerConnection.port", "StorageServerConnection.storage_type", "StorageServerConnection.user_name", "StorageServerConnection.password" }, new Object[] { GUIDS[0], ISCSI_SERVER_ADDRESS, // TODO: right now hard-coded, but this should change when VDSM and Backend support portal
    "1", ISCSI_IQN, ISCSI_PORT_STRING, ISCSI_STORAGE_TYPE, ISCSI_USER_NAME, ISCSI_USER_PASS }));
    Action action = new Action();
    IscsiDetails iscsiDetails = new IscsiDetails();
    iscsiDetails.setAddress(ISCSI_SERVER_ADDRESS);
    iscsiDetails.setPort(ISCSI_PORT_INT);
    iscsiDetails.setTarget(ISCSI_IQN);
    iscsiDetails.setUsername(ISCSI_USER_NAME);
    iscsiDetails.setPassword(ISCSI_USER_PASS);
    action.setIscsi(iscsiDetails);
    verifyActionResponse(resource.iscsiLogin(action));
}
#method_after
@Test
public void testIscsiLogin() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.ConnectStorageToVds, StorageServerConnectionParametersBase.class, new String[] { "VdsId", "StorageServerConnection.connection", "StorageServerConnection.portal", "StorageServerConnection.iqn", "StorageServerConnection.port", "StorageServerConnection.storage_type", "StorageServerConnection.user_name", "StorageServerConnection.password" }, new Object[] { GUIDS[0], ISCSI_SERVER_ADDRESS, // TODO: right now hard-coded, but this should change when VDSM and Backend support portal
    StorageServerConnections.DEFAULT_TPGT, ISCSI_IQN, ISCSI_PORT_STRING, ISCSI_STORAGE_TYPE, ISCSI_USER_NAME, ISCSI_USER_PASS }));
    Action action = new Action();
    IscsiDetails iscsiDetails = new IscsiDetails();
    iscsiDetails.setAddress(ISCSI_SERVER_ADDRESS);
    iscsiDetails.setPort(ISCSI_PORT_INT);
    iscsiDetails.setTarget(ISCSI_IQN);
    iscsiDetails.setUsername(ISCSI_USER_NAME);
    iscsiDetails.setPassword(ISCSI_USER_PASS);
    action.setIscsi(iscsiDetails);
    verifyActionResponse(resource.iscsiLogin(action));
}
#end_block

#method_before
public void handleQuotaColumnVisibility() {
    isQuotaVisible = false;
    SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
    if (treeItem != null && SystemTreeItemType.DataCenter.equals(treeItem.getType())) {
        StoragePool storagePool = (StoragePool) treeItem.getEntity();
        if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            isQuotaVisible = true;
        }
    }
    onDiskViewTypeChanged();
}
#method_after
public void handleQuotaColumnVisibility() {
    isQuotaVisible = false;
    SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModelManager.instance().getSystemTree().getSelectedItem();
    if (treeItem != null && SystemTreeItemType.DataCenter == treeItem.getType()) {
        StoragePool storagePool = (StoragePool) treeItem.getEntity();
        if (QuotaEnforcementTypeEnum.DISABLED != storagePool.getQuotaEnforcementType()) {
            isQuotaVisible = true;
        }
    }
    onDiskViewTypeChanged();
}
#end_block

#method_before
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "180px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.qoutaColumn, constants.qoutaDisk(), (all || images || luns) && isQuotaVisible, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "90px");
}
#method_after
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "180px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.qoutaColumn, constants.quotaDisk(), images && isQuotaVisible, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "90px");
}
#end_block

#method_before
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDisksSearchPrefix = "^\\s*(disk(s)?\\s*(:)+)+\\s*";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    // $NON-NLS-1$
    final String colon = ":";
    RegExp searchPatternDisksSearchPrefix = RegExp.compile(searchRegexDisksSearchPrefix, searchRegexFlags);
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = commonModel.getSearchString().trim();
    String inputSearchStringPrefix = commonModel.getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(colon);
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchPatternDisksSearchPrefix.test(searchStringPrefixRaw) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchPatternDisksSearchPrefix.test(searchStringPrefix) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    commonModel.setSearchStringPrefix(searchStringPrefix);
    commonModel.setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(commonModel.getEffectiveSearchString());
    getMainModel().search();
}
#method_after
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDisksSearchPrefix = "^\\s*(disk(s)?\\s*(:)+)+\\s*";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    // $NON-NLS-1$
    final String colon = ":";
    RegExp searchPatternDisksSearchPrefix = RegExp.compile(searchRegexDisksSearchPrefix, searchRegexFlags);
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = CommonModelManager.instance().getSearchString().trim();
    String inputSearchStringPrefix = CommonModelManager.instance().getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(colon);
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchPatternDisksSearchPrefix.test(searchStringPrefixRaw) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchPatternDisksSearchPrefix.test(searchStringPrefix) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    CommonModelManager.instance().setSearchStringPrefix(searchStringPrefix);
    CommonModelManager.instance().setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(CommonModelManager.instance().getEffectiveSearchString());
    getMainModel().search();
}
#end_block

#method_before
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        StoragePool storagePool = (StoragePool) itemModel.getEntity();
        storagePool.setQuotaEnforcementType(dataCenter.getQuotaEnforcementType());
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#method_after
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        itemModel.setEntity(dataCenter);
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#end_block

#method_before
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    ArrayList<StorageDomain> storages = null;
    int count = -1;
    treeItemById = new HashMap<Guid, SystemTreeItemModel>();
    // Build tree items.
    SystemTreeItemModel systemItem = new SystemTreeItemModel();
    systemItem.setType(SystemTreeItemType.System);
    systemItem.setIsSelected(true);
    systemItem.setTitle(ConstantsManager.getInstance().getConstants().systemTitle());
    // Add Data Centers node under System
    SystemTreeItemModel dataCentersItem = new SystemTreeItemModel();
    dataCentersItem.setType(SystemTreeItemType.DataCenters);
    dataCentersItem.setApplicationMode(ApplicationMode.VirtOnly);
    dataCentersItem.setTitle(ConstantsManager.getInstance().getConstants().dataCentersTitle());
    systemItem.addChild(dataCentersItem);
    // Populate everything under Data Centers
    for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
        ++count;
        if (!returnValue.getSucceeded()) {
            continue;
        }
        storages = (ArrayList<StorageDomain>) returnValue.getReturnValue();
        SystemTreeItemModel dataCenterItem = new SystemTreeItemModel();
        dataCenterItem.setType(SystemTreeItemType.DataCenter);
        dataCenterItem.setApplicationMode(ApplicationMode.VirtOnly);
        dataCenterItem.setTitle(getDataCenters().get(count).getName());
        dataCenterItem.setEntity(getDataCenters().get(count));
        dataCentersItem.addChild(dataCenterItem);
        SystemTreeItemModel storagesItem = new SystemTreeItemModel();
        storagesItem.setType(SystemTreeItemType.Storages);
        storagesItem.setApplicationMode(ApplicationMode.VirtOnly);
        storagesItem.setTitle(ConstantsManager.getInstance().getConstants().storageTitle());
        storagesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(storagesItem);
        treeItemById.put(getDataCenters().get(count).getId(), storagesItem);
        if (storages != null && storages.size() > 0) {
            // sort by name first
            Collections.sort(storages, new Linq.StorageDomainComparator());
            for (StorageDomain storage : storages) {
                SystemTreeItemModel storageItem = new SystemTreeItemModel();
                storageItem.setType(SystemTreeItemType.Storage);
                storageItem.setApplicationMode(ApplicationMode.VirtOnly);
                storageItem.setTitle(storage.getStorageName());
                storageItem.setEntity(storage);
                storagesItem.addChild(storageItem);
            }
        }
        SystemTreeItemModel networksItem = new SystemTreeItemModel();
        networksItem.setType(SystemTreeItemType.Networks);
        networksItem.setApplicationMode(ApplicationMode.VirtOnly);
        networksItem.setTitle(ConstantsManager.getInstance().getConstants().networksTitle());
        networksItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(networksItem);
        List<Network> dcNetworks = getNetworkMap().get(getDataCenters().get(count).getId());
        if (dcNetworks != null) {
            // sort by name first
            Collections.sort(dcNetworks, new Linq.NetworkComparator());
            for (Network network : dcNetworks) {
                SystemTreeItemModel networkItem = new SystemTreeItemModel();
                networkItem.setType(SystemTreeItemType.Network);
                networkItem.setApplicationMode(ApplicationMode.VirtOnly);
                networkItem.setTitle(network.getName());
                networkItem.setEntity(network);
                networksItem.addChild(networkItem);
                treeItemById.put(network.getId(), networkItem);
            }
        }
        SystemTreeItemModel templatesItem = new SystemTreeItemModel();
        templatesItem.setType(SystemTreeItemType.Templates);
        templatesItem.setApplicationMode(ApplicationMode.VirtOnly);
        templatesItem.setTitle(ConstantsManager.getInstance().getConstants().templatesTitle());
        templatesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(templatesItem);
        SystemTreeItemModel clustersItem = new SystemTreeItemModel();
        clustersItem.setType(SystemTreeItemType.Clusters);
        clustersItem.setTitle(ConstantsManager.getInstance().getConstants().clustersTitle());
        clustersItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(clustersItem);
        if (getClusterMap().containsKey(getDataCenters().get(count).getId())) {
            List<VDSGroup> clusters = getClusterMap().get(getDataCenters().get(count).getId());
            Collections.sort(clusters, new Linq.VDSGroupComparator());
            for (VDSGroup cluster : clusters) {
                SystemTreeItemModel clusterItem = new SystemTreeItemModel();
                clusterItem.setType(cluster.supportsGlusterService() ? SystemTreeItemType.Cluster_Gluster : SystemTreeItemType.Cluster);
                clusterItem.setTitle(cluster.getName());
                clusterItem.setEntity(cluster);
                clustersItem.addChild(clusterItem);
                SystemTreeItemModel hostsItem = new SystemTreeItemModel();
                hostsItem.setType(SystemTreeItemType.Hosts);
                hostsItem.setTitle(ConstantsManager.getInstance().getConstants().hostsTitle());
                hostsItem.setEntity(cluster);
                clusterItem.addChild(hostsItem);
                if (getHostMap().containsKey(cluster.getId())) {
                    for (VDS host : getHostMap().get(cluster.getId())) {
                        SystemTreeItemModel hostItem = new SystemTreeItemModel();
                        hostItem.setType(SystemTreeItemType.Host);
                        hostItem.setTitle(host.getName());
                        hostItem.setEntity(host);
                        hostsItem.addChild(hostItem);
                    }
                }
                if (cluster.supportsGlusterService()) {
                    SystemTreeItemModel volumesItem = new SystemTreeItemModel();
                    volumesItem.setType(SystemTreeItemType.Volumes);
                    volumesItem.setApplicationMode(ApplicationMode.GlusterOnly);
                    volumesItem.setTitle(ConstantsManager.getInstance().getConstants().volumesTitle());
                    volumesItem.setEntity(cluster);
                    clusterItem.addChild(volumesItem);
                    if (getVolumeMap().containsKey(cluster.getId())) {
                        for (GlusterVolumeEntity volume : getVolumeMap().get(cluster.getId())) {
                            SystemTreeItemModel volumeItem = new SystemTreeItemModel();
                            volumeItem.setType(SystemTreeItemType.Volume);
                            volumeItem.setApplicationMode(ApplicationMode.GlusterOnly);
                            volumeItem.setTitle(volume.getName());
                            volumeItem.setEntity(volume);
                            volumesItem.addChild(volumeItem);
                        }
                    }
                }
                if (cluster.supportsVirtService()) {
                    SystemTreeItemModel vmsItem = new SystemTreeItemModel();
                    vmsItem.setType(SystemTreeItemType.VMs);
                    vmsItem.setApplicationMode(ApplicationMode.VirtOnly);
                    vmsItem.setTitle(ConstantsManager.getInstance().getConstants().vmsTitle());
                    vmsItem.setEntity(cluster);
                    clusterItem.addChild(vmsItem);
                }
            }
        }
    }
    // Add Providers node under System
    SystemTreeItemModel providersItem = new SystemTreeItemModel();
    providersItem.setType(SystemTreeItemType.Providers);
    providersItem.setApplicationMode(ApplicationMode.VirtOnly);
    providersItem.setTitle(ConstantsManager.getInstance().getConstants().externalProvidersTitle());
    systemItem.addChild(providersItem);
    // Populate with providers
    for (Provider provider : getProviders()) {
        SystemTreeItemModel providerItem = new SystemTreeItemModel();
        providerItem.setType(SystemTreeItemType.Provider);
        providerItem.setApplicationMode(ApplicationMode.VirtOnly);
        providerItem.setTitle(provider.getName());
        providerItem.setEntity(provider);
        providersItem.addChild(providerItem);
        treeItemById.put(provider.getId(), providerItem);
    }
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterSystemTreeByApplictionMode(systemItem);
    }
    setItems(new ArrayList<SystemTreeItemModel>(Arrays.asList(new SystemTreeItemModel[] { systemItem })));
}
#method_after
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    ArrayList<StorageDomain> storages = null;
    int count = -1;
    treeItemById = new HashMap<Guid, SystemTreeItemModel>();
    // Build tree items.
    SystemTreeItemModel systemItem = new SystemTreeItemModel();
    systemItem.setType(SystemTreeItemType.System);
    systemItem.setIsSelected(true);
    systemItem.setTitle(ConstantsManager.getInstance().getConstants().systemTitle());
    // Add Data Centers node under System
    SystemTreeItemModel dataCentersItem = new SystemTreeItemModel();
    dataCentersItem.setType(SystemTreeItemType.DataCenters);
    dataCentersItem.setApplicationMode(ApplicationMode.VirtOnly);
    dataCentersItem.setTitle(ConstantsManager.getInstance().getConstants().dataCentersTitle());
    systemItem.addChild(dataCentersItem);
    // Populate everything under Data Centers
    for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
        ++count;
        if (!returnValue.getSucceeded()) {
            continue;
        }
        storages = (ArrayList<StorageDomain>) returnValue.getReturnValue();
        SystemTreeItemModel dataCenterItem = new SystemTreeItemModel();
        dataCenterItem.setType(SystemTreeItemType.DataCenter);
        dataCenterItem.setApplicationMode(ApplicationMode.VirtOnly);
        StoragePool dataCenter = getDataCenters().get(count);
        dataCenterItem.setTitle(dataCenter.getName());
        dataCenterItem.setEntity(dataCenter);
        dataCentersItem.addChild(dataCenterItem);
        treeItemById.put(dataCenter.getId(), dataCenterItem);
        SystemTreeItemModel storagesItem = new SystemTreeItemModel();
        storagesItem.setType(SystemTreeItemType.Storages);
        storagesItem.setApplicationMode(ApplicationMode.VirtOnly);
        storagesItem.setTitle(ConstantsManager.getInstance().getConstants().storageTitle());
        storagesItem.setEntity(dataCenter);
        dataCenterItem.addChild(storagesItem);
        if (storages != null && storages.size() > 0) {
            // sort by name first
            Collections.sort(storages, new Linq.StorageDomainComparator());
            for (StorageDomain storage : storages) {
                SystemTreeItemModel storageItem = new SystemTreeItemModel();
                storageItem.setType(SystemTreeItemType.Storage);
                storageItem.setApplicationMode(ApplicationMode.VirtOnly);
                storageItem.setTitle(storage.getStorageName());
                storageItem.setEntity(storage);
                storagesItem.addChild(storageItem);
            }
        }
        SystemTreeItemModel networksItem = new SystemTreeItemModel();
        networksItem.setType(SystemTreeItemType.Networks);
        networksItem.setApplicationMode(ApplicationMode.VirtOnly);
        networksItem.setTitle(ConstantsManager.getInstance().getConstants().networksTitle());
        networksItem.setEntity(dataCenter);
        dataCenterItem.addChild(networksItem);
        List<Network> dcNetworks = getNetworkMap().get(dataCenter.getId());
        if (dcNetworks != null) {
            // sort by name first
            Collections.sort(dcNetworks, new Linq.NetworkComparator());
            for (Network network : dcNetworks) {
                SystemTreeItemModel networkItem = new SystemTreeItemModel();
                networkItem.setType(SystemTreeItemType.Network);
                networkItem.setApplicationMode(ApplicationMode.VirtOnly);
                networkItem.setTitle(network.getName());
                networkItem.setEntity(network);
                networksItem.addChild(networkItem);
                treeItemById.put(network.getId(), networkItem);
            }
        }
        SystemTreeItemModel templatesItem = new SystemTreeItemModel();
        templatesItem.setType(SystemTreeItemType.Templates);
        templatesItem.setApplicationMode(ApplicationMode.VirtOnly);
        templatesItem.setTitle(ConstantsManager.getInstance().getConstants().templatesTitle());
        templatesItem.setEntity(dataCenter);
        dataCenterItem.addChild(templatesItem);
        SystemTreeItemModel clustersItem = new SystemTreeItemModel();
        clustersItem.setType(SystemTreeItemType.Clusters);
        clustersItem.setTitle(ConstantsManager.getInstance().getConstants().clustersTitle());
        clustersItem.setEntity(dataCenter);
        dataCenterItem.addChild(clustersItem);
        if (getClusterMap().containsKey(dataCenter.getId())) {
            List<VDSGroup> clusters = getClusterMap().get(dataCenter.getId());
            Collections.sort(clusters, new Linq.VDSGroupComparator());
            for (VDSGroup cluster : clusters) {
                SystemTreeItemModel clusterItem = new SystemTreeItemModel();
                clusterItem.setType(cluster.supportsGlusterService() ? SystemTreeItemType.Cluster_Gluster : SystemTreeItemType.Cluster);
                clusterItem.setTitle(cluster.getName());
                clusterItem.setEntity(cluster);
                clustersItem.addChild(clusterItem);
                SystemTreeItemModel hostsItem = new SystemTreeItemModel();
                hostsItem.setType(SystemTreeItemType.Hosts);
                hostsItem.setTitle(ConstantsManager.getInstance().getConstants().hostsTitle());
                hostsItem.setEntity(cluster);
                clusterItem.addChild(hostsItem);
                if (getHostMap().containsKey(cluster.getId())) {
                    for (VDS host : getHostMap().get(cluster.getId())) {
                        SystemTreeItemModel hostItem = new SystemTreeItemModel();
                        hostItem.setType(SystemTreeItemType.Host);
                        hostItem.setTitle(host.getName());
                        hostItem.setEntity(host);
                        hostsItem.addChild(hostItem);
                    }
                }
                if (cluster.supportsGlusterService()) {
                    SystemTreeItemModel volumesItem = new SystemTreeItemModel();
                    volumesItem.setType(SystemTreeItemType.Volumes);
                    volumesItem.setApplicationMode(ApplicationMode.GlusterOnly);
                    volumesItem.setTitle(ConstantsManager.getInstance().getConstants().volumesTitle());
                    volumesItem.setEntity(cluster);
                    clusterItem.addChild(volumesItem);
                    if (getVolumeMap().containsKey(cluster.getId())) {
                        for (GlusterVolumeEntity volume : getVolumeMap().get(cluster.getId())) {
                            SystemTreeItemModel volumeItem = new SystemTreeItemModel();
                            volumeItem.setType(SystemTreeItemType.Volume);
                            volumeItem.setApplicationMode(ApplicationMode.GlusterOnly);
                            volumeItem.setTitle(volume.getName());
                            volumeItem.setEntity(volume);
                            volumesItem.addChild(volumeItem);
                        }
                    }
                }
                if (cluster.supportsVirtService()) {
                    SystemTreeItemModel vmsItem = new SystemTreeItemModel();
                    vmsItem.setType(SystemTreeItemType.VMs);
                    vmsItem.setApplicationMode(ApplicationMode.VirtOnly);
                    vmsItem.setTitle(ConstantsManager.getInstance().getConstants().vmsTitle());
                    vmsItem.setEntity(cluster);
                    clusterItem.addChild(vmsItem);
                }
            }
        }
    }
    // Add Providers node under System
    SystemTreeItemModel providersItem = new SystemTreeItemModel();
    providersItem.setType(SystemTreeItemType.Providers);
    providersItem.setApplicationMode(ApplicationMode.VirtOnly);
    providersItem.setTitle(ConstantsManager.getInstance().getConstants().externalProvidersTitle());
    systemItem.addChild(providersItem);
    // Populate with providers
    for (Provider provider : getProviders()) {
        SystemTreeItemModel providerItem = new SystemTreeItemModel();
        providerItem.setType(SystemTreeItemType.Provider);
        providerItem.setApplicationMode(ApplicationMode.VirtOnly);
        providerItem.setTitle(provider.getName());
        providerItem.setEntity(provider);
        providersItem.addChild(providerItem);
        treeItemById.put(provider.getId(), providerItem);
    }
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterSystemTreeByApplictionMode(systemItem);
    }
    setItems(new ArrayList<SystemTreeItemModel>(Arrays.asList(new SystemTreeItemModel[] { systemItem })));
}
#end_block

#method_before
@Override
protected void onReveal() {
    Event entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    if (!systemTreeSelectedItemChangedEvent.getListeners().contains(getView().systemTreeChangedEventListener())) {
        systemTreeSelectedItemChangedEvent.addListener(getView().systemTreeChangedEventListener());
    }
    super.onReveal();
    ((MainTabDiskView) getView()).handleQuotaColumnVisibility();
}
#method_after
@Override
protected void onReveal() {
    Event entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    systemTreeSelectedItemChangedEvent.addListener(systemTreeListener);
    super.onReveal();
    getView().handleQuotaColumnVisibility();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setProviderId(getParameters().getProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = Backend.getInstance().runInternalMultipleActions(VdcActionType.InstallVds, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setProviderId(getParameters().getProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = Backend.getInstance().runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
                filterUnsupportedArchs(clusterModel);
            }
        }

        private void filterUnsupportedArchs(ClusterModel clusterModel) {
            Collection<ArchitectureType> archsWithSupportingCpus = new HashSet<ArchitectureType>();
            archsWithSupportingCpus.add(ArchitectureType.undefined);
            for (ServerCpu cpu : clusterModel.getCPU().getItems()) {
                archsWithSupportingCpus.add(cpu.getArchitecture());
            }
            clusterModel.getArchitecture().setItems(archsWithSupportingCpus);
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
        } else {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#method_after
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    MigrateBrokerVDSCommand<?> command = new MigrateBrokerVDSCommand<>(getParameters());
    command.execute();
    VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
    final VmDynamic vmDynamic = getVmDynamicDAO().get(getParameters().getVmId());
    if (vdsReturnValue.getSucceeded()) {
        vmDynamic.setStatus(VMStatus.MigratingFrom);
        vmDynamic.setMigratingToVds(getParameters().getDstVdsId());
        vmDynamic.setExitStatus(VmExitStatus.Normal);
        vmDynamic.setExitMessage(StringUtils.EMPTY);
        ResourceManager.getInstance().AddAsyncRunningVm(getParameters().getVmId());
        getVDSReturnValue().setReturnValue(VMStatus.MigratingFrom);
    } else {
        log.error("Failed Vm migration");
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setReturnValue(vmDynamic.getStatus());
        getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
        getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
        getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmDynamicDAO().update(vmDynamic);
            return null;
        }
    });
}
#method_after
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    MigrateBrokerVDSCommand<?> command = new MigrateBrokerVDSCommand<>(getParameters());
    command.execute();
    VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
    final VM vm = getVmDao().get(getParameters().getVmId());
    if (vdsReturnValue.getSucceeded()) {
        ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.MigratingFrom);
        vm.setMigratingToVds(getParameters().getDstVdsId());
        ResourceManager.getInstance().AddAsyncRunningVm(getParameters().getVmId());
        getVDSReturnValue().setReturnValue(VMStatus.MigratingFrom);
    } else {
        log.error("Failed Vm migration");
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setReturnValue(vm.getStatus());
        getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
        getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
        getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmDynamicDAO().update(vm.getDynamicData());
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null)
            ec.setJob(this.getExecutionContext().getJob());
        super.executeCommand();
        if (ec != null)
            this.setExecutionContext(ec);
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                ArrayList<String> verTempMissingBase = new ArrayList<String>();
                // check if relevant templates are already there
                for (Object selectedItem : templateListModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) selectedItem;
                    // only relevant for template versions
                    if (!template.isBaseTemplate()) {
                        boolean hasMatch = false;
                        for (VmTemplate a : templatesDiskSet.keySet()) {
                            if (template.getBaseTemplateId().equals(a.getId())) {
                                hasMatch = true;
                                break;
                            }
                        }
                        if (!template.getBaseTemplateId().equals(Guid.Empty) && !hasMatch) {
                            verTempMissingBase.add(template.getName());
                        }
                    }
                }
                templateListModel.postExportGetMissingTemplates(verTempMissingBase);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                ArrayList<String> verTempMissingBase = new ArrayList<String>();
                // check if relevant templates are already there
                for (Object selectedItem : templateListModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) selectedItem;
                    // only relevant for template versions
                    if (!template.isBaseTemplate()) {
                        boolean hasMatch = false;
                        for (VmTemplate a : templatesDiskSet.keySet()) {
                            if (template.getBaseTemplateId().equals(a.getId())) {
                                hasMatch = true;
                                break;
                            }
                        }
                        if (!template.getBaseTemplateId().equals(Guid.Empty) && !hasMatch) {
                            verTempMissingBase.add(template.getName());
                        }
                    }
                }
                templateListModel.postExportGetMissingTemplates(verTempMissingBase);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object item : getSelectedItems()) {
        VmTemplate a = (VmTemplate) item;
        if (a.getId().equals(Guid.Empty)) {
            continue;
        }
        MoveOrCopyParameters tempVar = new MoveOrCopyParameters(a.getId(), ((StorageDomain) model.getStorage().getSelectedItem()).getId());
        tempVar.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameters.add(tempVar);
    }
    if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().baseTemplatesNotFoundOnExportDomainTitle());
        confirmModel.setHelpTag(HelpTag.base_template_not_found_on_export_domain);
        // $NON-NLS-1$
        confirmModel.setHashName("base_template_not_found_on_export_domain");
        confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainForTemplateVersionsMsg());
        confirmModel.setItems(missingTemplatesFromVms);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnExportNoTemplates", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVmTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    if (!missingTemplatesFromVms.isEmpty()) {
        model.stopProgress();
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().baseTemplatesNotFoundOnExportDomainTitle());
        confirmModel.setHelpTag(HelpTag.base_template_not_found_on_export_domain);
        // $NON-NLS-1$
        confirmModel.setHashName("base_template_not_found_on_export_domain");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainForTemplateVersionsMsg());
        confirmModel.setItems(missingTemplatesFromVms);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnExportNoTemplates", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else {
        doExport();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportTemplateTitle());
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportTemplateTitle());
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        doExport();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown);
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown, "no reporting hosts");
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#end_block

#method_before
public java.util.HashSet<Guid> getTriedVdssList() {
    return mTriedVdssList;
}
#method_after
public HashSet<Guid> getTriedVdssList() {
    return mTriedVdssList;
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new java.util.HashSet<Guid>(java.util.Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new HashSet<Guid>(Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#end_block

#method_before
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
public static void updateApplicablePoolDomainsStatuses(Guid storagePoolId, Set<StorageDomainStatus> applicableStatusesForUpdate, StorageDomainStatus newStatus) {
    List<StoragePoolIsoMap> storagesStatusInPool = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(storagePoolId);
    for (StoragePoolIsoMap storageStatusInPool : storagesStatusInPool) {
        if (storageStatusInPool.getStatus() != null && storageStatusInPool.getStatus() != newStatus && applicableStatusesForUpdate.contains(storageStatusInPool.getStatus())) {
            storageStatusInPool.setStatus(newStatus);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(storageStatusInPool.getId(), storageStatusInPool.getStatus());
        }
    }
}
#method_after
public static void updateApplicablePoolDomainsStatuses(Guid storagePoolId, Set<StorageDomainStatus> applicableStatusesForUpdate, StorageDomainStatus newStatus, String reason) {
    List<StoragePoolIsoMap> storagesStatusInPool = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(storagePoolId);
    for (StoragePoolIsoMap storageStatusInPool : storagesStatusInPool) {
        if (storageStatusInPool.getStatus() != null && storageStatusInPool.getStatus() != newStatus && applicableStatusesForUpdate.contains(storageStatusInPool.getStatus())) {
            log.infoFormat("Storage Pool {0} - Updating Storage Domain {1} status from {2} to {3}, reason : {4}", storagePoolId, storageStatusInPool.getstorage_id(), storageStatusInPool.getStatus().name(), newStatus.name(), reason);
            storageStatusInPool.setStatus(newStatus);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(storageStatusInPool.getId(), storageStatusInPool.getStatus());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getStoragePool().setStatus(getParameters().getStatus());
    setVdsIdRef(getStoragePool().getspm_vds_id());
    DbFacade.getInstance().getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
    if (getParameters().getStatus() == StoragePoolStatus.NonResponsive || getParameters().getStatus() == StoragePoolStatus.NotOperational) {
        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(getStoragePool().getId(), Collections.singleton(StorageDomainStatus.Active), StorageDomainStatus.Unknown);
    }
    StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getStoragePool().setStatus(getParameters().getStatus());
    setVdsIdRef(getStoragePool().getspm_vds_id());
    DbFacade.getInstance().getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
    if (getParameters().getStatus() == StoragePoolStatus.NonResponsive || getParameters().getStatus() == StoragePoolStatus.NotOperational) {
        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(getStoragePool().getId(), EnumSet.of(StorageDomainStatus.Active), StorageDomainStatus.Unknown, null);
    }
    StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    setSucceeded(true);
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshAllUsers")
public void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    List<DbGroup> dbGroups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : dbGroups) {
        groupsMap.put(group.getExternalId(), group);
    }
    // Classify the users by directory. Note that the resulting map may have an entry with a null key, that
    // corresponds to the users whose directory has been removed from the configuration.
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(dbUser.getDomain());
        if (profile == null) {
            log.warn(String.format("No profile was found for user %1$s. It is possible that the relevant domain for the user was removed for the user. Marking the user as inactive", dbUser.getLoginName()));
            if (dbUser.isActive()) {
                dbUser.setActive(false);
                dao.update(dbUser);
            }
            continue;
        }
        Directory key = profile.getDirectory();
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#method_after
@OnTimerMethodAnnotation("refreshAllUsers")
public void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    List<DbGroup> dbGroups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : dbGroups) {
        groupsMap.put(group.getExternalId(), group);
    }
    // Classify the users by directory. Note that the resulting map may have an entry with a null key, that
    // corresponds to the users whose directory has been removed from the configuration.
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(dbUser.getDomain());
        if (profile == null) {
            log.warn(String.format("No profile was found for user %1$s. It is possible that the relevant " + "domain for the user was removed for the user. Marking the user as inactive", dbUser.getLoginName()));
            if (dbUser.isActive()) {
                dbUser.setActive(false);
                dao.update(dbUser);
            }
            continue;
        }
        Directory key = profile.getDirectory();
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#end_block

#method_before
@Override
public Integer getVmsCountByClusterId(Guid vdsGroupId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_group_id", vdsGroupId);
    return getCallsHandler().executeRead("GetNumberOfVmsInCluster", getIntegerMapper(), parameterSource);
}
#method_after
@Override
public int getVmsCountByClusterId(Guid vdsGroupId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_group_id", vdsGroupId);
    return getCallsHandler().executeRead("GetNumberOfVmsInCluster", getIntegerMapper(), parameterSource);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Integer numOfVms = getDbFacade().getVdsGroupDao().getVmsCountByClusterId(getParameters().getId());
    getQueryReturnValue().setReturnValue(numOfVms);
}
#method_after
@Override
protected void executeQueryCommand() {
    int numOfVms = getDbFacade().getVdsGroupDao().getVmsCountByClusterId(getParameters().getId());
    getQueryReturnValue().setReturnValue(numOfVms);
}
#end_block

#method_before
public String getNumberOfVms() {
    return Integer.toString(numberOfVms);
}
#method_after
public String getNumberOfVms() {
    // $NON-NLS-1$
    return numberOfVms == null ? "0" : Integer.toString(numberOfVms);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<String>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<VmDevice>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && ((List) source).size() > 0) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StoragePool> pools = (ArrayList<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && pools.size() > 0) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#method_after
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StoragePool> pools = (List<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && !pools.isEmpty()) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            if (siblingVlanInterfaces.size() > 0) {
                return true;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
private void createKerberosLdapAAAConfigurations() {
    for (String domain : Config.<String>getValue(ConfigValues.DomainName).split("[,]", 0)) {
        if (!domain.isEmpty()) {
            Properties authConfig = new Properties();
            authConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapAuthenticator");
            authConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authentication");
            authConfig.put(ExtensionsManager.ENABLED, "true");
            authConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            authConfig.put(ExtensionsManager.NAME, String.format("builtin-authn-%1$s", domain));
            authConfig.put("ovirt.engine.aaa.authn.profile.name", domain);
            authConfig.put("ovirt.engine.aaa.authn.authz.plugin", domain);
            ExtensionsManager.getInstance().load(authConfig);
            Properties dirConfig = new Properties();
            dirConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapDirectory");
            dirConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authorization");
            dirConfig.put(ExtensionsManager.ENABLED, "true");
            dirConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            dirConfig.put(ExtensionsManager.NAME, domain);
            ExtensionsManager.getInstance().load(dirConfig);
        }
    }
}
#method_after
private void createKerberosLdapAAAConfigurations() {
    for (String domain : Config.<String>getValue(ConfigValues.DomainName).split("[,]", 0)) {
        domain = domain.trim();
        if (!domain.isEmpty()) {
            Properties authConfig = new Properties();
            authConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapAuthenticator");
            authConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authentication");
            authConfig.put(ExtensionsManager.ENABLED, "true");
            authConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            authConfig.put(ExtensionsManager.NAME, String.format("builtin-authn-%1$s", domain));
            authConfig.put("ovirt.engine.aaa.authn.profile.name", domain);
            authConfig.put("ovirt.engine.aaa.authn.authz.plugin", domain);
            ExtensionsManager.getInstance().load(authConfig);
            Properties dirConfig = new Properties();
            dirConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapDirectory");
            dirConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authorization");
            dirConfig.put(ExtensionsManager.ENABLED, "true");
            dirConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            dirConfig.put(ExtensionsManager.NAME, domain);
            ExtensionsManager.getInstance().load(dirConfig);
        }
    }
}
#end_block

#method_before
private void storeExecutionParameters() {
    // Store defaults in meta-data and user-data that apply regardless
    // of parameters passed in from the user.
    // New instance id required for cloud-init to process data on startup
    metaData.put("uuid", UUID.randomUUID().toString());
    Map<String, String> meta = new HashMap<String, String>();
    // Local allows us to set up networking
    meta.put("dsmode", "local");
    meta.put("essential", "false");
    meta.put("role", "server");
    metaData.put("meta", meta);
    metaData.put("launch_index", "0");
    metaData.put("availability_zone", "nova");
    // Don't create ec2-user
    userData.put("user", "root");
    // Redirect log output from cloud-init execution from terminal
    Map<String, String> output = new HashMap<String, String>();
    output.put("all", ">> /var/log/cloud-init-output.log");
    userData.put("output", output);
    List<String> bootcmd = new ArrayList<String>();
    // set disable_root=0 for enabling root ssh login and
    // datasource_list in cloud.cfg
    bootcmd.add("sed -i '/^disable_root: /d' /etc/cloud/cloud.cfg");
    bootcmd.add("echo 'disable_root: 0' >> /etc/cloud/cloud.cfg");
    bootcmd.add("sed -i '/^datasource_list: /d' /etc/cloud/cloud.cfg");
    bootcmd.add("echo 'datasource_list: [\"NoCloud\", \"ConfigDrive\"]' >> /etc/cloud/cloud.cfg");
    userData.put("bootcmd", bootcmd);
    Map<String, Object> opts = new HashMap<String, Object>();
    opts.put("expire", false);
    userData.put("chpasswd", opts);
    userData.put("ssh_pwauth", true);
}
#method_after
private void storeExecutionParameters() {
    // Store defaults in meta-data and user-data that apply regardless
    // of parameters passed in from the user.
    // New instance id required for cloud-init to process data on startup
    metaData.put("uuid", UUID.randomUUID().toString());
    Map<String, String> meta = new HashMap<String, String>();
    // Local allows us to set up networking
    meta.put("dsmode", "local");
    meta.put("essential", "false");
    meta.put("role", "server");
    metaData.put("meta", meta);
    metaData.put("launch_index", "0");
    metaData.put("availability_zone", "nova");
    // Don't create ec2-user
    userData.put("user", "root");
    userData.put("disable_root", 0);
    // Redirect log output from cloud-init execution from terminal
    Map<String, String> output = new HashMap<String, String>();
    output.put("all", ">> /var/log/cloud-init-output.log");
    userData.put("output", output);
    // Disable metadata-server-based datasources to prevent long boot times
    List<String> runcmd = new ArrayList<String>();
    runcmd.add("sed -i '/^datasource_list: /d' /etc/cloud/cloud.cfg; echo 'datasource_list: [\"NoCloud\", \"ConfigDrive\"]' >> /etc/cloud/cloud.cfg");
    userData.put("runcmd", runcmd);
    Map<String, Object> opts = new HashMap<String, Object>();
    opts.put("expire", false);
    userData.put("chpasswd", opts);
    userData.put("ssh_pwauth", true);
}
#end_block

#method_before
private String mapToJson(Map<String, Object> input) throws IOException, JsonGenerationException, JsonMappingException {
    ObjectMapper mapper = new ObjectMapper();
    JsonFactory factory = new JsonFactory();
    StringWriter writer = new StringWriter();
    JsonGenerator generator = factory.createJsonGenerator(writer);
    generator.useDefaultPrettyPrinter();
    mapper.writeValue(generator, input);
    return writer.toString();
}
#method_after
private String mapToJson(Map<String, Object> input) throws IOException {
    return JsonHelper.mapToJson(input);
}
#end_block

#method_before
public void install() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#method_after
public void install() {
    final VDS host = (VDS) getSelectedItem();
    if (host.getVdsType() == VDSType.oVirtNode) {
        host.setSshUsername(HostModel.AdminUserName);
    }
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#end_block

#method_before
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
public void upgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#method_after
public void upgrade() {
    final VDS host = (VDS) getSelectedItem();
    host.setSshUsername(HostModel.AdminUserName);
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#end_block

#method_before
public void onUpgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpdateOvirtNode, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onUpgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpgradeOvirtNode, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                // do nothing
                }

                @Override
                public void queryFailed() {
                // do nothing
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        getWindow().stopProgress();
                        setWindow(null);
                        setGuideContext(returnValue.getActionReturnValue());
                        updateActionAvailability();
                        getGuideCommand().execute();
                    }
                    super.executed(result);
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                // do nothing
                }

                @Override
                public void queryFailed() {
                // do nothing
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    getWindow().stopProgress();
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        setWindow(null);
                        setGuideContext(returnValue.getActionReturnValue());
                        updateActionAvailability();
                        getGuideCommand().execute();
                    } else {
                        cancel();
                    }
                    super.executed(result);
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    IdQueryParameters params = new IdQueryParameters(dataCenterId);
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, params, aQuery);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, params, aQuery);
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    IdQueryParameters params = new IdQueryParameters(snapshotSourceId);
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, params, aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        VdcQueryParametersBase params = new VdcQueryParametersBase();
        params.setRefresh(false);
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, params, aQuery);
    }
}
#end_block

#method_before
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    if (severity == null) {
        severity = AuditLogSeverity.NORMAL;
        log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
    }
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserId() != null ? getDbFacadeInstance().getDbUserDao().get(auditLogable.getUserId()).getLoginName() : null, auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
        auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
        auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
        auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
        auditLog.setvds_group_id(auditLogable.getVdsGroupId());
        auditLog.setvds_group_name(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = log.transform(loggerString, resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
            case ALERT:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#method_after
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    if (severity == null) {
        severity = AuditLogSeverity.NORMAL;
        log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
    }
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserId() != null ? getDbFacadeInstance().getDbUserDao().get(auditLogable.getUserId()).getLoginName() : null, auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
        auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
        auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
        auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
        auditLog.setvds_group_id(auditLogable.getVdsGroupId());
        auditLog.setvds_group_name(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = log.transform(loggerString, resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case ALERT:
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#end_block

#method_before
@Override
public void updateOvfGenerations(List<Guid> ids, List<Long> values, List<String> ovfData) {
    getCallsHandler().executeModification("UpdateOvfGenerations", getCustomMapSqlParameterSource().addValue("vms_ids", StringUtils.join(ids, ',')).addValue("vms_db_generations", StringUtils.join(values, ',')).addValue("ovf_data", StringUtils.join(ovfData, "ENDOVF")).addValue("ovf_data_seperator", "ENDOVF"));
}
#method_after
@Override
public void updateOvfGenerations(List<Guid> ids, List<Long> values, List<String> ovfData) {
    getCallsHandler().executeModification("UpdateOvfGenerations", getCustomMapSqlParameterSource().addValue("vms_ids", StringUtils.join(ids, ',')).addValue("vms_db_generations", StringUtils.join(values, ',')).addValue("ovf_data", StringUtils.join(ovfData, ovfSeparator)).addValue("ovf_data_seperator", ovfSeparator));
}
#end_block

#method_before
@Override
public List<Pair<Guid, String>> loadOvfDataForIds(List<Guid> ids) {
    return getCallsHandler().executeReadList("LoadOvfDataForIds", new RowMapper<Pair<Guid, String>>() {

        @Override
        public Pair<Guid, String> mapRow(ResultSet resultSet, int i) throws SQLException {
            return new Pair<>(getGuid(resultSet, "vm_guid"), resultSet.getString("ovf_data"));
        }
    }, getCustomMapSqlParameterSource().addValue("ids", StringUtils.join(ids, ',')));
}
#method_after
@Override
public List<Pair<Guid, String>> loadOvfDataForIds(List<Guid> ids) {
    return getCallsHandler().executeReadList("LoadOvfDataForIds", ovfDataRowMapper, getCustomMapSqlParameterSource().addValue("ids", StringUtils.join(ids, ',')));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (isDiskUsedAsOvfStore(disk)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!checkDiskUsedAsOvfStore(diskValidator)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && isImageNotLocked() && !isDiskUsedAsOvfStore() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration() && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#method_after
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && isImageNotLocked() && isDiskUsedAsOvfStore() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration() && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#end_block

#method_before
protected boolean isDiskUsedAsOvfStore() {
    if (getImage().isOvfStore()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OVF_DISK_NOT_SUPPORTED);
        return true;
    }
    return false;
}
#method_after
protected boolean isDiskUsedAsOvfStore() {
    return validate(new DiskValidator(getImage()).isDiskUsedAsOvfStore());
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    if (diskImage.isOvfStore() && diskImage.getImageStatus() != ImageStatus.ILLEGAL) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_OVF_DISK_NOT_IN_APPLICABLE_STATUS);
    }
    if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(diskImage));
    if (diskImage.isOvfStore() && !validate(diskImagesValidator.disksInStatus(ImageStatus.ILLEGAL))) {
        return false;
    }
    if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (isDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm()));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateOvfStoreContent();
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        Backend.getInstance().runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount));
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateOvfStoreContent();
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        getBackend().runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount));
    }
    setSucceeded(true);
}
#end_block

#method_before
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId());
}
#method_after
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#end_block

#method_before
protected void updateCurrentCd(String cdPath) {
    VmHandler.updateCurrentCd(getVm(), cdPath);
}
#method_after
protected void updateCurrentCd(String cdPath) {
    VmHandler.updateCurrentCd(getVdsId(), getVm(), cdPath);
}
#end_block

#method_before
@Override
protected void perform() {
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#end_block

#method_before
public static void updateCurrentCd(VM vm, String currentCd) {
    VmDynamicDAO vmDynamicDao = DbFacade.getInstance().getVmDynamicDao();
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    vmDynamicDao.update(vmDynamic);
}
#method_after
public static void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vdsId, vmDynamic));
}
#end_block

#method_before
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    return from;
}
#method_after
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    return from;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    return model;
}
#end_block

#method_before
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGusetSessions(vm, sessions);
    return sessions;
}
#method_after
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGuestSessions(vm, sessions);
    return sessions;
}
#end_block

#method_before
@Override
public Sessions list() {
    Object vm = getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), vmId.toString(), true);
    Sessions sessions = VmMapper.map((VM) vm, new Sessions());
    UsersResource usersResource = getUsersResource();
    if (sessions.isSetSessions()) {
        for (Session session : sessions.getSessions()) {
            setSessionId(session);
            setSessionUser(usersResource, session);
            addLinks(session);
        }
    }
    return sessions;
}
#method_after
@Override
public Sessions list() {
    Object obj = getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), vmId.toString(), true);
    VM vm = (VM) obj;
    Sessions sessions = VmMapper.map(vm, new Sessions());
    org.ovirt.engine.api.model.VM vmModel = new org.ovirt.engine.api.model.VM();
    vmModel.setId(vm.getId().toString());
    if (sessions.isSetSessions()) {
        for (Session session : sessions.getSessions()) {
            setSessionId(session);
            setSessionVmId(vmModel, session);
            setSessionUser(session);
            addLinks(session, org.ovirt.engine.api.model.VM.class);
        }
    }
    return sessions;
}
#end_block

#method_before
private void setSessionId(Session session) {
    String idString = session.getUser().getName();
    if (session.isSetIp() && session.getIp().isSetAddress()) {
        idString += session.getIp().getAddress();
    }
    if (session.isSetProtocol()) {
        idString += session.getProtocol();
    }
    session.setId(GuidUtils.generateGuidUsingMd5(idString).toString());
    addLinks(session);
}
#method_after
private void setSessionId(Session session) {
    String idString = session.getUser().getName();
    if (session.isSetIp() && session.getIp().isSetAddress()) {
        idString += session.getIp().getAddress();
    }
    if (session.isSetProtocol()) {
        idString += session.getProtocol();
    }
    session.setId(GuidUtils.generateGuidUsingMd5(idString).toString());
}
#end_block

#method_before
private void setSessionUser(UsersResource usersResource, Session session) {
    if (session.isSetConsoleUser() && session.isConsoleUser()) {
        // all users and search.
        for (User user : usersResource.list().getUsers()) {
            if (user.getName().equals(session.getUser().getName())) {
                session.setUser(user);
                return;
            }
        }
        // Console user is an ovirt user and must be found.
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
}
#method_after
private void setSessionUser(Session session) {
    if (session.isSetConsoleUser() && session.isConsoleUser()) {
        // (only console user assumed to be an ovirt user).
        User user = getUserResource().getUserByName(session.getUser().getName());
        session.getUser().setId(user.getId());
        session.getUser().setHref(user.getHref());
    }
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).update(consoleTab, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).update(consoleTab, simpleField().visibleInAdvancedModeOnly()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // If this a blank template, use the proper value for the default OS
        if (template.getId().equals(Guid.Empty)) {
            Integer osId = AsyncDataProvider.getDefaultOs(getModel().getSelectedCluster().getArchitecture());
            if (osId != null) {
                setSelectedOSById(osId.intValue());
            }
        } else {
            setSelectedOSById(template.getOsId());
        }
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#method_after
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getOverrideSerialNumberPolicy()) {
            overrideSerialNumberPolicyChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getOverrideSerialNumberPolicy()) {
            overrideSerialNumberPolicyChanged();
        } else if (sender == getSerialNumberPolicy()) {
            serialNumberPolicyChanged();
        }
    }
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(highAvailabilityTab, hiddenField()).update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isStatelessEditor, hiddenField()).putOne(isRunAndPauseEditor, hiddenField()).putOne(editPoolEditVmsPanel, hiddenField()).putOne(editPoolIncraseNumOfVmsPanel, hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).putOne(editPoolEditMaxAssignedVmsPerUserPanel, hiddenField());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(highAvailabilityTab, hiddenField()).update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isStatelessEditor, hiddenField()).putOne(isRunAndPauseEditor, hiddenField()).putOne(editPoolEditVmsPanel, hiddenField()).putOne(editPoolIncraseNumOfVmsPanel, hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).putOne(editPoolEditMaxAssignedVmsPerUserPanel, hiddenField()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getOsId());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        BuilderExecutor.build(vmBase, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        BuilderExecutor.build(vmBase, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getTemplateVersionName().setIsChangable(!template.getId().equals(template.getBaseTemplateId()));
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    getModel().getTemplateVersionName().setEntity(template.getTemplateVersionName());
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMemSize().setIsChangable(vm.isDown());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).update(numOfVmsEditor, hiddenField()).update(newPoolEditVmsPanel, hiddenField()).update(newPoolEditMaxAssignedVmsPerUserPanel, hiddenField()).update(editPoolEditVmsPanel, simpleField()).update(editPoolIncraseNumOfVmsPanel, simpleField()).update(editPoolEditMaxAssignedVmsPerUserPanel, simpleField());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).update(numOfVmsEditor, hiddenField()).update(newPoolEditVmsPanel, hiddenField()).update(newPoolEditMaxAssignedVmsPerUserPanel, hiddenField()).update(editPoolEditVmsPanel, simpleField()).update(editPoolIncraseNumOfVmsPanel, simpleField()).update(editPoolEditMaxAssignedVmsPerUserPanel, simpleField()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    optimizeForUtilizationEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    optimizeForSpeedEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    guarantyResourcesEditor = new EntityModelRadioButtonEditor("4");
    // $NON-NLS-1$
    allowOverbookingEditor = new EntityModelRadioButtonEditor("4");
    serialNumberPolicyEditor = new SerialNumberPolicyWidget(eventBus);
}
#method_after
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    optimizeForUtilizationEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    optimizeForSpeedEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    guarantyResourcesEditor = new EntityModelRadioButtonEditor("4");
    // $NON-NLS-1$
    allowOverbookingEditor = new EntityModelRadioButtonEditor("4");
    serialNumberPolicyEditor = new SerialNumberPolicyWidget(eventBus, templates, messages, resources, new VisibilityRenderer.SimpleVisibilityRenderer());
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid();
}
#end_block

#method_before
private void initTextBoxEditors() {
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#method_after
private void initTextBoxEditors() {
    templateVersionNameEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                boolean sysprepEnabled = object.getSysprepEnabled().getEntity();
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
                domainEditor.setVisible(sysprepEnabled);
            }
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                boolean sysprepEnabled = object.getSysprepEnabled().getEntity();
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
                domainEditor.setVisible(sysprepEnabled);
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(any(List.class));
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown() && updateRuntimeParametersRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit()) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#end_block

#method_before
protected boolean validatePciAndIdeLimit() {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.isBalloonEnabled(vm.getId()), VmDeviceUtils.isSoundDeviceEnabled(vm.getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validatePciAndIdeLimit(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.isBalloonEnabled(vm.getId()), VmDeviceUtils.isSoundDeviceEnabled(vm.getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isAtLeastOneVmIsNotDown() {
    for (VM vm : vmsDiskPluggedTo) {
        if (vm.getStatus() != VMStatus.Down) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isAtLeastOneVmIsNotDown(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        if (vm.getStatus() != VMStatus.Down) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected void destroyVm() {
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(getVm().getMigratingToVds().toString()), getVmId(), true, false, 0));
    }
    if (getVm().getStatus() == VMStatus.Paused) {
        VmStatic vmStatic = getVm().getStaticData();
        decreasePendingVms(getVm().getRunOnVds(), vmStatic.getNumOfCpus(), vmStatic.getMinAllocatedMem(), vmStatic.getName());
    }
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), false, false, 0)).getReturnValue());
}
#method_after
protected void destroyVm() {
    boolean wasPaused = (getVm().getStatus() == VMStatus.Paused && getVm().getVmPauseStatus() == VmPauseStatus.NOERR);
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(getVm().getMigratingToVds().toString()), getVmId(), true, false, 0));
    }
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), false, false, 0)).getReturnValue());
    if (wasPaused) {
        VmHandler.decreasePendingVms(getVm(), getVdsId());
    }
}
#end_block

#method_before
@Override
public void rerun() {
    decreasePendingVms(getCurrentVdsId());
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    // set _isRerun flag to false so that we'll be able to know if
    // there is another rerun attempt within the method
    _isRerun = false;
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>getValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getStatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        insertAsyncTaskPlaceHolders();
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            runningFailed();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        runningFailed();
    }
}
#method_after
@Override
public void rerun() {
    decreasePendingVms();
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    // set _isRerun flag to false so that we'll be able to know if
    // there is another rerun attempt within the method
    _isRerun = false;
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>getValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getStatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        insertAsyncTaskPlaceHolders();
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            runningFailed();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        runningFailed();
    }
}
#end_block

#method_before
protected void runningFailed() {
    try {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmPoolOnStopVm();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#method_after
protected void runningFailed() {
    try {
        decreasePendingVms();
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmPoolOnStopVm();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        setSucceeded(true);
        setActionReturnValue(VMStatus.Up);
        log();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), true);
        notifyHostsVmFailed();
        if (getVm().getLastVdsRunOn() == null || !getVm().getLastVdsRunOn().equals(getCurrentVdsId())) {
            getVm().setLastVdsRunOn(getCurrentVdsId());
        }
        if (StringUtils.isNotEmpty(getVm().getHibernationVolHandle())) {
            removeVmHibernationVolumes();
            // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
            // this method (which is a part of the cached VM command,
            // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
            // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
            // status to up.
            getVm().setStatus(VMStatus.Up);
            getVm().setHibernationVolHandle(null);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
        }
    } finally {
        freeLock();
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        decreasePendingVms();
        setSucceeded(true);
        setActionReturnValue(VMStatus.Up);
        log();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), true);
        notifyHostsVmFailed();
        if (getVm().getLastVdsRunOn() == null || !getVm().getLastVdsRunOn().equals(getCurrentVdsId())) {
            getVm().setLastVdsRunOn(getCurrentVdsId());
        }
        if (StringUtils.isNotEmpty(getVm().getHibernationVolHandle())) {
            removeVmHibernationVolumes();
            // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
            // this method (which is a part of the cached VM command,
            // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
            // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
            // status to up.
            getVm().setStatus(VMStatus.Up);
            getVm().setHibernationVolHandle(null);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
        }
    } finally {
        freeLock();
    }
}
#end_block

#method_before
@Override
public void reportCompleted() {
    try {
        ExecutionContext executionContext = getExecutionContext();
        if (executionContext != null && executionContext.isMonitored() && !executionContext.isCompleted()) {
            endExecutionMonitoring();
        }
    } finally {
        freeLock();
    }
}
#method_after
@Override
public final void reportCompleted() {
    try {
        ExecutionContext executionContext = getExecutionContext();
        if (executionContext != null && executionContext.isMonitored() && !executionContext.isCompleted()) {
            endExecutionMonitoring();
        }
    } finally {
        freeLock();
    }
}
#end_block

#method_before
@Override
public void onPowerringUp() {
    VmStatic vmStatic = getVmStaticDAO().get(getVmId());
    decreasePendingVms(getCurrentVdsId(), vmStatic.getNumOfCpus(), vmStatic.getMinAllocatedMem(), vmStatic.getName());
}
#method_after
@Override
public void onPowerringUp() {
    VmStatic vmStatic = getVmStaticDAO().get(getVmId());
    VmHandler.decreasePendingVms(getCurrentVdsId(), vmStatic.getNumOfCpus(), vmStatic.getMinAllocatedMem(), vmStatic.getName());
}
#end_block

#method_before
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsDisabled");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TrustedService");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateType");
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    _writer.WriteStartElement("BaseTemplateId");
    _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateVersionNumber");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getTemplateVersionNumber()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateVersionName");
    _writer.WriteRaw(_vmTemplate.getTemplateVersionName());
    _writer.WriteEndElement();
    // aka highly available
    _writer.WriteStartElement("AutoStartup");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getAutoStartup()));
    _writer.WriteEndElement();
}
#method_after
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement(OvfProperties.NAME);
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_ID);
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.ORIGIN);
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_DEFAULT_DISPLAY_TYPE);
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.IS_DISABLED);
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TRUSTED_SERVICE);
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_TYPE);
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.BASE_TEMPLATE_ID);
    _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_VERSION_NUMBER);
    _writer.WriteRaw(String.valueOf(_vmTemplate.getTemplateVersionNumber()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_VERSION_NAME);
    _writer.WriteRaw(_vmTemplate.getTemplateVersionName());
    _writer.WriteEndElement();
    // aka highly available
    _writer.WriteStartElement("AutoStartup");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isAutoStartup()));
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsDisabled");
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TrustedService");
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TemplateType");
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    node = content.SelectSingleNode("BaseTemplateId");
    if (node != null) {
        _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
    } else {
        // in case base template is missing, we assume it is a base template
        _vmTemplate.setBaseTemplateId(_vmTemplate.getId());
    }
    node = content.SelectSingleNode("TemplateVersionNumber");
    if (node != null) {
        _vmTemplate.setTemplateVersionNumber(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode("TemplateVersionName");
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
    node = content.SelectSingleNode("AutoStartup");
    if (node != null) {
        _vmTemplate.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
}
#method_after
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode(OvfProperties.NAME);
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_DISABLED);
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.TRUSTED_SERVICE);
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_TYPE);
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.BASE_TEMPLATE_ID);
    if (node != null) {
        _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
    } else {
        // in case base template is missing, we assume it is a base template
        _vmTemplate.setBaseTemplateId(_vmTemplate.getId());
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_VERSION_NUMBER);
    if (node != null) {
        _vmTemplate.setTemplateVersionNumber(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_VERSION_NAME);
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
    node = content.SelectSingleNode("AutoStartup");
    if (node != null) {
        _vmTemplate.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
}
#end_block

#method_before
@Override
protected String getDefaultDisplayTypeStringRepresentation() {
    return "default_display_type";
}
#method_after
@Override
protected String getDefaultDisplayTypeStringRepresentation() {
    return OvfProperties.TEMPLATE_DEFAULT_DISPLAY_TYPE;
}
#end_block

#method_before
@Override
public List<Guid> runFilters(List<String> filterNames, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (filterNames.isEmpty()) {
            return hostIDs;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(FILTER, createFilterArgs(filterNames, hostIDs, vmID, propertiesMap));
        return parseFilterResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while filtering", e);
        auditLogFailedToConnect();
        return hostIDs;
    }
}
#method_after
@Override
public List<Guid> runFilters(List<String> filterNames, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (filterNames.isEmpty()) {
            return hostIDs;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object xmlRpcStruct = client.execute(FILTER, createFilterArgs(filterNames, hostIDs, vmID, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getFilteringResult(xmlRpcStruct).getHosts();
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while filtering", e);
        auditLogFailedToConnect();
        return hostIDs;
    }
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> runScores(List<Pair<String, Integer>> scoreNameAndWeight, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (scoreNameAndWeight.isEmpty()) {
            return null;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(SCORE, createScoreArgs(scoreNameAndWeight, hostIDs, vmID, propertiesMap));
        return parseScoreResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while running weight modules", e);
        auditLogFailedToConnect();
        return null;
    }
}
#method_after
@Override
public List<Pair<Guid, Integer>> runScores(List<Pair<String, Integer>> scoreNameAndWeight, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (scoreNameAndWeight.isEmpty()) {
            return null;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(SCORE, createScoreArgs(scoreNameAndWeight, hostIDs, vmID, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getScoreResult(result).getHosts();
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while running weight modules", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return parseBalanceResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while balancing", e);
        auditLogFailedToConnect();
        return null;
    }
}
#method_after
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getBalanceResults(result).getResult();
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while balancing", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    fetchImageTemplates();
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                StorageDomainStatic domain = getDbFacade().getStorageDomainStaticDao().get(domainId);
                problematicDomains.add(domain == null ? domainId.toString() : domain.getStorageName());
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getName());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(getDbFacade().getDiskDao().getAllForVm(vm.getId()), false, false, true);
            Set<Guid> domainsIds = getStorageDomainsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getName());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return validate(checkNoDisksBasedOnTemplateDisks());
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    fetchImageTemplates();
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                StorageDomainStatic domain = getDbFacade().getStorageDomainStaticDao().get(domainId);
                problematicDomains.add(domain == null ? domainId.toString() : domain.getStorageName());
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getName());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(getDbFacade().getDiskDao().getAllForVm(vm.getId()), false, false, true);
            Set<Guid> domainsIds = getStorageDomainsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getName());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    // for base templates, make sure it has no versions that need to be removed first
    if (getParameters().isRemoveTemplateFromDb() && vmTemplateId.equals(template.getBaseTemplateId())) {
        List<VmTemplate> templateVersions = getVmTemplateDAO().getTemplateVersionsForBaseTemplate(vmTemplateId);
        if (!templateVersions.isEmpty()) {
            List<String> templateVersionsNames = new ArrayList<>();
            for (VmTemplate version : templateVersions) {
                templateVersionsNames.add(version.getName());
            }
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_BASE_WITH_VERSIONS);
            addCanDoActionMessage(String.format("$versionsList %1$s", StringUtils.join(templateVersionsNames, ",")));
            return false;
        }
    }
    return validate(checkNoDisksBasedOnTemplateDisks());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (hasImages) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        HandleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (hasImages) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        HandleEndAction();
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getTemplateExclusiveLockMessage()));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getVmTemplate() != null) {
        return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getTemplateExclusiveLockMessage()));
    }
    return null;
}
#end_block

#method_before
public ValidationResult diskImagesAlreadyExist() {
    List<String> existingDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        if (isDiskExists(diskImage.getId())) {
            existingDisksAliases.add(diskImage.getDiskAlias());
        }
    }
    if (!existingDisksAliases.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", StringUtils.join(existingDisksAliases, ", ")));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesAlreadyExist() {
    List<String> existingDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        DiskImage existingDisk = getExistingDisk(diskImage.getId());
        if (existingDisk != null) {
            existingDisksAliases.add(diskImage.getDiskAlias().isEmpty() ? existingDisk.getDiskAlias() : diskImage.getDiskAlias());
        }
    }
    if (!existingDisksAliases.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", StringUtils.join(existingDisksAliases, ", ")));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult diskImagesSnapshotsNotAttachedToOtherVms(boolean onlyPlugged) {
    LinkedList<String> pluggedDiskSnapshotInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        List<VmDevice> devices = getVmDeviceDAO().getVmDevicesByDeviceId(diskImage.getId(), null);
        for (VmDevice device : devices) {
            if (device.getSnapshotId() != null && (!onlyPlugged || device.getIsPlugged())) {
                VM vm = getVmDAO().get(device.getVmId());
                Snapshot snapshot = getSnapshotDAO().get(device.getSnapshotId());
                pluggedDiskSnapshotInfo.add(String.format("%s (from Snapshot: %s VM attached to: %s) %n", diskImage.getDiskAlias(), snapshot.getDescription(), vm.getName()));
            }
        }
    }
    if (!pluggedDiskSnapshotInfo.isEmpty()) {
        pluggedDiskSnapshotInfo.addFirst(String.format("%n"));
        VdcBllMessages message = onlyPlugged ? VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_PLUGGED_TO_ANOTHER_VM : VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_ATTACHED_TO_ANOTHER_VM;
        return new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(pluggedDiskSnapshotInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesSnapshotsNotAttachedToOtherVms(boolean onlyPlugged) {
    LinkedList<String> pluggedDiskSnapshotInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        List<VmDevice> devices = getVmDeviceDAO().getVmDevicesByDeviceId(diskImage.getId(), null);
        for (VmDevice device : devices) {
            if (device.getSnapshotId() != null && (!onlyPlugged || device.getIsPlugged())) {
                VM vm = getVmDAO().get(device.getVmId());
                Snapshot snapshot = getSnapshotDAO().get(device.getSnapshotId());
                pluggedDiskSnapshotInfo.add(String.format("%s ,%s, %s", diskImage.getDiskAlias(), snapshot.getDescription(), vm.getName()));
            }
        }
    }
    if (!pluggedDiskSnapshotInfo.isEmpty()) {
        VdcBllMessages message = onlyPlugged ? VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_PLUGGED_TO_ANOTHER_VM : VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_ATTACHED_TO_ANOTHER_VM;
        return new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(pluggedDiskSnapshotInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult diskImagesHaveNoDerivedDisks(Guid storageDomainId) {
    List<String> disksInfo = null;
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
            List<DiskImage> basedDisks = getDiskImageDAO().getAllSnapshotsForParent(diskImage.getImageId());
            for (DiskImage basedDisk : basedDisks) {
                if (storageDomainId == null || basedDisk.getStorageIds().contains(storageDomainId)) {
                    if (disksInfo == null) {
                        disksInfo = new LinkedList<>();
                    }
                    disksInfo.add(String.format("%s  (%s) ", basedDisk.getDiskAlias(), basedDisk.getId()));
                }
            }
        }
    }
    if (disksInfo != null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_DERIVED_DISKS, String.format("$disksInfo %s", String.format(StringUtils.join(disksInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesHaveNoDerivedDisks(Guid storageDomainId) {
    List<String> disksInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
            List<DiskImage> basedDisks = getDiskImageDAO().getAllSnapshotsForParent(diskImage.getImageId());
            for (DiskImage basedDisk : basedDisks) {
                if (storageDomainId == null || basedDisk.getStorageIds().contains(storageDomainId)) {
                    disksInfo.add(String.format("%s  (%s) ", basedDisk.getDiskAlias(), basedDisk.getId()));
                }
            }
        }
    }
    if (!disksInfo.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_DERIVED_DISKS, String.format("$disksInfo %s", String.format(StringUtils.join(disksInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void diskImagesAlreadyExistBothExist() {
    doReturn(true).when(validator).isDiskExists(any(Guid.class));
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1, disk2)))));
}
#method_after
@Test
public void diskImagesAlreadyExistBothExist() {
    doReturn(new DiskImage()).when(validator).getExistingDisk(any(Guid.class));
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1, disk2)))));
}
#end_block

#method_before
@Test
public void diskImagesAlreadyExistOneExist() {
    doReturn(true).when(validator).isDiskExists(disk1.getId());
    doReturn(false).when(validator).isDiskExists(disk2.getId());
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1)))));
}
#method_after
@Test
public void diskImagesAlreadyExistOneExist() {
    doReturn(new DiskImage()).when(validator).getExistingDisk(disk1.getId());
    doReturn(null).when(validator).getExistingDisk(disk2.getId());
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1)))));
}
#end_block

#method_before
@Test
public void diskImagesAlreadyExistBothDoesntExist() {
    doReturn(false).when(validator).isDiskExists(any(Guid.class));
    assertEquals(validator.diskImagesAlreadyExist(), ValidationResult.VALID);
}
#method_after
@Test
public void diskImagesAlreadyExistBothDoesntExist() {
    doReturn(null).when(validator).getExistingDisk(any(Guid.class));
    assertEquals(validator.diskImagesAlreadyExist(), ValidationResult.VALID);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            }
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
private String convertStreamToString(InputStream is) {
    return new Scanner(is, Charset.defaultCharset().displayName()).useDelimiter("\\A").next().replace("\n", "");
}
#method_after
private String convertStreamToString(InputStream is) {
    return new Scanner(is).useDelimiter("\\A").next().replace("\n", "");
}
#end_block

#method_before
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort.equals("")) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#method_after
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private String readPasswordFile(String passwordFile) throws FileNotFoundException, IOException {
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(passwordFile), Charset.defaultCharset().displayName()))) {
        String readLine = reader.readLine();
        return readLine;
    }
}
#method_after
private String readPasswordFile(String passwordFile) throws FileNotFoundException, IOException {
    FileReader in = new FileReader(passwordFile);
    BufferedReader bufferedReader = new BufferedReader(in);
    String readLine = bufferedReader.readLine();
    closeQuietly(in, bufferedReader);
    return readLine;
}
#end_block

#method_before
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(propFile), Charset.defaultCharset().displayName()))) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordMsg.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#method_after
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (FileWriter fw = new FileWriter(propFile)) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordMsg.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    List<Properties> configurations = createInternalConfigurations();
    configurations.addAll(createKerberosLdapConfigurations());
    ExtensionManager.getInstance().load(configurations);
    AuthenticationProfileRepository.getInstance();
    KerberosManager.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    ExtensionsManager.getInstance().dump();
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#end_block

#method_before
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#method_after
public void updateActionAvailability() {
    if (getItems() == null) {
        // no need to update action availability
        return;
    }
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#end_block

#method_before
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache) throws IOException {
    // response if it doesn't:
    if (!canReadFile(file)) {
        if (!isWhiteListFiles(file)) {
            log.error("Can't read file \"" + (file != null ? file.getAbsolutePath() : "") + "\" for request \"" + request.getRequestURI() + "\", will send a 404 error response.");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        boolean send = true;
        if (cache) {
            String eTag = getETag(file);
            // Always include ETag on response
            response.setHeader("ETag", eTag);
            String IfNoneMatch = request.getHeader("If-None-Match");
            if ("*".equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
                send = false;
            } else if (eTag.equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                send = false;
            }
        }
        if (send) {
            // Send metadata
            String mime = defaultType;
            if (mime == null) {
                mime = mimeMap.getContentType(file);
            }
            response.setContentType(mime);
            response.setContentLength((int) getFileSize(file));
            // Send content
            writeFileToStream(response.getOutputStream(), file);
        }
    }
}
#method_after
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache) throws IOException {
    sendFile(request, response, file, defaultType, cache, true);
}
#end_block

#method_before
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache) throws IOException {
    // response if it doesn't:
    if (!canReadFile(file)) {
        if (!isWhiteListFiles(file)) {
            log.error("Can't read file \"" + (file != null ? file.getAbsolutePath() : "") + "\" for request \"" + request.getRequestURI() + "\", will send a 404 error response.");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        boolean send = true;
        if (cache) {
            String eTag = getETag(file);
            // Always include ETag on response
            response.setHeader("ETag", eTag);
            String IfNoneMatch = request.getHeader("If-None-Match");
            if ("*".equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
                send = false;
            } else if (eTag.equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                send = false;
            }
        }
        if (send) {
            // Send metadata
            String mime = defaultType;
            if (mime == null) {
                mime = mimeMap.getContentType(file);
            }
            response.setContentType(mime);
            response.setContentLength((int) getFileSize(file));
            // Send content
            writeFileToStream(response.getOutputStream(), file);
        }
    }
}
#method_after
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache, boolean required) throws IOException {
    // response if it doesn't:
    if (!canReadFile(file)) {
        if (required) {
            log.error("Can't read file \"" + (file != null ? file.getAbsolutePath() : "") + "\" for request \"" + request.getRequestURI() + "\", will send a 404 error response.");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        boolean send = true;
        if (cache) {
            String eTag = getETag(file);
            // Always include ETag on response
            response.setHeader("ETag", eTag);
            String IfNoneMatch = request.getHeader("If-None-Match");
            if ("*".equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
                send = false;
            } else if (eTag.equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                send = false;
            }
        }
        if (send) {
            // Send metadata
            String mime = defaultType;
            if (mime == null) {
                mime = mimeMap.getContentType(file);
            }
            response.setContentType(mime);
            response.setContentLength((int) getFileSize(file));
            // Send content
            writeFileToStream(response.getOutputStream(), file);
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getStorageDomainDao().getByName(getParameters().getName(), getUserID(), getParameters().isFiltered()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getStorageDomainStaticDao().getByName(getParameters().getName(), getUserID(), getParameters().isFiltered()));
}
#end_block

#method_before
private Guid getClusterId(Host host) {
    String name = (host.isSetCluster() && host.getCluster().isSetName() ? host.getCluster().getName() : "Default");
    return host.isSetCluster() && host.getCluster().isSetId() ? new Guid(host.getCluster().getId()) : getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name).getId();
}
#method_after
private Guid getClusterId(Host host) {
    if (host.isSetCluster()) {
        Cluster cluster = host.getCluster();
        if (cluster.isSetId()) {
            return new Guid(cluster.getId());
        }
        if (cluster.isSetName()) {
            return getClusterIdByName(cluster.getName());
        }
    }
    return getClusterIdByName(DEFAULT_NAME);
}
#end_block

#method_before
@Test
public void testAddHostClusterByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    // setUpGetEntityExpectations("Cluster: name=" + NAMES[1],
    // SearchType.Cluster,
    // setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetCertificateInfo();
    setUpCreationExpectations(VdcActionType.AddVds, AddVdsActionParameters.class, new String[] { "RootPassword" }, new Object[] { ROOT_PASSWORD }, true, true, GUIDS[0], VdcQueryType.GetVdsByVdsId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Host model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Host);
    verifyModel((Host) response.getEntity(), 0);
}
#method_after
@Test
public void testAddHostClusterByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetCertificateInfo();
    setUpCreationExpectations(VdcActionType.AddVds, AddVdsActionParameters.class, new String[] { "RootPassword" }, new Object[] { ROOT_PASSWORD }, true, true, GUIDS[0], VdcQueryType.GetVdsByVdsId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Host model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Host);
    verifyModel((Host) response.getEntity(), 0);
}
#end_block

#method_before
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), name);
}
#method_after
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name);
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUpGetEntityExpectations(2, GUIDS[0], getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, getUsers());
    // setUpGetEntityExpectations(VdcQueryType.Search,
    // SearchParameters.class,
    // new String[] {"SearchPattern", "SearchTypeValue"},
    // new Object[] {"users:", SearchType.DBUser},
    // getUsers());
    setUriInfo(setUpActionExpectations(VdcActionType.RemovePermission, PermissionsOperationsParameters.class, new String[] { "Permission.Id" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#method_after
@Test
public void testRemove() throws Exception {
    setUpGetEntityExpectations(2, GUIDS[0], getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, getUsers());
    setUriInfo(setUpActionExpectations(VdcActionType.RemovePermission, PermissionsOperationsParameters.class, new String[] { "Permission.Id" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testAddByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetConnection(1);
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[0] }, getEntity(0));
    setUpCreationExpectations(VdcActionType.AttachStorageDomainToPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true, null, VdcQueryType.GetStorageDomainByIdAndStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, getEntity(0));
    StorageDomain model = new StorageDomain();
    model.setName(NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof StorageDomain);
    verifyModel((StorageDomain) response.getEntity(), 0);
}
#method_after
@Test
public void testAddByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetConnection(1);
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[0] }, getEntityStatic(0));
    setUpCreationExpectations(VdcActionType.AttachStorageDomainToPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true, null, VdcQueryType.GetStorageDomainByIdAndStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, getEntity(0));
    StorageDomain model = new StorageDomain();
    model.setName(NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof StorageDomain);
    verifyModel((StorageDomain) response.getEntity(), 0);
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.StorageDomain setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomain entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getStatus()).andReturn(StorageDomainStatus.Active).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.StorageDomainStatic setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomainStatic entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    if (!isFiltered()) {
        StorageDomain storageDomain = getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), name);
        if (storageDomain != null) {
            return storageDomain.getId();
        }
        return null;
    } else {
        List<org.ovirt.engine.core.common.businessentities.StorageDomain> storageDomains = getBackendCollection(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetAllStorageDomains, new VdcQueryParametersBase());
        for (org.ovirt.engine.core.common.businessentities.StorageDomain storageDomain : storageDomains) {
            if (storageDomain.getStorageName().equals(name)) {
                return storageDomain.getId();
            }
        }
        return null;
    }
}
#method_after
protected Guid lookupStorageDomainIdByName(String name) {
    if (!isFiltered()) {
        StorageDomainStatic storageDomain = getEntity(org.ovirt.engine.core.common.businessentities.StorageDomainStatic.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), "Storage: name=" + name);
        if (storageDomain != null) {
            return storageDomain.getId();
        }
        return null;
    } else {
        List<org.ovirt.engine.core.common.businessentities.StorageDomain> storageDomains = getBackendCollection(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetAllStorageDomains, new VdcQueryParametersBase());
        for (org.ovirt.engine.core.common.businessentities.StorageDomain storageDomain : storageDomains) {
            if (storageDomain.getStorageName().equals(name)) {
                return storageDomain.getId();
            }
        }
        return null;
    }
}
#end_block

#method_before
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false);
}
#method_after
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false);
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), name).getId();
}
#method_after
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomainStatic.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), "Storage: name=" + name).getId();
}
#end_block

#method_before
protected Guid getDataCenterId(Network network) {
    return getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(network.getDataCenter().getName()), "Datacenter: name=" + network.getDataCenter().getName()).getId();
}
#method_after
protected Guid getDataCenterId(Network network) {
    String networkName = network.getDataCenter().getName();
    return getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(networkName), "Datacenter: name=" + networkName).getId();
}
#end_block

#method_before
protected void testCopyBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomainEntity(0)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainEntity(0));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveOrCopyDisk, MoveOrCopyImageGroupParameters.class, new String[] { "ImageId", "SourceDomainId", "StorageDomainId", "Operation" }, new Object[] { GUIDS[1], Guid.Empty, GUIDS[3], ImageOperation.Copy }));
    verifyActionResponse(resource.copy(setUpCopyParams(true)));
}
#method_after
protected void testCopyBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomainEntity(0)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStaticEntity(0));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveOrCopyDisk, MoveOrCopyImageGroupParameters.class, new String[] { "ImageId", "SourceDomainId", "StorageDomainId", "Operation" }, new Object[] { GUIDS[1], Guid.Empty, GUIDS[3], ImageOperation.Copy }));
    verifyActionResponse(resource.copy(setUpCopyParams(true)));
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.StorageDomain setUpStorageDomainEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomain entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[3]).anyTimes();
    expect(entity.getStorageName()).andReturn(NAMES[2]).anyTimes();
    expect(entity.getStatus()).andReturn(StorageDomainStatus.Active).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.StorageDomainStatic setUpStorageDomainEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomainStatic entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[3]).anyTimes();
    expect(entity.getStorageName()).andReturn(NAMES[2]).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#end_block

#method_before
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false, false);
}
#method_after
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false, false);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getParameters().getId());
    List<VmTemplate> templateList = DbFacade.getInstance().getVmTemplateDao().getAllForStorageDomain(pool.getId());
    for (VmTemplate template : templateList) {
        VmHandler.updateVmInitFromDB(template, true);
    }
    VmTemplate blank = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    if (!templateList.contains(blank)) {
        templateList.add(0, blank);
    }
    getQueryReturnValue().setReturnValue(templateList);
}
#method_after
@Override
protected void executeQueryCommand() {
    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getParameters().getId());
    List<VmTemplate> templateList = DbFacade.getInstance().getVmTemplateDao().getAllForStorageDomain(pool.getId());
    // Load VmInit and disks
    for (VmTemplate template : templateList) {
        VmHandler.updateVmInitFromDB(template, true);
        VmTemplateHandler.updateDisksFromDb(template);
    }
    VmTemplate blank = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    if (!templateList.contains(blank)) {
        templateList.add(0, blank);
    }
    getQueryReturnValue().setReturnValue(templateList);
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), name).getId();
}
#method_after
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomainStatic.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), "Storage: name=" + name).getId();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(new Guid(id)), "Datacenter: id=" + id);
    } else {
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(cluster.getDataCenter().getName()), "Datacenter: name=" + cluster.getDataCenter().getName());
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#method_after
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(new Guid(id)), "Datacenter: id=" + id);
    } else {
        String clusterName = cluster.getDataCenter().getName();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(clusterName), "Datacenter: name=" + clusterName);
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#end_block

#method_before
@Test
public void testExportWithStorageDomainName() throws Exception {
    // setUpGetEntityExpectations("Storage: name=" + NAMES[2],
    // SearchType.StorageDomain,
    // getStorageDomain(2));
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false, false);
}
#method_after
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false, false);
}
#end_block

#method_before
@Test
public void testMoveWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestMove(storageDomain);
}
#method_after
@Test
public void testMoveWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestMove(storageDomain);
}
#end_block

#method_before
@Test
public void testGet() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, getUsers());
    setUpGetEntityExpectations();
    control.replay();
    verifyModel(resource.get(), 0);
}
#method_after
@Test
public void testGet() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] { "Refresh", "Filtered" }, new Object[] { true, false }, getUsers());
    setUpGetEntityExpectations();
    control.replay();
    verifyModel(resource.get(), 0);
}
#end_block

#method_before
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false);
}
#method_after
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false);
}
#end_block

#method_before
protected void testMoveBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomain(2)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveDisks, MoveDisksParameters.class, new String[] {}, new Object[] {}));
    verifyActionResponse(((VmDiskResource) resource).move(setUpMoveParams(true)));
}
#method_after
protected void testMoveBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomain(2)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveDisks, MoveDisksParameters.class, new String[] {}, new Object[] {}));
    verifyActionResponse(((VmDiskResource) resource).move(setUpMoveParams(true)));
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.map(model.getSerialNumber(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.map(model.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.map(model.getSerialNumber(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = HasSerialNumberPolicy.class, to = SerialNumber.class)
public static SerialNumber map(HasSerialNumberPolicy entity, SerialNumber template) {
    if (template == null) {
        template = new SerialNumber();
    }
    SerialNumberPolicy policy = map(entity.getSerialNumberPolicy(), null);
    if (policy != null) {
        template.setPolicy(policy.value());
    }
    if (policy == SerialNumberPolicy.CUSTOM) {
        template.setValue(entity.getCustomSerialNumber());
    }
    return template;
}
#method_after
@Mapping(from = HasSerialNumberPolicy.class, to = SerialNumber.class)
public static SerialNumber map(HasSerialNumberPolicy entity, SerialNumber template) {
    if (template == null) {
        template = new SerialNumber();
    }
    SerialNumberPolicy policy = map(entity.getSerialNumberPolicy(), null);
    template.setPolicy(policy == null ? "" : policy.value());
    template.setValue(entity.getCustomSerialNumber());
    return template;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        if (staticVm.getVmInit().getDomain() == null) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.map(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName()).addValue("serial_number_policy", template.getSerialNumberPolicy() == null ? template.getSerialNumberPolicy().getValue() : null).addValue("custom_serial_number", template.getCustomSerialNumber());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName()).addValue("serial_number_policy", template.getSerialNumberPolicy() == null ? null : template.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", template.getCustomSerialNumber());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    buildVmData();
    mVmReturn = getBroker().create(createInfo);
    logCommandInfo();
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    buildVmData();
    logCommandInfo();
    mVmReturn = getBroker().create(createInfo);
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#end_block

#method_before
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId());
}
#method_after
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#end_block

#method_before
protected LdapUser populateUserData(LdapUser user, String domain, boolean populateGroups) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (populateGroups) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain, boolean populateGroups) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    HashMap<String, LdapGroup> groupsDict = new HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (populateGroups) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#end_block

#method_before
protected void populateGroup(LdapQueryData queryData, String domain, java.util.Map<String, LdapGroup> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                populateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("populateGroup failed. Exception: {0}", e);
    }
}
#method_after
protected void populateGroup(LdapQueryData queryData, String domain, Map<String, LdapGroup> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                populateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("populateGroup failed. Exception: {0}", e);
    }
}
#end_block

#method_before
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, java.util.Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    LdapGroup group = new LdapGroup();
    group.setid(groupsResult.getId());
    group.setname(LdapBrokerUtils.generateGroupDisplayValue(groupsResult.getDistinguishedName()));
    group.setMemberOf(groupsResult.getMemberOf());
    group.setDistinguishedName(groupsResult.getDistinguishedName());
    groupsDict.put(group.getname(), group);
    globalGroupsDict.put(group.getname(), group);
    proceedGroupsSearchResult(groupsResult.getId(), groupsList, groupsDict, generator);
}
#method_after
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    LdapGroup group = new LdapGroup();
    group.setid(groupsResult.getId());
    group.setname(LdapBrokerUtils.generateGroupDisplayValue(groupsResult.getDistinguishedName()));
    group.setMemberOf(groupsResult.getMemberOf());
    group.setDistinguishedName(groupsResult.getDistinguishedName());
    groupsDict.put(group.getname(), group);
    globalGroupsDict.put(group.getname(), group);
    proceedGroupsSearchResult(groupsResult.getId(), groupsList, groupsDict, generator);
}
#end_block

#method_before
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<LdapUser> tempUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#method_after
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        ArrayList<LdapUser> tempUsers = (ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isUserCanBeAuthenticated() && attachUserToSession();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = isUserCanBeAuthenticated() && attachUserToSession();
    if (!result) {
        logAutheticationFailure();
    }
    return result;
}
#end_block

#method_before
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "GetVdsGroupByName");
}
#method_after
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name);
}
#end_block

#method_before
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_IS_PASSWORD_AUTH, true);
}
#method_after
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES, AAA_AUTH_CAP_FLAGS_PASSWORD);
}
#end_block

#method_before
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Header authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH, true);
}
#method_after
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Header authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES, AAA_AUTH_CAP_FLAGS_NEGOTIATING);
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_IS_PASSWORD_AUTH, true);
    if (passwordChangeMsgPerDomain == null) {
        synchronized (ProvisionalAuthenticator.class) {
            if (passwordChangeMsgPerDomain == null) {
                passwordChangeMsgPerDomain = new HashMap<>();
                String changePasswordUrl = Config.<String>getValue(ConfigValues.ChangePasswordMsg);
                String[] pairs = changePasswordUrl.split(",");
                for (String pair : pairs) {
                    // Split the pair in such a way that if the URL contains :, it will not be split to strings
                    String[] pairParts = pair.split(":", 2);
                    if (pairParts.length >= 2) {
                        try {
                            passwordChangeMsgPerDomain.put(pairParts[0], URLDecoder.decode(pairParts[1], "UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                            throw new AAAExtensionException(AAAExtensionError.INVALID_CONFIGURATION, "error in obtaining the password change message or url for " + pairParts[0]);
                        }
                    }
                }
            }
        }
    }
    String changePasswordMsgOrUrl = passwordChangeMsgPerDomain.get(getProfileName());
    if (changePasswordMsgOrUrl != null) {
        ExtensionProperties key = containsURL(changePasswordMsgOrUrl) ? ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_URL : ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_MSG;
        context.put(key, changePasswordMsgOrUrl);
    }
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES, AAA_AUTH_CAP_FLAGS_PASSWORD);
    if (passwordChangeMsgPerDomain == null) {
        synchronized (ProvisionalAuthenticator.class) {
            if (passwordChangeMsgPerDomain == null) {
                passwordChangeMsgPerDomain = new HashMap<>();
                String changePasswordUrl = Config.<String>getValue(ConfigValues.ChangePasswordMsg);
                String[] pairs = changePasswordUrl.split(",");
                for (String pair : pairs) {
                    // Split the pair in such a way that if the URL contains :, it will not be split to strings
                    String[] pairParts = pair.split(":", 2);
                    if (pairParts.length >= 2) {
                        try {
                            passwordChangeMsgPerDomain.put(pairParts[0], URLDecoder.decode(pairParts[1], "UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                            throw new AAAExtensionException(AAAExtensionError.INVALID_CONFIGURATION, "error in obtaining the password change message or url for " + pairParts[0]);
                        }
                    }
                }
            }
        }
    }
    String changePasswordMsgOrUrl = passwordChangeMsgPerDomain.get(getProfileName());
    if (changePasswordMsgOrUrl != null) {
        ExtensionProperties key = containsURL(changePasswordMsgOrUrl) ? ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_URL : ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_MSG;
        context.put(key, changePasswordMsgOrUrl);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isUserCanBeAuthenticated() && attachUserToSession();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = isUserCanBeAuthenticated() && attachUserToSession();
    if (!result) {
        logAutheticationFailure();
    }
    return result;
}
#end_block

#method_before
public boolean isNegotiationAuth() {
    return context.get(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH) != null ? (Boolean) context.get(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH) : false;
}
#method_after
public boolean isNegotiationAuth() {
    Integer capabilities = (Integer) context.get(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES);
    if (capabilities == null) {
        return false;
    } else {
        return (capabilities & AAA_AUTH_CAP_FLAGS_NEGOTIATING) != 0;
    }
}
#end_block

#method_before
public boolean isPasswordAuth() {
    return context.get(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH) != null ? (Boolean) context.get(ExtensionProperties.AAA_IS_PASSWORD_AUTH) : false;
}
#method_after
public boolean isPasswordAuth() {
    Integer capabilities = (Integer) context.get(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES);
    if (capabilities == null) {
        return false;
    } else {
        return (capabilities & AAA_AUTH_CAP_FLAGS_PASSWORD) != 0;
    }
}
#end_block

#method_before
@Override
public void initialize() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsFromConfigurationByVmId, new IdQueryParameters(vmId), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response != null && response.getSucceeded()) {
                PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) model;
                ArrayList<SnapshotModel> snapshotModels = new ArrayList<SnapshotModel>();
                ArrayList<Snapshot> snapshots = response.getReturnValue();
                previewSnapshotModel.sortSnapshots(snapshots);
                Guid activeSnapshotId = null;
                Guid userSelectedSnapshotId = previewSnapshotModel.getSnapshotModel().getEntity().getId();
                for (Snapshot snapshot : snapshots) {
                    SnapshotModel snapshotModel = new SnapshotModel();
                    snapshotModel.setEntity(snapshot);
                    snapshotModel.getMemory().setEntity(false);
                    snapshotModel.setDisks((ArrayList<DiskImage>) snapshot.getDiskImages());
                    snapshotModels.add(snapshotModel);
                    if (snapshot.getType() == Snapshot.SnapshotType.ACTIVE) {
                        activeSnapshotId = snapshot.getId();
                    }
                }
                previewSnapshotModel.getSnapshots().setItems(snapshotModels);
                updateDiskSnapshotsMap();
                // Update disk-snapshots map
                updateDiskSnapshotsMap();
                // First selecting the active snapshot for ensuring default disks selection
                // (i.e. when some disk are missing from the selected snapshot,
                // the corresponding disks from the active snapshot should be selected).
                previewSnapshotModel.selectSnapshot(activeSnapshotId);
                // Selecting the snapshot the was selected by the user
                previewSnapshotModel.selectSnapshot(userSelectedSnapshotId);
            }
        }
    }));
}
#method_after
@Override
public void initialize() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsFromConfigurationByVmId, new IdQueryParameters(vmId), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response != null && response.getSucceeded()) {
                PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) model;
                ArrayList<SnapshotModel> snapshotModels = new ArrayList<SnapshotModel>();
                ArrayList<Snapshot> snapshots = response.getReturnValue();
                previewSnapshotModel.sortSnapshots(snapshots);
                Guid activeSnapshotId = null;
                Guid userSelectedSnapshotId = previewSnapshotModel.getSnapshotModel().getEntity().getId();
                for (Snapshot snapshot : snapshots) {
                    SnapshotModel snapshotModel = new SnapshotModel();
                    snapshotModel.setEntity(snapshot);
                    snapshotModel.getMemory().setEntity(false);
                    snapshotModel.setDisks((ArrayList<DiskImage>) snapshot.getDiskImages());
                    snapshotModels.add(snapshotModel);
                    if (snapshot.getType() == Snapshot.SnapshotType.ACTIVE) {
                        activeSnapshotId = snapshot.getId();
                    }
                }
                previewSnapshotModel.getSnapshots().setItems(snapshotModels);
                updateDiskSnapshotsMap();
                // Update disk-snapshots map
                updateDiskSnapshotsMap();
                // First selecting the active snapshot for ensuring default disks selection
                // (i.e. when some disks are missing from the selected snapshot,
                // the corresponding disks from the active snapshot should be selected).
                previewSnapshotModel.selectSnapshot(activeSnapshotId);
                // Selecting the snapshot the was selected by the user
                previewSnapshotModel.selectSnapshot(userSelectedSnapshotId);
            }
        }
    }));
}
#end_block

#method_before
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && !getOldNetwork().getLabel().equals(getNetwork().getLabel());
}
#method_after
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && labelChanged();
}
#end_block

#method_before
@Test
public void verifyListOfRunningVmsIsSameWithSuccessFromVdsmResponse() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(true);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<VM> runningAndUnchanged = updater.checkVmsStatusChanged();
    Assert.assertTrue("expecting the VM in running VMs map", updater.getRunningVms().containsKey(VM_1));
    Assert.assertFalse(runningAndUnchanged.contains(VM_1));
}
#method_after
@Test
public void verifyListOfRunningVmsIsSameWithSuccessFromVdsmResponse() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(true);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<Guid> staleRunningVms = updater.checkVmsStatusChanged();
    Assert.assertTrue(updater.getRunningVms().containsKey(VM_1));
    Assert.assertFalse(staleRunningVms.contains(VM_1));
}
#end_block

#method_before
@Test
public void verifyListOfRunningVmsIsSameWithFailureOnGetVmStats() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(false);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<VM> runningAndUnchanged = updater.checkVmsStatusChanged();
    Assert.assertTrue("expecting the VM to be missing from the running VMs map", !updater.getRunningVms().containsKey(VM_1));
    Assert.assertFalse(runningAndUnchanged.contains(VM_1));
}
#method_after
@Test
public void verifyListOfRunningVmsIsSameWithFailureOnGetVmStats() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(false);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<Guid> staleRunningVms = updater.checkVmsStatusChanged();
    Assert.assertFalse(updater.getRunningVms().containsKey(VM_1));
    Assert.assertTrue(staleRunningVms.contains(VM_1));
}
#end_block

#method_before
private void prepareForRefreshVmStatsCall() {
    initVm();
    mockUpdater();
    mockListCommand();
    muteNonRelatedMethods();
}
#method_after
private void prepareForRefreshVmStatsCall() {
    initVm();
    mockUpdater();
    mockListCommand();
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#end_block

#method_before
protected List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusNotChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                } else {
                    log.error("failed to fetch vm stats. status remain unchanged");
                    statusNotChanged = true;
                }
            } else {
                statusNotChanged = true;
            }
            if (statusNotChanged) {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VDSReturnValue vdsReturnValue;
    if (!_vdsManager.getRefreshStatistics()) {
        vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.List, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetAllVmStats, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (vdsReturnValue.getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", vdsReturnValue.toString());
        }
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VDSReturnValue vdsReturnValue;
    VDSCommandType commandType = _vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (vdsReturnValue.getSucceeded()) {
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", commandType.name());
        }
    }
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || !EnumSet.of(runningVm.getStatus(), VMStatus.PreparingForHibernate, VMStatus.Up).contains(vmToUpdate.getStatus())) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                } else {
                    log.error("failed to fetch vm stats. set to UNKNOWN to ignore it");
                    _runningVms.get(runningVm.getId()).getVmDynamic().setStatus(VMStatus.Unknown);
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
private List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vdsReturnValue.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vdsReturnValue.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                staleRunningVms.add(vmToUpdate.getId());
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        memCommited += vm.getVmMemSizeMb();
        memCommited += _vds.getGuestOverhead();
        vmsCoresCount += vm.getNumOfCpus();
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (vm.getStatus() != VMStatus.WaitForLaunch) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
    // do the state transition only if that VM is really running on SRC
    if (curVm.getRunOnVds() != null || curVm.getStatus() != VMStatus.MigratingTo) {
        // Updating the DB
        ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
    }
}
#method_after
private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
    // do the state transition only if that VM is really running on SRC
    if (getVdsId().equals(curVm.getRunOnVds())) {
        ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
    }
}
#end_block

#method_before
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    initActionButtons(constants);
    disableActiveSnapshotRow();
    getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateMemoryColumnVisibility();
        }
    });
    // Add selection listener
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Snapshot snapshot = (Snapshot) getModel().getSelectedItem();
            if (snapshot != null && !getTable().getSelectionModel().isSelected(snapshot)) {
                getTable().getSelectionModel().setSelected(snapshot, true);
            }
            vmSnapshotInfoPanel.updatePanel(snapshot);
        }
    });
}
#method_after
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    getTable().setMultiSelectionDisabled(true);
    initActionButtons(constants);
    // Add event listeners
    getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateMemoryColumnVisibility();
        }
    });
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateSnapshotInfo();
        }
    });
}
#end_block

#method_before
private void updateMemoryColumnVisibility() {
    VM vm = (VM) getModel().getEntity();
    if (vm == null) {
        return;
    }
    getTable().ensureColumnPresent(SnapshotsViewColumns.dateColumn, constants.dateSnapshot(), true, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.statusColumn, constants.statusSnapshot(), true, // $NON-NLS-1$
    "75px");
    boolean archSnapshotSupported = AsyncDataProvider.isSnapshotSupported(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archSnapshotSupported;
    getTable().ensureColumnPresent(SnapshotsViewColumns.memoryColumn, constants.memorySnapshot(), memorySnapshotSupported, // $NON-NLS-1$
    "55px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.descriptionColumn, constants.descriptionSnapshot(), true, // $NON-NLS-1$
    "185px");
}
#method_after
private void updateMemoryColumnVisibility() {
    VM vm = (VM) getModel().getEntity();
    if (vm == null) {
        return;
    }
    getTable().ensureColumnPresent(SnapshotsViewColumns.dateColumn, constants.dateSnapshot(), true, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.statusColumn, constants.statusSnapshot(), true, // $NON-NLS-1$
    "75px");
    boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && isMemorySnapshotSupported(vm);
    getTable().ensureColumnPresent(SnapshotsViewColumns.memoryColumn, constants.memorySnapshot(), memorySnapshotSupported, // $NON-NLS-1$
    "55px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.descriptionColumn, constants.descriptionSnapshot(), true, // $NON-NLS-1$
    "185px");
}
#end_block

#method_before
private void initActionButtons(final CommonApplicationConstants constants) {
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.createSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.previewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getPreviewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.undoSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getUndoCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.deleteSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.cloneSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }

        @Override
        public String getButtonToolTip() {
            if (!getModel().getIsCloneVmSupported() && getModel().getEntity() != null) {
                CommandVersionsInfo commandVersionsInfo = AsyncDataProvider.getCommandVersionsInfo(VdcActionType.AddVmFromSnapshot);
                String minimalClusterVersion = commandVersionsInfo != null ? commandVersionsInfo.getClusterVersion().toString(2) : // $NON-NLS-1$
                "";
                return messages.cloneVmNotSupported(minimalClusterVersion);
            } else {
                return this.getTitle();
            }
        }
    });
}
#method_after
private void initActionButtons(final CommonApplicationConstants constants) {
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.createSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    List<ActionButtonDefinition<Snapshot>> previewSubActions = new LinkedList<ActionButtonDefinition<Snapshot>>();
    previewSubActions.add(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.customPreviewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCustomPreviewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.previewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getPreviewCommand();
        }
    }, new DropdownActionButton<Snapshot>(previewSubActions, getModel().getSelectedItems()));
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.undoSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getUndoCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.deleteSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.cloneSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }

        @Override
        public String getButtonToolTip() {
            if (!getModel().getIsCloneVmSupported() && getModel().getEntity() != null) {
                CommandVersionsInfo commandVersionsInfo = AsyncDataProvider.getCommandVersionsInfo(VdcActionType.AddVmFromSnapshot);
                String minimalClusterVersion = commandVersionsInfo != null ? commandVersionsInfo.getClusterVersion().toString(2) : // $NON-NLS-1$
                "";
                return messages.cloneVmNotSupported(minimalClusterVersion);
            } else {
                return this.getTitle();
            }
        }
    });
}
#end_block

#method_before
void localize(CommonApplicationConstants constants) {
    descriptionEditor.setLabel(constants.virtualMachineSnapshotCreatePopupDescriptionLabel());
    memoryEditor.setLabel(constants.virtualMachineSnapshotCreatePopupMemoryLabel());
}
#method_after
void localize(CommonApplicationConstants constants) {
    descriptionEditor.setLabel(constants.virtualMachineSnapshotCreatePopupDescriptionLabel());
    memoryEditor.setLabel(constants.virtualMachineSnapshotCreatePopupMemoryLabel());
    disksTableLabel.setText(constants.snapshotDisks());
}
#end_block

#method_before
@Override
public void edit(final SnapshotModel model) {
    driver.edit(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            } else if ("VM".equals(propName)) {
                // $NON-NLS-1$
                updateMemoryBoxVisibility();
            }
        }

        private void updateMemoryBoxVisibility() {
            VM vm = model.getVm();
            if (vm == null) {
                return;
            }
            boolean archSnapshotSupported = AsyncDataProvider.isSnapshotSupported(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
            boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archSnapshotSupported;
            memoryEditor.setVisible(memorySnapshotSupported && vm.isRunning());
            // is not visible, we should disable it explicitly
            if (!memoryEditor.isVisible()) {
                model.getMemory().setEntity(false);
            }
        }
    });
}
#method_after
@Override
public void edit(final SnapshotModel model) {
    driver.edit(model);
    editDisksTable(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            } else if ("VM".equals(propName)) {
                // $NON-NLS-1$
                updateMemoryBoxVisibility();
            }
        }

        private void updateMemoryBoxVisibility() {
            VM vm = model.getVm();
            if (vm == null) {
                return;
            }
            boolean archMemorySnapshotSupported = AsyncDataProvider.isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
            boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
            memoryEditor.setVisible(memorySnapshotSupported && vm.isRunning());
            // is not visible, we should disable it explicitly
            if (!memoryEditor.isVisible()) {
                model.getMemory().setEntity(false);
            }
        }
    });
    model.getMemory().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateMemoryWarning(model);
        }
    });
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    ArrayList<Snapshot> snapshots = value != null ? Linq.<Snapshot>cast(value) : new ArrayList<Snapshot>();
    Collections.sort(snapshots, Collections.reverseOrder(new SnapshotByCreationDateCommparer()));
    ArrayList<Snapshot> sortedSnapshots = new ArrayList<Snapshot>();
    for (Snapshot snapshot : snapshots) {
        SnapshotModel snapshotModel = snapshotsMap.get(snapshot.getId());
        if (snapshotModel == null) {
            snapshotModel = new SnapshotModel();
            snapshotsMap.put(snapshot.getId(), snapshotModel);
        }
        snapshotModel.setEntity(snapshot);
        if ((snapshot.getType() == SnapshotType.ACTIVE && getInType(SnapshotType.PREVIEW, snapshots) == null) || snapshot.getType() == SnapshotType.PREVIEW) {
            sortedSnapshots.add(0, snapshot);
        } else if (snapshot.getType() == SnapshotType.REGULAR || snapshot.getType() == SnapshotType.STATELESS) {
            sortedSnapshots.add(snapshot);
        }
    }
    super.setItems(sortedSnapshots);
    if (isEntityChanged && sortedSnapshots.size() > 1) {
        setSelectedItem(sortedSnapshots.get(1));
    }
    isEntityChanged = false;
    updateActionAvailability();
}
#method_after
@Override
public void setItems(Iterable value) {
    ArrayList<Snapshot> snapshots = value != null ? Linq.<Snapshot>cast(value) : new ArrayList<Snapshot>();
    Collections.sort(snapshots, Collections.reverseOrder(new SnapshotByCreationDateCommparer()));
    ArrayList<Snapshot> sortedSnapshots = new ArrayList<Snapshot>();
    for (Snapshot snapshot : snapshots) {
        SnapshotModel snapshotModel = snapshotsMap.get(snapshot.getId());
        if (snapshotModel == null) {
            snapshotModel = new SnapshotModel();
            snapshotsMap.put(snapshot.getId(), snapshotModel);
        }
        snapshotModel.setEntity(snapshot);
        if ((snapshot.getType() == SnapshotType.ACTIVE && getInType(SnapshotType.PREVIEW, snapshots) == null) || snapshot.getType() == SnapshotType.PREVIEW) {
            sortedSnapshots.add(0, snapshot);
        } else if (snapshot.getType() == SnapshotType.REGULAR || snapshot.getType() == SnapshotType.STATELESS) {
            sortedSnapshots.add(snapshot);
        }
    }
    super.setItems(sortedSnapshots);
    // Try to select the last created snapshot (fallback to active snapshot)
    if (getSelectedItem() == null) {
        setSelectedItem(sortedSnapshots.size() > 1 ? sortedSnapshots.get(1) : sortedSnapshots.get(0));
    }
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        isEntityChanged = true;
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        getSearchCommand().execute();
    }
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    if (getSelectedItem() != null) {
        Snapshot snapshot = ((Snapshot) getSelectedItem());
        updateVmConfigurationBySnapshot(snapshot.getId());
    }
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#end_block

#method_before
private void onRemove() {
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = (VM) getEntity();
    if (vm != null) {
        Frontend.RunAction(VdcActionType.RemoveSnapshot, new RemoveSnapshotParameters(snapshot.getId(), vm.getId()), null, null);
    }
    getCanSelectSnapshot().setEntity(false);
    cancel();
}
#method_after
private void onRemove() {
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = (VM) getEntity();
    if (vm != null) {
        Frontend.getInstance().runAction(VdcActionType.RemoveSnapshot, new RemoveSnapshotParameters(snapshot.getId(), vm.getId()), null, null);
    }
    getCanSelectSnapshot().setEntity(false);
    cancel();
}
#end_block

#method_before
private void undo() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getPreview();
        Frontend.RunAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#method_after
private void undo() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getPreview();
        Frontend.getInstance().runAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#end_block

#method_before
private void commit() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getInPreview();
        Frontend.RunAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#method_after
private void commit() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getInPreview();
        Frontend.getInstance().runAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#end_block

#method_before
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.RunAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        model.getCommands().add(// $NON-NLS-1$
        new UICommand("OnPreview", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        UICommand cancelCommand = // $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true);
        model.getCommands().add(cancelCommand);
        model.setCancelCommand(cancelCommand);
        model.setCloseCommand(// $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsCancel(true));
    }
}
#method_after
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.getInstance().runAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        // $NON-NLS-1$
        addCommands(model, "OnPreview");
    }
}
#end_block

#method_before
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    model.setCancelCommand(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
private void onCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setcurrentVm(behavior.getVm());
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomProperties().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    VDS defaultHost = model.getDefaultHost().getSelectedItem();
    getcurrentVm().setDedicatedVmForVds(model.getIsAutoAssign().getEntity() ? null : defaultHost.getId());
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(getcurrentVm().getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.cancel();
                vmSnapshotListModel.updateActionAvailability();
            }
        }
    }, this);
}
#method_after
private void onCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setcurrentVm(behavior.getVm());
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomProperties().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    VDS defaultHost = model.getDefaultHost().getSelectedItem();
    getcurrentVm().setDedicatedVmForVds(model.getIsAutoAssign().getEntity() ? null : defaultHost.getId());
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(getcurrentVm().getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.cancel();
                vmSnapshotListModel.updateActionAvailability();
            }
        }
    }, this);
}
#end_block

#method_before
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#method_after
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#end_block

#method_before
protected boolean isMemorySnapshotSupported() {
    if (getEntity() == null) {
        return false;
    }
    VM vm = (VM) getEntity();
    boolean archSnapshotSupported = AsyncDataProvider.isSnapshotSupported(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archSnapshotSupported;
}
#method_after
protected boolean isMemorySnapshotSupported() {
    if (getEntity() == null) {
        return false;
    }
    VM vm = (VM) getEntity();
    boolean archMemorySnapshotSupported = AsyncDataProvider.isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        OnPreview();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCustomPreviewCommand()) {
        customPreview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        onPreview();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCustomPreview")) {
        onCustomPreview();
    }
}
#end_block

#method_before
protected void initCredentials(String domain) {
    DbUser curUser;
    String curPassword;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        setLoginName(curUser.getLoginName());
        setPassword(curPassword);
        setAuthenticationDomain(curUser.getDomain());
    } else {
        Domain domainObject = UsersDomainsCacheManagerService.getInstance().getDomain(domain);
        if (domainObject != null) {
            setLoginName(domainObject.getUserName());
            setPassword(domainObject.getPassword());
            if (getLoginName().contains("@")) {
                String userDomain = getLoginName().split("@")[1].toLowerCase();
                setAuthenticationDomain(userDomain);
            } else {
                setAuthenticationDomain(domain);
            }
        }
    }
}
#method_after
protected void initCredentials(String domain) {
    setUserDomainCredentials(domain);
}
#end_block

#method_before
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccured = false;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccured = directorySearcher.getException() != null;
    } catch (RuntimeException e) {
        log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
    } finally {
        if (exceptionOccured) {
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#method_after
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccurred = true;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccurred = directorySearcher.getException() != null;
    } finally {
        if (exceptionOccurred) {
            log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#end_block

#method_before
protected LdapUser populateUserData(LdapUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (user != null) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain) {
    return populateUserData(user, domain, true);
}
#end_block

#method_before
protected LdapUser populateUserData(LdapUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (user != null) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain, boolean populateGroups) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (populateGroups) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        authResult = handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        if (authResult == null) {
            authResult = new UserAuthenticationResult(user, VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        } else if (authResult.getErrorMessages().isEmpty()) {
            authResult.getErrorMessages().add(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
    }
    setReturnValue(authResult);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(AAAExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#end_block

#method_before
private UserAuthenticationResult handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    VdcBllMessages errorMsg = VdcBllMessages.USER_FAILED_TO_AUTHENTICATE;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        errorMsg = VdcBllMessages.valueOf(result.getVdcBllMessage());
        log.error(result.getDetailedMessage());
    }
    authResult = new UserAuthenticationResult(errorMsg);
    return authResult;
}
#method_after
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw new AAAExtensionException(authResultToExceptionMap.get(result), "");
    }
}
#end_block

#method_before
@Override
protected void handleRootDSEFailure(DirectorySearcher directorySearcher) {
    Exception ex = directorySearcher.getException();
    UserAuthenticationResult authResult = handleDirectorySearcherException(ex);
    setReturnValue(authResult);
}
#method_after
@Override
protected void handleRootDSEFailure(DirectorySearcher directorySearcher) {
    Exception ex = directorySearcher.getException();
    handleDirectorySearcherException(ex);
}
#end_block

#method_before
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccured = false;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccured = directorySearcher.getException() != null;
    } catch (RuntimeException e) {
        log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
    } finally {
        if (exceptionOccured) {
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#method_after
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccurred = true;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccurred = directorySearcher.getException() != null;
    } finally {
        if (exceptionOccurred) {
            log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    try {
        if (!passwordAuthenticator.authenticate(loginName, password)) {
            return false;
        }
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        String passwordChangeMsg = passwordChangeMsgPerDomain.get(getParameters().getProfileName());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED && passwordChangeMsg != null) {
            if (passwordChangeMsg.indexOf("http") == 0 || passwordChangeMsg.indexOf("https") == 0) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordChangeMsg));
            } else {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordChangeMsg));
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    try {
        passwordAuthenticator.authenticate(loginName, password);
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (passwordAuthenticator.getChangeExpiredPasswordMsg() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordAuthenticator.getChangeExpiredPasswordMsg()));
                addedUserPasswordExpiredCDA = true;
            }
            if (passwordAuthenticator.getChangeExpiredPasswordURL() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordAuthenticator.getChangeExpiredPasswordURL()));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(ExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(AAAExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#end_block

#method_before
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw authResultToExceptionMap.get(result);
    }
}
#method_after
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw new AAAExtensionException(authResultToExceptionMap.get(result), "");
    }
}
#end_block

#method_before
public ExtensionError getError() {
    return error;
}
#method_after
public AAAExtensionError getError() {
    return error;
}
#end_block

#method_before
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccured = false;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccured = directorySearcher.getException() != null;
    } catch (RuntimeException e) {
        log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
    } finally {
        if (exceptionOccured) {
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#method_after
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccurred = true;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccurred = directorySearcher.getException() != null;
    } finally {
        if (exceptionOccurred) {
            log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    try {
        if (!passwordAuthenticator.authenticate(loginName, password)) {
            return false;
        }
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        String passwordChangeMsg = passwordChangeMsgPerDomain.get(getParameters().getProfileName());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED && passwordChangeMsg != null) {
            if (passwordChangeMsg.indexOf("http") == 0 || passwordChangeMsg.indexOf("https") == 0) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordChangeMsg));
            } else {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordChangeMsg));
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    try {
        passwordAuthenticator.authenticate(loginName, password);
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (passwordAuthenticator.getChangeExpiredPasswordMsg() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordAuthenticator.getChangeExpiredPasswordMsg()));
                addedUserPasswordExpiredCDA = true;
            }
            if (passwordAuthenticator.getChangeExpiredPasswordURL() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordAuthenticator.getChangeExpiredPasswordURL()));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    if (passwordChangeMsgPerDomain == null) {
        synchronized (ProvisionalAuthenticator.class) {
            if (passwordChangeMsgPerDomain == null) {
                passwordChangeMsgPerDomain = new HashMap<>();
                String changePasswordUrl = Config.<String>getValue(ConfigValues.ChangePasswordMsg);
                String[] pairs = changePasswordUrl.split(",");
                for (String pair : pairs) {
                    // Split the pair in such a way that if the URL contains :, it will not be split to strings
                    String[] pairParts = pair.split(":", 2);
                    if (pairParts.length >= 2) {
                        try {
                            passwordChangeMsgPerDomain.put(pairParts[0], URLDecoder.decode(pairParts[1], "UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                            throw new AAAExtensionException(AAAExtensionError.INVALID_CONFIGURATION, "error in obtaining the password change message or url for " + pairParts[0]);
                        }
                    }
                }
            }
        }
    }
    String changePasswordMsgOrUrl = passwordChangeMsgPerDomain.get(getProfileName());
    if (changePasswordMsgOrUrl != null) {
        ExtensionProperties key = containsURL(changePasswordMsgOrUrl) ? ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_URL : ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_MSG;
        context.put(key, changePasswordMsgOrUrl);
    }
}
#end_block

#method_before
@Override
public boolean authenticate(String name, String password) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(getProfileName(), name, password));
    return ldapResult.getSucceeded();
}
#method_after
@Override
public void authenticate(String name, String password) {
    broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(getProfileName(), name, password));
}
#end_block

#method_before
@Override
public boolean authenticate(String name, String password) {
    return true;
}
#method_after
@Override
public void authenticate(String name, String password) {
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(ExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(AAAExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#end_block

#method_before
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw authResultToExceptionMap.get(result);
    }
}
#method_after
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw new AAAExtensionException(authResultToExceptionMap.get(result), "");
    }
}
#end_block

#method_before
@Override
public boolean authenticate(String user, String password) {
    String adminName = Config.<String>getValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword);
    return ObjectUtils.equals(user, adminName) && ObjectUtils.equals(password, adminPassword);
}
#method_after
@Override
public void authenticate(String user, String password) {
    String adminName = Config.<String>getValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword);
    if (!ObjectUtils.equals(user, adminName) || !ObjectUtils.equals(password, adminPassword)) {
        throw new AAAExtensionException(AAAExtensionException.AAAExtensionError.INCORRECT_CREDENTIALS, "");
    }
}
#end_block

#method_before
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getWindowsHostname().setEntity("");
    getInputLocale().setEntity(VmInit.DEFALUT_LOCALE);
    getUiLanguage().setEntity(VmInit.DEFALUT_LOCALE);
    getSystemLocale().setEntity(VmInit.DEFALUT_LOCALE);
    getUserLocale().setEntity(VmInit.DEFALUT_LOCALE);
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    isWindowsOS = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
            getWindowsHostname().setEntity(vmInit.getHostname());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getInputLocale())) {
            getInputLocale().setEntity(vmInit.getInputLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUiLanguage())) {
            getUiLanguage().setEntity(vmInit.getUiLanguage());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getSystemLocale())) {
            getSystemLocale().setEntity(vmInit.getSystemLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUserLocale())) {
            getUserLocale().setEntity(vmInit.getUserLocale());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#method_after
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getWindowsHostname().setEntity("");
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    isWindowsOS = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
            getWindowsHostname().setEntity(vmInit.getHostname());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void removeNetwork() {
    networkMap.remove(getNetworkList().getSelectedItem());
    getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
    getNetworkList().setSelectedItem(Linq.firstOrDefault(networkMap.keySet()));
}
#method_after
private void removeNetwork() {
    networkMap.remove((String) getNetworkList().getSelectedItem());
    getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
    getNetworkList().setSelectedItem(Linq.firstOrDefault(networkMap.keySet()));
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#end_block

#method_before
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#method_after
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpGetMatrixConstraintsExpectations(BackendHostResource.REGENERATE_CONSTRAINT, true, "true", setUpBasicUriExpectations(), false));
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpGetMatrixConstraintsExpectations(BackendHostResource.REGENERATE_CONSTRAINT, false, "false", setUpBasicUriExpectations(), false));
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpGetEntityExpectations("Hosts: name=" + NAMES[1], SearchType.VDS, getHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpGetEntityExpectations("Hosts: name=" + NAMES[1], SearchType.VDS, getHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations("Cluster: name=" + NAMES[2], SearchType.Cluster, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations("Cluster: name=" + NAMES[2], SearchType.Cluster, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VDSGroup getVdsGroupEntity() {
    return new VDSGroup();
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VDSGroup getVdsGroupEntity() {
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.x86_64);
    return cluster;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), lookupCluster(staticVm.getVdsGroupId())));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetDisplay()) {
                staticVm.setDefaultDisplayType(null);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
public Response importVmFromConfiguration(VM vm) {
    Configuration config = vm.getInitialization().getConfiguration();
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(ConfigurationType.fromValue(config.getType()), null), config.getData().trim()), "");
    VmMapper.map(vm, vmConfiguration.getStaticData());
    Guid clusterId = namedCluster(vm) ? getClusterId(vm) : asGuid(vm.getCluster().getId());
    ImportVmParameters parameters = new ImportVmParameters();
    parameters.setVm(vmConfiguration);
    parameters.setVdsGroupId(clusterId);
    parameters.setImportAsNewEntity(isRegenerate());
    return performCreate(VdcActionType.ImportVmFromConfiguration, parameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
public Response importVmFromConfiguration(VM vm) {
    Initialization initialization = vm.getInitialization();
    Configuration config = initialization.getConfiguration();
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(ConfigurationType.fromValue(config.getType()), null), config.getData().trim()), "");
    VmMapper.map(vm, vmConfiguration.getStaticData());
    Guid clusterId = namedCluster(vm) ? getClusterId(vm) : asGuid(vm.getCluster().getId());
    ImportVmParameters parameters = new ImportVmParameters();
    parameters.setVm(vmConfiguration);
    parameters.setVdsGroupId(clusterId);
    if (initialization.isSetRegenerateIds()) {
        parameters.setImportAsNewEntity(initialization.isRegenerateIds());
    }
    return performCreate(VdcActionType.ImportVmFromConfiguration, parameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        // Filtered users are not allowed to view host related information
        if (isFiltered) {
            removeRestrictedInfoFromVM(vm);
        }
        collection.getVMs().add(addLinks(populate(vm, entity)));
    }
    return collection;
}
#method_after
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    // Fill VmInit for entities - the search query no join the VmInit to Vm
    IdsQueryParameters params = new IdsQueryParameters();
    List<Guid> ids = Entities.getIds(entities);
    params.setId(ids);
    VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
    if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
        List<VmInit> vmInits = queryReturnValue.getReturnValue();
        Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
        for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
            vm.setVmInit(initMap.get(vm.getId()));
        }
    }
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        // Filtered users are not allowed to view host related information
        if (isFiltered) {
            removeRestrictedInfoFromVM(vm);
        }
        collection.getVMs().add(addLinks(populate(vm, entity)));
    }
    return collection;
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setConsoleDevice(model);
    setVirtioScsiController(model);
    setCertificateInfo(model);
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setConsoleDevice(model);
    setVirtioScsiController(model);
    setCertificateInfo(model);
    setVmOvfConfiguration(model, entity);
    return model;
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<LogicalNetworkModel>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicToNetwork.get(nicName).contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(nicName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<LogicalNetworkModel>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<NetworkLabelModel>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    if (!labelModel.getNetworks().isEmpty()) {
                        nicLabels.add(labelModel);
                    }
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.debugFormat("host {0} is missing the cluster's display network", host.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MISSING_DISPLAY_NETWORK);
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.debugFormat("Host {0} has the display network {1} configured with improper boot protocol on interface {2}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CONFIGURE_DISPLAY_NETWORK_WITHOUT_BOOT_PROTOCOL, String.format("$DisplayNetwork %s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.debugFormat("host {0} is missing the cluster's display network", host.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MISSING_DISPLAY_NETWORK);
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.debugFormat("Host {0} has the display network {1} configured with improper boot protocol on interface {2}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL, String.format("$DisplayNetwork %s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (NetworkUtils.isLabeled(getNic()) && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_BOND_IS_LABELED);
    }
    if (Boolean.TRUE.equals(getNic().getBonded())) {
        int slavesCount = 0;
        for (VdsNetworkInterface nic : getHostInterfaces()) {
            if (StringUtils.equals(getNic().getName(), nic.getBondName())) {
                slavesCount++;
                if (slavesCount == 2) {
                    break;
                }
            }
        }
        if (slavesCount < 2) {
            return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
        }
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && NetworkUtils.isLabeled(nic) && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks, ", "));
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (NetworkUtils.isLabeled(getNic()) && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
    }
    if (Boolean.TRUE.equals(getNic().getBonded())) {
        int slavesCount = 0;
        for (VdsNetworkInterface nic : getHostInterfaces()) {
            if (StringUtils.equals(getNic().getName(), nic.getBondName())) {
                slavesCount++;
                if (slavesCount == 2) {
                    break;
                }
            }
        }
        if (slavesCount < 2) {
            return failCanDoAction(VdcBllMessages.IMPROPER_BOND_IS_LABELED);
        }
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && NetworkUtils.isLabeled(nic) && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks, ", "));
    }
    return true;
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Iterable<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, StorageType type) {
    return !((type == StorageType.LOCALFS && version.compareTo(new Version(2, 2)) <= 0) || (type == StorageType.POSIXFS && version.compareTo(new Version(3, 0)) <= 0) || (type == StorageType.GLUSTERFS && version.compareTo(new Version(3, 2)) <= 0));
}
#method_after
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI }));
    return diskInterfaces;
}
#method_after
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
private HashMap<ArchitectureType, HashMap<Version, Boolean>> getMap(ArchCapabilitiesVerb archCapabilitiesVerb) {
    HashMap<ArchitectureType, HashMap<Version, Boolean>> supportMap = new HashMap<ArchitectureType, HashMap<Version, Boolean>>();
    for (ArchitectureType arch : ArchitectureType.values()) {
        HashMap<Version, Boolean> archMap = new HashMap<Version, Boolean>();
        for (Version version : Version.ALL) {
            boolean isSupported = isSupported(archCapabilitiesVerb, arch, version);
            archMap.put(version, isSupported);
        }
        supportMap.put(arch, archMap);
    }
    return supportMap;
}
#method_after
private static Map<ArchitectureType, Map<Version, Boolean>> getMap(ArchCapabilitiesVerb archCapabilitiesVerb) {
    if (archCapabilitiesVerb == null) {
        return null;
    }
    Map<ArchitectureType, Map<Version, Boolean>> supportMap = new EnumMap<ArchitectureType, Map<Version, Boolean>>(ArchitectureType.class);
    for (ArchitectureType arch : ArchitectureType.values()) {
        Map<Version, Boolean> archMap = new HashMap<Version, Boolean>();
        for (Version version : Version.ALL) {
            archMap.put(version, isSupported(archCapabilitiesVerb, arch, version));
        }
        supportMap.put(arch, archMap);
    }
    return supportMap;
}
#end_block

#method_before
private boolean isSupported(ArchCapabilitiesVerb archCapabilitiesVerb, ArchitectureType architecture, Version version) {
    switch(archCapabilitiesVerb) {
        case GetMigrationSupport:
            return FeatureSupported.isMigrationSupported(architecture, version);
        case GetMemorySnapshotSupport:
            return FeatureSupported.isMemorySnapshotSupportedByArchitecture(architecture, version);
    }
    return false;
}
#method_after
private static boolean isSupported(ArchCapabilitiesVerb archCapabilitiesVerb, ArchitectureType architecture, Version version) {
    switch(archCapabilitiesVerb) {
        case GetMigrationSupport:
            return FeatureSupported.isMigrationSupported(architecture, version);
        case GetMemorySnapshotSupport:
            return FeatureSupported.isMemorySnapshotSupportedByArchitecture(architecture, version);
        case GetSuspendSupport:
            return FeatureSupported.isSuspendSupportedByArchitecture(architecture, version);
    }
    return false;
}
#end_block

#method_before
public static boolean supportedInConfig(ConfigValues feature, Version version) {
    return Config.<Boolean>getValue(feature, version.getValue());
}
#method_after
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    return Boolean.parseBoolean(((Map<String, String>) Config.<Map>getValue(feature, version.getValue())).get(arch.name()));
}
#end_block

#method_before
public static boolean antiMacSpoofing(Version version) {
    return supportedInConfig(ConfigValues.EnableMACAntiSpoofingFilterRules, version);
}
#method_after
public static boolean antiMacSpoofing(Version version) {
    return supportedInConfig(ConfigValues.MacAntiSpoofingFilterRulesSupported, version);
}
#end_block

#method_before
public static boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return isFeatureSupportedByArchitecture(ConfigValues.IsMigrationSupported, version, architecture);
}
#method_after
public static boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return supportedInConfig(ConfigValues.IsMigrationSupported, version, architecture);
}
#end_block

#method_before
public static boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return isFeatureSupportedByArchitecture(ConfigValues.IsMemorySnapshotSupported, version, architecture);
}
#method_after
public static boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return supportedInConfig(ConfigValues.IsMemorySnapshotSupported, version, architecture);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setVdsGroupId(getParameters().getClusterId());
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
        // Importing as a template is available only for DC level 3.4 and above
        if (getStoragePool().getcompatibility_version().compareTo(Version.v3_4) < 0) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.errorFormat("Unable to get the disk image from the provider proxy: {0} ({1})", e.getMessage(), e.getErrorType());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setVdsGroupId(getParameters().getClusterId());
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
        if (!FeatureSupported.importGlanceImageAsTemplate(getStoragePool().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.errorFormat("Unable to get the disk image from the provider proxy: {0} ({1})", e.getMessage(), e.getErrorType());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        if (getTagId() != null && DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) != null) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (template != null) {
                appendCustomValue("TemplatesNames", template.getName(), ", ");
            }
            DbFacade.getInstance().getTagDao().detachTemplateFromTag(getTagId(), templateGuid);
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) != null) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (template != null) {
                appendCustomValue("TemplatesNames", template.getName(), ", ");
                DbFacade.getInstance().getTagDao().detachTemplateFromTag(getTagId(), templateGuid);
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid templateGuid : getTemplatesList()) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) == null) {
                if (template != null) {
                    appendCustomValue("TemplatesNames", template.getName(), ", ");
                }
                TagsTemplateMap map = new TagsTemplateMap(getTagId(), templateGuid);
                DbFacade.getInstance().getTagDao().attachTemplateToTag(map);
                noActionDone = false;
            } else {
                if (template != null) {
                    appendCustomValue("TemplatesNamesExists", template.getName(), ", ");
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
        if (template != null) {
            if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) == null) {
                appendCustomValue("TemplatesNames", template.getName(), ", ");
                TagsTemplateMap map = new TagsTemplateMap(getTagId(), templateGuid);
                DbFacade.getInstance().getTagDao().attachTemplateToTag(map);
                noActionDone = false;
            } else {
                appendCustomValue("TemplatesNamesExists", template.getName(), ", ");
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster : lookupCluster(staticVm.getVdsGroupId())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster : lookupCluster(staticVm.getVdsGroupId())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
protected Templates mapCollection(List<VmTemplate> entities) {
    Templates collection = new Templates();
    for (VmTemplate entity : entities) {
        collection.getTemplates().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#method_after
protected Templates mapCollection(List<VmTemplate> entities) {
    // Fill VmInit for entities - the search query no join the VmInit to Templates
    IdsQueryParameters params = new IdsQueryParameters();
    List<Guid> ids = Entities.getIds(entities);
    params.setId(ids);
    VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
    if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
        List<VmInit> vmInits = queryReturnValue.getReturnValue();
        Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
        for (VmTemplate template : entities) {
            template.setVmInit(initMap.get(template.getId()));
        }
    }
    Templates collection = new Templates();
    for (VmTemplate entity : entities) {
        collection.getTemplates().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#end_block

#method_before
protected java.util.ArrayList<Guid> getTemplatesList() {
    return getParameters().getEntitiesId();
}
#method_after
protected ArrayList<Guid> getTemplatesList() {
    return getParameters().getEntitiesId();
}
#end_block

#method_before
public String getTemplateId() {
    return _templateId;
}
#method_after
public String getTemplateId() {
    return templateId;
}
#end_block

#method_before
@Override
protected Widget getContents() {
    LogicalNetworkModel network = (LogicalNetworkModel) item;
    Image mgmtNetworkImage;
    Image vmImage;
    Image monitorImage;
    Image migrationImage;
    Image notSyncImage;
    Image alertImage;
    if (!network.isManaged()) {
        monitorImage = null;
        mgmtNetworkImage = null;
        vmImage = null;
        migrationImage = null;
        notSyncImage = null;
        alertImage = null;
    } else {
        monitorImage = network.getEntity().getCluster().isDisplay() ? new Image(resources.networkMonitor()) : null;
        mgmtNetworkImage = network.isManagement() ? new Image(resources.mgmtNetwork()) : null;
        vmImage = network.getEntity().isVmNetwork() ? new Image(resources.networkVm()) : null;
        migrationImage = network.getEntity().getCluster().isMigration() ? new Image(resources.migrationNetwork()) : null;
        notSyncImage = !network.isInSync() ? new Image(resources.networkNotSyncImage()) : null;
        alertImage = network.getErrorNicName() != null ? new Image(resources.alertImage()) : null;
        if (network.isManagement()) {
            mgmtNetworkImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().isVmNetwork()) {
            vmImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isDisplay()) {
            monitorImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isMigration()) {
            migrationImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (!network.isInSync()) {
            notSyncImage.setStylePrimaryName(style.networkImageBorder());
        }
    }
    Grid rowPanel = new Grid(1, 9);
    rowPanel.setCellSpacing(3);
    // $NON-NLS-1$
    rowPanel.setWidth("100%");
    // $NON-NLS-1$
    rowPanel.setHeight("100%");
    ColumnFormatter columnFormatter = rowPanel.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "5px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "20px");
    // $NON-NLS-1$
    columnFormatter.setWidth(2, "100%");
    rowPanel.setWidget(0, 0, dragImage);
    Panel statusPanel = new HorizontalPanel();
    rowPanel.setWidget(0, 1, statusPanel);
    if (alertImage != null) {
        statusPanel.add(alertImage);
    }
    ImageResource statusImage = getStatusImage();
    if (statusImage != null) {
        statusPanel.add(new Image(statusImage));
    }
    Label titleLabel = new Label(getItemTitle());
    rowPanel.setWidget(0, 2, titleLabel);
    rowPanel.setWidget(0, 3, actionButton);
    rowPanel.setWidget(0, 4, mgmtNetworkImage);
    rowPanel.setWidget(0, 5, monitorImage);
    rowPanel.setWidget(0, 6, vmImage);
    rowPanel.setWidget(0, 7, migrationImage);
    rowPanel.setWidget(0, 8, notSyncImage);
    return rowPanel;
}
#method_after
@Override
protected Widget getContents() {
    LogicalNetworkModel network = (LogicalNetworkModel) item;
    Image mgmtNetworkImage;
    Image vmImage;
    Image monitorImage;
    Image migrationImage;
    Image notSyncImage;
    Image alertImage;
    if (!network.isManaged()) {
        monitorImage = null;
        mgmtNetworkImage = null;
        vmImage = null;
        migrationImage = null;
        notSyncImage = null;
        alertImage = null;
    } else {
        monitorImage = network.getEntity().getCluster().isDisplay() ? new Image(resources.networkMonitor()) : null;
        mgmtNetworkImage = network.isManagement() ? new Image(resources.mgmtNetwork()) : null;
        vmImage = network.getEntity().isVmNetwork() ? new Image(resources.networkVm()) : null;
        migrationImage = network.getEntity().getCluster().isMigration() ? new Image(resources.migrationNetwork()) : null;
        notSyncImage = !network.isInSync() ? new Image(resources.networkNotSyncImage()) : null;
        alertImage = network.getErrorMessage() != null ? new Image(resources.alertImage()) : null;
        if (network.isManagement()) {
            mgmtNetworkImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().isVmNetwork()) {
            vmImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isDisplay()) {
            monitorImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isMigration()) {
            migrationImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (!network.isInSync()) {
            notSyncImage.setStylePrimaryName(style.networkImageBorder());
        }
    }
    Grid rowPanel = new Grid(1, 9);
    rowPanel.setCellSpacing(0);
    // $NON-NLS-1$
    rowPanel.setWidth("100%");
    // $NON-NLS-1$
    rowPanel.setHeight("100%");
    ColumnFormatter columnFormatter = rowPanel.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "5px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "20px");
    // $NON-NLS-1$
    columnFormatter.setWidth(2, "100%");
    rowPanel.setWidget(0, 0, dragImage);
    Panel statusPanel = new HorizontalPanel();
    rowPanel.setWidget(0, 1, statusPanel);
    if (alertImage != null) {
        statusPanel.add(alertImage);
    }
    ImageResource statusImage = getStatusImage();
    if (statusImage != null) {
        statusPanel.add(new Image(statusImage));
    }
    Label titleLabel = new Label(getItemTitle());
    rowPanel.setWidget(0, 2, titleLabel);
    rowPanel.setWidget(0, 3, actionButton);
    rowPanel.setWidget(0, 4, mgmtNetworkImage);
    rowPanel.setWidget(0, 5, monitorImage);
    rowPanel.setWidget(0, 6, vmImage);
    rowPanel.setWidget(0, 7, migrationImage);
    rowPanel.setWidget(0, 8, notSyncImage);
    return rowPanel;
}
#end_block

#method_before
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    contents.clear();
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
    }
    showRelativeTo(panel);
}
#method_after
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
    } else if (item instanceof NetworkLabelModel) {
        return;
    }
    showRelativeTo(panel);
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorNicName() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, SafeHtmlUtils.fromTrustedString(messages.networkLabelConflict(networkModel.getErrorNicName(), networkModel.getEntity().getLabel()))));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#end_block

#method_before
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<String, LogicalNetworkModel>();
    networkLabelMap = new HashMap<String, NetworkLabelModel>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (!network.isExternal()) {
            NetworkLabelModel labelModel = networkLabelMap.get(network.getLabel());
            if (labelModel == null) {
                labelModel = new NetworkLabelModel(network.getLabel(), this);
                networkLabelMap.put(network.getLabel(), labelModel);
            }
            labelModel.getNetworks().add(networkModel);
        }
    }
    setNetworks(networkModels);
}
#method_after
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<String, LogicalNetworkModel>();
    networkLabelMap = new HashMap<String, NetworkLabelModel>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (!network.isExternal()) {
            NetworkLabelModel labelModel = networkLabelMap.get(network.getLabel());
            if (labelModel == null) {
                labelModel = new NetworkLabelModel(network.getLabel(), this);
                networkLabelMap.put(network.getLabel(), labelModel);
            }
            // The network model is candidate to be drawn as part of the label.
            // This doesn't yet consider whether it actually exists on the interface.
            labelModel.getNetworks().add(networkModel);
        }
    }
    setNetworks(networkModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, ifName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicToNetwork.get(ifName).contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            // It means this network couldn't be attached to the nic
                            // because it has a conflict with the other networks on the nic.
                            iter.remove();
                            networkModel.setErrorNicName(ifName);
                        }
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<LogicalNetworkModel>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, ifName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicToNetwork.get(ifName).contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (!VMStatus.WaitForLaunch.equals(vm.getStatus())) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (vm.getStatus() != VMStatus.WaitForLaunch) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
public void deserialize(String value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    if (value != null) {
        // always reset the list of items when the item changes
        keyValueMap_used = new HashMap<String, String>();
        if (!value.isEmpty()) {
            String[] lines = value.split(PROPERTIES_DELIMETER);
            keyValueMap_used = new HashMap<String, String>();
            String[] splitLine;
            for (String line : lines) {
                if (line.isEmpty()) {
                    continue;
                }
                splitLine = line.split(KEY_VALUE_DELIMETER, 2);
                String key = splitLine[0];
                if (allKeyValueMap.containsKey(key)) {
                    keyValueMap_used.put(key, splitLine[1]);
                }
            }
        }
    }
    init(allKeyValueMap.keySet(), keyValueMap_used.keySet());
}
#method_after
public void deserialize(String value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    // always reset the list of items when the item changes
    keyValueMap_used = new HashMap<String, String>();
    if (value != null && !value.isEmpty()) {
        String[] lines = value.split(PROPERTIES_DELIMETER);
        String[] splitLine;
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            splitLine = line.split(KEY_VALUE_DELIMETER, 2);
            String key = splitLine[0];
            if (allKeyValueMap.containsKey(key)) {
                keyValueMap_used.put(key, splitLine[1]);
            }
        }
    }
    init(allKeyValueMap.keySet(), keyValueMap_used.keySet());
}
#end_block

#method_before
protected static RoleNode createSystemRoleTree() {
    return new RoleNode(getConstants().systemRoleTree(), new RoleNode(getConstants().configureSystemRoleTree(), new RoleNode[] { new RoleNode(ActionGroup.MANIPULATE_USERS, getConstants().allowToAddRemoveUsersFromTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_PERMISSIONS, getConstants().allowToAddUsersFromDirectoryOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.ADD_NON_EXISTING_USERS, getConstants().allowToAddNonExistingUsersAndGroupsOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_ROLES, getConstants().allowToDefineConfigureRolesInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.LOGIN, getConstants().allowToLoginToTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.TAG_MANAGEMENT, getConstants().allowToManageTags()), new RoleNode(ActionGroup.BOOKMARK_MANAGEMENT, getConstants().allowToManageBookmarks()), new RoleNode(ActionGroup.EVENT_NOTIFICATION_MANAGEMENT, getConstants().allowToManageEventNotifications()), new RoleNode(ActionGroup.CONFIGURE_ENGINE, getConstants().allowToGetOrSetSystemConfigurationRoleTreeTooltip()) }));
}
#method_after
protected static RoleNode createSystemRoleTree() {
    return new RoleNode(getConstants().systemRoleTree(), new RoleNode(getConstants().configureSystemRoleTree(), new RoleNode[] { new RoleNode(ActionGroup.MANIPULATE_USERS, getConstants().allowToAddRemoveUsersFromTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_PERMISSIONS, getConstants().allowToAddRemovePermissionsForUsersOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.ADD_USERS_AND_GROUPS_FROM_DIRECTORY, getConstants().allowToAddUsersAndGroupsFromDirectoryOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_ROLES, getConstants().allowToDefineConfigureRolesInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.LOGIN, getConstants().allowToLoginToTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.TAG_MANAGEMENT, getConstants().allowToManageTags()), new RoleNode(ActionGroup.BOOKMARK_MANAGEMENT, getConstants().allowToManageBookmarks()), new RoleNode(ActionGroup.EVENT_NOTIFICATION_MANAGEMENT, getConstants().allowToManageEventNotifications()), new RoleNode(ActionGroup.CONFIGURE_ENGINE, getConstants().allowToGetOrSetSystemConfigurationRoleTreeTooltip()) }));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && dbUser == null) {
        permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), ActionGroup.ADD_USERS_FROM_DIRECTORY));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if ((getParameters().getUser() != null && dbUser == null) || (getParameters().getGroup() != null && dbGroup == null)) {
        permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), ActionGroup.ADD_USERS_AND_GROUPS_FROM_DIRECTORY));
    }
    return permissionsSubject;
}
#end_block

#method_before
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    CheckboxHeader assignAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    changeIsAttached(clusterNetworkManageModel, value);
                }
            }
            refreshNetworksTable();
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isAttached()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).getDisplayedName();
        }
    }, constants.nameNetwork(), // $NON-NLS-1$
    "85px");
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            changeIsAttached(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isAttached();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return ClusterManageNetworkPopupView.this.canEditAssign(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.assign()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "90px");
    CheckboxHeader requiredAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    clusterNetworkManageModel.setRequired(value);
                }
                refreshNetworksTable();
            }
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isRequired()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ((ClusterNetworkModel) model).setRequired(value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isRequired();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return canEditRequired(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "110px");
    SafeHtmlWithSafeHtmlTooltipColumn<EntityModel> vmColumn = new SafeHtmlWithSafeHtmlTooltipColumn<EntityModel>() {

        @Override
        public SafeHtml getValue(EntityModel model) {
            List<SafeHtml> images = new LinkedList<SafeHtml>();
            if (((ClusterNetworkModel) model).isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(EntityModel model) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<SafeHtml, String>();
            if (((ClusterNetworkModel) model).isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    networks.addColumn(vmColumn, constants.vmNetwork(), "80px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setDisplayNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isDisplayNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = (ClusterNetworkModel) model;
            return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.displayNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setMigrationNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isMigrationNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = ((ClusterNetworkModel) model);
            Boolean migrationNetworkEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationNetworkEnabled, clusterNetworkModel.getCluster().getcompatibility_version().toString());
            return migrationNetworkEnabled && clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#method_after
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    CheckboxHeader assignAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    changeIsAttached(clusterNetworkManageModel, value);
                }
            }
            refreshNetworksTable();
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isAttached()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).getDisplayedName();
        }
    }, constants.nameNetwork(), // $NON-NLS-1$
    "85px");
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            changeIsAttached(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isAttached();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return ClusterManageNetworkPopupView.this.canEditAssign(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.assign()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "90px");
    CheckboxHeader requiredAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    clusterNetworkManageModel.setRequired(value);
                }
                refreshNetworksTable();
            }
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isRequired()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ((ClusterNetworkModel) model).setRequired(value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isRequired();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return canEditRequired(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "110px");
    SafeHtmlWithSafeHtmlTooltipColumn<ClusterNetworkModel> vmColumn = new SafeHtmlWithSafeHtmlTooltipColumn<ClusterNetworkModel>() {

        @Override
        public SafeHtml getValue(ClusterNetworkModel model) {
            return NetworkRoleColumnHelper.getValue(Collections.singletonList(model.isVmNetwork() ? vmImage : emptyImage));
        }

        @Override
        public SafeHtml getTooltip(ClusterNetworkModel model) {
            return NetworkRoleColumnHelper.getTooltip(model.isVmNetwork() ? Collections.singletonMap(vmImage, constants.vmItemInfo()) : Collections.<SafeHtml, String>emptyMap());
        }
    };
    // $NON-NLS-1$
    networks.addColumn(vmColumn, constants.vmNetwork(), "80px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setDisplayNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isDisplayNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = (ClusterNetworkModel) model;
            return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.displayNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setMigrationNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isMigrationNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = ((ClusterNetworkModel) model);
            Boolean migrationNetworkEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationNetworkEnabled, clusterNetworkModel.getCluster().getcompatibility_version().toString());
            return migrationNetworkEnabled && clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#end_block

#method_before
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
        showRelativeTo(panel);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
        showRelativeTo(panel);
    }
}
#method_after
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
    } else if (item instanceof NetworkLabelModel) {
        return;
    }
    showRelativeTo(panel);
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorNicName() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, SafeHtmlUtils.fromTrustedString(messages.networkLabelConflict(networkModel.getErrorNicName(), networkModel.getEntity().getLabel()))));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#end_block

#method_before
private void updatePortMirroringChangability() {
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            List<VM> vms = (List<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            if (vms != null && !vms.isEmpty()) {
                getPortMirroring().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().portMirroringNotChangedIfUsedByVms());
                getPortMirroring().setIsChangable(false);
            }
            stopProgress();
        }
    };
    IdQueryParameters params = new IdQueryParameters(getProfile().getId());
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsByVnicProfileId, params, asyncQuery);
}
#method_after
private void updatePortMirroringChangability() {
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            Collection<VM> vms = (Collection<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            if (vms != null && !vms.isEmpty()) {
                getPortMirroring().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().portMirroringNotChangedIfUsedByVms());
                getPortMirroring().setIsChangable(false);
            }
            stopProgress();
        }
    };
    IdQueryParameters params = new IdQueryParameters(getProfile().getId());
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsByVnicProfileId, params, asyncQuery);
}
#end_block

#method_before
private void showContextMenu(NetworkItemPanel panel, int clientX, int clientY) {
    if (menu.size() > 0) {
        menuPopup.setWidget(menu);
        menuPopup.setPopupPosition(clientX, clientY);
        menuPopup.show();
    }
}
#method_after
private void showContextMenu(NetworkItemPanel panel, int clientX, int clientY) {
    if (!menu.isEmpty()) {
        menuPopup.setWidget(menu);
        menuPopup.setPopupPosition(clientX, clientY);
        menuPopup.show();
    }
}
#end_block

#method_before
// The domain realm section is the following section
// [domain_realm]
// .example.com = EXAMPLE.COM
private String appendDomainRealms(List<String> realms) throws AuthenticationException {
    StringBuffer text = new StringBuffer(" [domain_realm]\n");
    if (!domainRealmMappingFileExits()) {
        for (String realm : realms) {
            text.append("\t" + realm.toLowerCase() + " = " + realm.toUpperCase() + "\n");
        }
    } else {
        // This can be useful in case the realm is not an upper case of the domain
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(domainRealmMappingFile), "UTF-8"))) {
            while (true) {
                String readLine = reader.readLine();
                if (readLine == null) {
                    break;
                }
                text.append("\t").append(readLine).append("\n");
            }
        } catch (FileNotFoundException e) {
        // This exception should not really happen as we check that the file exists at
        // domainRealmMappingFileExits()
        } catch (IOException e) {
        }
    }
    return text.toString();
}
#method_after
// The domain realm section is the following section
// [domain_realm]
// .example.com = EXAMPLE.COM
private String appendDomainRealms(List<String> realms) throws AuthenticationException {
    StringBuffer text = new StringBuffer(" [domain_realm]\n");
    if (!domainRealmMappingFileExits()) {
        for (String realm : realms) {
            text.append("\t" + realm.toLowerCase() + " = " + realm.toUpperCase() + "\n");
        }
    } else {
        // This can be useful in case the realm is not an upper case of the domain
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(domainRealmMappingFile), java.nio.charset.Charset.defaultCharset().displayName()))) {
            while (true) {
                String readLine = reader.readLine();
                if (readLine == null) {
                    break;
                }
                text.append("\t").append(readLine).append("\n");
            }
        } catch (FileNotFoundException e) {
        // This exception should not really happen as we check that the file exists at
        // domainRealmMappingFileExits()
        } catch (IOException e) {
        }
    }
    return text.toString();
}
#end_block

#method_before
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#method_after
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    modelTimer.setRefreshRate(readRefreshRate());
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#end_block

#method_before
protected void listenOnManualRefresh() {
    refreshPanel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (manualRefreshCallback != null) {
                manualRefreshCallback.onManualRefresh();
            }
            controller.refresh();
        }
    });
}
#method_after
protected void listenOnManualRefresh() {
    refreshPanel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (manualRefreshCallback != null) {
                manualRefreshCallback.onManualRefresh();
            }
            ManualRefreshEvent.fire(AbstractRefreshManager.this);
            controller.refresh();
        }
    });
}
#end_block

#method_before
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    getModelTimer().setRefreshRate(readRefreshRate());
    updateTimer();
}
#method_after
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    updateTimer();
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    getModelProvider().getModel().getTimer().addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            getView().setRefreshButtonVisibility(!getModelProvider().getModel().getTimer().isActive());
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getEventBus().addHandler(ManualRefreshEvent.getType(), new ManualRefreshHandler() {

        @Override
        public void onManualRefresh(ManualRefreshEvent event) {
            if (SubTabHostInterfacePresenter.this.isVisible() && SubTabHostInterfacePresenter.this.getModelProvider().getModel().equals(event.getSource())) {
                getView().removeContent();
            }
        }
    }));
    getModelProvider().getModel().getTimer().addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            getView().setRefreshButtonVisibility(!getModelProvider().getModel().getTimer().isActive());
        }
    });
}
#end_block

#method_before
private boolean activateDataCenter() {
    boolean result = false;
    _fenceSpmCalled = false;
    StorageDomain masterDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePool().getId()), new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain != null && masterDomain.getStatus() != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.InActive)) {
        if (!getStoragePool().isLocal()) {
            // if only one\"the fenced" host connected to sp in dc
            if (getAmountOfVdssInPoll() == 1) {
                resetIrs();
                result = true;
            } else {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        SpmStatusResult statusResult = (SpmStatusResult) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vds.getId(), getStoragePool().getId())).getReturnValue();
                        log.infoFormat("Trying to fence spm {0} via vds {1}", _problematicVds.getName(), vds.getName());
                        if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceSpmStorage, new FenceSpmStorageVDSCommandParameters(vds.getId(), getStoragePool().getId(), statusResult.getSpmId(), statusResult.getSpmLVER())).getSucceeded()) {
                            resetIrs();
                            result = true;
                            _fenceSpmCalled = true;
                            break;
                        }
                    } catch (java.lang.Exception e) {
                        log.warnFormat("Could not fence spm on vds {0}", vds.getName());
                    }
                }
            }
        } else {
            resetIrs();
            result = true;
        }
    } else {
        result = true;
    }
    return result;
}
#method_after
private boolean activateDataCenter() {
    boolean result = false;
    _fenceSpmCalled = false;
    StorageDomain masterDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePool().getId()), new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain != null && masterDomain.getStatus() != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.InActive)) {
        if (!getStoragePool().isLocal()) {
            // if only one\"the fenced" host connected to sp in dc
            if (getAmountOfVdssInPool() == 1) {
                resetIrs();
                result = true;
            } else {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        SpmStatusResult statusResult = (SpmStatusResult) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vds.getId(), getStoragePool().getId())).getReturnValue();
                        log.infoFormat("Trying to fence spm {0} via vds {1}", _problematicVds.getName(), vds.getName());
                        if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceSpmStorage, new FenceSpmStorageVDSCommandParameters(vds.getId(), getStoragePool().getId(), statusResult.getSpmId(), statusResult.getSpmLVER())).getSucceeded()) {
                            resetIrs();
                            result = true;
                            _fenceSpmCalled = true;
                            break;
                        }
                    } catch (java.lang.Exception e) {
                        log.warnFormat("Could not fence spm on vds {0}", vds.getName());
                    }
                }
            }
        } else {
            resetIrs();
            result = true;
        }
    } else {
        result = true;
    }
    return result;
}
#end_block

#method_before
private void mainLogic() {
    try {
        try {
            log.debug("Start event notification service iteration");
            // Clear filter chain
            firstMatchSimpleFilter.clearFilterEntries();
            // Read Database subscriptions first
            firstMatchSimpleFilter.addFilterEntries(eventsManager.getAuditLogEventSubscribers());
            // Backward compatibility, aim to remove (can be replaced by "FILTER")
            String dbDownSubscribers = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
            if (!StringUtils.isEmpty(dbDownSubscribers)) {
                for (String subscriber : dbDownSubscribers.split(",")) {
                    new FirstMatchSimpleFilter.FilterEntry(EventsManager.DATABASE_UNREACHABLE, false, EventNotificationMethod.SMTP.name(), subscriber);
                }
            }
            // Add configurations subscription
            firstMatchSimpleFilter.addFilterEntries(configurationFilters);
            for (AuditLogEvent event : eventsManager.getAuditLogEvents()) {
                firstMatchSimpleFilter.processEvent(event);
                eventsManager.updateAuditLogEventProcessed(event.getId());
            }
            deleteObsoleteHistoryData();
            log.debug("Finished event notification service iteration");
        } catch (SQLException se) {
            distributeDbDownEvent();
            throw se;
        }
    } catch (Throwable t) {
        log.error(String.format("Failed to run the service."), t);
    }
}
#method_after
private void mainLogic() {
    try {
        try {
            log.debug("Start event notification service iteration");
            // Clear filter chain
            firstMatchSimpleFilter.clearFilterEntries();
            // Read Database subscriptions first
            firstMatchSimpleFilter.addFilterEntries(eventsManager.getAuditLogEventSubscribers());
            // Backward compatibility, aim to remove (can be replaced by "FILTER")
            String dbDownSubscribers = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
            if (!StringUtils.isEmpty(dbDownSubscribers)) {
                for (String subscriber : dbDownSubscribers.split(",")) {
                    new FirstMatchSimpleFilter.FilterEntry(EventsManager.DATABASE_UNREACHABLE, false, EventNotificationMethod.SMTP.getAsString(), subscriber);
                }
            }
            // Add configurations subscription
            firstMatchSimpleFilter.addFilterEntries(configurationFilters);
            for (AuditLogEvent event : eventsManager.getAuditLogEvents()) {
                firstMatchSimpleFilter.processEvent(event);
                eventsManager.updateAuditLogEventProcessed(event.getId());
            }
            deleteObsoleteHistoryData();
            log.debug("Finished event notification service iteration");
        } catch (SQLException se) {
            distributeDbDownEvent();
            throw se;
        }
    } catch (Throwable t) {
        log.error(String.format("Failed to run the service."), t);
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    for (String domain : LdapBrokerUtils.getDomainsList()) {
        Map<ExtensionProperties, Object> dirContext = new EnumMap<>(ExtensionProperties.class);
        Properties dirProps = new Properties();
        dirProps.put("ovirt.engine.aaa.authz.profile.name", domain);
        dirContext.put(ExtensionProperties.CONFIGURATION, dirProps);
        dirContext.put(ExtensionProperties.NAME, domain);
        Directory directory = new ProvisionalDirectory();
        directory.setContext(dirContext);
        directory.init();
        Map<ExtensionProperties, Object> authContext = new EnumMap<>(ExtensionProperties.class);
        Properties authProps = new Properties();
        authProps.put("ovirt.engine.aaa.authn.profile.name", domain);
        authContext.put(ExtensionProperties.CONFIGURATION, authProps);
        authContext.put(ExtensionProperties.NAME, domain);
        Authenticator authenticator = new ProvisionalAuthenticator();
        authenticator.setContext(authContext);
        authenticator.init();
        AuthenticationProfile profile = new AuthenticationProfile(authenticator, directory);
        AuthenticationProfileRepository.getInstance().registerProfile(profile);
    }
    ExtensionManager.getInstance().load();
    AuthenticationProfileRepository.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    for (String domain : LdapBrokerUtils.getDomainsList()) {
        Map<ExtensionProperties, Object> dirContext = new EnumMap<>(ExtensionProperties.class);
        Properties dirProps = new Properties();
        dirProps.put("ovirt.engine.aaa.authz.profile.name", domain);
        dirContext.put(ExtensionProperties.CONFIGURATION, dirProps);
        dirContext.put(ExtensionProperties.NAME, domain);
        Directory directory = new ProvisionalDirectory();
        directory.setContext(dirContext);
        directory.init();
        Map<ExtensionProperties, Object> authContext = new EnumMap<>(ExtensionProperties.class);
        Properties authProps = new Properties();
        authProps.put("ovirt.engine.aaa.authn.profile.name", domain);
        authContext.put(ExtensionProperties.CONFIGURATION, authProps);
        authContext.put(ExtensionProperties.NAME, domain);
        Authenticator authenticator = new ProvisionalAuthenticator();
        authenticator.setContext(authContext);
        authenticator.init();
        AuthenticationProfile profile = new AuthenticationProfile(authenticator, directory);
        AuthenticationProfileRepository.getInstance().registerProfile(profile);
    }
    AuthenticationProfileRepository.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#end_block

#method_before
public void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#method_after
private void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#end_block

#method_before
private void activate() {
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper ENGINE_EXTENSION_ENABLE_<NAME> entry exists at the engine config.
        entry.enabled = EngineLocalConfig.getInstance().getBoolean("ENGINE_EXTENSION_ENABLE_" + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
}
#method_after
private void activate() {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper entry exists at the engine config.
        entry.enabled = config.getBoolean(ENGINE_EXTENSION_ENABLED + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                entry.enabled = false;
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void init() {
    admin = new DirectoryUser(getProfileName(), ADMIN_ID, ADMIN_NAME);
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authorization");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    admin = new DirectoryUser(getProfileName(), ADMIN_ID, ADMIN_NAME);
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authorization (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Provisional Authentication (LbapBroker code based)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "oVirt");
    context.put(ExtensionProperties.EXTENSION_NAME, "Provisional Authorization (LbapBroker code based)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "1.0");
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authorization (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#end_block

#method_before
public void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#method_after
private void load() throws ConfigurationException {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        load(directory);
    }
    activate();
}
#end_block

#method_before
private void activate() {
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper ENGINE_EXTENSION_ENABLE_<NAME> entry exists at the engine config.
        entry.enabled = EngineLocalConfig.getInstance().getBoolean("ENGINE_EXTENSION_ENABLE_" + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
    log.info("Activated extensions list: ");
    for (ExtensionEntry entry : loadedEntries.values()) {
        if (entry.extension != null) {
            log.info(String.format("Name: %1$s Author %2$s Version %3$s Home: %4$s License: %5$s", emptyIfNull(entry.extension.getContext().get(ExtensionProperties.EXTENSION_NAME)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.AUTHOR)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.VERSION)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.HOME)), emptyIfNull(entry.extension.getContext().get(ExtensionProperties.LICENSE))));
        }
    }
    log.info("End of activated extensions list");
}
#method_after
private void activate() {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    for (ExtensionEntry entry : loadedEntries.values()) {
        // Engine local config might override the enabled property of the configuration
        // if a proper entry exists at the engine config.
        entry.enabled = config.getBoolean(ENGINE_EXTENSION_ENABLED + entry.getName(), entry.enabled);
        if (entry.enabled) {
            try {
                entry.extension = (Extension) lookupService(Extension.class, entry.getConfig().getProperty(CLASS), entry.getConfig().getProperty(MODULE)).newInstance();
                entry.extension.setContext(entry.context);
                entry.extension.init();
                activatedEntries.put(entry.getName(), entry);
                MultiValueMapUtils.addToMap(entry.getProvides(), entry, providesEntries);
            } catch (Exception ex) {
                entry.enabled = false;
                log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.getName(), ex.getMessage()));
                if (log.isDebugEnabled()) {
                    log.error("", ex);
                }
            }
        }
    }
    logEnabledExtensions();
}
#end_block

#method_before
private String emptyIfNull(Object value) {
    return value == null ? "" : value.toString();
}
#method_after
private Object emptyIfNull(Object value) {
    return value == null ? "" : value;
}
#end_block

